// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates the specified <code>AttackId</code> does not exist, or the requester does not have the appropriate permissions to access the <code>AttackId</code>.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedForDependencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedForDependencyException(message: \(String(describing: message)))"}
}

extension AccessDeniedForDependencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedForDependencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>In order to grant the necessary access to the DDoS Response Team (DRT), the user submitting the request must have the <code>iam:PassRole</code> permission. This error indicates the user did not have the appropriate permissions. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html">Granting a User Permissions to Pass a Role to an AWS Service</a>. </p>
public struct AccessDeniedForDependencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedForDependencyExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedForDependencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateDRTLogBucketInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDRTLogBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<AssociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTLogBucketOutputError>
}

extension AssociateDRTLogBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDRTLogBucketInput(logBucket: \(String(describing: logBucket)))"}
}

extension AssociateDRTLogBucketInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

public struct AssociateDRTLogBucketInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDRTLogBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<AssociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTLogBucketOutputError>
}

public struct AssociateDRTLogBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDRTLogBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<AssociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTLogBucketOutputError>
}

public struct AssociateDRTLogBucketInput: Equatable {
    /// <p>The Amazon S3 bucket that contains your AWS WAF logs.</p>
    public let logBucket: String?

    public init (
        logBucket: String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct AssociateDRTLogBucketInputBody: Equatable {
    public let logBucket: String?
}

extension AssociateDRTLogBucketInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logBucket = "LogBucket"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension AssociateDRTLogBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDRTLogBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAssociatedRoleException" : self = .noAssociatedRoleException(try NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDRTLogBucketOutputError: Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case noAssociatedRoleException(NoAssociatedRoleException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDRTLogBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDRTLogBucketOutputResponse()"}
}

extension AssociateDRTLogBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDRTLogBucketOutputResponse: Equatable {

    public init() {}
}

struct AssociateDRTLogBucketOutputResponseBody: Equatable {
}

extension AssociateDRTLogBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateDRTRoleInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDRTRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTRoleInput>
    public typealias MOutput = OperationOutput<AssociateDRTRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTRoleOutputError>
}

extension AssociateDRTRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDRTRoleInput(roleArn: \(String(describing: roleArn)))"}
}

extension AssociateDRTRoleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct AssociateDRTRoleInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDRTRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTRoleInput>
    public typealias MOutput = OperationOutput<AssociateDRTRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTRoleOutputError>
}

public struct AssociateDRTRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDRTRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDRTRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDRTRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDRTRoleInput>
    public typealias MOutput = OperationOutput<AssociateDRTRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDRTRoleOutputError>
}

public struct AssociateDRTRoleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the role the DRT will use to access your AWS account.</p>
    /// 	        <p>Prior to making the <code>AssociateDRTRole</code> request, you must attach the <a href="https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy">AWSShieldDRTAccessPolicy</a> managed policy to this role.  For more information see <a href=" https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html">Attaching and Detaching IAM Policies</a>.</p>
    public let roleArn: String?

    public init (
        roleArn: String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateDRTRoleInputBody: Equatable {
    public let roleArn: String?
}

extension AssociateDRTRoleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateDRTRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDRTRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDRTRoleOutputError: Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDRTRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDRTRoleOutputResponse()"}
}

extension AssociateDRTRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDRTRoleOutputResponse: Equatable {

    public init() {}
}

struct AssociateDRTRoleOutputResponseBody: Equatable {
}

extension AssociateDRTRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateHealthCheckInputBodyMiddleware: Middleware {
    public let id: String = "AssociateHealthCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHealthCheckInput>
    public typealias MOutput = OperationOutput<AssociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHealthCheckOutputError>
}

extension AssociateHealthCheckInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateHealthCheckInput(healthCheckArn: \(String(describing: healthCheckArn)), protectionId: \(String(describing: protectionId)))"}
}

extension AssociateHealthCheckInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

public struct AssociateHealthCheckInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateHealthCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHealthCheckInput>
    public typealias MOutput = OperationOutput<AssociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHealthCheckOutputError>
}

public struct AssociateHealthCheckInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateHealthCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateHealthCheckInput>
    public typealias MOutput = OperationOutput<AssociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateHealthCheckOutputError>
}

public struct AssociateHealthCheckInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the health check to associate with the protection.</p>
    public let healthCheckArn: String?
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to add the health check association to. </p>
    public let protectionId: String?

    public init (
        healthCheckArn: String? = nil,
        protectionId: String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct AssociateHealthCheckInputBody: Equatable {
    public let protectionId: String?
    public let healthCheckArn: String?
}

extension AssociateHealthCheckInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension AssociateHealthCheckOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateHealthCheckOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateHealthCheckOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateHealthCheckOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateHealthCheckOutputResponse()"}
}

extension AssociateHealthCheckOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateHealthCheckOutputResponse: Equatable {

    public init() {}
}

struct AssociateHealthCheckOutputResponseBody: Equatable {
}

extension AssociateHealthCheckOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateProactiveEngagementDetailsInputBodyMiddleware: Middleware {
    public let id: String = "AssociateProactiveEngagementDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProactiveEngagementDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProactiveEngagementDetailsInput>
    public typealias MOutput = OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProactiveEngagementDetailsOutputError>
}

extension AssociateProactiveEngagementDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateProactiveEngagementDetailsInput(emergencyContactList: \(String(describing: emergencyContactList)))"}
}

extension AssociateProactiveEngagementDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontactlist0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontactlist0)
            }
        }
    }
}

public struct AssociateProactiveEngagementDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateProactiveEngagementDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProactiveEngagementDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProactiveEngagementDetailsInput>
    public typealias MOutput = OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProactiveEngagementDetailsOutputError>
}

public struct AssociateProactiveEngagementDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateProactiveEngagementDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProactiveEngagementDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProactiveEngagementDetailsInput>
    public typealias MOutput = OperationOutput<AssociateProactiveEngagementDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProactiveEngagementDetailsOutputError>
}

public struct AssociateProactiveEngagementDetailsInput: Equatable {
    /// <p>A list of email addresses and phone numbers that the DDoS Response Team (DRT) can use to contact you for escalations to the DRT and to initiate proactive customer support. </p>
    ///          <p>To enable proactive engagement, the contact list must include at least one phone number.</p>
    ///          <note>
    ///             <p>The contacts that you provide here replace any contacts that were already defined. If you already have contacts defined and want to use them, retrieve the list using <code>DescribeEmergencyContactSettings</code> and then provide it here.  </p>
    ///          </note>
    public let emergencyContactList: [EmergencyContact]?

    public init (
        emergencyContactList: [EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct AssociateProactiveEngagementDetailsInputBody: Equatable {
    public let emergencyContactList: [EmergencyContact]?
}

extension AssociateProactiveEngagementDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension AssociateProactiveEngagementDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateProactiveEngagementDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateProactiveEngagementDetailsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateProactiveEngagementDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateProactiveEngagementDetailsOutputResponse()"}
}

extension AssociateProactiveEngagementDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateProactiveEngagementDetailsOutputResponse: Equatable {

    public init() {}
}

struct AssociateProactiveEngagementDetailsOutputResponseBody: Equatable {
}

extension AssociateProactiveEngagementDetailsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AttackDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackCounters = "AttackCounters"
        case attackId = "AttackId"
        case attackProperties = "AttackProperties"
        case endTime = "EndTime"
        case mitigations = "Mitigations"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
        case subResources = "SubResources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackCounters = attackCounters {
            var attackCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackCounters)
            for summarizedcounterlist0 in attackCounters {
                try attackCountersContainer.encode(summarizedcounterlist0)
            }
        }
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackProperties = attackProperties {
            var attackPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackProperties)
            for attackproperties0 in attackProperties {
                try attackPropertiesContainer.encode(attackproperties0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let mitigations = mitigations {
            var mitigationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mitigations)
            for mitigationlist0 in mitigations {
                try mitigationsContainer.encode(mitigationlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let subResources = subResources {
            var subResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subResources)
            for subresourcesummarylist0 in subResources {
                try subResourcesContainer.encode(subresourcesummarylist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let subResourcesContainer = try containerValues.decodeIfPresent([SubResourceSummary?].self, forKey: .subResources)
        var subResourcesDecoded0:[SubResourceSummary]? = nil
        if let subResourcesContainer = subResourcesContainer {
            subResourcesDecoded0 = [SubResourceSummary]()
            for structure0 in subResourcesContainer {
                if let structure0 = structure0 {
                    subResourcesDecoded0?.append(structure0)
                }
            }
        }
        subResources = subResourcesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let attackCountersContainer = try containerValues.decodeIfPresent([SummarizedCounter?].self, forKey: .attackCounters)
        var attackCountersDecoded0:[SummarizedCounter]? = nil
        if let attackCountersContainer = attackCountersContainer {
            attackCountersDecoded0 = [SummarizedCounter]()
            for structure0 in attackCountersContainer {
                if let structure0 = structure0 {
                    attackCountersDecoded0?.append(structure0)
                }
            }
        }
        attackCounters = attackCountersDecoded0
        let attackPropertiesContainer = try containerValues.decodeIfPresent([AttackProperty?].self, forKey: .attackProperties)
        var attackPropertiesDecoded0:[AttackProperty]? = nil
        if let attackPropertiesContainer = attackPropertiesContainer {
            attackPropertiesDecoded0 = [AttackProperty]()
            for structure0 in attackPropertiesContainer {
                if let structure0 = structure0 {
                    attackPropertiesDecoded0?.append(structure0)
                }
            }
        }
        attackProperties = attackPropertiesDecoded0
        let mitigationsContainer = try containerValues.decodeIfPresent([Mitigation?].self, forKey: .mitigations)
        var mitigationsDecoded0:[Mitigation]? = nil
        if let mitigationsContainer = mitigationsContainer {
            mitigationsDecoded0 = [Mitigation]()
            for structure0 in mitigationsContainer {
                if let structure0 = structure0 {
                    mitigationsDecoded0?.append(structure0)
                }
            }
        }
        mitigations = mitigationsDecoded0
    }
}

extension AttackDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackDetail(attackCounters: \(String(describing: attackCounters)), attackId: \(String(describing: attackId)), attackProperties: \(String(describing: attackProperties)), endTime: \(String(describing: endTime)), mitigations: \(String(describing: mitigations)), resourceArn: \(String(describing: resourceArn)), startTime: \(String(describing: startTime)), subResources: \(String(describing: subResources)))"}
}

/// <p>The details of a DDoS attack.</p>
public struct AttackDetail: Equatable {
    /// <p>List of counters that describe the attack for the specified time period.</p>
    public let attackCounters: [SummarizedCounter]?
    /// <p>The unique identifier (ID) of the attack.</p>
    public let attackId: String?
    /// <p>The array of <a>AttackProperty</a> objects.</p>
    public let attackProperties: [AttackProperty]?
    /// <p>The time the attack ended, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let endTime: Date?
    /// <p>List of mitigation actions taken for the attack.</p>
    public let mitigations: [Mitigation]?
    /// <p>The ARN (Amazon Resource Name) of the resource that was attacked.</p>
    public let resourceArn: String?
    /// <p>The time the attack started, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let startTime: Date?
    /// <p>If applicable, additional detail about the resource being attacked, for example, IP address or URL.</p>
    public let subResources: [SubResourceSummary]?

    public init (
        attackCounters: [SummarizedCounter]? = nil,
        attackId: String? = nil,
        attackProperties: [AttackProperty]? = nil,
        endTime: Date? = nil,
        mitigations: [Mitigation]? = nil,
        resourceArn: String? = nil,
        startTime: Date? = nil,
        subResources: [SubResourceSummary]? = nil
    )
    {
        self.attackCounters = attackCounters
        self.attackId = attackId
        self.attackProperties = attackProperties
        self.endTime = endTime
        self.mitigations = mitigations
        self.resourceArn = resourceArn
        self.startTime = startTime
        self.subResources = subResources
    }
}

public enum AttackLayer {
    case application
    case network
    case sdkUnknown(String)
}

extension AttackLayer : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttackLayer] {
        return [
            .application,
            .network,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .application: return "APPLICATION"
        case .network: return "NETWORK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttackLayer(rawValue: rawValue) ?? AttackLayer.sdkUnknown(rawValue)
    }
}

extension AttackProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackLayer = "AttackLayer"
        case attackPropertyIdentifier = "AttackPropertyIdentifier"
        case topContributors = "TopContributors"
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackLayer = attackLayer {
            try encodeContainer.encode(attackLayer.rawValue, forKey: .attackLayer)
        }
        if let attackPropertyIdentifier = attackPropertyIdentifier {
            try encodeContainer.encode(attackPropertyIdentifier.rawValue, forKey: .attackPropertyIdentifier)
        }
        if let topContributors = topContributors {
            var topContributorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topContributors)
            for topcontributors0 in topContributors {
                try topContributorsContainer.encode(topcontributors0)
            }
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackLayerDecoded = try containerValues.decodeIfPresent(AttackLayer.self, forKey: .attackLayer)
        attackLayer = attackLayerDecoded
        let attackPropertyIdentifierDecoded = try containerValues.decodeIfPresent(AttackPropertyIdentifier.self, forKey: .attackPropertyIdentifier)
        attackPropertyIdentifier = attackPropertyIdentifierDecoded
        let topContributorsContainer = try containerValues.decodeIfPresent([Contributor?].self, forKey: .topContributors)
        var topContributorsDecoded0:[Contributor]? = nil
        if let topContributorsContainer = topContributorsContainer {
            topContributorsDecoded0 = [Contributor]()
            for structure0 in topContributorsContainer {
                if let structure0 = structure0 {
                    topContributorsDecoded0?.append(structure0)
                }
            }
        }
        topContributors = topContributorsDecoded0
        let unitDecoded = try containerValues.decodeIfPresent(Unit.self, forKey: .unit)
        unit = unitDecoded
        let totalDecoded = try containerValues.decode(Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension AttackProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackProperty(attackLayer: \(String(describing: attackLayer)), attackPropertyIdentifier: \(String(describing: attackPropertyIdentifier)), topContributors: \(String(describing: topContributors)), total: \(String(describing: total)), unit: \(String(describing: unit)))"}
}

/// <p>Details of the described attack.</p>
public struct AttackProperty: Equatable {
    /// <p>The type of distributed denial of service (DDoS) event that was observed.
    ///             <code>NETWORK</code> indicates layer 3 and layer 4 events and <code>APPLICATION</code>
    ///          indicates layer 7 events.</p>
    public let attackLayer: AttackLayer?
    /// <p>Defines the DDoS attack property information that is provided. The
    ///             <code>WORDPRESS_PINGBACK_REFLECTOR</code> and <code>WORDPRESS_PINGBACK_SOURCE</code>
    ///          values are valid only for WordPress reflective pingback DDoS attacks.</p>
    public let attackPropertyIdentifier: AttackPropertyIdentifier?
    /// <p>The array of contributor objects that includes the top five contributors to an attack. </p>
    public let topContributors: [Contributor]?
    /// <p>The total contributions made to this attack by all contributors, not just the five listed in the <code>TopContributors</code> list.</p>
    public let total: Int
    /// <p>The unit of the <code>Value</code> of the contributions.</p>
    public let unit: Unit?

    public init (
        attackLayer: AttackLayer? = nil,
        attackPropertyIdentifier: AttackPropertyIdentifier? = nil,
        topContributors: [Contributor]? = nil,
        total: Int = 0,
        unit: Unit? = nil
    )
    {
        self.attackLayer = attackLayer
        self.attackPropertyIdentifier = attackPropertyIdentifier
        self.topContributors = topContributors
        self.total = total
        self.unit = unit
    }
}

public enum AttackPropertyIdentifier {
    case destinationUrl
    case referrer
    case sourceAsn
    case sourceCountry
    case sourceIpAddress
    case sourceUserAgent
    case wordpressPingbackReflector
    case wordpressPingbackSource
    case sdkUnknown(String)
}

extension AttackPropertyIdentifier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttackPropertyIdentifier] {
        return [
            .destinationUrl,
            .referrer,
            .sourceAsn,
            .sourceCountry,
            .sourceIpAddress,
            .sourceUserAgent,
            .wordpressPingbackReflector,
            .wordpressPingbackSource,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .destinationUrl: return "DESTINATION_URL"
        case .referrer: return "REFERRER"
        case .sourceAsn: return "SOURCE_ASN"
        case .sourceCountry: return "SOURCE_COUNTRY"
        case .sourceIpAddress: return "SOURCE_IP_ADDRESS"
        case .sourceUserAgent: return "SOURCE_USER_AGENT"
        case .wordpressPingbackReflector: return "WORDPRESS_PINGBACK_REFLECTOR"
        case .wordpressPingbackSource: return "WORDPRESS_PINGBACK_SOURCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttackPropertyIdentifier(rawValue: rawValue) ?? AttackPropertyIdentifier.sdkUnknown(rawValue)
    }
}

extension AttackStatisticsDataItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackCount = "AttackCount"
        case attackVolume = "AttackVolume"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attackCount != 0 {
            try encodeContainer.encode(attackCount, forKey: .attackCount)
        }
        if let attackVolume = attackVolume {
            try encodeContainer.encode(attackVolume, forKey: .attackVolume)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackVolumeDecoded = try containerValues.decodeIfPresent(AttackVolume.self, forKey: .attackVolume)
        attackVolume = attackVolumeDecoded
        let attackCountDecoded = try containerValues.decode(Int.self, forKey: .attackCount)
        attackCount = attackCountDecoded
    }
}

extension AttackStatisticsDataItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackStatisticsDataItem(attackCount: \(String(describing: attackCount)), attackVolume: \(String(describing: attackVolume)))"}
}

/// <p>A single attack statistics data record. This is returned by <a>DescribeAttackStatistics</a> along with a time range indicating the time period that the attack statistics apply to.  </p>
public struct AttackStatisticsDataItem: Equatable {
    /// <p>The number of attacks detected during the time period. This is always present, but might be zero. </p>
    public let attackCount: Int
    /// <p>Information about the volume of attacks during the time period. If the accompanying <code>AttackCount</code> is zero, this setting might be empty.</p>
    public let attackVolume: AttackVolume?

    public init (
        attackCount: Int = 0,
        attackVolume: AttackVolume? = nil
    )
    {
        self.attackCount = attackCount
        self.attackVolume = attackVolume
    }
}

extension AttackSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackId = "AttackId"
        case attackVectors = "AttackVectors"
        case endTime = "EndTime"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for attackvectordescriptionlist0 in attackVectors {
                try attackVectorsContainer.encode(attackvectordescriptionlist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([AttackVectorDescription?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[AttackVectorDescription]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [AttackVectorDescription]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
    }
}

extension AttackSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackSummary(attackId: \(String(describing: attackId)), attackVectors: \(String(describing: attackVectors)), endTime: \(String(describing: endTime)), resourceArn: \(String(describing: resourceArn)), startTime: \(String(describing: startTime)))"}
}

/// <p>Summarizes all DDoS attacks for a specified time period.</p>
public struct AttackSummary: Equatable {
    /// <p>The unique identifier (ID) of the attack.</p>
    public let attackId: String?
    /// <p>The list of attacks for a specified time period.</p>
    public let attackVectors: [AttackVectorDescription]?
    /// <p>The end time of the attack, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let endTime: Date?
    /// <p>The ARN (Amazon Resource Name) of the resource that was attacked.</p>
    public let resourceArn: String?
    /// <p>The start time of the attack, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let startTime: Date?

    public init (
        attackId: String? = nil,
        attackVectors: [AttackVectorDescription]? = nil,
        endTime: Date? = nil,
        resourceArn: String? = nil,
        startTime: Date? = nil
    )
    {
        self.attackId = attackId
        self.attackVectors = attackVectors
        self.endTime = endTime
        self.resourceArn = resourceArn
        self.startTime = startTime
    }
}

extension AttackVectorDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorType = vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
    }
}

extension AttackVectorDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackVectorDescription(vectorType: \(String(describing: vectorType)))"}
}

/// <p>Describes the attack.</p>
public struct AttackVectorDescription: Equatable {
    /// <p>The attack type. Valid values:</p>
    /// 	        <ul>
    ///             <li>
    ///                <p>UDP_TRAFFIC</p>
    ///             </li>
    ///             <li>
    ///                <p>UDP_FRAGMENT</p>
    ///             </li>
    ///             <li>
    ///                <p>GENERIC_UDP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>DNS_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>NTP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>CHARGEN_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>SSDP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>PORT_MAPPER</p>
    ///             </li>
    ///             <li>
    ///                <p>RIP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>SNMP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>MSSQL_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>NET_BIOS_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>SYN_FLOOD</p>
    ///             </li>
    ///             <li>
    ///                <p>ACK_FLOOD</p>
    ///             </li>
    ///             <li>
    ///                <p>REQUEST_FLOOD</p>
    ///             </li>
    ///             <li>
    ///                <p>HTTP_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>UDS_REFLECTION</p>
    ///             </li>
    ///             <li>
    ///                <p>MEMCACHED_REFLECTION</p>
    ///             </li>
    ///          </ul>
    public let vectorType: String?

    public init (
        vectorType: String? = nil
    )
    {
        self.vectorType = vectorType
    }
}

extension AttackVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bitsPerSecond = "BitsPerSecond"
        case packetsPerSecond = "PacketsPerSecond"
        case requestsPerSecond = "RequestsPerSecond"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitsPerSecond = bitsPerSecond {
            try encodeContainer.encode(bitsPerSecond, forKey: .bitsPerSecond)
        }
        if let packetsPerSecond = packetsPerSecond {
            try encodeContainer.encode(packetsPerSecond, forKey: .packetsPerSecond)
        }
        if let requestsPerSecond = requestsPerSecond {
            try encodeContainer.encode(requestsPerSecond, forKey: .requestsPerSecond)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bitsPerSecondDecoded = try containerValues.decodeIfPresent(AttackVolumeStatistics.self, forKey: .bitsPerSecond)
        bitsPerSecond = bitsPerSecondDecoded
        let packetsPerSecondDecoded = try containerValues.decodeIfPresent(AttackVolumeStatistics.self, forKey: .packetsPerSecond)
        packetsPerSecond = packetsPerSecondDecoded
        let requestsPerSecondDecoded = try containerValues.decodeIfPresent(AttackVolumeStatistics.self, forKey: .requestsPerSecond)
        requestsPerSecond = requestsPerSecondDecoded
    }
}

extension AttackVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackVolume(bitsPerSecond: \(String(describing: bitsPerSecond)), packetsPerSecond: \(String(describing: packetsPerSecond)), requestsPerSecond: \(String(describing: requestsPerSecond)))"}
}

/// <p>Information about the volume of attacks during the time period, included in an <a>AttackStatisticsDataItem</a>. If the accompanying <code>AttackCount</code> in the statistics object is zero, this setting might be empty.</p>
public struct AttackVolume: Equatable {
    /// <p>A statistics object that uses bits per second as the unit. This is included for network level attacks. </p>
    public let bitsPerSecond: AttackVolumeStatistics?
    /// <p>A statistics object that uses packets per second as the unit. This is included for network level attacks. </p>
    public let packetsPerSecond: AttackVolumeStatistics?
    /// <p>A statistics object that uses requests per second as the unit. This is included for application level attacks, and is only available for accounts that are subscribed to Shield Advanced.</p>
    public let requestsPerSecond: AttackVolumeStatistics?

    public init (
        bitsPerSecond: AttackVolumeStatistics? = nil,
        packetsPerSecond: AttackVolumeStatistics? = nil,
        requestsPerSecond: AttackVolumeStatistics? = nil
    )
    {
        self.bitsPerSecond = bitsPerSecond
        self.packetsPerSecond = packetsPerSecond
        self.requestsPerSecond = requestsPerSecond
    }
}

extension AttackVolumeStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max = "Max"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decode(Double.self, forKey: .max)
        max = maxDecoded
    }
}

extension AttackVolumeStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttackVolumeStatistics(max: \(String(describing: max)))"}
}

/// <p>Statistics objects for the various data types in <a>AttackVolume</a>. </p>
public struct AttackVolumeStatistics: Equatable {
    /// <p>The maximum attack volume observed for the given unit.</p>
    public let max: Double

    public init (
        max: Double = 0.0
    )
    {
        self.max = max
    }
}

public enum AutoRenew {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension AutoRenew : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoRenew] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoRenew(rawValue: rawValue) ?? AutoRenew.sdkUnknown(rawValue)
    }
}

extension Contributor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension Contributor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Contributor(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>A contributor to the attack and their contribution.</p>
public struct Contributor: Equatable {
    /// <p>The name of the contributor. This is dependent on the <code>AttackPropertyIdentifier</code>. For example, if the <code>AttackPropertyIdentifier</code> is <code>SOURCE_COUNTRY</code>, the <code>Name</code> could be <code>United States</code>.</p>
    public let name: String?
    /// <p>The contribution of this contributor expressed in <a>Protection</a> units. For example <code>10,000</code>.</p>
    public let value: Int

    public init (
        name: String? = nil,
        value: Int = 0
    )
    {
        self.name = name
        self.value = value
    }
}

public struct CreateProtectionGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateProtectionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionGroupInput>
    public typealias MOutput = OperationOutput<CreateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionGroupOutputError>
}

extension CreateProtectionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProtectionGroupInput(aggregation: \(String(describing: aggregation)), members: \(String(describing: members)), pattern: \(String(describing: pattern)), protectionGroupId: \(String(describing: protectionGroupId)), resourceType: \(String(describing: resourceType)), tags: \(String(describing: tags)))"}
}

extension CreateProtectionGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateProtectionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProtectionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionGroupInput>
    public typealias MOutput = OperationOutput<CreateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionGroupOutputError>
}

public struct CreateProtectionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProtectionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionGroupInput>
    public typealias MOutput = OperationOutput<CreateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionGroupOutputError>
}

public struct CreateProtectionGroupInput: Equatable {
    /// <p>Defines how AWS Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
    ///             </li>
    ///             <li>
    ///                <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include CloudFront distributions and origin resources for CloudFront distributions.</p>
    ///             </li>
    ///          </ul>
    public let aggregation: ProtectionGroupAggregation?
    /// <p>The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set <code>Pattern</code> to <code>ARBITRARY</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let members: [String]?
    /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type. </p>
    public let pattern: ProtectionGroupPattern?
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?
    /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group.
    ///            You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let resourceType: ProtectedResourceType?
    /// <p>One or more tag key-value pairs for the protection group.</p>
    public let tags: [Tag]?

    public init (
        aggregation: ProtectionGroupAggregation? = nil,
        members: [String]? = nil,
        pattern: ProtectionGroupPattern? = nil,
        protectionGroupId: String? = nil,
        resourceType: ProtectedResourceType? = nil,
        tags: [Tag]? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct CreateProtectionGroupInputBody: Equatable {
    public let protectionGroupId: String?
    public let aggregation: ProtectionGroupAggregation?
    public let pattern: ProtectionGroupPattern?
    public let resourceType: ProtectedResourceType?
    public let members: [String]?
    public let tags: [Tag]?
}

extension CreateProtectionGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .members)
        var membersDecoded0:[String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProtectionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProtectionGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProtectionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProtectionGroupOutputResponse()"}
}

extension CreateProtectionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateProtectionGroupOutputResponse: Equatable {

    public init() {}
}

struct CreateProtectionGroupOutputResponseBody: Equatable {
}

extension CreateProtectionGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateProtectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionInput>
    public typealias MOutput = OperationOutput<CreateProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionOutputError>
}

extension CreateProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProtectionInput(name: \(String(describing: name)), resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension CreateProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionInput>
    public typealias MOutput = OperationOutput<CreateProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionOutputError>
}

public struct CreateProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProtectionInput>
    public typealias MOutput = OperationOutput<CreateProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProtectionOutputError>
}

public struct CreateProtectionInput: Equatable {
    /// <p>Friendly name for the <code>Protection</code> you are creating.</p>
    public let name: String?
    /// <p>The ARN (Amazon Resource Name) of the resource to be protected.</p>
    ///          <p>The ARN should be in one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an Elastic Load Balancer (Classic Load Balancer): <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/<i>load-balancer-name</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an AWS CloudFront distribution: <code>arn:aws:cloudfront::<i>account-id</i>:distribution/<i>distribution-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an AWS Global Accelerator accelerator: <code>arn:aws:globalaccelerator::<i>account-id</i>:accelerator/<i>accelerator-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For Amazon Route 53: <code>arn:aws:route53:::hostedzone/<i>hosted-zone-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an Elastic IP address: <code>arn:aws:ec2:<i>region</i>:<i>account-id</i>:eip-allocation/<i>allocation-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let resourceArn: String?
    /// <p>One or more tag key-value pairs for the <a>Protection</a> object that is created.</p>
    public let tags: [Tag]?

    public init (
        name: String? = nil,
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateProtectionInputBody: Equatable {
    public let name: String?
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension CreateProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProtectionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProtectionOutputResponse(protectionId: \(String(describing: protectionId)))"}
}

extension CreateProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.protectionId = output.protectionId
        } else {
            self.protectionId = nil
        }
    }
}

public struct CreateProtectionOutputResponse: Equatable {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object that is created.</p>
    public let protectionId: String?

    public init (
        protectionId: String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct CreateProtectionOutputResponseBody: Equatable {
    public let protectionId: String?
}

extension CreateProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

extension CreateSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionInput()"}
}

extension CreateSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionOutputError>
}

public struct CreateSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriptionOutputError>
}

public struct CreateSubscriptionInput: Equatable {

    public init() {}
}

struct CreateSubscriptionInputBody: Equatable {
}

extension CreateSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriptionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriptionOutputResponse()"}
}

extension CreateSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct CreateSubscriptionOutputResponseBody: Equatable {
}

extension CreateSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProtectionGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProtectionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionGroupInput>
    public typealias MOutput = OperationOutput<DeleteProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionGroupOutputError>
}

extension DeleteProtectionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtectionGroupInput(protectionGroupId: \(String(describing: protectionGroupId)))"}
}

extension DeleteProtectionGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

public struct DeleteProtectionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProtectionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionGroupInput>
    public typealias MOutput = OperationOutput<DeleteProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionGroupOutputError>
}

public struct DeleteProtectionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProtectionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionGroupInput>
    public typealias MOutput = OperationOutput<DeleteProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionGroupOutputError>
}

public struct DeleteProtectionGroupInput: Equatable {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?

    public init (
        protectionGroupId: String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DeleteProtectionGroupInputBody: Equatable {
    public let protectionGroupId: String?
}

extension DeleteProtectionGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DeleteProtectionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtectionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtectionGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtectionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtectionGroupOutputResponse()"}
}

extension DeleteProtectionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtectionGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteProtectionGroupOutputResponseBody: Equatable {
}

extension DeleteProtectionGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProtectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionInput>
    public typealias MOutput = OperationOutput<DeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionOutputError>
}

extension DeleteProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtectionInput(protectionId: \(String(describing: protectionId)))"}
}

extension DeleteProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

public struct DeleteProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionInput>
    public typealias MOutput = OperationOutput<DeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionOutputError>
}

public struct DeleteProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtectionInput>
    public typealias MOutput = OperationOutput<DeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtectionOutputError>
}

public struct DeleteProtectionInput: Equatable {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to be
    ///          deleted.</p>
    public let protectionId: String?

    public init (
        protectionId: String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct DeleteProtectionInputBody: Equatable {
    public let protectionId: String?
}

extension DeleteProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

extension DeleteProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtectionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtectionOutputResponse()"}
}

extension DeleteProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtectionOutputResponse: Equatable {

    public init() {}
}

struct DeleteProtectionOutputResponseBody: Equatable {
}

extension DeleteProtectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriptionInput()"}
}

extension DeleteSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriptionOutputError>
}

public struct DeleteSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriptionOutputError>
}

@available(*, deprecated)
public struct DeleteSubscriptionInput: Equatable {

    public init() {}
}

struct DeleteSubscriptionInputBody: Equatable {
}

extension DeleteSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockedSubscriptionException" : self = .lockedSubscriptionException(try LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubscriptionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case lockedSubscriptionException(LockedSubscriptionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriptionOutputResponse()"}
}

extension DeleteSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteSubscriptionOutputResponseBody: Equatable {
}

extension DeleteSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAttackInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAttackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttackInput>
    public typealias MOutput = OperationOutput<DescribeAttackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttackOutputError>
}

extension DescribeAttackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttackInput(attackId: \(String(describing: attackId)))"}
}

extension DescribeAttackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackId = "AttackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
    }
}

public struct DescribeAttackInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAttackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttackInput>
    public typealias MOutput = OperationOutput<DescribeAttackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttackOutputError>
}

public struct DescribeAttackInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAttackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttackInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttackInput>
    public typealias MOutput = OperationOutput<DescribeAttackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttackOutputError>
}

public struct DescribeAttackInput: Equatable {
    /// <p>The unique identifier (ID) for the attack that to be described.</p>
    public let attackId: String?

    public init (
        attackId: String? = nil
    )
    {
        self.attackId = attackId
    }
}

struct DescribeAttackInputBody: Equatable {
    public let attackId: String?
}

extension DescribeAttackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attackId = "AttackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attackId)
        attackId = attackIdDecoded
    }
}

extension DescribeAttackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttackOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttackOutputResponse(attack: \(String(describing: attack)))"}
}

extension DescribeAttackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAttackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attack = output.attack
        } else {
            self.attack = nil
        }
    }
}

public struct DescribeAttackOutputResponse: Equatable {
    /// <p>The attack that is described.</p>
    public let attack: AttackDetail?

    public init (
        attack: AttackDetail? = nil
    )
    {
        self.attack = attack
    }
}

struct DescribeAttackOutputResponseBody: Equatable {
    public let attack: AttackDetail?
}

extension DescribeAttackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attack = "Attack"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackDecoded = try containerValues.decodeIfPresent(AttackDetail.self, forKey: .attack)
        attack = attackDecoded
    }
}

extension DescribeAttackStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttackStatisticsInput()"}
}

extension DescribeAttackStatisticsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAttackStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAttackStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttackStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttackStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttackStatisticsInput>
    public typealias MOutput = OperationOutput<DescribeAttackStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttackStatisticsOutputError>
}

public struct DescribeAttackStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAttackStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttackStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttackStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttackStatisticsInput>
    public typealias MOutput = OperationOutput<DescribeAttackStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttackStatisticsOutputError>
}

public struct DescribeAttackStatisticsInput: Equatable {

    public init() {}
}

struct DescribeAttackStatisticsInputBody: Equatable {
}

extension DescribeAttackStatisticsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAttackStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttackStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttackStatisticsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttackStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttackStatisticsOutputResponse(dataItems: \(String(describing: dataItems)), timeRange: \(String(describing: timeRange)))"}
}

extension DescribeAttackStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAttackStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataItems = output.dataItems
            self.timeRange = output.timeRange
        } else {
            self.dataItems = nil
            self.timeRange = nil
        }
    }
}

public struct DescribeAttackStatisticsOutputResponse: Equatable {
    /// <p>The data that describes the attacks detected during the time period.</p>
    public let dataItems: [AttackStatisticsDataItem]?
    /// <p>The time range. </p>
    public let timeRange: TimeRange?

    public init (
        dataItems: [AttackStatisticsDataItem]? = nil,
        timeRange: TimeRange? = nil
    )
    {
        self.dataItems = dataItems
        self.timeRange = timeRange
    }
}

struct DescribeAttackStatisticsOutputResponseBody: Equatable {
    public let timeRange: TimeRange?
    public let dataItems: [AttackStatisticsDataItem]?
}

extension DescribeAttackStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataItems = "DataItems"
        case timeRange = "TimeRange"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let dataItemsContainer = try containerValues.decodeIfPresent([AttackStatisticsDataItem?].self, forKey: .dataItems)
        var dataItemsDecoded0:[AttackStatisticsDataItem]? = nil
        if let dataItemsContainer = dataItemsContainer {
            dataItemsDecoded0 = [AttackStatisticsDataItem]()
            for structure0 in dataItemsContainer {
                if let structure0 = structure0 {
                    dataItemsDecoded0?.append(structure0)
                }
            }
        }
        dataItems = dataItemsDecoded0
    }
}

extension DescribeDRTAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDRTAccessInput()"}
}

extension DescribeDRTAccessInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDRTAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDRTAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDRTAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDRTAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDRTAccessInput>
    public typealias MOutput = OperationOutput<DescribeDRTAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDRTAccessOutputError>
}

public struct DescribeDRTAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDRTAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDRTAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDRTAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDRTAccessInput>
    public typealias MOutput = OperationOutput<DescribeDRTAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDRTAccessOutputError>
}

public struct DescribeDRTAccessInput: Equatable {

    public init() {}
}

struct DescribeDRTAccessInputBody: Equatable {
}

extension DescribeDRTAccessInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDRTAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDRTAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDRTAccessOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDRTAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDRTAccessOutputResponse(logBucketList: \(String(describing: logBucketList)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribeDRTAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDRTAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logBucketList = output.logBucketList
            self.roleArn = output.roleArn
        } else {
            self.logBucketList = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeDRTAccessOutputResponse: Equatable {
    /// <p>The list of Amazon S3 buckets accessed by the DRT.</p>
    public let logBucketList: [String]?
    /// <p>The Amazon Resource Name (ARN) of the role the DRT used to access your AWS account.</p>
    public let roleArn: String?

    public init (
        logBucketList: [String]? = nil,
        roleArn: String? = nil
    )
    {
        self.logBucketList = logBucketList
        self.roleArn = roleArn
    }
}

struct DescribeDRTAccessOutputResponseBody: Equatable {
    public let roleArn: String?
    public let logBucketList: [String]?
}

extension DescribeDRTAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logBucketList = "LogBucketList"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logBucketListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logBucketList)
        var logBucketListDecoded0:[String]? = nil
        if let logBucketListContainer = logBucketListContainer {
            logBucketListDecoded0 = [String]()
            for string0 in logBucketListContainer {
                if let string0 = string0 {
                    logBucketListDecoded0?.append(string0)
                }
            }
        }
        logBucketList = logBucketListDecoded0
    }
}

extension DescribeEmergencyContactSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEmergencyContactSettingsInput()"}
}

extension DescribeEmergencyContactSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEmergencyContactSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEmergencyContactSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEmergencyContactSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEmergencyContactSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEmergencyContactSettingsInput>
    public typealias MOutput = OperationOutput<DescribeEmergencyContactSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEmergencyContactSettingsOutputError>
}

public struct DescribeEmergencyContactSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEmergencyContactSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEmergencyContactSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEmergencyContactSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEmergencyContactSettingsInput>
    public typealias MOutput = OperationOutput<DescribeEmergencyContactSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEmergencyContactSettingsOutputError>
}

public struct DescribeEmergencyContactSettingsInput: Equatable {

    public init() {}
}

struct DescribeEmergencyContactSettingsInputBody: Equatable {
}

extension DescribeEmergencyContactSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEmergencyContactSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEmergencyContactSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEmergencyContactSettingsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEmergencyContactSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEmergencyContactSettingsOutputResponse(emergencyContactList: \(String(describing: emergencyContactList)))"}
}

extension DescribeEmergencyContactSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEmergencyContactSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.emergencyContactList = output.emergencyContactList
        } else {
            self.emergencyContactList = nil
        }
    }
}

public struct DescribeEmergencyContactSettingsOutputResponse: Equatable {
    /// <p>A list of email addresses and phone numbers that the DDoS Response Team (DRT) can use to contact you if you have proactive engagement enabled, for escalations to the DRT and to initiate proactive customer support.</p>
    public let emergencyContactList: [EmergencyContact]?

    public init (
        emergencyContactList: [EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct DescribeEmergencyContactSettingsOutputResponseBody: Equatable {
    public let emergencyContactList: [EmergencyContact]?
}

extension DescribeEmergencyContactSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

public struct DescribeProtectionGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProtectionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionGroupInput>
    public typealias MOutput = OperationOutput<DescribeProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionGroupOutputError>
}

extension DescribeProtectionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectionGroupInput(protectionGroupId: \(String(describing: protectionGroupId)))"}
}

extension DescribeProtectionGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

public struct DescribeProtectionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProtectionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionGroupInput>
    public typealias MOutput = OperationOutput<DescribeProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionGroupOutputError>
}

public struct DescribeProtectionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProtectionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionGroupInput>
    public typealias MOutput = OperationOutput<DescribeProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionGroupOutputError>
}

public struct DescribeProtectionGroupInput: Equatable {
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?

    public init (
        protectionGroupId: String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DescribeProtectionGroupInputBody: Equatable {
    public let protectionGroupId: String?
}

extension DescribeProtectionGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DescribeProtectionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectionGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectionGroupOutputResponse(protectionGroup: \(String(describing: protectionGroup)))"}
}

extension DescribeProtectionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProtectionGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.protectionGroup = output.protectionGroup
        } else {
            self.protectionGroup = nil
        }
    }
}

public struct DescribeProtectionGroupOutputResponse: Equatable {
    /// <p>A grouping of protected resources that you and AWS Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives. </p>
    public let protectionGroup: ProtectionGroup?

    public init (
        protectionGroup: ProtectionGroup? = nil
    )
    {
        self.protectionGroup = protectionGroup
    }
}

struct DescribeProtectionGroupOutputResponseBody: Equatable {
    public let protectionGroup: ProtectionGroup?
}

extension DescribeProtectionGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionGroup = "ProtectionGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupDecoded = try containerValues.decodeIfPresent(ProtectionGroup.self, forKey: .protectionGroup)
        protectionGroup = protectionGroupDecoded
    }
}

public struct DescribeProtectionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionInput>
    public typealias MOutput = OperationOutput<DescribeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionOutputError>
}

extension DescribeProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectionInput(protectionId: \(String(describing: protectionId)), resourceArn: \(String(describing: resourceArn)))"}
}

extension DescribeProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DescribeProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionInput>
    public typealias MOutput = OperationOutput<DescribeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionOutputError>
}

public struct DescribeProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProtectionInput>
    public typealias MOutput = OperationOutput<DescribeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProtectionOutputError>
}

public struct DescribeProtectionInput: Equatable {
    /// <p>The unique identifier (ID) for the <a>Protection</a> object that is
    ///          described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
    public let protectionId: String?
    /// <p>The ARN (Amazon Resource Name) of the AWS resource for the <a>Protection</a> object that is
    ///          described. When submitting the <code>DescribeProtection</code> request you must provide either the <code>ResourceArn</code> or the <code>ProtectionID</code>, but not both.</p>
    public let resourceArn: String?

    public init (
        protectionId: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.protectionId = protectionId
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectionInputBody: Equatable {
    public let protectionId: String?
    public let resourceArn: String?
}

extension DescribeProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProtectionOutputResponse(protection: \(String(describing: protection)))"}
}

extension DescribeProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.protection = output.protection
        } else {
            self.protection = nil
        }
    }
}

public struct DescribeProtectionOutputResponse: Equatable {
    /// <p>The <a>Protection</a> object that is described.</p>
    public let protection: Protection?

    public init (
        protection: Protection? = nil
    )
    {
        self.protection = protection
    }
}

struct DescribeProtectionOutputResponseBody: Equatable {
    public let protection: Protection?
}

extension DescribeProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protection = "Protection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionDecoded = try containerValues.decodeIfPresent(Protection.self, forKey: .protection)
        protection = protectionDecoded
    }
}

extension DescribeSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubscriptionInput()"}
}

extension DescribeSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubscriptionInput>
    public typealias MOutput = OperationOutput<DescribeSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubscriptionOutputError>
}

public struct DescribeSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubscriptionInput>
    public typealias MOutput = OperationOutput<DescribeSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubscriptionOutputError>
}

public struct DescribeSubscriptionInput: Equatable {

    public init() {}
}

struct DescribeSubscriptionInputBody: Equatable {
}

extension DescribeSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubscriptionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubscriptionOutputResponse(subscription: \(String(describing: subscription)))"}
}

extension DescribeSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct DescribeSubscriptionOutputResponse: Equatable {
    /// <p>The AWS Shield Advanced subscription details for an account.</p>
    public let subscription: Subscription?

    public init (
        subscription: Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct DescribeSubscriptionOutputResponseBody: Equatable {
    public let subscription: Subscription?
}

extension DescribeSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscription = "Subscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

extension DisableProactiveEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableProactiveEngagementInput()"}
}

extension DisableProactiveEngagementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableProactiveEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "DisableProactiveEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableProactiveEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableProactiveEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableProactiveEngagementInput>
    public typealias MOutput = OperationOutput<DisableProactiveEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableProactiveEngagementOutputError>
}

public struct DisableProactiveEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableProactiveEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableProactiveEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableProactiveEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableProactiveEngagementInput>
    public typealias MOutput = OperationOutput<DisableProactiveEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableProactiveEngagementOutputError>
}

public struct DisableProactiveEngagementInput: Equatable {

    public init() {}
}

struct DisableProactiveEngagementInputBody: Equatable {
}

extension DisableProactiveEngagementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableProactiveEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableProactiveEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableProactiveEngagementOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableProactiveEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableProactiveEngagementOutputResponse()"}
}

extension DisableProactiveEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableProactiveEngagementOutputResponse: Equatable {

    public init() {}
}

struct DisableProactiveEngagementOutputResponseBody: Equatable {
}

extension DisableProactiveEngagementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateDRTLogBucketInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateDRTLogBucketInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<DisassociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDRTLogBucketOutputError>
}

extension DisassociateDRTLogBucketInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDRTLogBucketInput(logBucket: \(String(describing: logBucket)))"}
}

extension DisassociateDRTLogBucketInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

public struct DisassociateDRTLogBucketInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDRTLogBucketInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<DisassociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDRTLogBucketOutputError>
}

public struct DisassociateDRTLogBucketInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDRTLogBucketInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDRTLogBucketInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDRTLogBucketOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDRTLogBucketInput>
    public typealias MOutput = OperationOutput<DisassociateDRTLogBucketOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDRTLogBucketOutputError>
}

public struct DisassociateDRTLogBucketInput: Equatable {
    /// <p>The Amazon S3 bucket that contains your AWS WAF logs.</p>
    public let logBucket: String?

    public init (
        logBucket: String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct DisassociateDRTLogBucketInputBody: Equatable {
    public let logBucket: String?
}

extension DisassociateDRTLogBucketInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logBucket = "LogBucket"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension DisassociateDRTLogBucketOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDRTLogBucketOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAssociatedRoleException" : self = .noAssociatedRoleException(try NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDRTLogBucketOutputError: Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case noAssociatedRoleException(NoAssociatedRoleException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDRTLogBucketOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDRTLogBucketOutputResponse()"}
}

extension DisassociateDRTLogBucketOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDRTLogBucketOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDRTLogBucketOutputResponseBody: Equatable {
}

extension DisassociateDRTLogBucketOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateDRTRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDRTRoleInput()"}
}

extension DisassociateDRTRoleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateDRTRoleInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDRTRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDRTRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDRTRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDRTRoleInput>
    public typealias MOutput = OperationOutput<DisassociateDRTRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDRTRoleOutputError>
}

public struct DisassociateDRTRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDRTRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDRTRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDRTRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDRTRoleInput>
    public typealias MOutput = OperationOutput<DisassociateDRTRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDRTRoleOutputError>
}

public struct DisassociateDRTRoleInput: Equatable {

    public init() {}
}

struct DisassociateDRTRoleInputBody: Equatable {
}

extension DisassociateDRTRoleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateDRTRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDRTRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDRTRoleOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDRTRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDRTRoleOutputResponse()"}
}

extension DisassociateDRTRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDRTRoleOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDRTRoleOutputResponseBody: Equatable {
}

extension DisassociateDRTRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateHealthCheckInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateHealthCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateHealthCheckInput>
    public typealias MOutput = OperationOutput<DisassociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateHealthCheckOutputError>
}

extension DisassociateHealthCheckInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateHealthCheckInput(healthCheckArn: \(String(describing: healthCheckArn)), protectionId: \(String(describing: protectionId)))"}
}

extension DisassociateHealthCheckInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

public struct DisassociateHealthCheckInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateHealthCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateHealthCheckInput>
    public typealias MOutput = OperationOutput<DisassociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateHealthCheckOutputError>
}

public struct DisassociateHealthCheckInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateHealthCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateHealthCheckInput>
    public typealias MOutput = OperationOutput<DisassociateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateHealthCheckOutputError>
}

public struct DisassociateHealthCheckInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the health check that is associated with the protection.</p>
    public let healthCheckArn: String?
    /// <p>The unique identifier (ID) for the <a>Protection</a> object to remove the health check association from. </p>
    public let protectionId: String?

    public init (
        healthCheckArn: String? = nil,
        protectionId: String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct DisassociateHealthCheckInputBody: Equatable {
    public let protectionId: String?
    public let healthCheckArn: String?
}

extension DisassociateHealthCheckInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension DisassociateHealthCheckOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateHealthCheckOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateHealthCheckOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateHealthCheckOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateHealthCheckOutputResponse()"}
}

extension DisassociateHealthCheckOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateHealthCheckOutputResponse: Equatable {

    public init() {}
}

struct DisassociateHealthCheckOutputResponseBody: Equatable {
}

extension DisassociateHealthCheckOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EmergencyContact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactNotes = "ContactNotes"
        case emailAddress = "EmailAddress"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactNotes = contactNotes {
            try encodeContainer.encode(contactNotes, forKey: .contactNotes)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let contactNotesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactNotes)
        contactNotes = contactNotesDecoded
    }
}

extension EmergencyContact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmergencyContact(contactNotes: \(String(describing: contactNotes)), emailAddress: \(String(describing: emailAddress)), phoneNumber: \(String(describing: phoneNumber)))"}
}

/// <p>Contact information that the DRT can use to contact you if you have proactive engagement enabled, for escalations to the DRT and to initiate proactive customer support.</p>
public struct EmergencyContact: Equatable {
    /// <p>Additional notes regarding the contact. </p>
    public let contactNotes: String?
    /// <p>The email address for the contact.</p>
    public let emailAddress: String?
    /// <p>The phone number for the contact.</p>
    public let phoneNumber: String?

    public init (
        contactNotes: String? = nil,
        emailAddress: String? = nil,
        phoneNumber: String? = nil
    )
    {
        self.contactNotes = contactNotes
        self.emailAddress = emailAddress
        self.phoneNumber = phoneNumber
    }
}

extension EnableProactiveEngagementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableProactiveEngagementInput()"}
}

extension EnableProactiveEngagementInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableProactiveEngagementInputHeadersMiddleware: Middleware {
    public let id: String = "EnableProactiveEngagementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableProactiveEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableProactiveEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableProactiveEngagementInput>
    public typealias MOutput = OperationOutput<EnableProactiveEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableProactiveEngagementOutputError>
}

public struct EnableProactiveEngagementInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableProactiveEngagementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableProactiveEngagementInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableProactiveEngagementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableProactiveEngagementInput>
    public typealias MOutput = OperationOutput<EnableProactiveEngagementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableProactiveEngagementOutputError>
}

public struct EnableProactiveEngagementInput: Equatable {

    public init() {}
}

struct EnableProactiveEngagementInputBody: Equatable {
}

extension EnableProactiveEngagementInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableProactiveEngagementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableProactiveEngagementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableProactiveEngagementOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableProactiveEngagementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableProactiveEngagementOutputResponse()"}
}

extension EnableProactiveEngagementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableProactiveEngagementOutputResponse: Equatable {

    public init() {}
}

struct EnableProactiveEngagementOutputResponseBody: Equatable {
}

extension EnableProactiveEngagementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSubscriptionStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionStateInput()"}
}

extension GetSubscriptionStateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSubscriptionStateInputHeadersMiddleware: Middleware {
    public let id: String = "GetSubscriptionStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionStateInput>
    public typealias MOutput = OperationOutput<GetSubscriptionStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionStateOutputError>
}

public struct GetSubscriptionStateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSubscriptionStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSubscriptionStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSubscriptionStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSubscriptionStateInput>
    public typealias MOutput = OperationOutput<GetSubscriptionStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSubscriptionStateOutputError>
}

public struct GetSubscriptionStateInput: Equatable {

    public init() {}
}

struct GetSubscriptionStateInputBody: Equatable {
}

extension GetSubscriptionStateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSubscriptionStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionStateOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSubscriptionStateOutputResponse(subscriptionState: \(String(describing: subscriptionState)))"}
}

extension GetSubscriptionStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSubscriptionStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscriptionState = output.subscriptionState
        } else {
            self.subscriptionState = nil
        }
    }
}

public struct GetSubscriptionStateOutputResponse: Equatable {
    /// <p>The status of the subscription.</p>
    public let subscriptionState: SubscriptionState?

    public init (
        subscriptionState: SubscriptionState? = nil
    )
    {
        self.subscriptionState = subscriptionState
    }
}

struct GetSubscriptionStateOutputResponseBody: Equatable {
    public let subscriptionState: SubscriptionState?
}

extension GetSubscriptionStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionState = "SubscriptionState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionStateDecoded = try containerValues.decodeIfPresent(SubscriptionState.self, forKey: .subscriptionState)
        subscriptionState = subscriptionStateDecoded
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that a problem occurred with the service infrastructure. You
///          can retry the request.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the operation would not cause any change to occur.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPaginationTokenException(message: \(String(describing: message)))"}
}

extension InvalidPaginationTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the NextToken specified in the request is invalid. Submit the request using the NextToken value that was returned in the response.</p>
public struct InvalidPaginationTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPaginationTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the parameters passed to the API are invalid. If available, this exception includes details in additional properties. </p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Fields that caused the exception.</p>
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// <p>Additional information about the exception.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension InvalidResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceException(message: \(String(describing: message)))"}
}

extension InvalidResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the resource is invalid. You might not have access to the resource, or the resource might not exist.</p>
public struct InvalidResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Limit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let maxDecoded = try containerValues.decode(Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension Limit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Limit(max: \(String(describing: max)), type: \(String(describing: type)))"}
}

/// <p>Specifies how many protections of a given type you can create.</p>
public struct Limit: Equatable {
    /// <p>The maximum number of protections that can be created for the specified <code>Type</code>.</p>
    public let max: Int
    /// <p>The type of protection.</p>
    public let type: String?

    public init (
        max: Int = 0,
        type: String? = nil
    )
    {
        self.max = max
        self.type = type
    }
}

extension LimitsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitsExceededException(limit: \(String(describing: limit)), type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension LimitsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limit = output.limit
            self.message = output.message
            self.type = output.type
        } else {
            self.limit = 0
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the operation would exceed a limit.</p>
public struct LimitsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The threshold that would be exceeded.</p>
    public var limit: Int
    public var message: String?
    /// <p>The type of limit that would be exceeded.</p>
    public var type: String?

    public init (
        limit: Int = 0,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.type = type
    }
}

struct LimitsExceededExceptionBody: Equatable {
    public let message: String?
    public let type: String?
    public let limit: Int
}

extension LimitsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

public struct ListAttacksInputBodyMiddleware: Middleware {
    public let id: String = "ListAttacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttacksInput>
    public typealias MOutput = OperationOutput<ListAttacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttacksOutputError>
}

extension ListAttacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttacksInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArns: \(String(describing: resourceArns)), startTime: \(String(describing: startTime)))"}
}

extension ListAttacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnfilterlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnfilterlist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

public struct ListAttacksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAttacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttacksInput>
    public typealias MOutput = OperationOutput<ListAttacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttacksOutputError>
}

public struct ListAttacksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAttacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAttacksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAttacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAttacksInput>
    public typealias MOutput = OperationOutput<ListAttacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAttacksOutputError>
}

public struct ListAttacksInput: Equatable {
    /// <p>The end of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
    public let endTime: TimeRange?
    /// <p>The maximum number of <a>AttackSummary</a> objects to return. If you leave this blank,
    ///          Shield Advanced returns the first 20 results.</p>
    ///          <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>The <code>ListAttacksRequest.NextMarker</code> value from a previous call to <code>ListAttacksRequest</code>. Pass null if this is the first call.</p>
    public let nextToken: String?
    /// <p>The ARN (Amazon Resource Name) of the resource that was attacked. If this is left
    ///          blank, all applicable resources for this account will be included.</p>
    public let resourceArns: [String]?
    /// <p>The start of the time period for the attacks. This is a <code>timestamp</code> type. The sample request above indicates a <code>number</code> type because the default used by WAF is Unix time in seconds. However any valid <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp format</a>  is allowed.  </p>
    public let startTime: TimeRange?

    public init (
        endTime: TimeRange? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArns: [String]? = nil,
        startTime: TimeRange? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArns = resourceArns
        self.startTime = startTime
    }
}

struct ListAttacksInputBody: Equatable {
    public let resourceArns: [String]?
    public let startTime: TimeRange?
    public let endTime: TimeRange?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAttacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttacksOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAttacksOutputResponse(attackSummaries: \(String(describing: attackSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAttacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAttacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attackSummaries = output.attackSummaries
            self.nextToken = output.nextToken
        } else {
            self.attackSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttacksOutputResponse: Equatable {
    /// <p>The attack information for the specified time range.</p>
    public let attackSummaries: [AttackSummary]?
    /// <p>The token returned by a previous call to indicate that there is more data available.
    ///          If not null, more results are available. Pass this value for the <code>NextMarker</code>
    ///          parameter in a subsequent call to <code>ListAttacks</code> to retrieve the next set of
    ///          items.</p>
    ///          <p>Shield Advanced might return the list of <a>AttackSummary</a> objects in batches smaller than the number specified by MaxResults. If there are more attack summary objects to return, Shield Advanced will always also return a <code>NextToken</code>.</p>
    public let nextToken: String?

    public init (
        attackSummaries: [AttackSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.attackSummaries = attackSummaries
        self.nextToken = nextToken
    }
}

struct ListAttacksOutputResponseBody: Equatable {
    public let attackSummaries: [AttackSummary]?
    public let nextToken: String?
}

extension ListAttacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attackSummaries = "AttackSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackSummariesContainer = try containerValues.decodeIfPresent([AttackSummary?].self, forKey: .attackSummaries)
        var attackSummariesDecoded0:[AttackSummary]? = nil
        if let attackSummariesContainer = attackSummariesContainer {
            attackSummariesDecoded0 = [AttackSummary]()
            for structure0 in attackSummariesContainer {
                if let structure0 = structure0 {
                    attackSummariesDecoded0?.append(structure0)
                }
            }
        }
        attackSummaries = attackSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProtectionGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListProtectionGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionGroupsInput>
    public typealias MOutput = OperationOutput<ListProtectionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionGroupsOutputError>
}

extension ListProtectionGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectionGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProtectionGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProtectionGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProtectionGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionGroupsInput>
    public typealias MOutput = OperationOutput<ListProtectionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionGroupsOutputError>
}

public struct ListProtectionGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProtectionGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionGroupsInput>
    public typealias MOutput = OperationOutput<ListProtectionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionGroupsOutputError>
}

public struct ListProtectionGroupsInput: Equatable {
    /// <p>The maximum number of <a>ProtectionGroup</a> objects to return. If you leave this blank,
    ///          Shield Advanced returns the first 20 results.</p>
    ///          <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>The next token value from a previous call to <code>ListProtectionGroups</code>. Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListProtectionGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtectionGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectionGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectionGroupsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectionGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectionGroupsOutputResponse(nextToken: \(String(describing: nextToken)), protectionGroups: \(String(describing: protectionGroups)))"}
}

extension ListProtectionGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProtectionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.protectionGroups = output.protectionGroups
        } else {
            self.nextToken = nil
            self.protectionGroups = nil
        }
    }
}

public struct ListProtectionGroupsOutputResponse: Equatable {
    /// <p>If you specify a value for <code>MaxResults</code> and you have more protection groups than the value of MaxResults, AWS Shield Advanced returns this token that you can use in your next request, to get the next batch of objects. </p>
    public let nextToken: String?
    /// <p></p>
    public let protectionGroups: [ProtectionGroup]?

    public init (
        nextToken: String? = nil,
        protectionGroups: [ProtectionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectionGroups = protectionGroups
    }
}

struct ListProtectionGroupsOutputResponseBody: Equatable {
    public let protectionGroups: [ProtectionGroup]?
    public let nextToken: String?
}

extension ListProtectionGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case protectionGroups = "ProtectionGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupsContainer = try containerValues.decodeIfPresent([ProtectionGroup?].self, forKey: .protectionGroups)
        var protectionGroupsDecoded0:[ProtectionGroup]? = nil
        if let protectionGroupsContainer = protectionGroupsContainer {
            protectionGroupsDecoded0 = [ProtectionGroup]()
            for structure0 in protectionGroupsContainer {
                if let structure0 = structure0 {
                    protectionGroupsDecoded0?.append(structure0)
                }
            }
        }
        protectionGroups = protectionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProtectionsInputBodyMiddleware: Middleware {
    public let id: String = "ListProtectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionsInput>
    public typealias MOutput = OperationOutput<ListProtectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionsOutputError>
}

extension ListProtectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProtectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProtectionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProtectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionsInput>
    public typealias MOutput = OperationOutput<ListProtectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionsOutputError>
}

public struct ListProtectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProtectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtectionsInput>
    public typealias MOutput = OperationOutput<ListProtectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtectionsOutputError>
}

public struct ListProtectionsInput: Equatable {
    /// <p>The maximum number of <a>Protection</a> objects to return. If you leave this blank,
    ///          Shield Advanced returns the first 20 results.</p>
    ///          <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>The <code>ListProtectionsRequest.NextToken</code> value from a previous call to <code>ListProtections</code>. Pass null if this is the first call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListProtectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectionsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtectionsOutputResponse(nextToken: \(String(describing: nextToken)), protections: \(String(describing: protections)))"}
}

extension ListProtectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProtectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.protections = output.protections
        } else {
            self.nextToken = nil
            self.protections = nil
        }
    }
}

public struct ListProtectionsOutputResponse: Equatable {
    /// <p>If you specify a value for <code>MaxResults</code> and you have more Protections than the value of MaxResults, AWS Shield Advanced returns a NextToken value in the response that allows you to list another group of Protections. For the second and subsequent ListProtections requests, specify the value of NextToken from the previous response to get information about another batch of Protections.</p>
    ///          <p>Shield Advanced might return the list of <a>Protection</a> objects in batches smaller than the number specified by MaxResults. If there are more <a>Protection</a> objects to return, Shield Advanced will always also return a <code>NextToken</code>.</p>
    public let nextToken: String?
    /// <p>The array of enabled <a>Protection</a> objects.</p>
    public let protections: [Protection]?

    public init (
        nextToken: String? = nil,
        protections: [Protection]? = nil
    )
    {
        self.nextToken = nextToken
        self.protections = protections
    }
}

struct ListProtectionsOutputResponseBody: Equatable {
    public let protections: [Protection]?
    public let nextToken: String?
}

extension ListProtectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case protections = "Protections"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionsContainer = try containerValues.decodeIfPresent([Protection?].self, forKey: .protections)
        var protectionsDecoded0:[Protection]? = nil
        if let protectionsContainer = protectionsContainer {
            protectionsDecoded0 = [Protection]()
            for structure0 in protectionsContainer {
                if let structure0 = structure0 {
                    protectionsDecoded0?.append(structure0)
                }
            }
        }
        protections = protectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInProtectionGroupInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesInProtectionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesInProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInProtectionGroupInput>
    public typealias MOutput = OperationOutput<ListResourcesInProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesInProtectionGroupOutputError>
}

extension ListResourcesInProtectionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInProtectionGroupInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), protectionGroupId: \(String(describing: protectionGroupId)))"}
}

extension ListResourcesInProtectionGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

public struct ListResourcesInProtectionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesInProtectionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesInProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInProtectionGroupInput>
    public typealias MOutput = OperationOutput<ListResourcesInProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesInProtectionGroupOutputError>
}

public struct ListResourcesInProtectionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesInProtectionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesInProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInProtectionGroupInput>
    public typealias MOutput = OperationOutput<ListResourcesInProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesInProtectionGroupOutputError>
}

public struct ListResourcesInProtectionGroupInput: Equatable {
    /// <p>The maximum number of resource ARN objects to return. If you leave this blank,
    ///          Shield Advanced returns the first 20 results.</p>
    ///          <p>This is a maximum value. Shield Advanced might return the results in smaller batches. That is, the number of objects returned could be less than <code>MaxResults</code>, even if there are still more objects yet to return. If there are more objects to return, Shield Advanced returns a value in <code>NextToken</code> that you can use in your next request, to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>The next token value from a previous call to <code>ListResourcesInProtectionGroup</code>. Pass null if this is the first call.</p>
    public let nextToken: String?
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        protectionGroupId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.protectionGroupId = protectionGroupId
    }
}

struct ListResourcesInProtectionGroupInputBody: Equatable {
    public let protectionGroupId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourcesInProtectionGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesInProtectionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesInProtectionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesInProtectionGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesInProtectionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInProtectionGroupOutputResponse(nextToken: \(String(describing: nextToken)), resourceArns: \(String(describing: resourceArns)))"}
}

extension ListResourcesInProtectionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesInProtectionGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceArns = output.resourceArns
        } else {
            self.nextToken = nil
            self.resourceArns = nil
        }
    }
}

public struct ListResourcesInProtectionGroupOutputResponse: Equatable {
    /// <p>If you specify a value for <code>MaxResults</code> and you have more resources in the protection group than the value of MaxResults, AWS Shield Advanced returns this token that you can use in your next request, to get the next batch of objects. </p>
    public let nextToken: String?
    /// <p>The Amazon Resource Names (ARNs) of the resources that are included in the protection group.</p>
    public let resourceArns: [String]?

    public init (
        nextToken: String? = nil,
        resourceArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArns = resourceArns
    }
}

struct ListResourcesInProtectionGroupOutputResponseBody: Equatable {
    public let resourceArns: [String]?
    public let nextToken: String?
}

extension ListResourcesInProtectionGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tag key and value pairs associated with the specified resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LockedSubscriptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LockedSubscriptionException(message: \(String(describing: message)))"}
}

extension LockedSubscriptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LockedSubscriptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are trying to update a subscription that has not yet completed the 1-year commitment. You can change the <code>AutoRenew</code> parameter during the last 30 days of your subscription. This exception indicates that you are attempting to change <code>AutoRenew</code> prior to that period.</p>
public struct LockedSubscriptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LockedSubscriptionExceptionBody: Equatable {
    public let message: String?
}

extension LockedSubscriptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Mitigation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mitigationName = "MitigationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mitigationName = mitigationName {
            try encodeContainer.encode(mitigationName, forKey: .mitigationName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mitigationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mitigationName)
        mitigationName = mitigationNameDecoded
    }
}

extension Mitigation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Mitigation(mitigationName: \(String(describing: mitigationName)))"}
}

/// <p>The mitigation applied to a DDoS attack.</p>
public struct Mitigation: Equatable {
    /// <p>The name of the mitigation taken for this attack.</p>
    public let mitigationName: String?

    public init (
        mitigationName: String? = nil
    )
    {
        self.mitigationName = mitigationName
    }
}

extension NoAssociatedRoleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAssociatedRoleException(message: \(String(describing: message)))"}
}

extension NoAssociatedRoleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAssociatedRoleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ARN of the role that you specifed does not exist.</p>
public struct NoAssociatedRoleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoAssociatedRoleExceptionBody: Equatable {
    public let message: String?
}

extension NoAssociatedRoleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptimisticLockException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OptimisticLockException(message: \(String(describing: message)))"}
}

extension OptimisticLockException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OptimisticLockExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception that indicates that the resource state has been modified by another
///          client. Retrieve the resource and then retry your request.</p>
public struct OptimisticLockException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OptimisticLockExceptionBody: Equatable {
    public let message: String?
}

extension OptimisticLockExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ProactiveEngagementStatus {
    case disabled
    case enabled
    case pending
    case sdkUnknown(String)
}

extension ProactiveEngagementStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProactiveEngagementStatus] {
        return [
            .disabled,
            .enabled,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProactiveEngagementStatus(rawValue: rawValue) ?? ProactiveEngagementStatus.sdkUnknown(rawValue)
    }
}

public enum ProtectedResourceType {
    case applicationLoadBalancer
    case classicLoadBalancer
    case cloudfrontDistribution
    case elasticIpAllocation
    case globalAccelerator
    case route53HostedZone
    case sdkUnknown(String)
}

extension ProtectedResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProtectedResourceType] {
        return [
            .applicationLoadBalancer,
            .classicLoadBalancer,
            .cloudfrontDistribution,
            .elasticIpAllocation,
            .globalAccelerator,
            .route53HostedZone,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applicationLoadBalancer: return "APPLICATION_LOAD_BALANCER"
        case .classicLoadBalancer: return "CLASSIC_LOAD_BALANCER"
        case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
        case .elasticIpAllocation: return "ELASTIC_IP_ALLOCATION"
        case .globalAccelerator: return "GLOBAL_ACCELERATOR"
        case .route53HostedZone: return "ROUTE_53_HOSTED_ZONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProtectedResourceType(rawValue: rawValue) ?? ProtectedResourceType.sdkUnknown(rawValue)
    }
}

extension Protection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthCheckIds = "HealthCheckIds"
        case id = "Id"
        case name = "Name"
        case protectionArn = "ProtectionArn"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckIds = healthCheckIds {
            var healthCheckIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .healthCheckIds)
            for healthcheckids0 in healthCheckIds {
                try healthCheckIdsContainer.encode(healthcheckids0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protectionArn = protectionArn {
            try encodeContainer.encode(protectionArn, forKey: .protectionArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let healthCheckIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .healthCheckIds)
        var healthCheckIdsDecoded0:[String]? = nil
        if let healthCheckIdsContainer = healthCheckIdsContainer {
            healthCheckIdsDecoded0 = [String]()
            for string0 in healthCheckIdsContainer {
                if let string0 = string0 {
                    healthCheckIdsDecoded0?.append(string0)
                }
            }
        }
        healthCheckIds = healthCheckIdsDecoded0
        let protectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionArn)
        protectionArn = protectionArnDecoded
    }
}

extension Protection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Protection(healthCheckIds: \(String(describing: healthCheckIds)), id: \(String(describing: id)), name: \(String(describing: name)), protectionArn: \(String(describing: protectionArn)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>An object that represents a resource that is under DDoS protection.</p>
public struct Protection: Equatable {
    /// <p>The unique identifier (ID) for the Route 53 health check that's associated with the protection. </p>
    public let healthCheckIds: [String]?
    /// <p>The unique identifier (ID) of the protection.</p>
    public let id: String?
    /// <p>The name of the protection. For example, <code>My CloudFront distributions</code>.</p>
    public let name: String?
    /// <p>The ARN (Amazon Resource Name) of the protection.</p>
    public let protectionArn: String?
    /// <p>The ARN (Amazon Resource Name) of the AWS resource that is protected.</p>
    public let resourceArn: String?

    public init (
        healthCheckIds: [String]? = nil,
        id: String? = nil,
        name: String? = nil,
        protectionArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.healthCheckIds = healthCheckIds
        self.id = id
        self.name = name
        self.protectionArn = protectionArn
        self.resourceArn = resourceArn
    }
}

extension ProtectionGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupArn = "ProtectionGroupArn"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupArn = protectionGroupArn {
            try encodeContainer.encode(protectionGroupArn, forKey: .protectionGroupArn)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .members)
        var membersDecoded0:[String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let protectionGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupArn)
        protectionGroupArn = protectionGroupArnDecoded
    }
}

extension ProtectionGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectionGroup(aggregation: \(String(describing: aggregation)), members: \(String(describing: members)), pattern: \(String(describing: pattern)), protectionGroupArn: \(String(describing: protectionGroupArn)), protectionGroupId: \(String(describing: protectionGroupId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>A grouping of protected resources that you and AWS Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives. </p>
public struct ProtectionGroup: Equatable {
    /// <p>Defines how AWS Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
    ///             </li>
    ///             <li>
    ///                <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include CloudFront distributions and origin resources for CloudFront distributions.</p>
    ///             </li>
    ///          </ul>
    public let aggregation: ProtectionGroupAggregation?
    /// <p>The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set <code>Pattern</code> to <code>ARBITRARY</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let members: [String]?
    /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.</p>
    public let pattern: ProtectionGroupPattern?
    /// <p>The ARN (Amazon Resource Name) of the protection group.</p>
    public let protectionGroupArn: String?
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?
    /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group.
    ///            You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let resourceType: ProtectedResourceType?

    public init (
        aggregation: ProtectionGroupAggregation? = nil,
        members: [String]? = nil,
        pattern: ProtectionGroupPattern? = nil,
        protectionGroupArn: String? = nil,
        protectionGroupId: String? = nil,
        resourceType: ProtectedResourceType? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupArn = protectionGroupArn
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
    }
}

public enum ProtectionGroupAggregation {
    case max
    case mean
    case sum
    case sdkUnknown(String)
}

extension ProtectionGroupAggregation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProtectionGroupAggregation] {
        return [
            .max,
            .mean,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .max: return "MAX"
        case .mean: return "MEAN"
        case .sum: return "SUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProtectionGroupAggregation(rawValue: rawValue) ?? ProtectionGroupAggregation.sdkUnknown(rawValue)
    }
}

extension ProtectionGroupArbitraryPatternLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxMembers = "MaxMembers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxMembers != 0 {
            try encodeContainer.encode(maxMembers, forKey: .maxMembers)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxMembersDecoded = try containerValues.decode(Int.self, forKey: .maxMembers)
        maxMembers = maxMembersDecoded
    }
}

extension ProtectionGroupArbitraryPatternLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectionGroupArbitraryPatternLimits(maxMembers: \(String(describing: maxMembers)))"}
}

/// <p>Limits settings on protection groups with arbitrary pattern type. </p>
public struct ProtectionGroupArbitraryPatternLimits: Equatable {
    /// <p>The maximum number of resources you can specify for a single arbitrary pattern in a protection group.</p>
    public let maxMembers: Int

    public init (
        maxMembers: Int = 0
    )
    {
        self.maxMembers = maxMembers
    }
}

extension ProtectionGroupLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxProtectionGroups = "MaxProtectionGroups"
        case patternTypeLimits = "PatternTypeLimits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxProtectionGroups != 0 {
            try encodeContainer.encode(maxProtectionGroups, forKey: .maxProtectionGroups)
        }
        if let patternTypeLimits = patternTypeLimits {
            try encodeContainer.encode(patternTypeLimits, forKey: .patternTypeLimits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxProtectionGroupsDecoded = try containerValues.decode(Int.self, forKey: .maxProtectionGroups)
        maxProtectionGroups = maxProtectionGroupsDecoded
        let patternTypeLimitsDecoded = try containerValues.decodeIfPresent(ProtectionGroupPatternTypeLimits.self, forKey: .patternTypeLimits)
        patternTypeLimits = patternTypeLimitsDecoded
    }
}

extension ProtectionGroupLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectionGroupLimits(maxProtectionGroups: \(String(describing: maxProtectionGroups)), patternTypeLimits: \(String(describing: patternTypeLimits)))"}
}

/// <p>Limits settings on protection groups for your subscription. </p>
public struct ProtectionGroupLimits: Equatable {
    /// <p>The maximum number of protection groups that you can have at one time. </p>
    public let maxProtectionGroups: Int
    /// <p>Limits settings by pattern type in the protection groups for your subscription. </p>
    public let patternTypeLimits: ProtectionGroupPatternTypeLimits?

    public init (
        maxProtectionGroups: Int = 0,
        patternTypeLimits: ProtectionGroupPatternTypeLimits? = nil
    )
    {
        self.maxProtectionGroups = maxProtectionGroups
        self.patternTypeLimits = patternTypeLimits
    }
}

public enum ProtectionGroupPattern {
    case all
    case arbitrary
    case byResourceType
    case sdkUnknown(String)
}

extension ProtectionGroupPattern : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProtectionGroupPattern] {
        return [
            .all,
            .arbitrary,
            .byResourceType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .arbitrary: return "ARBITRARY"
        case .byResourceType: return "BY_RESOURCE_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProtectionGroupPattern(rawValue: rawValue) ?? ProtectionGroupPattern.sdkUnknown(rawValue)
    }
}

extension ProtectionGroupPatternTypeLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arbitraryPatternLimits = "ArbitraryPatternLimits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arbitraryPatternLimits = arbitraryPatternLimits {
            try encodeContainer.encode(arbitraryPatternLimits, forKey: .arbitraryPatternLimits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arbitraryPatternLimitsDecoded = try containerValues.decodeIfPresent(ProtectionGroupArbitraryPatternLimits.self, forKey: .arbitraryPatternLimits)
        arbitraryPatternLimits = arbitraryPatternLimitsDecoded
    }
}

extension ProtectionGroupPatternTypeLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectionGroupPatternTypeLimits(arbitraryPatternLimits: \(String(describing: arbitraryPatternLimits)))"}
}

/// <p>Limits settings by pattern type in the protection groups for your subscription. </p>
public struct ProtectionGroupPatternTypeLimits: Equatable {
    /// <p>Limits settings on protection groups with arbitrary pattern type. </p>
    public let arbitraryPatternLimits: ProtectionGroupArbitraryPatternLimits?

    public init (
        arbitraryPatternLimits: ProtectionGroupArbitraryPatternLimits? = nil
    )
    {
        self.arbitraryPatternLimits = arbitraryPatternLimits
    }
}

extension ProtectionLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectedResourceTypeLimits = "ProtectedResourceTypeLimits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectedResourceTypeLimits = protectedResourceTypeLimits {
            var protectedResourceTypeLimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protectedResourceTypeLimits)
            for limits0 in protectedResourceTypeLimits {
                try protectedResourceTypeLimitsContainer.encode(limits0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedResourceTypeLimitsContainer = try containerValues.decodeIfPresent([Limit?].self, forKey: .protectedResourceTypeLimits)
        var protectedResourceTypeLimitsDecoded0:[Limit]? = nil
        if let protectedResourceTypeLimitsContainer = protectedResourceTypeLimitsContainer {
            protectedResourceTypeLimitsDecoded0 = [Limit]()
            for structure0 in protectedResourceTypeLimitsContainer {
                if let structure0 = structure0 {
                    protectedResourceTypeLimitsDecoded0?.append(structure0)
                }
            }
        }
        protectedResourceTypeLimits = protectedResourceTypeLimitsDecoded0
    }
}

extension ProtectionLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtectionLimits(protectedResourceTypeLimits: \(String(describing: protectedResourceTypeLimits)))"}
}

/// <p>Limits settings on protections for your subscription. </p>
public struct ProtectionLimits: Equatable {
    /// <p>The maximum number of resource types that you can specify in a protection.</p>
    public let protectedResourceTypeLimits: [Limit]?

    public init (
        protectedResourceTypeLimits: [Limit]? = nil
    )
    {
        self.protectedResourceTypeLimits = protectedResourceTypeLimits
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception indicating the specified resource already exists. If available, this exception includes details in additional properties. </p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The type of resource that already exists.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception indicating the specified resource does not exist. If available, this exception includes details in additional properties. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Type of resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SubResourceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attackVectors = "AttackVectors"
        case counters = "Counters"
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for summarizedattackvectorlist0 in attackVectors {
                try attackVectorsContainer.encode(summarizedattackvectorlist0)
            }
        }
        if let counters = counters {
            var countersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .counters)
            for summarizedcounterlist0 in counters {
                try countersContainer.encode(summarizedcounterlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SubResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([SummarizedAttackVector?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[SummarizedAttackVector]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [SummarizedAttackVector]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
        let countersContainer = try containerValues.decodeIfPresent([SummarizedCounter?].self, forKey: .counters)
        var countersDecoded0:[SummarizedCounter]? = nil
        if let countersContainer = countersContainer {
            countersDecoded0 = [SummarizedCounter]()
            for structure0 in countersContainer {
                if let structure0 = structure0 {
                    countersDecoded0?.append(structure0)
                }
            }
        }
        counters = countersDecoded0
    }
}

extension SubResourceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubResourceSummary(attackVectors: \(String(describing: attackVectors)), counters: \(String(describing: counters)), id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>The attack information for the specified SubResource.</p>
public struct SubResourceSummary: Equatable {
    /// <p>The list of attack types and associated counters.</p>
    public let attackVectors: [SummarizedAttackVector]?
    /// <p>The counters that describe the details of the attack.</p>
    public let counters: [SummarizedCounter]?
    /// <p>The unique identifier (ID) of the <code>SubResource</code>.</p>
    public let id: String?
    /// <p>The <code>SubResource</code> type.</p>
    public let type: SubResourceType?

    public init (
        attackVectors: [SummarizedAttackVector]? = nil,
        counters: [SummarizedCounter]? = nil,
        id: String? = nil,
        type: SubResourceType? = nil
    )
    {
        self.attackVectors = attackVectors
        self.counters = counters
        self.id = id
        self.type = type
    }
}

public enum SubResourceType {
    case ip
    case url
    case sdkUnknown(String)
}

extension SubResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubResourceType] {
        return [
            .ip,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ip: return "IP"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubResourceType(rawValue: rawValue) ?? SubResourceType.sdkUnknown(rawValue)
    }
}

extension Subscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoRenew = "AutoRenew"
        case endTime = "EndTime"
        case limits = "Limits"
        case proactiveEngagementStatus = "ProactiveEngagementStatus"
        case startTime = "StartTime"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionLimits = "SubscriptionLimits"
        case timeCommitmentInSeconds = "TimeCommitmentInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let limits = limits {
            var limitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .limits)
            for limits0 in limits {
                try limitsContainer.encode(limits0)
            }
        }
        if let proactiveEngagementStatus = proactiveEngagementStatus {
            try encodeContainer.encode(proactiveEngagementStatus.rawValue, forKey: .proactiveEngagementStatus)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionLimits = subscriptionLimits {
            try encodeContainer.encode(subscriptionLimits, forKey: .subscriptionLimits)
        }
        if timeCommitmentInSeconds != 0 {
            try encodeContainer.encode(timeCommitmentInSeconds, forKey: .timeCommitmentInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let timeCommitmentInSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeCommitmentInSeconds)
        timeCommitmentInSeconds = timeCommitmentInSecondsDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let limitsContainer = try containerValues.decodeIfPresent([Limit?].self, forKey: .limits)
        var limitsDecoded0:[Limit]? = nil
        if let limitsContainer = limitsContainer {
            limitsDecoded0 = [Limit]()
            for structure0 in limitsContainer {
                if let structure0 = structure0 {
                    limitsDecoded0?.append(structure0)
                }
            }
        }
        limits = limitsDecoded0
        let proactiveEngagementStatusDecoded = try containerValues.decodeIfPresent(ProactiveEngagementStatus.self, forKey: .proactiveEngagementStatus)
        proactiveEngagementStatus = proactiveEngagementStatusDecoded
        let subscriptionLimitsDecoded = try containerValues.decodeIfPresent(SubscriptionLimits.self, forKey: .subscriptionLimits)
        subscriptionLimits = subscriptionLimitsDecoded
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension Subscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscription(autoRenew: \(String(describing: autoRenew)), endTime: \(String(describing: endTime)), limits: \(String(describing: limits)), proactiveEngagementStatus: \(String(describing: proactiveEngagementStatus)), startTime: \(String(describing: startTime)), subscriptionArn: \(String(describing: subscriptionArn)), subscriptionLimits: \(String(describing: subscriptionLimits)), timeCommitmentInSeconds: \(String(describing: timeCommitmentInSeconds)))"}
}

/// <p>Information about the AWS Shield Advanced subscription for an account.</p>
public struct Subscription: Equatable {
    /// <p>If <code>ENABLED</code>, the subscription will be automatically renewed at the end of the existing subscription period.</p>
    ///          <p>When you initally create a subscription, <code>AutoRenew</code> is set to <code>ENABLED</code>. You can change this by submitting an <code>UpdateSubscription</code> request. If the <code>UpdateSubscription</code> request does not included a value for <code>AutoRenew</code>, the existing value for <code>AutoRenew</code> remains unchanged.</p>
    public let autoRenew: AutoRenew?
    /// <p>The date and time your subscription will end.</p>
    public let endTime: Date?
    /// <p>Specifies how many protections of a given type you can create.</p>
    public let limits: [Limit]?
    /// <p>If <code>ENABLED</code>, the DDoS Response Team (DRT) will use email and phone to notify contacts about escalations to the DRT and to initiate proactive customer support.</p>
    ///          <p>If <code>PENDING</code>, you have requested proactive engagement and the request is pending. The status changes to <code>ENABLED</code> when your request is fully processed.</p>
    ///          <p>If <code>DISABLED</code>, the DRT will not proactively notify contacts about escalations or to initiate proactive customer support. </p>
    public let proactiveEngagementStatus: ProactiveEngagementStatus?
    /// <p>The start time of the subscription, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let startTime: Date?
    /// <p>The ARN (Amazon Resource Name) of the subscription.</p>
    public let subscriptionArn: String?
    /// <p>Limits settings for your subscription. </p>
    public let subscriptionLimits: SubscriptionLimits?
    /// <p>The length, in seconds, of the AWS Shield Advanced subscription for the account.</p>
    public let timeCommitmentInSeconds: Int

    public init (
        autoRenew: AutoRenew? = nil,
        endTime: Date? = nil,
        limits: [Limit]? = nil,
        proactiveEngagementStatus: ProactiveEngagementStatus? = nil,
        startTime: Date? = nil,
        subscriptionArn: String? = nil,
        subscriptionLimits: SubscriptionLimits? = nil,
        timeCommitmentInSeconds: Int = 0
    )
    {
        self.autoRenew = autoRenew
        self.endTime = endTime
        self.limits = limits
        self.proactiveEngagementStatus = proactiveEngagementStatus
        self.startTime = startTime
        self.subscriptionArn = subscriptionArn
        self.subscriptionLimits = subscriptionLimits
        self.timeCommitmentInSeconds = timeCommitmentInSeconds
    }
}

extension SubscriptionLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protectionGroupLimits = "ProtectionGroupLimits"
        case protectionLimits = "ProtectionLimits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupLimits = protectionGroupLimits {
            try encodeContainer.encode(protectionGroupLimits, forKey: .protectionGroupLimits)
        }
        if let protectionLimits = protectionLimits {
            try encodeContainer.encode(protectionLimits, forKey: .protectionLimits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionLimitsDecoded = try containerValues.decodeIfPresent(ProtectionLimits.self, forKey: .protectionLimits)
        protectionLimits = protectionLimitsDecoded
        let protectionGroupLimitsDecoded = try containerValues.decodeIfPresent(ProtectionGroupLimits.self, forKey: .protectionGroupLimits)
        protectionGroupLimits = protectionGroupLimitsDecoded
    }
}

extension SubscriptionLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscriptionLimits(protectionGroupLimits: \(String(describing: protectionGroupLimits)), protectionLimits: \(String(describing: protectionLimits)))"}
}

/// <p>Limits settings for your subscription. </p>
public struct SubscriptionLimits: Equatable {
    /// <p>Limits settings on protection groups for your subscription. </p>
    public let protectionGroupLimits: ProtectionGroupLimits?
    /// <p>Limits settings on protections for your subscription. </p>
    public let protectionLimits: ProtectionLimits?

    public init (
        protectionGroupLimits: ProtectionGroupLimits? = nil,
        protectionLimits: ProtectionLimits? = nil
    )
    {
        self.protectionGroupLimits = protectionGroupLimits
        self.protectionLimits = protectionLimits
    }
}

public enum SubscriptionState {
    case active
    case inactive
    case sdkUnknown(String)
}

extension SubscriptionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionState] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionState(rawValue: rawValue) ?? SubscriptionState.sdkUnknown(rawValue)
    }
}

extension SummarizedAttackVector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vectorCounters = "VectorCounters"
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorCounters = vectorCounters {
            var vectorCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vectorCounters)
            for summarizedcounterlist0 in vectorCounters {
                try vectorCountersContainer.encode(summarizedcounterlist0)
            }
        }
        if let vectorType = vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
        let vectorCountersContainer = try containerValues.decodeIfPresent([SummarizedCounter?].self, forKey: .vectorCounters)
        var vectorCountersDecoded0:[SummarizedCounter]? = nil
        if let vectorCountersContainer = vectorCountersContainer {
            vectorCountersDecoded0 = [SummarizedCounter]()
            for structure0 in vectorCountersContainer {
                if let structure0 = structure0 {
                    vectorCountersDecoded0?.append(structure0)
                }
            }
        }
        vectorCounters = vectorCountersDecoded0
    }
}

extension SummarizedAttackVector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SummarizedAttackVector(vectorCounters: \(String(describing: vectorCounters)), vectorType: \(String(describing: vectorType)))"}
}

/// <p>A summary of information about the attack.</p>
public struct SummarizedAttackVector: Equatable {
    /// <p>The list of counters that describe the details of the attack.</p>
    public let vectorCounters: [SummarizedCounter]?
    /// <p>The attack type, for example, SNMP reflection or SYN flood.</p>
    public let vectorType: String?

    public init (
        vectorCounters: [SummarizedCounter]? = nil,
        vectorType: String? = nil
    )
    {
        self.vectorCounters = vectorCounters
        self.vectorType = vectorType
    }
}

extension SummarizedCounter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case average = "Average"
        case max = "Max"
        case n = "N"
        case name = "Name"
        case sum = "Sum"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if average != 0.0 {
            try encodeContainer.encode(average, forKey: .average)
        }
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if n != 0 {
            try encodeContainer.encode(n, forKey: .n)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if sum != 0.0 {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decode(Double.self, forKey: .max)
        max = maxDecoded
        let averageDecoded = try containerValues.decode(Double.self, forKey: .average)
        average = averageDecoded
        let sumDecoded = try containerValues.decode(Double.self, forKey: .sum)
        sum = sumDecoded
        let nDecoded = try containerValues.decode(Int.self, forKey: .n)
        n = nDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension SummarizedCounter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SummarizedCounter(average: \(String(describing: average)), max: \(String(describing: max)), n: \(String(describing: n)), name: \(String(describing: name)), sum: \(String(describing: sum)), unit: \(String(describing: unit)))"}
}

/// <p>The counter that describes a DDoS attack.</p>
public struct SummarizedCounter: Equatable {
    /// <p>The average value of the counter for a specified time period.</p>
    public let average: Double
    /// <p>The maximum value of the counter for a specified time period.</p>
    public let max: Double
    /// <p>The number of counters for a specified time period.</p>
    public let n: Int
    /// <p>The counter name.</p>
    public let name: String?
    /// <p>The total of counter values for a specified time period.</p>
    public let sum: Double
    /// <p>The unit of the counters.</p>
    public let unit: String?

    public init (
        average: Double = 0.0,
        max: Double = 0.0,
        n: Int = 0,
        name: String? = nil,
        sum: Double = 0.0,
        unit: String? = nil
    )
    {
        self.average = average
        self.max = max
        self.n = n
        self.name = name
        self.sum = sum
        self.unit = unit
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag associated with an AWS resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each AWS resource, up to 50 tags for a resource.</p>
public struct Tag: Equatable {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    public let key: String?
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.</p>
    public let resourceARN: String?
    /// <p>The tags that you want to modify or add to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromInclusive = "FromInclusive"
        case toExclusive = "ToExclusive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromInclusive = fromInclusive {
            try encodeContainer.encode(fromInclusive.timeIntervalSince1970, forKey: .fromInclusive)
        }
        if let toExclusive = toExclusive {
            try encodeContainer.encode(toExclusive.timeIntervalSince1970, forKey: .toExclusive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromInclusiveDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .fromInclusive)
        fromInclusive = fromInclusiveDecoded
        let toExclusiveDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .toExclusive)
        toExclusive = toExclusiveDecoded
    }
}

extension TimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeRange(fromInclusive: \(String(describing: fromInclusive)), toExclusive: \(String(describing: toExclusive)))"}
}

/// <p>The time range. </p>
public struct TimeRange: Equatable {
    /// <p>The start time, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let fromInclusive: Date?
    /// <p>The end time, in Unix time in seconds. For more information see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#parameter-types">timestamp</a>.</p>
    public let toExclusive: Date?

    public init (
        fromInclusive: Date? = nil,
        toExclusive: Date? = nil
    )
    {
        self.fromInclusive = fromInclusive
        self.toExclusive = toExclusive
    }
}

public enum Unit {
    case bits
    case bytes
    case packets
    case requests
    case sdkUnknown(String)
}

extension Unit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Unit] {
        return [
            .bits,
            .bytes,
            .packets,
            .requests,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bits: return "BITS"
        case .bytes: return "BYTES"
        case .packets: return "PACKETS"
        case .requests: return "REQUESTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to remove tags from.</p>
    public let resourceARN: String?
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEmergencyContactSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEmergencyContactSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmergencyContactSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmergencyContactSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmergencyContactSettingsInput>
    public typealias MOutput = OperationOutput<UpdateEmergencyContactSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmergencyContactSettingsOutputError>
}

extension UpdateEmergencyContactSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmergencyContactSettingsInput(emergencyContactList: \(String(describing: emergencyContactList)))"}
}

extension UpdateEmergencyContactSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontactlist0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontactlist0)
            }
        }
    }
}

public struct UpdateEmergencyContactSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEmergencyContactSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmergencyContactSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmergencyContactSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmergencyContactSettingsInput>
    public typealias MOutput = OperationOutput<UpdateEmergencyContactSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmergencyContactSettingsOutputError>
}

public struct UpdateEmergencyContactSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEmergencyContactSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmergencyContactSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmergencyContactSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmergencyContactSettingsInput>
    public typealias MOutput = OperationOutput<UpdateEmergencyContactSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmergencyContactSettingsOutputError>
}

public struct UpdateEmergencyContactSettingsInput: Equatable {
    /// <p>A list of email addresses and phone numbers that the DDoS Response Team (DRT) can use to contact you if you have proactive engagement enabled, for escalations to the DRT and to initiate proactive customer support.</p>
    ///          <p>If you have proactive engagement enabled, the contact list must include at least one phone number.</p>
    public let emergencyContactList: [EmergencyContact]?

    public init (
        emergencyContactList: [EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct UpdateEmergencyContactSettingsInputBody: Equatable {
    public let emergencyContactList: [EmergencyContact]?
}

extension UpdateEmergencyContactSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension UpdateEmergencyContactSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmergencyContactSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmergencyContactSettingsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmergencyContactSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmergencyContactSettingsOutputResponse()"}
}

extension UpdateEmergencyContactSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEmergencyContactSettingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateEmergencyContactSettingsOutputResponseBody: Equatable {
}

extension UpdateEmergencyContactSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateProtectionGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProtectionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProtectionGroupInput>
    public typealias MOutput = OperationOutput<UpdateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProtectionGroupOutputError>
}

extension UpdateProtectionGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProtectionGroupInput(aggregation: \(String(describing: aggregation)), members: \(String(describing: members)), pattern: \(String(describing: pattern)), protectionGroupId: \(String(describing: protectionGroupId)), resourceType: \(String(describing: resourceType)))"}
}

extension UpdateProtectionGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct UpdateProtectionGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProtectionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProtectionGroupInput>
    public typealias MOutput = OperationOutput<UpdateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProtectionGroupOutputError>
}

public struct UpdateProtectionGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProtectionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProtectionGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProtectionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProtectionGroupInput>
    public typealias MOutput = OperationOutput<UpdateProtectionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProtectionGroupOutputError>
}

public struct UpdateProtectionGroupInput: Equatable {
    /// <p>Defines how AWS Shield combines resource data for the group in order to detect, mitigate, and report events.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.</p>
    ///             </li>
    ///             <li>
    ///                <p>Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include CloudFront distributions and origin resources for CloudFront distributions.</p>
    ///             </li>
    ///          </ul>
    public let aggregation: ProtectionGroupAggregation?
    /// <p>The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set <code>Pattern</code> to <code>ARBITRARY</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let members: [String]?
    /// <p>The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.</p>
    public let pattern: ProtectionGroupPattern?
    /// <p>The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it. </p>
    public let protectionGroupId: String?
    /// <p>The resource type to include in the protection group. All protected resources of this type are included in the protection group.
    ///            You must set this when you set <code>Pattern</code> to <code>BY_RESOURCE_TYPE</code> and you must not set it for any other <code>Pattern</code> setting. </p>
    public let resourceType: ProtectedResourceType?

    public init (
        aggregation: ProtectionGroupAggregation? = nil,
        members: [String]? = nil,
        pattern: ProtectionGroupPattern? = nil,
        protectionGroupId: String? = nil,
        resourceType: ProtectedResourceType? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
    }
}

struct UpdateProtectionGroupInputBody: Equatable {
    public let protectionGroupId: String?
    public let aggregation: ProtectionGroupAggregation?
    public let pattern: ProtectionGroupPattern?
    public let resourceType: ProtectedResourceType?
    public let members: [String]?
}

extension UpdateProtectionGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .members)
        var membersDecoded0:[String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension UpdateProtectionGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProtectionGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProtectionGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProtectionGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProtectionGroupOutputResponse()"}
}

extension UpdateProtectionGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProtectionGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateProtectionGroupOutputResponseBody: Equatable {
}

extension UpdateProtectionGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionOutputError>
}

extension UpdateSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriptionInput(autoRenew: \(String(describing: autoRenew)))"}
}

extension UpdateSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoRenew = "AutoRenew"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
    }
}

public struct UpdateSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionOutputError>
}

public struct UpdateSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriptionOutputError>
}

public struct UpdateSubscriptionInput: Equatable {
    /// <p>When you initally create a subscription, <code>AutoRenew</code> is set to <code>ENABLED</code>. If <code>ENABLED</code>, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an <code>UpdateSubscription</code> request. If the <code>UpdateSubscription</code> request does not included a value for <code>AutoRenew</code>, the existing value for <code>AutoRenew</code> remains unchanged.</p>
    public let autoRenew: AutoRenew?

    public init (
        autoRenew: AutoRenew? = nil
    )
    {
        self.autoRenew = autoRenew
    }
}

struct UpdateSubscriptionInputBody: Equatable {
    public let autoRenew: AutoRenew?
}

extension UpdateSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoRenew = "AutoRenew"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoRenewDecoded = try containerValues.decodeIfPresent(AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
    }
}

extension UpdateSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockedSubscriptionException" : self = .lockedSubscriptionException(try LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubscriptionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case lockedSubscriptionException(LockedSubscriptionException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriptionOutputResponse()"}
}

extension UpdateSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct UpdateSubscriptionOutputResponseBody: Equatable {
}

extension UpdateSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Provides information about a particular parameter passed inside a request that resulted in an exception.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>The message describing why the parameter failed validation.</p>
    public let message: String?
    /// <p>The name of the parameter that failed validation.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case fieldValidationFailed
    case other
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .fieldValidationFailed,
            .other,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
