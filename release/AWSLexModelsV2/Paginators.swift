// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAggregatedUtterancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAggregatedUtterancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAggregatedUtterancesOutputResponse`
extension LexModelsV2Client {
    public func listAggregatedUtterancesPaginated(input: ListAggregatedUtterancesInput) -> ClientRuntime.PaginatorSequence<ListAggregatedUtterancesInput, ListAggregatedUtterancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAggregatedUtterancesInput, ListAggregatedUtterancesOutputResponse>(input: input, inputKey: \ListAggregatedUtterancesInput.nextToken, outputKey: \ListAggregatedUtterancesOutputResponse.nextToken, paginationFunction: self.listAggregatedUtterances(input:))
    }
}

extension ListAggregatedUtterancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAggregatedUtterancesInput {
        return ListAggregatedUtterancesInput(
            aggregationDuration: self.aggregationDuration,
            botAliasId: self.botAliasId,
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListBotAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotAliasesOutputResponse`
extension LexModelsV2Client {
    public func listBotAliasesPaginated(input: ListBotAliasesInput) -> ClientRuntime.PaginatorSequence<ListBotAliasesInput, ListBotAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotAliasesInput, ListBotAliasesOutputResponse>(input: input, inputKey: \ListBotAliasesInput.nextToken, outputKey: \ListBotAliasesOutputResponse.nextToken, paginationFunction: self.listBotAliases(input:))
    }
}

extension ListBotAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotAliasesInput {
        return ListBotAliasesInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListBotLocalesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotLocalesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotLocalesOutputResponse`
extension LexModelsV2Client {
    public func listBotLocalesPaginated(input: ListBotLocalesInput) -> ClientRuntime.PaginatorSequence<ListBotLocalesInput, ListBotLocalesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotLocalesInput, ListBotLocalesOutputResponse>(input: input, inputKey: \ListBotLocalesInput.nextToken, outputKey: \ListBotLocalesOutputResponse.nextToken, paginationFunction: self.listBotLocales(input:))
    }
}

extension ListBotLocalesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotLocalesInput {
        return ListBotLocalesInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListBotRecommendationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotRecommendationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotRecommendationsOutputResponse`
extension LexModelsV2Client {
    public func listBotRecommendationsPaginated(input: ListBotRecommendationsInput) -> ClientRuntime.PaginatorSequence<ListBotRecommendationsInput, ListBotRecommendationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotRecommendationsInput, ListBotRecommendationsOutputResponse>(input: input, inputKey: \ListBotRecommendationsInput.nextToken, outputKey: \ListBotRecommendationsOutputResponse.nextToken, paginationFunction: self.listBotRecommendations(input:))
    }
}

extension ListBotRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotRecommendationsInput {
        return ListBotRecommendationsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListBotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotsOutputResponse`
extension LexModelsV2Client {
    public func listBotsPaginated(input: ListBotsInput) -> ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutputResponse>(input: input, inputKey: \ListBotsInput.nextToken, outputKey: \ListBotsOutputResponse.nextToken, paginationFunction: self.listBots(input:))
    }
}

extension ListBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotsInput {
        return ListBotsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListBotVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBotVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBotVersionsOutputResponse`
extension LexModelsV2Client {
    public func listBotVersionsPaginated(input: ListBotVersionsInput) -> ClientRuntime.PaginatorSequence<ListBotVersionsInput, ListBotVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBotVersionsInput, ListBotVersionsOutputResponse>(input: input, inputKey: \ListBotVersionsInput.nextToken, outputKey: \ListBotVersionsOutputResponse.nextToken, paginationFunction: self.listBotVersions(input:))
    }
}

extension ListBotVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotVersionsInput {
        return ListBotVersionsInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListBuiltInIntentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBuiltInIntentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBuiltInIntentsOutputResponse`
extension LexModelsV2Client {
    public func listBuiltInIntentsPaginated(input: ListBuiltInIntentsInput) -> ClientRuntime.PaginatorSequence<ListBuiltInIntentsInput, ListBuiltInIntentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBuiltInIntentsInput, ListBuiltInIntentsOutputResponse>(input: input, inputKey: \ListBuiltInIntentsInput.nextToken, outputKey: \ListBuiltInIntentsOutputResponse.nextToken, paginationFunction: self.listBuiltInIntents(input:))
    }
}

extension ListBuiltInIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuiltInIntentsInput {
        return ListBuiltInIntentsInput(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListBuiltInSlotTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBuiltInSlotTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBuiltInSlotTypesOutputResponse`
extension LexModelsV2Client {
    public func listBuiltInSlotTypesPaginated(input: ListBuiltInSlotTypesInput) -> ClientRuntime.PaginatorSequence<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutputResponse>(input: input, inputKey: \ListBuiltInSlotTypesInput.nextToken, outputKey: \ListBuiltInSlotTypesOutputResponse.nextToken, paginationFunction: self.listBuiltInSlotTypes(input:))
    }
}

extension ListBuiltInSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuiltInSlotTypesInput {
        return ListBuiltInSlotTypesInput(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListExportsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExportsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExportsOutputResponse`
extension LexModelsV2Client {
    public func listExportsPaginated(input: ListExportsInput) -> ClientRuntime.PaginatorSequence<ListExportsInput, ListExportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExportsInput, ListExportsOutputResponse>(input: input, inputKey: \ListExportsInput.nextToken, outputKey: \ListExportsOutputResponse.nextToken, paginationFunction: self.listExports(input:))
    }
}

extension ListExportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExportsInput {
        return ListExportsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListImportsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImportsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImportsOutputResponse`
extension LexModelsV2Client {
    public func listImportsPaginated(input: ListImportsInput) -> ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutputResponse>(input: input, inputKey: \ListImportsInput.nextToken, outputKey: \ListImportsOutputResponse.nextToken, paginationFunction: self.listImports(input:))
    }
}

extension ListImportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImportsInput {
        return ListImportsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListIntentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIntentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIntentsOutputResponse`
extension LexModelsV2Client {
    public func listIntentsPaginated(input: ListIntentsInput) -> ClientRuntime.PaginatorSequence<ListIntentsInput, ListIntentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIntentsInput, ListIntentsOutputResponse>(input: input, inputKey: \ListIntentsInput.nextToken, outputKey: \ListIntentsOutputResponse.nextToken, paginationFunction: self.listIntents(input:))
    }
}

extension ListIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntentsInput {
        return ListIntentsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListRecommendedIntentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRecommendedIntentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRecommendedIntentsOutputResponse`
extension LexModelsV2Client {
    public func listRecommendedIntentsPaginated(input: ListRecommendedIntentsInput) -> ClientRuntime.PaginatorSequence<ListRecommendedIntentsInput, ListRecommendedIntentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecommendedIntentsInput, ListRecommendedIntentsOutputResponse>(input: input, inputKey: \ListRecommendedIntentsInput.nextToken, outputKey: \ListRecommendedIntentsOutputResponse.nextToken, paginationFunction: self.listRecommendedIntents(input:))
    }
}

extension ListRecommendedIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendedIntentsInput {
        return ListRecommendedIntentsInput(
            botId: self.botId,
            botRecommendationId: self.botRecommendationId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListSlotsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSlotsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSlotsOutputResponse`
extension LexModelsV2Client {
    public func listSlotsPaginated(input: ListSlotsInput) -> ClientRuntime.PaginatorSequence<ListSlotsInput, ListSlotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSlotsInput, ListSlotsOutputResponse>(input: input, inputKey: \ListSlotsInput.nextToken, outputKey: \ListSlotsOutputResponse.nextToken, paginationFunction: self.listSlots(input:))
    }
}

extension ListSlotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSlotsInput {
        return ListSlotsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            intentId: self.intentId,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}

/// Paginate over `[ListSlotTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSlotTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSlotTypesOutputResponse`
extension LexModelsV2Client {
    public func listSlotTypesPaginated(input: ListSlotTypesInput) -> ClientRuntime.PaginatorSequence<ListSlotTypesInput, ListSlotTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSlotTypesInput, ListSlotTypesOutputResponse>(input: input, inputKey: \ListSlotTypesInput.nextToken, outputKey: \ListSlotTypesOutputResponse.nextToken, paginationFunction: self.listSlotTypes(input:))
    }
}

extension ListSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSlotTypesInput {
        return ListSlotTypesInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
