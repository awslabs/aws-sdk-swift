// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpenSearchServerlessClientTypes.AccessPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .policy)
        policy = policyDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless access policy.
    public struct AccessPolicyDetail: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: ClientRuntime.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init (
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: ClientRuntime.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.AccessPolicyStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPolicyCount = "DataPolicyCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPolicyCount = self.dataPolicyCount {
            try encodeContainer.encode(dataPolicyCount, forKey: .dataPolicyCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPolicyCount)
        dataPolicyCount = dataPolicyCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless access policy.
    public struct AccessPolicyStats: Swift.Equatable {
        /// The number of data access policies in the current account.
        public var dataPolicyCount: Swift.Int?

        public init (
            dataPolicyCount: Swift.Int? = nil
        )
        {
            self.dataPolicyCount = dataPolicyCount
        }
    }

}

extension OpenSearchServerlessClientTypes.AccessPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of the data access policy.
    public struct AccessPolicySummary: Swift.Equatable {
        /// The Epoch time when the access policy was created.
        public var createdDate: Swift.Int?
        /// The description of the access policy.
        public var description: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the access policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of access policy. Currently the only available type is data.
        public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

        public init (
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum AccessPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// data policy type
        case data
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPolicyType] {
            return [
                .data,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .data: return "data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPolicyType(rawValue: rawValue) ?? AccessPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.AccountSettingsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityLimits = self.capacityLimits {
            try encodeContainer.encode(capacityLimits, forKey: .capacityLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CapacityLimits.self, forKey: .capacityLimits)
        capacityLimits = capacityLimitsDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// OpenSearch Serverless-related information for the current account.
    public struct AccountSettingsDetail: Swift.Equatable {
        /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Autoscaling](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-overview.html#serverless-scaling).
        public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

        public init (
            capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
        )
        {
            self.capacityLimits = capacityLimits
        }
    }

}

extension BatchGetCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for collectionid0 in ids {
                try idsContainer.encode(collectionid0)
            }
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for collectionname0 in names {
                try namesContainer.encode(collectionname0)
            }
        }
    }
}

extension BatchGetCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetCollectionInput: Swift.Equatable {
    /// A list of collection IDs. You can't provide names and IDs in the same request. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    public var ids: [Swift.String]?
    /// A list of collection names. You can't provide names and IDs in the same request.
    public var names: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.names = names
    }
}

struct BatchGetCollectionInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let names: [Swift.String]?
}

extension BatchGetCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case names
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetCollectionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionDetails = output.collectionDetails
            self.collectionErrorDetails = output.collectionErrorDetails
        } else {
            self.collectionDetails = nil
            self.collectionErrorDetails = nil
        }
    }
}

public struct BatchGetCollectionOutputResponse: Swift.Equatable {
    /// Details about each collection.
    public var collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]?
    /// Error information for the request.
    public var collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]?

    public init (
        collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]? = nil,
        collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]? = nil
    )
    {
        self.collectionDetails = collectionDetails
        self.collectionErrorDetails = collectionErrorDetails
    }
}

struct BatchGetCollectionOutputResponseBody: Swift.Equatable {
    let collectionDetails: [OpenSearchServerlessClientTypes.CollectionDetail]?
    let collectionErrorDetails: [OpenSearchServerlessClientTypes.CollectionErrorDetail]?
}

extension BatchGetCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionDetails
        case collectionErrorDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionDetail?].self, forKey: .collectionDetails)
        var collectionDetailsDecoded0:[OpenSearchServerlessClientTypes.CollectionDetail]? = nil
        if let collectionDetailsContainer = collectionDetailsContainer {
            collectionDetailsDecoded0 = [OpenSearchServerlessClientTypes.CollectionDetail]()
            for structure0 in collectionDetailsContainer {
                if let structure0 = structure0 {
                    collectionDetailsDecoded0?.append(structure0)
                }
            }
        }
        collectionDetails = collectionDetailsDecoded0
        let collectionErrorDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionErrorDetail?].self, forKey: .collectionErrorDetails)
        var collectionErrorDetailsDecoded0:[OpenSearchServerlessClientTypes.CollectionErrorDetail]? = nil
        if let collectionErrorDetailsContainer = collectionErrorDetailsContainer {
            collectionErrorDetailsDecoded0 = [OpenSearchServerlessClientTypes.CollectionErrorDetail]()
            for structure0 in collectionErrorDetailsContainer {
                if let structure0 = structure0 {
                    collectionErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        collectionErrorDetails = collectionErrorDetailsDecoded0
    }
}

extension BatchGetVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for vpcendpointid0 in ids {
                try idsContainer.encode(vpcendpointid0)
            }
        }
    }
}

extension BatchGetVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetVpcEndpointInput: Swift.Equatable {
    /// A list of VPC endpoint identifiers.
    /// This member is required.
    public var ids: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetVpcEndpointInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchGetVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetVpcEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetVpcEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetVpcEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetVpcEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetVpcEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcEndpointDetails = output.vpcEndpointDetails
            self.vpcEndpointErrorDetails = output.vpcEndpointErrorDetails
        } else {
            self.vpcEndpointDetails = nil
            self.vpcEndpointErrorDetails = nil
        }
    }
}

public struct BatchGetVpcEndpointOutputResponse: Swift.Equatable {
    /// Details about the specified VPC endpoint.
    public var vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]?
    /// Error information for a failed request.
    public var vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]?

    public init (
        vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]? = nil,
        vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]? = nil
    )
    {
        self.vpcEndpointDetails = vpcEndpointDetails
        self.vpcEndpointErrorDetails = vpcEndpointErrorDetails
    }
}

struct BatchGetVpcEndpointOutputResponseBody: Swift.Equatable {
    let vpcEndpointDetails: [OpenSearchServerlessClientTypes.VpcEndpointDetail]?
    let vpcEndpointErrorDetails: [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]?
}

extension BatchGetVpcEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcEndpointDetails
        case vpcEndpointErrorDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointDetail?].self, forKey: .vpcEndpointDetails)
        var vpcEndpointDetailsDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointDetail]? = nil
        if let vpcEndpointDetailsContainer = vpcEndpointDetailsContainer {
            vpcEndpointDetailsDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointDetail]()
            for structure0 in vpcEndpointDetailsContainer {
                if let structure0 = structure0 {
                    vpcEndpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointDetails = vpcEndpointDetailsDecoded0
        let vpcEndpointErrorDetailsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointErrorDetail?].self, forKey: .vpcEndpointErrorDetails)
        var vpcEndpointErrorDetailsDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]? = nil
        if let vpcEndpointErrorDetailsContainer = vpcEndpointErrorDetailsContainer {
            vpcEndpointErrorDetailsDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointErrorDetail]()
            for structure0 in vpcEndpointErrorDetailsContainer {
                if let structure0 = structure0 {
                    vpcEndpointErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointErrorDetails = vpcEndpointErrorDetailsDecoded0
    }
}

extension OpenSearchServerlessClientTypes.CapacityLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxIndexingCapacityInOCU
        case maxSearchCapacityInOCU
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxIndexingCapacityInOCU = self.maxIndexingCapacityInOCU {
            try encodeContainer.encode(maxIndexingCapacityInOCU, forKey: .maxIndexingCapacityInOCU)
        }
        if let maxSearchCapacityInOCU = self.maxSearchCapacityInOCU {
            try encodeContainer.encode(maxSearchCapacityInOCU, forKey: .maxSearchCapacityInOCU)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxIndexingCapacityInOCUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIndexingCapacityInOCU)
        maxIndexingCapacityInOCU = maxIndexingCapacityInOCUDecoded
        let maxSearchCapacityInOCUDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSearchCapacityInOCU)
        maxSearchCapacityInOCU = maxSearchCapacityInOCUDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Autoscaling](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-overview.html#serverless-scaling).
    public struct CapacityLimits: Swift.Equatable {
        /// The maximum indexing capacity for collections.
        public var maxIndexingCapacityInOCU: Swift.Int?
        /// The maximum search capacity for collections.
        public var maxSearchCapacityInOCU: Swift.Int?

        public init (
            maxIndexingCapacityInOCU: Swift.Int? = nil,
            maxSearchCapacityInOCU: Swift.Int? = nil
        )
        {
            self.maxIndexingCapacityInOCU = maxIndexingCapacityInOCU
            self.maxSearchCapacityInOCU = maxSearchCapacityInOCU
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collectionEndpoint
        case createdDate
        case dashboardEndpoint
        case description
        case id
        case kmsKeyArn
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collectionEndpoint = self.collectionEndpoint {
            try encodeContainer.encode(collectionEndpoint, forKey: .collectionEndpoint)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let dashboardEndpoint = self.dashboardEndpoint {
            try encodeContainer.encode(dashboardEndpoint, forKey: .dashboardEndpoint)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let collectionEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionEndpoint)
        collectionEndpoint = collectionEndpointDecoded
        let dashboardEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardEndpoint)
        dashboardEndpoint = dashboardEndpointDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about each OpenSearch Serverless collection, including the collection endpoint and the OpenSearch Dashboards endpoint.
    public struct CollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// Collection-specific endpoint used to submit index, search, and data upload requests to an OpenSearch Serverless collection.
        public var collectionEndpoint: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// Collection-specific endpoint used to access OpenSearch Dashboards.
        public var dashboardEndpoint: Swift.String?
        /// A description of the collection.
        public var description: Swift.String?
        /// A unique identifier for the collection.
        public var id: Swift.String?
        /// The ARN of the Amazon Web Services KMS key used to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init (
            arn: Swift.String? = nil,
            collectionEndpoint: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            dashboardEndpoint: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.collectionEndpoint = collectionEndpoint
            self.createdDate = createdDate
            self.dashboardEndpoint = dashboardEndpoint
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Error information for an OpenSearch Serverless request.
    public struct CollectionErrorDetail: Swift.Equatable {
        /// The error code for the request. For example, NOT_FOUND.
        public var errorCode: Swift.String?
        /// A description of the error. For example, The specified Collection is not found.
        public var errorMessage: Swift.String?
        /// If the request contains collection IDs, the response includes the IDs provided in the request.
        public var id: Swift.String?
        /// If the request contains collection names, the response includes the names provided in the request.
        public var name: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
        }
    }

}

extension OpenSearchServerlessClientTypes.CollectionFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// List of filter keys that you can use for LIST, UPDATE, and DELETE requests to OpenSearch Serverless collections.
    public struct CollectionFilters: Swift.Equatable {
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init (
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum CollectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Collection resource is ready to use
        case active
        /// Creating collection resource
        case creating
        /// Deleting collection resource
        case deleting
        /// Collection resource create or delete failed
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectionStatus(rawValue: rawValue) ?? CollectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.CollectionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about each OpenSearch Serverless collection.
    public struct CollectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum CollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Search collection type
        case search
        /// Timeseries collection type
        case timeseries
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectionType] {
            return [
                .search,
                .timeseries,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .search: return "SEARCH"
            case .timeseries: return "TIMESERIES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectionType(rawValue: rawValue) ?? CollectionType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// When creating a collection, thrown when a collection with the same name already exists or is being created. When deleting a collection, thrown when the collection is not in the ACTIVE or FAILED state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

struct CreateAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct CreateAccessPolicyOutputResponse: Swift.Equatable {
    /// Details about the created access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init (
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct CreateAccessPolicyOutputResponseBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension CreateAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

extension OpenSearchServerlessClientTypes.CreateCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case id
        case kmsKeyArn
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about the created OpenSearch Serverless collection.
    public struct CreateCollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The Epoch time when the collection was created.
        public var createdDate: Swift.Int?
        /// A description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the collection.
        public var kmsKeyArn: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The type of collection.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init (
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension CreateCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCollectionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// Description of the collection.
    public var description: Swift.String?
    /// Name of the collection.
    /// This member is required.
    public var name: Swift.String?
    /// An arbitrary set of tags (keyvalue pairs) to associate with the OpenSearch Serverless collection.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?
    /// The type of collection.
    public var type: OpenSearchServerlessClientTypes.CollectionType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil,
        type: OpenSearchServerlessClientTypes.CollectionType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateCollectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: OpenSearchServerlessClientTypes.CollectionType?
    let description: Swift.String?
    let tags: [OpenSearchServerlessClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCollectionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createCollectionDetail = output.createCollectionDetail
        } else {
            self.createCollectionDetail = nil
        }
    }
}

public struct CreateCollectionOutputResponse: Swift.Equatable {
    /// Details about the collection.
    public var createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail?

    public init (
        createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail? = nil
    )
    {
        self.createCollectionDetail = createCollectionDetail
    }
}

struct CreateCollectionOutputResponseBody: Swift.Equatable {
    let createCollectionDetail: OpenSearchServerlessClientTypes.CreateCollectionDetail?
}

extension CreateCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createCollectionDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CreateCollectionDetail.self, forKey: .createCollectionDetail)
        createCollectionDetail = createCollectionDetailDecoded
    }
}

extension CreateSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case samlOptions
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// The name of the security configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Describes SAML options in in the form of a key-value map.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.samlOptions = samlOptions
        self.type = type
    }
}

struct CreateSecurityConfigInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityConfigType?
    let name: Swift.String?
    let description: Swift.String?
    let samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    let clientToken: Swift.String?
}

extension CreateSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case samlOptions
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSecurityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecurityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSecurityConfigOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecurityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSecurityConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct CreateSecurityConfigOutputResponse: Swift.Equatable {
    /// Details about the created security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init (
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct CreateSecurityConfigOutputResponseBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension CreateSecurityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

extension CreateSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.type = type
    }
}

struct CreateSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension CreateSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct CreateSecurityPolicyOutputResponse: Swift.Equatable {
    /// Details about the created security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init (
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct CreateSecurityPolicyOutputResponseBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension CreateSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

extension OpenSearchServerlessClientTypes.CreateVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Creation details for an OpenSearch Serverless-managed interface endpoint. For more information, see [Access Amazon OpenSearch Serverless using an interface endpoint](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-vpc.html).
    public struct CreateVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status in the endpoint creation process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension CreateVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVpcEndpointInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the interface endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var securityGroupIds: [Swift.String]?
    /// The ID of one or more subnets from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC from which you'll access OpenSearch Serverless.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct CreateVpcEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let vpcId: Swift.String?
    let subnetIds: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension CreateVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVpcEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVpcEndpointOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVpcEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createVpcEndpointDetail = output.createVpcEndpointDetail
        } else {
            self.createVpcEndpointDetail = nil
        }
    }
}

public struct CreateVpcEndpointOutputResponse: Swift.Equatable {
    /// Details about the created interface VPC endpoint.
    public var createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail?

    public init (
        createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail? = nil
    )
    {
        self.createVpcEndpointDetail = createVpcEndpointDetail
    }
}

struct CreateVpcEndpointOutputResponseBody: Swift.Equatable {
    let createVpcEndpointDetail: OpenSearchServerlessClientTypes.CreateVpcEndpointDetail?
}

extension CreateVpcEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createVpcEndpointDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CreateVpcEndpointDetail.self, forKey: .createVpcEndpointDetail)
        createVpcEndpointDetail = createVpcEndpointDetailDecoded
    }
}

extension DeleteAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DeleteAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

struct DeleteAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension OpenSearchServerlessClientTypes.DeleteCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about a deleted OpenSearch Serverless collection.
    public struct DeleteCollectionDetail: Swift.Equatable {
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension DeleteCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCollectionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the collection. For example, 1iu5usc406kd. The ID is part of the collection endpoint. You can also retrieve it using the [ListCollections](https://docs.aws.amazon.com/opensearch-service/latest/ServerlessAPIReference/API_ListCollections.html) API.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteCollectionInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCollectionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deleteCollectionDetail = output.deleteCollectionDetail
        } else {
            self.deleteCollectionDetail = nil
        }
    }
}

public struct DeleteCollectionOutputResponse: Swift.Equatable {
    /// Details of the deleted collection.
    public var deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail?

    public init (
        deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail? = nil
    )
    {
        self.deleteCollectionDetail = deleteCollectionDetail
    }
}

struct DeleteCollectionOutputResponseBody: Swift.Equatable {
    let deleteCollectionDetail: OpenSearchServerlessClientTypes.DeleteCollectionDetail?
}

extension DeleteCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteCollectionDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.DeleteCollectionDetail.self, forKey: .deleteCollectionDetail)
        deleteCollectionDetail = deleteCollectionDetailDecoded
    }
}

extension DeleteSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteSecurityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecurityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSecurityConfigOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecurityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSecurityConfigOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DeleteSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the policy to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.type = type
    }
}

struct DeleteSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSecurityPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Deletion details for an OpenSearch Serverless-managed interface endpoint.
    public struct DeleteVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint deletion process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension DeleteVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVpcEndpointInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The VPC endpoint identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteVpcEndpointInputBody: Swift.Equatable {
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteVpcEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVpcEndpointOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVpcEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deleteVpcEndpointDetail = output.deleteVpcEndpointDetail
        } else {
            self.deleteVpcEndpointDetail = nil
        }
    }
}

public struct DeleteVpcEndpointOutputResponse: Swift.Equatable {
    /// Details about the deleted endpoint.
    public var deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail?

    public init (
        deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail? = nil
    )
    {
        self.deleteVpcEndpointDetail = deleteVpcEndpointDetail
    }
}

struct DeleteVpcEndpointOutputResponseBody: Swift.Equatable {
    let deleteVpcEndpointDetail: OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail?
}

extension DeleteVpcEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteVpcEndpointDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.DeleteVpcEndpointDetail.self, forKey: .deleteVpcEndpointDetail)
        deleteVpcEndpointDetail = deleteVpcEndpointDetailDecoded
    }
}

extension GetAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccessPolicyInput: Swift.Equatable {
    /// The name of the access policy.
    /// This member is required.
    public var name: Swift.String?
    /// Tye type of policy. Currently the only supported value is data.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init (
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

struct GetAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
}

extension GetAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct GetAccessPolicyOutputResponse: Swift.Equatable {
    /// Details about the requested access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init (
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct GetAccessPolicyOutputResponseBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension GetAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

extension GetAccountSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {

    public init () { }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettingsDetail = output.accountSettingsDetail
        } else {
            self.accountSettingsDetail = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Swift.Equatable {
    /// OpenSearch Serverless-related details for the current account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init (
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

struct GetAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?
}

extension GetAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettingsDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccountSettingsDetail.self, forKey: .accountSettingsDetail)
        accountSettingsDetail = accountSettingsDetailDecoded
    }
}

extension GetPoliciesStatsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetPoliciesStatsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPoliciesStatsInput: Swift.Equatable {

    public init () { }
}

struct GetPoliciesStatsInputBody: Swift.Equatable {
}

extension GetPoliciesStatsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPoliciesStatsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPoliciesStatsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPoliciesStatsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPoliciesStatsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPoliciesStatsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyStats = output.accessPolicyStats
            self.securityConfigStats = output.securityConfigStats
            self.securityPolicyStats = output.securityPolicyStats
            self.totalPolicyCount = output.totalPolicyCount
        } else {
            self.accessPolicyStats = nil
            self.securityConfigStats = nil
            self.securityPolicyStats = nil
            self.totalPolicyCount = nil
        }
    }
}

public struct GetPoliciesStatsOutputResponse: Swift.Equatable {
    /// Information about the data access policies in your account.
    public var accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats?
    /// Information about the security configurations in your account.
    public var securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats?
    /// Information about the security policies in your account.
    public var securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats?
    /// The total number of OpenSearch Serverless security policies and configurations in your account.
    public var totalPolicyCount: Swift.Int?

    public init (
        accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats? = nil,
        securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats? = nil,
        securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats? = nil,
        totalPolicyCount: Swift.Int? = nil
    )
    {
        self.accessPolicyStats = accessPolicyStats
        self.securityConfigStats = securityConfigStats
        self.securityPolicyStats = securityPolicyStats
        self.totalPolicyCount = totalPolicyCount
    }
}

struct GetPoliciesStatsOutputResponseBody: Swift.Equatable {
    let accessPolicyStats: OpenSearchServerlessClientTypes.AccessPolicyStats?
    let securityPolicyStats: OpenSearchServerlessClientTypes.SecurityPolicyStats?
    let securityConfigStats: OpenSearchServerlessClientTypes.SecurityConfigStats?
    let totalPolicyCount: Swift.Int?
}

extension GetPoliciesStatsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyStats = "AccessPolicyStats"
        case securityConfigStats = "SecurityConfigStats"
        case securityPolicyStats = "SecurityPolicyStats"
        case totalPolicyCount = "TotalPolicyCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyStats.self, forKey: .accessPolicyStats)
        accessPolicyStats = accessPolicyStatsDecoded
        let securityPolicyStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyStats.self, forKey: .securityPolicyStats)
        securityPolicyStats = securityPolicyStatsDecoded
        let securityConfigStatsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigStats.self, forKey: .securityConfigStats)
        securityConfigStats = securityConfigStatsDecoded
        let totalPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalPolicyCount)
        totalPolicyCount = totalPolicyCountDecoded
    }
}

extension GetSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension GetSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSecurityConfigInput: Swift.Equatable {
    /// The unique identifier of the security configuration.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetSecurityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecurityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSecurityConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecurityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSecurityConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct GetSecurityConfigOutputResponse: Swift.Equatable {
    /// Details of the requested security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init (
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct GetSecurityConfigOutputResponseBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension GetSecurityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

extension GetSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension GetSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSecurityPolicyInput: Swift.Equatable {
    /// The name of the security policy.
    /// This member is required.
    public var name: Swift.String?
    /// The type of security policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init (
        name: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

struct GetSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
}

extension GetSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct GetSecurityPolicyOutputResponse: Swift.Equatable {
    /// Details about the requested security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init (
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct GetSecurityPolicyOutputResponseBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension GetSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when an error internal to the service occurs while processing a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resource = resource {
            var resourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resource)
            for resource0 in resource {
                try resourceContainer.encode(resource0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccessPoliciesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListAccessPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListAccessPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collection or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

struct ListAccessPoliciesInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let resource: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAccessPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let resourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resource)
        var resourceDecoded0:[Swift.String]? = nil
        if let resourceContainer = resourceContainer {
            resourceDecoded0 = [Swift.String]()
            for string0 in resourceContainer {
                if let string0 = string0 {
                    resourceDecoded0?.append(string0)
                }
            }
        }
        resource = resourceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutputResponse: Swift.Equatable {
    /// Details about the requested access policies.
    public var accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputResponseBody: Swift.Equatable {
    let accessPolicySummaries: [OpenSearchServerlessClientTypes.AccessPolicySummary]?
    let nextToken: Swift.String?
}

extension ListAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[OpenSearchServerlessClientTypes.AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [OpenSearchServerlessClientTypes.AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCollectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionFilters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionFilters = self.collectionFilters {
            try encodeContainer.encode(collectionFilters, forKey: .collectionFilters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCollectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCollectionsInput: Swift.Equatable {
    /// List of filter names and values that you can use for requests.
    public var collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters?
    /// The maximum number of results to return. Default is 20. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListCollections operation returns a nextToken, you can include the returned nextToken in subsequent ListCollections operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init (
        collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionFilters = collectionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollectionsInputBody: Swift.Equatable {
    let collectionFilters: OpenSearchServerlessClientTypes.CollectionFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCollectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionFilters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionFiltersDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionFilters.self, forKey: .collectionFilters)
        collectionFilters = collectionFiltersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCollectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCollectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCollectionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCollectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCollectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectionSummaries = output.collectionSummaries
            self.nextToken = output.nextToken
        } else {
            self.collectionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollectionsOutputResponse: Swift.Equatable {
    /// Details about each collection.
    public var collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectionSummaries = collectionSummaries
        self.nextToken = nextToken
    }
}

struct ListCollectionsOutputResponseBody: Swift.Equatable {
    let collectionSummaries: [OpenSearchServerlessClientTypes.CollectionSummary]?
    let nextToken: Swift.String?
}

extension ListCollectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.CollectionSummary?].self, forKey: .collectionSummaries)
        var collectionSummariesDecoded0:[OpenSearchServerlessClientTypes.CollectionSummary]? = nil
        if let collectionSummariesContainer = collectionSummariesContainer {
            collectionSummariesDecoded0 = [OpenSearchServerlessClientTypes.CollectionSummary]()
            for structure0 in collectionSummariesContainer {
                if let structure0 = structure0 {
                    collectionSummariesDecoded0?.append(structure0)
                }
            }
        }
        collectionSummaries = collectionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListSecurityConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityConfigsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityConfigs operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityConfigs operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The type of security configuration.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListSecurityConfigsInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityConfigType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSecurityConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSecurityConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSecurityConfigsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSecurityConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityConfigSummaries = output.securityConfigSummaries
        } else {
            self.nextToken = nil
            self.securityConfigSummaries = nil
        }
    }
}

public struct ListSecurityConfigsOutputResponse: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security configurations in your account.
    public var securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]?

    public init (
        nextToken: Swift.String? = nil,
        securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityConfigSummaries = securityConfigSummaries
    }
}

struct ListSecurityConfigsOutputResponseBody: Swift.Equatable {
    let securityConfigSummaries: [OpenSearchServerlessClientTypes.SecurityConfigSummary]?
    let nextToken: Swift.String?
}

extension ListSecurityConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityConfigSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.SecurityConfigSummary?].self, forKey: .securityConfigSummaries)
        var securityConfigSummariesDecoded0:[OpenSearchServerlessClientTypes.SecurityConfigSummary]? = nil
        if let securityConfigSummariesContainer = securityConfigSummariesContainer {
            securityConfigSummariesDecoded0 = [OpenSearchServerlessClientTypes.SecurityConfigSummary]()
            for structure0 in securityConfigSummariesContainer {
                if let structure0 = structure0 {
                    securityConfigSummariesDecoded0?.append(structure0)
                }
            }
        }
        securityConfigSummaries = securityConfigSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resource = resource {
            var resourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resource)
            for resource0 in resource {
                try resourceContainer.encode(resource0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListSecurityPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListSecurityPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityPolicies operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Resource filters (can be collection or indexes) that policies can apply to.
    public var resource: [Swift.String]?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resource: [Swift.String]? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resource = resource
        self.type = type
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let resource: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resource
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let resourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resource)
        var resourceDecoded0:[Swift.String]? = nil
        if let resourceContainer = resourceContainer {
            resourceDecoded0 = [Swift.String]()
            for string0 in resourceContainer {
                if let string0 = string0 {
                    resourceDecoded0?.append(string0)
                }
            }
        }
        resource = resourceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSecurityPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSecurityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicySummaries = output.securityPolicySummaries
        } else {
            self.nextToken = nil
            self.securityPolicySummaries = nil
        }
    }
}

public struct ListSecurityPoliciesOutputResponse: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about the security policies in your account.
    public var securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]?

    public init (
        nextToken: Swift.String? = nil,
        securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicySummaries = securityPolicySummaries
    }
}

struct ListSecurityPoliciesOutputResponseBody: Swift.Equatable {
    let securityPolicySummaries: [OpenSearchServerlessClientTypes.SecurityPolicySummary]?
    let nextToken: Swift.String?
}

extension ListSecurityPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityPolicySummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicySummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.SecurityPolicySummary?].self, forKey: .securityPolicySummaries)
        var securityPolicySummariesDecoded0:[OpenSearchServerlessClientTypes.SecurityPolicySummary]? = nil
        if let securityPolicySummariesContainer = securityPolicySummariesContainer {
            securityPolicySummariesDecoded0 = [OpenSearchServerlessClientTypes.SecurityPolicySummary]()
            for structure0 in securityPolicySummariesContainer {
                if let structure0 = structure0 {
                    securityPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        securityPolicySummaries = securityPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init (
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [OpenSearchServerlessClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVpcEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vpcEndpointFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let vpcEndpointFilters = self.vpcEndpointFilters {
            try encodeContainer.encode(vpcEndpointFilters, forKey: .vpcEndpointFilters)
        }
    }
}

extension ListVpcEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVpcEndpointsInput: Swift.Equatable {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
    public var maxResults: Swift.Int?
    /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// Filter the results according to the current status of the VPC endpoint. Possible statuses are CREATING, DELETING, UPDATING, ACTIVE, and FAILED.
    public var vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcEndpointFilters = vpcEndpointFilters
    }
}

struct ListVpcEndpointsInputBody: Swift.Equatable {
    let vpcEndpointFilters: OpenSearchServerlessClientTypes.VpcEndpointFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListVpcEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vpcEndpointFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointFiltersDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointFilters.self, forKey: .vpcEndpointFilters)
        vpcEndpointFilters = vpcEndpointFiltersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListVpcEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVpcEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVpcEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVpcEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVpcEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpcEndpointSummaries = output.vpcEndpointSummaries
        } else {
            self.nextToken = nil
            self.vpcEndpointSummaries = nil
        }
    }
}

public struct ListVpcEndpointsOutputResponse: Swift.Equatable {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Details about each VPC endpoint, including the name and current status.
    public var vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]?

    public init (
        nextToken: Swift.String? = nil,
        vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcEndpointSummaries = vpcEndpointSummaries
    }
}

struct ListVpcEndpointsOutputResponseBody: Swift.Equatable {
    let vpcEndpointSummaries: [OpenSearchServerlessClientTypes.VpcEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListVpcEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vpcEndpointSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcEndpointSummariesContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.VpcEndpointSummary?].self, forKey: .vpcEndpointSummaries)
        var vpcEndpointSummariesDecoded0:[OpenSearchServerlessClientTypes.VpcEndpointSummary]? = nil
        if let vpcEndpointSummariesContainer = vpcEndpointSummariesContainer {
            vpcEndpointSummariesDecoded0 = [OpenSearchServerlessClientTypes.VpcEndpointSummary]()
            for structure0 in vpcEndpointSummariesContainer {
                if let structure0 = structure0 {
                    vpcEndpointSummariesDecoded0?.append(structure0)
                }
            }
        }
        vpcEndpointSummaries = vpcEndpointSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when accessing or deleting a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchServerlessClientTypes.SamlConfigOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupAttribute
        case metadata
        case sessionTimeout
        case userAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupAttribute = self.groupAttribute {
            try encodeContainer.encode(groupAttribute, forKey: .groupAttribute)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let sessionTimeout = self.sessionTimeout {
            try encodeContainer.encode(sessionTimeout, forKey: .sessionTimeout)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let groupAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupAttribute)
        groupAttribute = groupAttributeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Describes SAML options for an OpenSearch Serverless security configuration in the form of a key-value map.
    public struct SamlConfigOptions: Swift.Equatable {
        /// The group attribute for this SAML integration.
        public var groupAttribute: Swift.String?
        /// The XML IdP metadata file generated from your identity provider.
        /// This member is required.
        public var metadata: Swift.String?
        /// The session timeout, in minutes. Minimum is 15 minutes and maximum is 1440 minutes (24 hours or 1 day). Default is 60 minutes.
        public var sessionTimeout: Swift.Int?
        /// A user attribute for this SAML integration.
        public var userAttribute: Swift.String?

        public init (
            groupAttribute: Swift.String? = nil,
            metadata: Swift.String? = nil,
            sessionTimeout: Swift.Int? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.groupAttribute = groupAttribute
            self.metadata = metadata
            self.sessionTimeout = sessionTimeout
            self.userAttribute = userAttribute
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configVersion
        case createdDate
        case description
        case id
        case lastModifiedDate
        case samlOptions
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about a security configuration for OpenSearch Serverless.
    public struct SecurityConfigDetail: Swift.Equatable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The date the configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// SAML options for the security configuration in the form of a key-value map.
        public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init (
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.samlOptions = samlOptions
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samlConfigCount = "SamlConfigCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samlConfigCount = self.samlConfigCount {
            try encodeContainer.encode(samlConfigCount, forKey: .samlConfigCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlConfigCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samlConfigCount)
        samlConfigCount = samlConfigCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless security configuration.
    public struct SecurityConfigStats: Swift.Equatable {
        /// The number of security configurations in the current account.
        public var samlConfigCount: Swift.Int?

        public init (
            samlConfigCount: Swift.Int? = nil
        )
        {
            self.samlConfigCount = samlConfigCount
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configVersion
        case createdDate
        case description
        case id
        case lastModifiedDate
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigType.self, forKey: .type)
        type = typeDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of a security configuration for OpenSearch Serverless.
    public struct SecurityConfigSummary: Swift.Equatable {
        /// The version of the security configuration.
        public var configVersion: Swift.String?
        /// The Epoch time when the security configuration was created.
        public var createdDate: Swift.Int?
        /// The description of the security configuration.
        public var description: Swift.String?
        /// The unique identifier of the security configuration.
        public var id: Swift.String?
        /// The timestamp of when the configuration was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The type of security configuration.
        public var type: OpenSearchServerlessClientTypes.SecurityConfigType?

        public init (
            configVersion: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            type: OpenSearchServerlessClientTypes.SecurityConfigType? = nil
        )
        {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum SecurityConfigType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// saml provider
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityConfigType] {
            return [
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .saml: return "saml"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityConfigType(rawValue: rawValue) ?? SecurityConfigType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.SecurityPolicyDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .policy)
        policy = policyDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless security policy.
    public struct SecurityPolicyDetail: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The JSON policy document without any whitespaces.
        public var policy: ClientRuntime.Document?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init (
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: ClientRuntime.Document? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityPolicyStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionPolicyCount = "EncryptionPolicyCount"
        case networkPolicyCount = "NetworkPolicyCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionPolicyCount = self.encryptionPolicyCount {
            try encodeContainer.encode(encryptionPolicyCount, forKey: .encryptionPolicyCount)
        }
        if let networkPolicyCount = self.networkPolicyCount {
            try encodeContainer.encode(networkPolicyCount, forKey: .networkPolicyCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .encryptionPolicyCount)
        encryptionPolicyCount = encryptionPolicyCountDecoded
        let networkPolicyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkPolicyCount)
        networkPolicyCount = networkPolicyCountDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Statistics for an OpenSearch Serverless security policy.
    public struct SecurityPolicyStats: Swift.Equatable {
        /// The number of encryption policies in the current account.
        public var encryptionPolicyCount: Swift.Int?
        /// The number of network policies in the current account.
        public var networkPolicyCount: Swift.Int?

        public init (
            encryptionPolicyCount: Swift.Int? = nil,
            networkPolicyCount: Swift.Int? = nil
        )
        {
            self.encryptionPolicyCount = encryptionPolicyCount
            self.networkPolicyCount = networkPolicyCount
        }
    }

}

extension OpenSearchServerlessClientTypes.SecurityPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastModifiedDate
        case name
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A summary of a security policy for OpenSearch Serverless.
    public struct SecurityPolicySummary: Swift.Equatable {
        /// The date the policy was created.
        public var createdDate: Swift.Int?
        /// The description of the security policy.
        public var description: Swift.String?
        /// The timestamp of when the policy was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the policy.
        public var name: Swift.String?
        /// The version of the policy.
        public var policyVersion: Swift.String?
        /// The type of security policy.
        public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

        public init (
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyVersion: Swift.String? = nil,
            type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum SecurityPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// encryption policy type
        case encryption
        /// network policy type
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicyType] {
            return [
                .encryption,
                .network,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryption: return "encryption"
            case .network: return "network"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicyType(rawValue: rawValue) ?? SecurityPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// A map of key-value pairs associated to an OpenSearch Serverless resource.
    public struct Tag: Swift.Equatable {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags (key-value pairs) to add to the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tags: [OpenSearchServerlessClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [OpenSearchServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [OpenSearchServerlessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpenSearchServerlessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpenSearchServerlessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpenSearchServerlessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource. All tag keys in the request must be unique.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccessPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.AccessPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.AccessPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

struct UpdateAccessPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.AccessPolicyType?
    let name: Swift.String?
    let policyVersion: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyDetail = output.accessPolicyDetail
        } else {
            self.accessPolicyDetail = nil
        }
    }
}

public struct UpdateAccessPolicyOutputResponse: Swift.Equatable {
    /// Details about the updated access policy.
    public var accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?

    public init (
        accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail? = nil
    )
    {
        self.accessPolicyDetail = accessPolicyDetail
    }
}

struct UpdateAccessPolicyOutputResponseBody: Swift.Equatable {
    let accessPolicyDetail: OpenSearchServerlessClientTypes.AccessPolicyDetail?
}

extension UpdateAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccessPolicyDetail.self, forKey: .accessPolicyDetail)
        accessPolicyDetail = accessPolicyDetailDecoded
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityLimits = self.capacityLimits {
            try encodeContainer.encode(capacityLimits, forKey: .capacityLimits)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The maximum capacity limits for all OpenSearch Serverless collections, in OpenSearch Compute Units (OCUs). These limits are used to scale your collections based on the current workload. For more information, see [Autoscaling](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/serverless-overview.html#serverless-scaling).
    public var capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?

    public init (
        capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits? = nil
    )
    {
        self.capacityLimits = capacityLimits
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let capacityLimits: OpenSearchServerlessClientTypes.CapacityLimits?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityLimits
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CapacityLimits.self, forKey: .capacityLimits)
        capacityLimits = capacityLimitsDecoded
    }
}

extension UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettingsDetail = output.accountSettingsDetail
        } else {
            self.accountSettingsDetail = nil
        }
    }
}

public struct UpdateAccountSettingsOutputResponse: Swift.Equatable {
    /// OpenSearch Serverless-related settings for the current Amazon Web Services account.
    public var accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?

    public init (
        accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail? = nil
    )
    {
        self.accountSettingsDetail = accountSettingsDetail
    }
}

struct UpdateAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountSettingsDetail: OpenSearchServerlessClientTypes.AccountSettingsDetail?
}

extension UpdateAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettingsDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.AccountSettingsDetail.self, forKey: .accountSettingsDetail)
        accountSettingsDetail = accountSettingsDetailDecoded
    }
}

extension OpenSearchServerlessClientTypes.UpdateCollectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case description
        case id
        case lastModifiedDate
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.CollectionType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an updated OpenSearch Serverless collection.
    public struct UpdateCollectionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the collection.
        public var arn: Swift.String?
        /// The date and time when the collection was created.
        public var createdDate: Swift.Int?
        /// The description of the collection.
        public var description: Swift.String?
        /// The unique identifier of the collection.
        public var id: Swift.String?
        /// The date and time when the collection was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the collection.
        public var name: Swift.String?
        /// The current status of the collection.
        public var status: OpenSearchServerlessClientTypes.CollectionStatus?
        /// The collection type.
        public var type: OpenSearchServerlessClientTypes.CollectionType?

        public init (
            arn: Swift.String? = nil,
            createdDate: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.CollectionStatus? = nil,
            type: OpenSearchServerlessClientTypes.CollectionType? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension UpdateCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension UpdateCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCollectionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the collection.
    public var description: Swift.String?
    /// The unique identifier of the collection.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.id = id
    }
}

struct UpdateCollectionInputBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCollectionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateCollectionDetail = output.updateCollectionDetail
        } else {
            self.updateCollectionDetail = nil
        }
    }
}

public struct UpdateCollectionOutputResponse: Swift.Equatable {
    /// Details about the updated collection.
    public var updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail?

    public init (
        updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail? = nil
    )
    {
        self.updateCollectionDetail = updateCollectionDetail
    }
}

struct UpdateCollectionOutputResponseBody: Swift.Equatable {
    let updateCollectionDetail: OpenSearchServerlessClientTypes.UpdateCollectionDetail?
}

extension UpdateCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateCollectionDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCollectionDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.UpdateCollectionDetail.self, forKey: .updateCollectionDetail)
        updateCollectionDetail = updateCollectionDetailDecoded
    }
}

extension UpdateSecurityConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configVersion
        case description
        case id
        case samlOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configVersion = self.configVersion {
            try encodeContainer.encode(configVersion, forKey: .configVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let samlOptions = self.samlOptions {
            try encodeContainer.encode(samlOptions, forKey: .samlOptions)
        }
    }
}

extension UpdateSecurityConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSecurityConfigInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The version of the security configuration to be updated. You can find the most recent version of a security configuration using the GetSecurityPolicy command.
    /// This member is required.
    public var configVersion: Swift.String?
    /// A description of the security configuration.
    public var description: Swift.String?
    /// The security configuration identifier. For SAML the ID will be saml/<accountId>/<idpProviderName>. For example, saml/123456789123/OKTADev.
    /// This member is required.
    public var id: Swift.String?
    /// SAML options in in the form of a key-value map.
    public var samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?

    public init (
        clientToken: Swift.String? = nil,
        configVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions? = nil
    )
    {
        self.clientToken = clientToken
        self.configVersion = configVersion
        self.description = description
        self.id = id
        self.samlOptions = samlOptions
    }
}

struct UpdateSecurityConfigInputBody: Swift.Equatable {
    let id: Swift.String?
    let configVersion: Swift.String?
    let description: Swift.String?
    let samlOptions: OpenSearchServerlessClientTypes.SamlConfigOptions?
    let clientToken: Swift.String?
}

extension UpdateSecurityConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configVersion
        case description
        case id
        case samlOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let configVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configVersion)
        configVersion = configVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let samlOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SamlConfigOptions.self, forKey: .samlOptions)
        samlOptions = samlOptionsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateSecurityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSecurityConfigOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSecurityConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityConfigDetail = output.securityConfigDetail
        } else {
            self.securityConfigDetail = nil
        }
    }
}

public struct UpdateSecurityConfigOutputResponse: Swift.Equatable {
    /// Details about the updated security configuration.
    public var securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?

    public init (
        securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail? = nil
    )
    {
        self.securityConfigDetail = securityConfigDetail
    }
}

struct UpdateSecurityConfigOutputResponseBody: Swift.Equatable {
    let securityConfigDetail: OpenSearchServerlessClientTypes.SecurityConfigDetail?
}

extension UpdateSecurityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityConfigDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityConfigDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityConfigDetail.self, forKey: .securityConfigDetail)
        securityConfigDetail = securityConfigDetailDecoded
    }
}

extension UpdateSecurityPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let policyVersion = self.policyVersion {
            try encodeContainer.encode(policyVersion, forKey: .policyVersion)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateSecurityPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSecurityPolicyInput: Swift.Equatable {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A description of the policy. Typically used to store information about the permissions defined in the policy.
    public var description: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The JSON policy document to use as the content for the new policy.
    public var policy: Swift.String?
    /// The version of the policy being updated.
    /// This member is required.
    public var policyVersion: Swift.String?
    /// The type of access policy.
    /// This member is required.
    public var type: OpenSearchServerlessClientTypes.SecurityPolicyType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyVersion: Swift.String? = nil,
        type: OpenSearchServerlessClientTypes.SecurityPolicyType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policy = policy
        self.policyVersion = policyVersion
        self.type = type
    }
}

struct UpdateSecurityPolicyInputBody: Swift.Equatable {
    let type: OpenSearchServerlessClientTypes.SecurityPolicyType?
    let name: Swift.String?
    let policyVersion: Swift.String?
    let description: Swift.String?
    let policy: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case policy
        case policyVersion
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let policyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersion)
        policyVersion = policyVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicyDetail = output.securityPolicyDetail
        } else {
            self.securityPolicyDetail = nil
        }
    }
}

public struct UpdateSecurityPolicyOutputResponse: Swift.Equatable {
    /// Details about the updated security policy.
    public var securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?

    public init (
        securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail? = nil
    )
    {
        self.securityPolicyDetail = securityPolicyDetail
    }
}

struct UpdateSecurityPolicyOutputResponseBody: Swift.Equatable {
    let securityPolicyDetail: OpenSearchServerlessClientTypes.SecurityPolicyDetail?
}

extension UpdateSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.SecurityPolicyDetail.self, forKey: .securityPolicyDetail)
        securityPolicyDetail = securityPolicyDetailDecoded
    }
}

extension OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case lastModifiedDate
        case name
        case securityGroupIds
        case status
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Update details for an OpenSearch Serverless-managed interface endpoint.
    public struct UpdateVpcEndpointDetail: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The timestamp of when the endpoint was last modified.
        public var lastModifiedDate: Swift.Int?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint update process.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?

        public init (
            id: Swift.String? = nil,
            lastModifiedDate: Swift.Int? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
        }
    }

}

extension UpdateVpcEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSecurityGroupIds
        case addSubnetIds
        case clientToken
        case id
        case removeSecurityGroupIds
        case removeSubnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSecurityGroupIds = addSecurityGroupIds {
            var addSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSecurityGroupIds)
            for securitygroupid0 in addSecurityGroupIds {
                try addSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let addSubnetIds = addSubnetIds {
            var addSubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnetIds)
            for subnetid0 in addSubnetIds {
                try addSubnetIdsContainer.encode(subnetid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let removeSecurityGroupIds = removeSecurityGroupIds {
            var removeSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSecurityGroupIds)
            for securitygroupid0 in removeSecurityGroupIds {
                try removeSecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let removeSubnetIds = removeSubnetIds {
            var removeSubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnetIds)
            for subnetid0 in removeSubnetIds {
                try removeSubnetIdsContainer.encode(subnetid0)
            }
        }
    }
}

extension UpdateVpcEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVpcEndpointInput: Swift.Equatable {
    /// The unique identifiers of the security groups to add to the endpoint. Security groups define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var addSecurityGroupIds: [Swift.String]?
    /// The ID of one or more subnets to add to the endpoint.
    public var addSubnetIds: [Swift.String]?
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the interface endpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// The unique identifiers of the security groups to remove from the endpoint.
    public var removeSecurityGroupIds: [Swift.String]?
    /// The unique identifiers of the subnets to remove from the endpoint.
    public var removeSubnetIds: [Swift.String]?

    public init (
        addSecurityGroupIds: [Swift.String]? = nil,
        addSubnetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        removeSecurityGroupIds: [Swift.String]? = nil,
        removeSubnetIds: [Swift.String]? = nil
    )
    {
        self.addSecurityGroupIds = addSecurityGroupIds
        self.addSubnetIds = addSubnetIds
        self.clientToken = clientToken
        self.id = id
        self.removeSecurityGroupIds = removeSecurityGroupIds
        self.removeSubnetIds = removeSubnetIds
    }
}

struct UpdateVpcEndpointInputBody: Swift.Equatable {
    let id: Swift.String?
    let addSubnetIds: [Swift.String]?
    let removeSubnetIds: [Swift.String]?
    let addSecurityGroupIds: [Swift.String]?
    let removeSecurityGroupIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension UpdateVpcEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSecurityGroupIds
        case addSubnetIds
        case clientToken
        case id
        case removeSecurityGroupIds
        case removeSubnetIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let addSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnetIds)
        var addSubnetIdsDecoded0:[Swift.String]? = nil
        if let addSubnetIdsContainer = addSubnetIdsContainer {
            addSubnetIdsDecoded0 = [Swift.String]()
            for string0 in addSubnetIdsContainer {
                if let string0 = string0 {
                    addSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        addSubnetIds = addSubnetIdsDecoded0
        let removeSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnetIds)
        var removeSubnetIdsDecoded0:[Swift.String]? = nil
        if let removeSubnetIdsContainer = removeSubnetIdsContainer {
            removeSubnetIdsDecoded0 = [Swift.String]()
            for string0 in removeSubnetIdsContainer {
                if let string0 = string0 {
                    removeSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        removeSubnetIds = removeSubnetIdsDecoded0
        let addSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSecurityGroupIds)
        var addSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let addSecurityGroupIdsContainer = addSecurityGroupIdsContainer {
            addSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in addSecurityGroupIdsContainer {
                if let string0 = string0 {
                    addSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        addSecurityGroupIds = addSecurityGroupIdsDecoded0
        let removeSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSecurityGroupIds)
        var removeSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let removeSecurityGroupIdsContainer = removeSecurityGroupIdsContainer {
            removeSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in removeSecurityGroupIdsContainer {
                if let string0 = string0 {
                    removeSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        removeSecurityGroupIds = removeSecurityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVpcEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVpcEndpointOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVpcEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateVpcEndpointDetail = output.updateVpcEndpointDetail
        } else {
            self.updateVpcEndpointDetail = nil
        }
    }
}

public struct UpdateVpcEndpointOutputResponse: Swift.Equatable {
    /// Details about the updated VPC endpoint.
    public var updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail?

    public init (
        updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail? = nil
    )
    {
        self.updateVpcEndpointDetail = updateVpcEndpointDetail
    }
}

struct UpdateVpcEndpointOutputResponseBody: Swift.Equatable {
    let updateVpcEndpointDetail: OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail?
}

extension UpdateVpcEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateVpcEndpointDetail = "UpdateVpcEndpointDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateVpcEndpointDetailDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.UpdateVpcEndpointDetail.self, forKey: .updateVpcEndpointDetail)
        updateVpcEndpointDetail = updateVpcEndpointDetailDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the HTTP request contains invalid input or is missing required input.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case id
        case name
        case securityGroupIds
        case status
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Details about an OpenSearch Serverless-managed interface endpoint.
    public struct VpcEndpointDetail: Swift.Equatable {
        /// The date the endpoint was created.
        public var createdDate: Swift.Int?
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC from which you access OpenSearch Serverless
        public var vpcId: Swift.String?

        public init (
            createdDate: Swift.Int? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.id = id
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension OpenSearchServerlessClientTypes.VpcEndpointErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Error information for a failed BatchGetVpcEndpoint request.
    public struct VpcEndpointErrorDetail: Swift.Equatable {
        /// The error code for the failed request.
        public var errorCode: Swift.String?
        /// An error message describing the reason for the failure.
        public var errorMessage: Swift.String?
        /// The unique identifier of the VPC endpoint.
        public var id: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

extension OpenSearchServerlessClientTypes.VpcEndpointFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// Filter the results of a ListVpcEndpoints request.
    public struct VpcEndpointFilters: Swift.Equatable {
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init (
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension OpenSearchServerlessClientTypes {
    public enum VpcEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// VPCEndpoint resource is ready to use
        case active
        /// Deleting VPCEndpoint resource
        case deleting
        /// VPCEndpoint resource create or delete failed
        case failed
        /// Pending VPCEndpoint resource
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointStatus] {
            return [
                .active,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcEndpointStatus(rawValue: rawValue) ?? VpcEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchServerlessClientTypes.VpcEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchServerlessClientTypes.VpcEndpointStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchServerlessClientTypes {
    /// The VPC endpoint object.
    public struct VpcEndpointSummary: Swift.Equatable {
        /// The unique identifier of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The current status of the endpoint.
        public var status: OpenSearchServerlessClientTypes.VpcEndpointStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchServerlessClientTypes.VpcEndpointStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}
