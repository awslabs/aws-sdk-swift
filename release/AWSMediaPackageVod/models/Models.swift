// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaPackageVodClientTypes {
    public enum AdMarkers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case passthrough
        case scte35Enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkers] {
            return [
                .none,
                .passthrough,
                .scte35Enhanced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .passthrough: return "PASSTHROUGH"
            case .scte35Enhanced: return "SCTE35_ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdMarkers(rawValue: rawValue) ?? AdMarkers.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes.AssetShallow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let packagingGroupId = self.packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceRoleArn = self.sourceRoleArn {
            try encodeContainer.encode(sourceRoleArn, forKey: .sourceRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes {
    /// A MediaPackage VOD Asset resource.
    public struct AssetShallow: Swift.Equatable {
        /// The ARN of the Asset.
        public var arn: Swift.String?
        /// The time the Asset was initially submitted for Ingest.
        public var createdAt: Swift.String?
        /// The unique identifier for the Asset.
        public var id: Swift.String?
        /// The ID of the PackagingGroup for the Asset.
        public var packagingGroupId: Swift.String?
        /// The resource ID to include in SPEKE key requests.
        public var resourceId: Swift.String?
        /// ARN of the source object in S3.
        public var sourceArn: Swift.String?
        /// The IAM role ARN used to access the source S3 bucket.
        public var sourceRoleArn: Swift.String?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            id: Swift.String? = nil,
            packagingGroupId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            sourceRoleArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }
    }

}

extension MediaPackageVodClientTypes.Authorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdnIdentifierSecret = "cdnIdentifierSecret"
        case secretsRoleArn = "secretsRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdnIdentifierSecret = self.cdnIdentifierSecret {
            try encodeContainer.encode(cdnIdentifierSecret, forKey: .cdnIdentifierSecret)
        }
        if let secretsRoleArn = self.secretsRoleArn {
            try encodeContainer.encode(secretsRoleArn, forKey: .secretsRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdnIdentifierSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdnIdentifierSecret)
        cdnIdentifierSecret = cdnIdentifierSecretDecoded
        let secretsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsRoleArn)
        secretsRoleArn = secretsRoleArnDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// CDN Authorization credentials
    public struct Authorization: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
        /// This member is required.
        public var cdnIdentifierSecret: Swift.String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        /// This member is required.
        public var secretsRoleArn: Swift.String?

        public init (
            cdnIdentifierSecret: Swift.String? = nil,
            secretsRoleArn: Swift.String? = nil
        )
        {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }
    }

}

extension MediaPackageVodClientTypes.CmafEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A CMAF encryption configuration.
    public struct CmafEncryption: Swift.Equatable {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider?

        public init (
            constantInitializationVector: Swift.String? = nil,
            spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageVodClientTypes.CmafPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
        case segmentDurationSeconds = "segmentDurationSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for hlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(hlsmanifest0)
            }
        }
        if let includeEncoderConfigurationInSegments = self.includeEncoderConfigurationInSegments {
            try encodeContainer.encode(includeEncoderConfigurationInSegments, forKey: .includeEncoderConfigurationInSegments)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageVodClientTypes.HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageVodClientTypes.HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let includeEncoderConfigurationInSegmentsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeEncoderConfigurationInSegments)
        includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegmentsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A CMAF packaging configuration.
    public struct CmafPackage: Swift.Equatable {
        /// A CMAF encryption configuration.
        public var encryption: MediaPackageVodClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations.
        /// This member is required.
        public var hlsManifests: [MediaPackageVodClientTypes.HlsManifest]?
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public var includeEncoderConfigurationInSegments: Swift.Bool?
        /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
        public var segmentDurationSeconds: Swift.Int?

        public init (
            encryption: MediaPackageVodClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageVodClientTypes.HlsManifest]? = nil,
            includeEncoderConfigurationInSegments: Swift.Bool? = nil,
            segmentDurationSeconds: Swift.Int? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.segmentDurationSeconds = segmentDurationSeconds
        }
    }

}

extension ConfigureLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressAccessLogs = self.egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
    }
}

extension ConfigureLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_groups/\(id.urlPercentEncoding())/configure_logs"
    }
}

/// The option to configure log subscription.
public struct ConfigureLogsInput: Swift.Equatable {
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    /// This member is required.
    public var id: Swift.String?

    public init (
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
    }
}

struct ConfigureLogsInputBody: Swift.Equatable {
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
}

extension ConfigureLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
    }
}

extension ConfigureLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfigureLogsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfigureLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct ConfigureLogsOutputResponse: Swift.Equatable {
    /// The ARN of the PackagingGroup.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public var domainName: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        domainName: Swift.String? = nil,
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct ConfigureLogsOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let authorization: MediaPackageVodClientTypes.Authorization?
    let domainName: Swift.String?
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ConfigureLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let packagingGroupId = self.packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceRoleArn = self.sourceRoleArn {
            try encodeContainer.encode(sourceRoleArn, forKey: .sourceRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

/// A new MediaPackage VOD Asset configuration.
public struct CreateAssetInput: Swift.Equatable {
    /// The unique identifier for the Asset.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the PackagingGroup for the Asset.
    /// This member is required.
    public var packagingGroupId: Swift.String?
    /// The resource ID to include in SPEKE key requests.
    public var resourceId: Swift.String?
    /// ARN of the source object in S3.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The IAM role ARN used to access the source S3 bucket.
    /// This member is required.
    public var sourceRoleArn: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        id: Swift.String? = nil,
        packagingGroupId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct CreateAssetInputBody: Swift.Equatable {
    let id: Swift.String?
    let packagingGroupId: Swift.String?
    let resourceId: Swift.String?
    let sourceArn: Swift.String?
    let sourceRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssetOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.egressEndpoints = output.egressEndpoints
            self.id = output.id
            self.packagingGroupId = output.packagingGroupId
            self.resourceId = output.resourceId
            self.sourceArn = output.sourceArn
            self.sourceRoleArn = output.sourceRoleArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.egressEndpoints = nil
            self.id = nil
            self.packagingGroupId = nil
            self.resourceId = nil
            self.sourceArn = nil
            self.sourceRoleArn = nil
            self.tags = nil
        }
    }
}

public struct CreateAssetOutputResponse: Swift.Equatable {
    /// The ARN of the Asset.
    public var arn: Swift.String?
    /// The time the Asset was initially submitted for Ingest.
    public var createdAt: Swift.String?
    /// The list of egress endpoints available for the Asset.
    public var egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]?
    /// The unique identifier for the Asset.
    public var id: Swift.String?
    /// The ID of the PackagingGroup for the Asset.
    public var packagingGroupId: Swift.String?
    /// The resource ID to include in SPEKE key requests.
    public var resourceId: Swift.String?
    /// ARN of the source object in S3.
    public var sourceArn: Swift.String?
    /// The IAM role_arn used to access the source S3 bucket.
    public var sourceRoleArn: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]? = nil,
        id: Swift.String? = nil,
        packagingGroupId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.egressEndpoints = egressEndpoints
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct CreateAssetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]?
    let id: Swift.String?
    let packagingGroupId: Swift.String?
    let resourceId: Swift.String?
    let sourceArn: Swift.String?
    let sourceRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case egressEndpoints = "egressEndpoints"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let egressEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.EgressEndpoint?].self, forKey: .egressEndpoints)
        var egressEndpointsDecoded0:[MediaPackageVodClientTypes.EgressEndpoint]? = nil
        if let egressEndpointsContainer = egressEndpointsContainer {
            egressEndpointsDecoded0 = [MediaPackageVodClientTypes.EgressEndpoint]()
            for structure0 in egressEndpointsContainer {
                if let structure0 = structure0 {
                    egressEndpointsDecoded0?.append(structure0)
                }
            }
        }
        egressEndpoints = egressEndpointsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmafPackage = self.cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = self.dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let hlsPackage = self.hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let mssPackage = self.mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let packagingGroupId = self.packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackagingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packaging_configurations"
    }
}

/// A new MediaPackage VOD PackagingConfiguration resource configuration.
public struct CreatePackagingConfigurationInput: Swift.Equatable {
    /// A CMAF packaging configuration.
    public var cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageVodClientTypes.DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    /// The ID of the PackagingConfiguration.
    /// This member is required.
    public var id: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public var mssPackage: MediaPackageVodClientTypes.MssPackage?
    /// The ID of a PackagingGroup.
    /// This member is required.
    public var packagingGroupId: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        cmafPackage: MediaPackageVodClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageVodClientTypes.DashPackage? = nil,
        hlsPackage: MediaPackageVodClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        mssPackage: MediaPackageVodClientTypes.MssPackage? = nil,
        packagingGroupId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct CreatePackagingConfigurationInputBody: Swift.Equatable {
    let cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    let dashPackage: MediaPackageVodClientTypes.DashPackage?
    let hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    let id: Swift.String?
    let mssPackage: MediaPackageVodClientTypes.MssPackage?
    let packagingGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackagingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackagingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePackagingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackagingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePackagingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.mssPackage = output.mssPackage
            self.packagingGroupId = output.packagingGroupId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.hlsPackage = nil
            self.id = nil
            self.mssPackage = nil
            self.packagingGroupId = nil
            self.tags = nil
        }
    }
}

public struct CreatePackagingConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the PackagingConfiguration.
    public var arn: Swift.String?
    /// A CMAF packaging configuration.
    public var cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageVodClientTypes.DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    /// The ID of the PackagingConfiguration.
    public var id: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public var mssPackage: MediaPackageVodClientTypes.MssPackage?
    /// The ID of a PackagingGroup.
    public var packagingGroupId: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        cmafPackage: MediaPackageVodClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageVodClientTypes.DashPackage? = nil,
        hlsPackage: MediaPackageVodClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        mssPackage: MediaPackageVodClientTypes.MssPackage? = nil,
        packagingGroupId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct CreatePackagingConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    let dashPackage: MediaPackageVodClientTypes.DashPackage?
    let hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    let id: Swift.String?
    let mssPackage: MediaPackageVodClientTypes.MssPackage?
    let packagingGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackagingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let egressAccessLogs = self.egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackagingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packaging_groups"
    }
}

/// A new MediaPackage VOD PackagingGroup resource configuration.
public struct CreatePackagingGroupInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of the PackagingGroup.
    /// This member is required.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct CreatePackagingGroupInputBody: Swift.Equatable {
    let authorization: MediaPackageVodClientTypes.Authorization?
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackagingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackagingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePackagingGroupOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackagingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct CreatePackagingGroupOutputResponse: Swift.Equatable {
    /// The ARN of the PackagingGroup.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public var domainName: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        domainName: Swift.String? = nil,
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct CreatePackagingGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let authorization: MediaPackageVodClientTypes.Authorization?
    let domainName: Swift.String?
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackagingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes.DashEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public struct DashEncryption: Swift.Equatable {
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider?

        public init (
            spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageVodClientTypes.DashManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestLayout = "manifestLayout"
        case manifestName = "manifestName"
        case minBufferTimeSeconds = "minBufferTimeSeconds"
        case profile = "profile"
        case scteMarkersSource = "scteMarkersSource"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestLayout = self.manifestLayout {
            try encodeContainer.encode(manifestLayout.rawValue, forKey: .manifestLayout)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let minBufferTimeSeconds = self.minBufferTimeSeconds {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let profile = self.profile {
            try encodeContainer.encode(profile.rawValue, forKey: .profile)
        }
        if let scteMarkersSource = self.scteMarkersSource {
            try encodeContainer.encode(scteMarkersSource.rawValue, forKey: .scteMarkersSource)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestLayoutDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.ManifestLayout.self, forKey: .manifestLayout)
        manifestLayout = manifestLayoutDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let profileDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
        let scteMarkersSourceDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.ScteMarkersSource.self, forKey: .scteMarkersSource)
        scteMarkersSource = scteMarkersSourceDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A DASH manifest configuration.
    public struct DashManifest: Swift.Equatable {
        /// Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public var manifestLayout: MediaPackageVodClientTypes.ManifestLayout?
        /// An optional string to include in the name of the manifest.
        public var manifestName: Swift.String?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public var minBufferTimeSeconds: Swift.Int?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public var profile: MediaPackageVodClientTypes.Profile?
        /// The source of scte markers used. When set to SEGMENTS, the scte markers are sourced from the segments of the ingested content. When set to MANIFEST, the scte markers are sourced from the manifest of the ingested content. The MANIFEST value is compatible with source HLS playlists using the SCTE-35 Enhanced syntax (#EXT-OATCLS-SCTE35 tags). SCTE-35 Elemental and SCTE-35 Daterange syntaxes are not supported with this option.
        public var scteMarkersSource: MediaPackageVodClientTypes.ScteMarkersSource?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageVodClientTypes.StreamSelection?

        public init (
            manifestLayout: MediaPackageVodClientTypes.ManifestLayout? = nil,
            manifestName: Swift.String? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            profile: MediaPackageVodClientTypes.Profile? = nil,
            scteMarkersSource: MediaPackageVodClientTypes.ScteMarkersSource? = nil,
            streamSelection: MediaPackageVodClientTypes.StreamSelection? = nil
        )
        {
            self.manifestLayout = manifestLayout
            self.manifestName = manifestName
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.profile = profile
            self.scteMarkersSource = scteMarkersSource
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageVodClientTypes.DashPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashManifests = "dashManifests"
        case encryption = "encryption"
        case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case periodTriggers = "periodTriggers"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentTemplateFormat = "segmentTemplateFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashManifests = dashManifests {
            var dashManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dashManifests)
            for dashmanifest0 in dashManifests {
                try dashManifestsContainer.encode(dashmanifest0)
            }
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeEncoderConfigurationInSegments = self.includeEncoderConfigurationInSegments {
            try encodeContainer.encode(includeEncoderConfigurationInSegments, forKey: .includeEncoderConfigurationInSegments)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let periodTriggers = periodTriggers {
            var periodTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .periodTriggers)
            for __periodtriggerselement0 in periodTriggers {
                try periodTriggersContainer.encode(__periodtriggerselement0.rawValue)
            }
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentTemplateFormat = self.segmentTemplateFormat {
            try encodeContainer.encode(segmentTemplateFormat.rawValue, forKey: .segmentTemplateFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashManifestsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.DashManifest?].self, forKey: .dashManifests)
        var dashManifestsDecoded0:[MediaPackageVodClientTypes.DashManifest]? = nil
        if let dashManifestsContainer = dashManifestsContainer {
            dashManifestsDecoded0 = [MediaPackageVodClientTypes.DashManifest]()
            for structure0 in dashManifestsContainer {
                if let structure0 = structure0 {
                    dashManifestsDecoded0?.append(structure0)
                }
            }
        }
        dashManifests = dashManifestsDecoded0
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.DashEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeEncoderConfigurationInSegmentsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeEncoderConfigurationInSegments)
        includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegmentsDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let periodTriggersContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.__PeriodTriggersElement?].self, forKey: .periodTriggers)
        var periodTriggersDecoded0:[MediaPackageVodClientTypes.__PeriodTriggersElement]? = nil
        if let periodTriggersContainer = periodTriggersContainer {
            periodTriggersDecoded0 = [MediaPackageVodClientTypes.__PeriodTriggersElement]()
            for enum0 in periodTriggersContainer {
                if let enum0 = enum0 {
                    periodTriggersDecoded0?.append(enum0)
                }
            }
        }
        periodTriggers = periodTriggersDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentTemplateFormatDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.SegmentTemplateFormat.self, forKey: .segmentTemplateFormat)
        segmentTemplateFormat = segmentTemplateFormatDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public struct DashPackage: Swift.Equatable {
        /// A list of DASH manifest configurations.
        /// This member is required.
        public var dashManifests: [MediaPackageVodClientTypes.DashManifest]?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
        public var encryption: MediaPackageVodClientTypes.DashEncryption?
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public var includeEncoderConfigurationInSegments: Swift.Bool?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Asset contains SCTE-35 ad markers.
        public var periodTriggers: [MediaPackageVodClientTypes.__PeriodTriggersElement]?
        /// Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public var segmentTemplateFormat: MediaPackageVodClientTypes.SegmentTemplateFormat?

        public init (
            dashManifests: [MediaPackageVodClientTypes.DashManifest]? = nil,
            encryption: MediaPackageVodClientTypes.DashEncryption? = nil,
            includeEncoderConfigurationInSegments: Swift.Bool? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            periodTriggers: [MediaPackageVodClientTypes.__PeriodTriggersElement]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentTemplateFormat: MediaPackageVodClientTypes.SegmentTemplateFormat? = nil
        )
        {
            self.dashManifests = dashManifests
            self.encryption = encryption
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.periodTriggers = periodTriggers
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
        }
    }

}

extension DeleteAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/assets/\(id.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The ID of the MediaPackage VOD Asset resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssetOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePackagingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_configurations/\(id.urlPercentEncoding())"
    }
}

public struct DeletePackagingConfigurationInput: Swift.Equatable {
    /// The ID of the MediaPackage VOD PackagingConfiguration resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePackagingConfigurationInputBody: Swift.Equatable {
}

extension DeletePackagingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackagingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackagingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePackagingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackagingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePackagingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePackagingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_groups/\(id.urlPercentEncoding())"
    }
}

public struct DeletePackagingGroupInput: Swift.Equatable {
    /// The ID of the MediaPackage VOD PackagingGroup resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePackagingGroupInputBody: Swift.Equatable {
}

extension DeletePackagingGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackagingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackagingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePackagingGroupOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackagingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePackagingGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/assets/\(id.urlPercentEncoding())"
    }
}

public struct DescribeAssetInput: Swift.Equatable {
    /// The ID of an MediaPackage VOD Asset resource.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeAssetInputBody: Swift.Equatable {
}

extension DescribeAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAssetOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.egressEndpoints = output.egressEndpoints
            self.id = output.id
            self.packagingGroupId = output.packagingGroupId
            self.resourceId = output.resourceId
            self.sourceArn = output.sourceArn
            self.sourceRoleArn = output.sourceRoleArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.egressEndpoints = nil
            self.id = nil
            self.packagingGroupId = nil
            self.resourceId = nil
            self.sourceArn = nil
            self.sourceRoleArn = nil
            self.tags = nil
        }
    }
}

public struct DescribeAssetOutputResponse: Swift.Equatable {
    /// The ARN of the Asset.
    public var arn: Swift.String?
    /// The time the Asset was initially submitted for Ingest.
    public var createdAt: Swift.String?
    /// The list of egress endpoints available for the Asset.
    public var egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]?
    /// The unique identifier for the Asset.
    public var id: Swift.String?
    /// The ID of the PackagingGroup for the Asset.
    public var packagingGroupId: Swift.String?
    /// The resource ID to include in SPEKE key requests.
    public var resourceId: Swift.String?
    /// ARN of the source object in S3.
    public var sourceArn: Swift.String?
    /// The IAM role_arn used to access the source S3 bucket.
    public var sourceRoleArn: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]? = nil,
        id: Swift.String? = nil,
        packagingGroupId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        sourceArn: Swift.String? = nil,
        sourceRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.egressEndpoints = egressEndpoints
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct DescribeAssetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let createdAt: Swift.String?
    let egressEndpoints: [MediaPackageVodClientTypes.EgressEndpoint]?
    let id: Swift.String?
    let packagingGroupId: Swift.String?
    let resourceId: Swift.String?
    let sourceArn: Swift.String?
    let sourceRoleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case egressEndpoints = "egressEndpoints"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let egressEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.EgressEndpoint?].self, forKey: .egressEndpoints)
        var egressEndpointsDecoded0:[MediaPackageVodClientTypes.EgressEndpoint]? = nil
        if let egressEndpointsContainer = egressEndpointsContainer {
            egressEndpointsDecoded0 = [MediaPackageVodClientTypes.EgressEndpoint]()
            for structure0 in egressEndpointsContainer {
                if let structure0 = structure0 {
                    egressEndpointsDecoded0?.append(structure0)
                }
            }
        }
        egressEndpoints = egressEndpointsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribePackagingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_configurations/\(id.urlPercentEncoding())"
    }
}

public struct DescribePackagingConfigurationInput: Swift.Equatable {
    /// The ID of a MediaPackage VOD PackagingConfiguration resource.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribePackagingConfigurationInputBody: Swift.Equatable {
}

extension DescribePackagingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackagingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackagingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePackagingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackagingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePackagingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.mssPackage = output.mssPackage
            self.packagingGroupId = output.packagingGroupId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.hlsPackage = nil
            self.id = nil
            self.mssPackage = nil
            self.packagingGroupId = nil
            self.tags = nil
        }
    }
}

public struct DescribePackagingConfigurationOutputResponse: Swift.Equatable {
    /// The ARN of the PackagingConfiguration.
    public var arn: Swift.String?
    /// A CMAF packaging configuration.
    public var cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageVodClientTypes.DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    /// The ID of the PackagingConfiguration.
    public var id: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public var mssPackage: MediaPackageVodClientTypes.MssPackage?
    /// The ID of a PackagingGroup.
    public var packagingGroupId: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        cmafPackage: MediaPackageVodClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageVodClientTypes.DashPackage? = nil,
        hlsPackage: MediaPackageVodClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        mssPackage: MediaPackageVodClientTypes.MssPackage? = nil,
        packagingGroupId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct DescribePackagingConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let cmafPackage: MediaPackageVodClientTypes.CmafPackage?
    let dashPackage: MediaPackageVodClientTypes.DashPackage?
    let hlsPackage: MediaPackageVodClientTypes.HlsPackage?
    let id: Swift.String?
    let mssPackage: MediaPackageVodClientTypes.MssPackage?
    let packagingGroupId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePackagingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribePackagingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_groups/\(id.urlPercentEncoding())"
    }
}

public struct DescribePackagingGroupInput: Swift.Equatable {
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribePackagingGroupInputBody: Swift.Equatable {
}

extension DescribePackagingGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackagingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackagingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePackagingGroupOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackagingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approximateAssetCount = output.approximateAssetCount
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.approximateAssetCount = nil
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct DescribePackagingGroupOutputResponse: Swift.Equatable {
    /// The approximate asset count of the PackagingGroup.
    public var approximateAssetCount: Swift.Int?
    /// The ARN of the PackagingGroup.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public var domainName: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        approximateAssetCount: Swift.Int? = nil,
        arn: Swift.String? = nil,
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        domainName: Swift.String? = nil,
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.approximateAssetCount = approximateAssetCount
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct DescribePackagingGroupOutputResponseBody: Swift.Equatable {
    let approximateAssetCount: Swift.Int?
    let arn: Swift.String?
    let authorization: MediaPackageVodClientTypes.Authorization?
    let domainName: Swift.String?
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePackagingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateAssetCount = "approximateAssetCount"
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateAssetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateAssetCount)
        approximateAssetCount = approximateAssetCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes.EgressAccessLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// Configure egress access logging.
    public struct EgressAccessLogs: Swift.Equatable {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init (
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension MediaPackageVodClientTypes.EgressEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packagingConfigurationId = "packagingConfigurationId"
        case status = "status"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packagingConfigurationId = self.packagingConfigurationId {
            try encodeContainer.encode(packagingConfigurationId, forKey: .packagingConfigurationId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagingConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingConfigurationId)
        packagingConfigurationId = packagingConfigurationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// The endpoint URL used to access an Asset using one PackagingConfiguration.
    public struct EgressEndpoint: Swift.Equatable {
        /// The ID of the PackagingConfiguration being applied to the Asset.
        public var packagingConfigurationId: Swift.String?
        /// The current processing status of the asset used for the packaging configuration. The status can be either QUEUED, PROCESSING, PLAYABLE, or FAILED. Status information won't be available for most assets ingested before 2021-09-30.
        public var status: Swift.String?
        /// The URL of the parent manifest for the repackaged Asset.
        public var url: Swift.String?

        public init (
            packagingConfigurationId: Swift.String? = nil,
            status: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.packagingConfigurationId = packagingConfigurationId
            self.status = status
            self.url = url
        }
    }

}

extension MediaPackageVodClientTypes.EncryptionContractConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presetSpeke20Audio = "presetSpeke20Audio"
        case presetSpeke20Video = "presetSpeke20Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = self.presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = self.presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
    public struct EncryptionContractConfiguration: Swift.Equatable {
        /// A collection of audio encryption presets.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageVodClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageVodClientTypes.PresetSpeke20Video?

        public init (
            presetSpeke20Audio: MediaPackageVodClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageVodClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageVodClientTypes {
    public enum EncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMethod] {
            return [
                .aes128,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionMethod(rawValue: rawValue) ?? EncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageVodClientTypes.HlsEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = self.constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = self.encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public struct HlsEncryption: Swift.Equatable {
        /// A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageVodClientTypes.EncryptionMethod?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider?

        public init (
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageVodClientTypes.EncryptionMethod? = nil,
            spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageVodClientTypes.HlsManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case repeatExtXKey = "repeatExtXKey"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = self.adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let includeIframeOnlyStream = self.includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let programDateTimeIntervalSeconds = self.programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let repeatExtXKey = self.repeatExtXKey {
            try encodeContainer.encode(repeatExtXKey, forKey: .repeatExtXKey)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let repeatExtXKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .repeatExtXKey)
        repeatExtXKey = repeatExtXKeyDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// An HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifest: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source.
        public var adMarkers: MediaPackageVodClientTypes.AdMarkers?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional string to include in the name of the manifest.
        public var manifestName: Swift.String?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public var repeatExtXKey: Swift.Bool?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageVodClientTypes.StreamSelection?

        public init (
            adMarkers: MediaPackageVodClientTypes.AdMarkers? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            repeatExtXKey: Swift.Bool? = nil,
            streamSelection: MediaPackageVodClientTypes.StreamSelection? = nil
        )
        {
            self.adMarkers = adMarkers
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageVodClientTypes.HlsPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case includeDvbSubtitles = "includeDvbSubtitles"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case useAudioRenditionGroup = "useAudioRenditionGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for hlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(hlsmanifest0)
            }
        }
        if let includeDvbSubtitles = self.includeDvbSubtitles {
            try encodeContainer.encode(includeDvbSubtitles, forKey: .includeDvbSubtitles)
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let useAudioRenditionGroup = self.useAudioRenditionGroup {
            try encodeContainer.encode(useAudioRenditionGroup, forKey: .useAudioRenditionGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.HlsEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageVodClientTypes.HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageVodClientTypes.HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let includeDvbSubtitlesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDvbSubtitles)
        includeDvbSubtitles = includeDvbSubtitlesDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let useAudioRenditionGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAudioRenditionGroup)
        useAudioRenditionGroup = useAudioRenditionGroupDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public struct HlsPackage: Swift.Equatable {
        /// An HTTP Live Streaming (HLS) encryption configuration.
        public var encryption: MediaPackageVodClientTypes.HlsEncryption?
        /// A list of HLS manifest configurations.
        /// This member is required.
        public var hlsManifests: [MediaPackageVodClientTypes.HlsManifest]?
        /// When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
        public var includeDvbSubtitles: Swift.Bool?
        /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public var useAudioRenditionGroup: Swift.Bool?

        public init (
            encryption: MediaPackageVodClientTypes.HlsEncryption? = nil,
            hlsManifests: [MediaPackageVodClientTypes.HlsManifest]? = nil,
            includeDvbSubtitles: Swift.Bool? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            useAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.includeDvbSubtitles = includeDvbSubtitles
            self.segmentDurationSeconds = segmentDurationSeconds
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let packagingGroupId = packagingGroupId {
                let packagingGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "packagingGroupId".urlPercentEncoding(), value: Swift.String(packagingGroupId).urlPercentEncoding())
                items.append(packagingGroupIdQueryItem)
            }
            return items
        }
    }
}

extension ListAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

public struct ListAssetsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?
    /// Returns Assets associated with the specified PackagingGroup.
    public var packagingGroupId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        packagingGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packagingGroupId = packagingGroupId
    }
}

struct ListAssetsInputBody: Swift.Equatable {
}

extension ListAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.nextToken = output.nextToken
        } else {
            self.assets = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutputResponse: Swift.Equatable {
    /// A list of MediaPackage VOD Asset resources.
    public var assets: [MediaPackageVodClientTypes.AssetShallow]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init (
        assets: [MediaPackageVodClientTypes.AssetShallow]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputResponseBody: Swift.Equatable {
    let assets: [MediaPackageVodClientTypes.AssetShallow]?
    let nextToken: Swift.String?
}

extension ListAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets = "assets"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.AssetShallow?].self, forKey: .assets)
        var assetsDecoded0:[MediaPackageVodClientTypes.AssetShallow]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [MediaPackageVodClientTypes.AssetShallow]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagingConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let packagingGroupId = packagingGroupId {
                let packagingGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "packagingGroupId".urlPercentEncoding(), value: Swift.String(packagingGroupId).urlPercentEncoding())
                items.append(packagingGroupIdQueryItem)
            }
            return items
        }
    }
}

extension ListPackagingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packaging_configurations"
    }
}

public struct ListPackagingConfigurationsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?
    /// Returns MediaPackage VOD PackagingConfigurations associated with the specified PackagingGroup.
    public var packagingGroupId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        packagingGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packagingGroupId = packagingGroupId
    }
}

struct ListPackagingConfigurationsInputBody: Swift.Equatable {
}

extension ListPackagingConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPackagingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPackagingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packagingConfigurations = output.packagingConfigurations
        } else {
            self.nextToken = nil
            self.packagingConfigurations = nil
        }
    }
}

public struct ListPackagingConfigurationsOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?
    /// A list of MediaPackage VOD PackagingConfiguration resources.
    public var packagingConfigurations: [MediaPackageVodClientTypes.PackagingConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        packagingConfigurations: [MediaPackageVodClientTypes.PackagingConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.packagingConfigurations = packagingConfigurations
    }
}

struct ListPackagingConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let packagingConfigurations: [MediaPackageVodClientTypes.PackagingConfiguration]?
}

extension ListPackagingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case packagingConfigurations = "packagingConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let packagingConfigurationsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.PackagingConfiguration?].self, forKey: .packagingConfigurations)
        var packagingConfigurationsDecoded0:[MediaPackageVodClientTypes.PackagingConfiguration]? = nil
        if let packagingConfigurationsContainer = packagingConfigurationsContainer {
            packagingConfigurationsDecoded0 = [MediaPackageVodClientTypes.PackagingConfiguration]()
            for structure0 in packagingConfigurationsContainer {
                if let structure0 = structure0 {
                    packagingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        packagingConfigurations = packagingConfigurationsDecoded0
    }
}

extension ListPackagingGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPackagingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packaging_groups"
    }
}

public struct ListPackagingGroupsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagingGroupsInputBody: Swift.Equatable {
}

extension ListPackagingGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagingGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagingGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPackagingGroupsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagingGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPackagingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packagingGroups = output.packagingGroups
        } else {
            self.nextToken = nil
            self.packagingGroups = nil
        }
    }
}

public struct ListPackagingGroupsOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?
    /// A list of MediaPackage VOD PackagingGroup resources.
    public var packagingGroups: [MediaPackageVodClientTypes.PackagingGroup]?

    public init (
        nextToken: Swift.String? = nil,
        packagingGroups: [MediaPackageVodClientTypes.PackagingGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.packagingGroups = packagingGroups
    }
}

struct ListPackagingGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let packagingGroups: [MediaPackageVodClientTypes.PackagingGroup]?
}

extension ListPackagingGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case packagingGroups = "packagingGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let packagingGroupsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.PackagingGroup?].self, forKey: .packagingGroups)
        var packagingGroupsDecoded0:[MediaPackageVodClientTypes.PackagingGroup]? = nil
        if let packagingGroupsContainer = packagingGroupsContainer {
            packagingGroupsDecoded0 = [MediaPackageVodClientTypes.PackagingGroup]()
            for structure0 in packagingGroupsContainer {
                if let structure0 = structure0 {
                    packagingGroupsDecoded0?.append(structure0)
                }
            }
        }
        packagingGroups = packagingGroupsDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes {
    public enum ManifestLayout: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compact
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestLayout] {
            return [
                .compact,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compact: return "COMPACT"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManifestLayout(rawValue: rawValue) ?? ManifestLayout.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes.MssEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = self.spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public struct MssEncryption: Swift.Equatable {
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider?

        public init (
            spekeKeyProvider: MediaPackageVodClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageVodClientTypes.MssManifest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestName = "manifestName"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let streamSelection = self.streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A Microsoft Smooth Streaming (MSS) manifest configuration.
    public struct MssManifest: Swift.Equatable {
        /// An optional string to include in the name of the manifest.
        public var manifestName: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageVodClientTypes.StreamSelection?

        public init (
            manifestName: Swift.String? = nil,
            streamSelection: MediaPackageVodClientTypes.StreamSelection? = nil
        )
        {
            self.manifestName = manifestName
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageVodClientTypes.MssPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case mssManifests = "mssManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let mssManifests = mssManifests {
            var mssManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mssManifests)
            for mssmanifest0 in mssManifests {
                try mssManifestsContainer.encode(mssmanifest0)
            }
        }
        if let segmentDurationSeconds = self.segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.MssEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let mssManifestsContainer = try containerValues.decodeIfPresent([MediaPackageVodClientTypes.MssManifest?].self, forKey: .mssManifests)
        var mssManifestsDecoded0:[MediaPackageVodClientTypes.MssManifest]? = nil
        if let mssManifestsContainer = mssManifestsContainer {
            mssManifestsDecoded0 = [MediaPackageVodClientTypes.MssManifest]()
            for structure0 in mssManifestsContainer {
                if let structure0 = structure0 {
                    mssManifestsDecoded0?.append(structure0)
                }
            }
        }
        mssManifests = mssManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public struct MssPackage: Swift.Equatable {
        /// A Microsoft Smooth Streaming (MSS) encryption configuration.
        public var encryption: MediaPackageVodClientTypes.MssEncryption?
        /// A list of MSS manifest configurations.
        /// This member is required.
        public var mssManifests: [MediaPackageVodClientTypes.MssManifest]?
        /// The duration (in seconds) of each segment.
        public var segmentDurationSeconds: Swift.Int?

        public init (
            encryption: MediaPackageVodClientTypes.MssEncryption? = nil,
            mssManifests: [MediaPackageVodClientTypes.MssManifest]? = nil,
            segmentDurationSeconds: Swift.Int? = nil
        )
        {
            self.encryption = encryption
            self.mssManifests = mssManifests
            self.segmentDurationSeconds = segmentDurationSeconds
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageVodClientTypes.PackagingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let cmafPackage = self.cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = self.dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let hlsPackage = self.hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let mssPackage = self.mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let packagingGroupId = self.packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes {
    /// A MediaPackage VOD PackagingConfiguration resource.
    public struct PackagingConfiguration: Swift.Equatable {
        /// The ARN of the PackagingConfiguration.
        public var arn: Swift.String?
        /// A CMAF packaging configuration.
        public var cmafPackage: MediaPackageVodClientTypes.CmafPackage?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
        public var dashPackage: MediaPackageVodClientTypes.DashPackage?
        /// An HTTP Live Streaming (HLS) packaging configuration.
        public var hlsPackage: MediaPackageVodClientTypes.HlsPackage?
        /// The ID of the PackagingConfiguration.
        public var id: Swift.String?
        /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
        public var mssPackage: MediaPackageVodClientTypes.MssPackage?
        /// The ID of a PackagingGroup.
        public var packagingGroupId: Swift.String?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            cmafPackage: MediaPackageVodClientTypes.CmafPackage? = nil,
            dashPackage: MediaPackageVodClientTypes.DashPackage? = nil,
            hlsPackage: MediaPackageVodClientTypes.HlsPackage? = nil,
            id: Swift.String? = nil,
            mssPackage: MediaPackageVodClientTypes.MssPackage? = nil,
            packagingGroupId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }
    }

}

extension MediaPackageVodClientTypes.PackagingGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateAssetCount = "approximateAssetCount"
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateAssetCount = self.approximateAssetCount {
            try encodeContainer.encode(approximateAssetCount, forKey: .approximateAssetCount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let egressAccessLogs = self.egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateAssetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateAssetCount)
        approximateAssetCount = approximateAssetCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes {
    /// A MediaPackage VOD PackagingGroup resource.
    public struct PackagingGroup: Swift.Equatable {
        /// The approximate asset count of the PackagingGroup.
        public var approximateAssetCount: Swift.Int?
        /// The ARN of the PackagingGroup.
        public var arn: Swift.String?
        /// CDN Authorization credentials
        public var authorization: MediaPackageVodClientTypes.Authorization?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public var domainName: Swift.String?
        /// Configure egress access logging.
        public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public var id: Swift.String?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?

        public init (
            approximateAssetCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            authorization: MediaPackageVodClientTypes.Authorization? = nil,
            domainName: Swift.String? = nil,
            egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.approximateAssetCount = approximateAssetCount
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }
    }

}

extension MediaPackageVodClientTypes {
    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetAudio1
        case presetAudio2
        case presetAudio3
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .presetAudio2,
                .presetAudio3,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET-AUDIO-1"
            case .presetAudio2: return "PRESET-AUDIO-2"
            case .presetAudio3: return "PRESET-AUDIO-3"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes {
    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetVideo1
        case presetVideo2
        case presetVideo3
        case presetVideo4
        case presetVideo5
        case presetVideo6
        case presetVideo7
        case presetVideo8
        case shared
        case unencrypted
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .presetVideo2,
                .presetVideo3,
                .presetVideo4,
                .presetVideo5,
                .presetVideo6,
                .presetVideo7,
                .presetVideo8,
                .shared,
                .unencrypted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET-VIDEO-1"
            case .presetVideo2: return "PRESET-VIDEO-2"
            case .presetVideo3: return "PRESET-VIDEO-3"
            case .presetVideo4: return "PRESET-VIDEO-4"
            case .presetVideo5: return "PRESET-VIDEO-5"
            case .presetVideo6: return "PRESET-VIDEO-6"
            case .presetVideo7: return "PRESET-VIDEO-7"
            case .presetVideo8: return "PRESET-VIDEO-8"
            case .shared: return "SHARED"
            case .unencrypted: return "UNENCRYPTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes {
    public enum Profile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hbbtv15
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Profile] {
            return [
                .hbbtv15,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hbbtv15: return "HBBTV_1_5"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Profile(rawValue: rawValue) ?? Profile.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes {
    public enum ScteMarkersSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manifest
        case segments
        case sdkUnknown(Swift.String)

        public static var allCases: [ScteMarkersSource] {
            return [
                .manifest,
                .segments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manifest: return "MANIFEST"
            case .segments: return "SEGMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScteMarkersSource(rawValue: rawValue) ?? ScteMarkersSource.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes {
    public enum SegmentTemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case numberWithDuration
        case numberWithTimeline
        case timeWithTimeline
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentTemplateFormat] {
            return [
                .numberWithDuration,
                .numberWithTimeline,
                .timeWithTimeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .numberWithDuration: return "NUMBER_WITH_DURATION"
            case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
            case .timeWithTimeline: return "TIME_WITH_TIMELINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SegmentTemplateFormat(rawValue: rawValue) ?? SegmentTemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageVodClientTypes.SpekeKeyProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionContractConfiguration = "encryptionContractConfiguration"
        case roleArn = "roleArn"
        case systemIds = "systemIds"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContractConfiguration = self.encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let systemIds = systemIds {
            var systemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemIds)
            for __string0 in systemIds {
                try systemIdsContainer.encode(__string0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let systemIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .systemIds)
        var systemIdsDecoded0:[Swift.String]? = nil
        if let systemIdsContainer = systemIdsContainer {
            systemIdsDecoded0 = [Swift.String]()
            for string0 in systemIdsContainer {
                if let string0 = string0 {
                    systemIdsDecoded0?.append(string0)
                }
            }
        }
        systemIds = systemIdsDecoded0
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public struct SpekeKeyProvider: Swift.Equatable {
        /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use. Note the following considerations when using encryptionContractConfiguration: encryptionContractConfiguration can be used for DASH endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification. You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
        public var encryptionContractConfiguration: MediaPackageVodClientTypes.EncryptionContractConfiguration?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The system IDs to include in key requests.
        /// This member is required.
        public var systemIds: [Swift.String]?
        /// The URL of the external key provider service.
        /// This member is required.
        public var url: Swift.String?

        public init (
            encryptionContractConfiguration: MediaPackageVodClientTypes.EncryptionContractConfiguration? = nil,
            roleArn: Swift.String? = nil,
            systemIds: [Swift.String]? = nil,
            url: Swift.String? = nil
        )
        {
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }
    }

}

extension MediaPackageVodClientTypes {
    public enum StreamOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case original
        case videoBitrateAscending
        case videoBitrateDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamOrder] {
            return [
                .original,
                .videoBitrateAscending,
                .videoBitrateDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
            case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamOrder(rawValue: rawValue) ?? StreamOrder.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageVodClientTypes.StreamSelection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
        case minVideoBitsPerSecond = "minVideoBitsPerSecond"
        case streamOrder = "streamOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVideoBitsPerSecond = self.maxVideoBitsPerSecond {
            try encodeContainer.encode(maxVideoBitsPerSecond, forKey: .maxVideoBitsPerSecond)
        }
        if let minVideoBitsPerSecond = self.minVideoBitsPerSecond {
            try encodeContainer.encode(minVideoBitsPerSecond, forKey: .minVideoBitsPerSecond)
        }
        if let streamOrder = self.streamOrder {
            try encodeContainer.encode(streamOrder.rawValue, forKey: .streamOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVideoBitsPerSecond)
        maxVideoBitsPerSecond = maxVideoBitsPerSecondDecoded
        let minVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minVideoBitsPerSecond)
        minVideoBitsPerSecond = minVideoBitsPerSecondDecoded
        let streamOrderDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.StreamOrder.self, forKey: .streamOrder)
        streamOrder = streamOrderDecoded
    }
}

extension MediaPackageVodClientTypes {
    /// A StreamSelection configuration.
    public struct StreamSelection: Swift.Equatable {
        /// The maximum video bitrate (bps) to include in output.
        public var maxVideoBitsPerSecond: Swift.Int?
        /// The minimum video bitrate (bps) to include in output.
        public var minVideoBitsPerSecond: Swift.Int?
        /// A directive that determines the order of streams in the output.
        public var streamOrder: MediaPackageVodClientTypes.StreamOrder?

        public init (
            maxVideoBitsPerSecond: Swift.Int? = nil,
            minVideoBitsPerSecond: Swift.Int? = nil,
            streamOrder: MediaPackageVodClientTypes.StreamOrder? = nil
        )
        {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of tags associated with a resource
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A comma-separated list of the tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePackagingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = self.authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
    }
}

extension UpdatePackagingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/packaging_groups/\(id.urlPercentEncoding())"
    }
}

/// A MediaPackage VOD PackagingGroup resource configuration.
public struct UpdatePackagingGroupInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    /// This member is required.
    public var id: Swift.String?

    public init (
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        id: Swift.String? = nil
    )
    {
        self.authorization = authorization
        self.id = id
    }
}

struct UpdatePackagingGroupInputBody: Swift.Equatable {
    let authorization: MediaPackageVodClientTypes.Authorization?
}

extension UpdatePackagingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
    }
}

extension UpdatePackagingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackagingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePackagingGroupOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackagingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approximateAssetCount = output.approximateAssetCount
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.approximateAssetCount = nil
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct UpdatePackagingGroupOutputResponse: Swift.Equatable {
    /// The approximate asset count of the PackagingGroup.
    public var approximateAssetCount: Swift.Int?
    /// The ARN of the PackagingGroup.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageVodClientTypes.Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public var domainName: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        approximateAssetCount: Swift.Int? = nil,
        arn: Swift.String? = nil,
        authorization: MediaPackageVodClientTypes.Authorization? = nil,
        domainName: Swift.String? = nil,
        egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.approximateAssetCount = approximateAssetCount
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct UpdatePackagingGroupOutputResponseBody: Swift.Equatable {
    let approximateAssetCount: Swift.Int?
    let arn: Swift.String?
    let authorization: MediaPackageVodClientTypes.Authorization?
    let domainName: Swift.String?
    let egressAccessLogs: MediaPackageVodClientTypes.EgressAccessLogs?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdatePackagingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateAssetCount = "approximateAssetCount"
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateAssetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateAssetCount)
        approximateAssetCount = approximateAssetCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageVodClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageVodClientTypes {
    public enum __PeriodTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ads
        case sdkUnknown(Swift.String)

        public static var allCases: [__PeriodTriggersElement] {
            return [
                .ads,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ADS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = __PeriodTriggersElement(rawValue: rawValue) ?? __PeriodTriggersElement.sdkUnknown(rawValue)
        }
    }
}
