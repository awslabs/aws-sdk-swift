// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetResourcePoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetResourcePoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutputResponse`
extension SsmIncidentsClient {
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse>(input: input, inputKey: \GetResourcePoliciesInput.nextToken, outputKey: \GetResourcePoliciesOutputResponse.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
/// to access the nested member `[SsmIncidentsClientTypes.ResourcePolicy]`
/// - Returns: `[SsmIncidentsClientTypes.ResourcePolicy]`
extension PaginatorSequence where Input == GetResourcePoliciesInput, Output == GetResourcePoliciesOutputResponse {
    func resourcePolicies() async throws -> [SsmIncidentsClientTypes.ResourcePolicy] {
        return try await self.asyncCompactMap { item in item.resourcePolicies }
    }
}

/// Paginate over `[ListIncidentRecordsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIncidentRecordsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIncidentRecordsOutputResponse`
extension SsmIncidentsClient {
    public func listIncidentRecordsPaginated(input: ListIncidentRecordsInput) -> ClientRuntime.PaginatorSequence<ListIncidentRecordsInput, ListIncidentRecordsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIncidentRecordsInput, ListIncidentRecordsOutputResponse>(input: input, inputKey: \ListIncidentRecordsInput.nextToken, outputKey: \ListIncidentRecordsOutputResponse.nextToken, paginationFunction: self.listIncidentRecords(input:))
    }
}

extension ListIncidentRecordsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIncidentRecordsInput {
        return ListIncidentRecordsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listIncidentRecordsPaginated`
/// to access the nested member `[SsmIncidentsClientTypes.IncidentRecordSummary]`
/// - Returns: `[SsmIncidentsClientTypes.IncidentRecordSummary]`
extension PaginatorSequence where Input == ListIncidentRecordsInput, Output == ListIncidentRecordsOutputResponse {
    func incidentRecordSummaries() async throws -> [SsmIncidentsClientTypes.IncidentRecordSummary] {
        return try await self.asyncCompactMap { item in item.incidentRecordSummaries }
    }
}

/// Paginate over `[ListRelatedItemsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRelatedItemsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRelatedItemsOutputResponse`
extension SsmIncidentsClient {
    public func listRelatedItemsPaginated(input: ListRelatedItemsInput) -> ClientRuntime.PaginatorSequence<ListRelatedItemsInput, ListRelatedItemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRelatedItemsInput, ListRelatedItemsOutputResponse>(input: input, inputKey: \ListRelatedItemsInput.nextToken, outputKey: \ListRelatedItemsOutputResponse.nextToken, paginationFunction: self.listRelatedItems(input:))
    }
}

extension ListRelatedItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRelatedItemsInput {
        return ListRelatedItemsInput(
            incidentRecordArn: self.incidentRecordArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRelatedItemsPaginated`
/// to access the nested member `[SsmIncidentsClientTypes.RelatedItem]`
/// - Returns: `[SsmIncidentsClientTypes.RelatedItem]`
extension PaginatorSequence where Input == ListRelatedItemsInput, Output == ListRelatedItemsOutputResponse {
    func relatedItems() async throws -> [SsmIncidentsClientTypes.RelatedItem] {
        return try await self.asyncCompactMap { item in item.relatedItems }
    }
}

/// Paginate over `[ListReplicationSetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListReplicationSetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListReplicationSetsOutputResponse`
extension SsmIncidentsClient {
    public func listReplicationSetsPaginated(input: ListReplicationSetsInput) -> ClientRuntime.PaginatorSequence<ListReplicationSetsInput, ListReplicationSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReplicationSetsInput, ListReplicationSetsOutputResponse>(input: input, inputKey: \ListReplicationSetsInput.nextToken, outputKey: \ListReplicationSetsOutputResponse.nextToken, paginationFunction: self.listReplicationSets(input:))
    }
}

extension ListReplicationSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReplicationSetsInput {
        return ListReplicationSetsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listReplicationSetsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListReplicationSetsInput, Output == ListReplicationSetsOutputResponse {
    func replicationSetArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.replicationSetArns }
    }
}

/// Paginate over `[ListResponsePlansOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListResponsePlansInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListResponsePlansOutputResponse`
extension SsmIncidentsClient {
    public func listResponsePlansPaginated(input: ListResponsePlansInput) -> ClientRuntime.PaginatorSequence<ListResponsePlansInput, ListResponsePlansOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResponsePlansInput, ListResponsePlansOutputResponse>(input: input, inputKey: \ListResponsePlansInput.nextToken, outputKey: \ListResponsePlansOutputResponse.nextToken, paginationFunction: self.listResponsePlans(input:))
    }
}

extension ListResponsePlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResponsePlansInput {
        return ListResponsePlansInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listResponsePlansPaginated`
/// to access the nested member `[SsmIncidentsClientTypes.ResponsePlanSummary]`
/// - Returns: `[SsmIncidentsClientTypes.ResponsePlanSummary]`
extension PaginatorSequence where Input == ListResponsePlansInput, Output == ListResponsePlansOutputResponse {
    func responsePlanSummaries() async throws -> [SsmIncidentsClientTypes.ResponsePlanSummary] {
        return try await self.asyncCompactMap { item in item.responsePlanSummaries }
    }
}

/// Paginate over `[ListTimelineEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTimelineEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTimelineEventsOutputResponse`
extension SsmIncidentsClient {
    public func listTimelineEventsPaginated(input: ListTimelineEventsInput) -> ClientRuntime.PaginatorSequence<ListTimelineEventsInput, ListTimelineEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTimelineEventsInput, ListTimelineEventsOutputResponse>(input: input, inputKey: \ListTimelineEventsInput.nextToken, outputKey: \ListTimelineEventsOutputResponse.nextToken, paginationFunction: self.listTimelineEvents(input:))
    }
}

extension ListTimelineEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTimelineEventsInput {
        return ListTimelineEventsInput(
            filters: self.filters,
            incidentRecordArn: self.incidentRecordArn,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTimelineEventsPaginated`
/// to access the nested member `[SsmIncidentsClientTypes.EventSummary]`
/// - Returns: `[SsmIncidentsClientTypes.EventSummary]`
extension PaginatorSequence where Input == ListTimelineEventsInput, Output == ListTimelineEventsOutputResponse {
    func eventSummaries() async throws -> [SsmIncidentsClientTypes.EventSummary] {
        return try await self.asyncCompactMap { item in item.eventSummaries }
    }
}
