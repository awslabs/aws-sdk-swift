// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient access to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSMIncidentsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case ssmautomation = "ssmAutomation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ssmautomation(ssmautomation):
                try container.encode(ssmautomation, forKey: .ssmautomation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ssmautomationDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.SsmAutomation.self, forKey: .ssmautomation)
        if let ssmautomation = ssmautomationDecoded {
            self = .ssmautomation(ssmautomation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// The action that starts at the beginning of an incident. The response plan defines the action.
    public enum Action: Swift.Equatable {
        /// The Systems Manager automation document to start as the runbook at the beginning of the incident.
        case ssmautomation(SSMIncidentsClientTypes.SsmAutomation)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.AddRegionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionName
        case sseKmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let sseKmsKeyId = self.sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Defines the Amazon Web Services Region and KMS key to add to the replication set.
    public struct AddRegionAction: Swift.Equatable {
        /// The Amazon Web Services Region name to add to the replication set.
        /// This member is required.
        public var regionName: Swift.String?
        /// The KMS key ID to use to encrypt your replication set.
        public var sseKmsKeyId: Swift.String?

        public init (
            regionName: Swift.String? = nil,
            sseKmsKeyId: Swift.String? = nil
        )
        {
            self.regionName = regionName
            self.sseKmsKeyId = sseKmsKeyId
        }
    }

}

extension SSMIncidentsClientTypes.AttributeValueList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integervalues = "integerValues"
        case sdkUnknown
        case stringvalues = "stringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integervalues(integervalues):
                var integervaluesContainer = container.nestedUnkeyedContainer(forKey: .integervalues)
                for integer0 in integervalues {
                    try integervaluesContainer.encode(integer0)
                }
            case let .stringvalues(stringvalues):
                var stringvaluesContainer = container.nestedUnkeyedContainer(forKey: .stringvalues)
                for string0 in stringvalues {
                    try stringvaluesContainer.encode(string0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvaluesContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringvalues)
        var stringvaluesDecoded0:[Swift.String]? = nil
        if let stringvaluesContainer = stringvaluesContainer {
            stringvaluesDecoded0 = [Swift.String]()
            for string0 in stringvaluesContainer {
                if let string0 = string0 {
                    stringvaluesDecoded0?.append(string0)
                }
            }
        }
        if let stringvalues = stringvaluesDecoded0 {
            self = .stringvalues(stringvalues)
            return
        }
        let integervaluesContainer = try values.decodeIfPresent([Swift.Int?].self, forKey: .integervalues)
        var integervaluesDecoded0:[Swift.Int]? = nil
        if let integervaluesContainer = integervaluesContainer {
            integervaluesDecoded0 = [Swift.Int]()
            for integer0 in integervaluesContainer {
                if let integer0 = integer0 {
                    integervaluesDecoded0?.append(integer0)
                }
            }
        }
        if let integervalues = integervaluesDecoded0 {
            self = .integervalues(integervalues)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// Use the AttributeValueList to filter by string or integer values.
    public enum AttributeValueList: Swift.Equatable {
        /// The list of string values that the filter matches.
        case stringvalues([Swift.String])
        /// The list of integer values that the filter matches.
        case integervalues([Swift.Int])
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.AutomationExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case ssmexecutionarn = "ssmExecutionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ssmexecutionarn(ssmexecutionarn):
                try container.encode(ssmexecutionarn, forKey: .ssmexecutionarn)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ssmexecutionarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .ssmexecutionarn)
        if let ssmexecutionarn = ssmexecutionarnDecoded {
            self = .ssmexecutionarn(ssmexecutionarn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// The Systems Manager automation document process to start as the runbook at the beginning of the incident.
    public enum AutomationExecution: Swift.Equatable, Swift.Hashable {
        /// The Amazon Resource Name (ARN) of the automation process.
        case ssmexecutionarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.ChatChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chatbotsns = "chatbotSns"
        case empty
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .chatbotsns(chatbotsns):
                var chatbotsnsContainer = container.nestedUnkeyedContainer(forKey: .chatbotsns)
                for snsarn0 in chatbotsns {
                    try chatbotsnsContainer.encode(snsarn0)
                }
            case let .empty(empty):
                try container.encode(empty, forKey: .empty)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let emptyDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.EmptyChatChannel.self, forKey: .empty)
        if let empty = emptyDecoded {
            self = .empty(empty)
            return
        }
        let chatbotsnsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .chatbotsns)
        var chatbotsnsDecoded0:[Swift.String]? = nil
        if let chatbotsnsContainer = chatbotsnsContainer {
            chatbotsnsDecoded0 = [Swift.String]()
            for string0 in chatbotsnsContainer {
                if let string0 = string0 {
                    chatbotsnsDecoded0?.append(string0)
                }
            }
        }
        if let chatbotsns = chatbotsnsDecoded0 {
            self = .chatbotsns(chatbotsns)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// The Chatbot chat channel used for collaboration during an incident.
    public enum ChatChannel: Swift.Equatable {
        /// Used to remove the chat channel from an incident record or response plan.
        case empty(SSMIncidentsClientTypes.EmptyChatChannel)
        /// The Amazon SNS targets that Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel by using the Amazon SNS topics.
        case chatbotsns([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case after
        case before
        case equals
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .after(after):
                try container.encodeTimestamp(after, format: .epochSeconds, forKey: .after)
            case let .before(before):
                try container.encodeTimestamp(before, format: .epochSeconds, forKey: .before)
            case let .equals(equals):
                try container.encode(equals, forKey: .equals)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let beforeDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .before)
        if let before = beforeDecoded {
            self = .before(before)
            return
        }
        let afterDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .after)
        if let after = afterDecoded {
            self = .after(after)
            return
        }
        let equalsDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.AttributeValueList.self, forKey: .equals)
        if let equals = equalsDecoded {
            self = .equals(equals)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// A conditional statement with which to compare a value, after a timestamp, before a timestamp, or equal to a string or integer. If multiple conditions are specified, the conditionals become an ANDed statement. If multiple values are specified for a conditional, the values are ORd.
    public enum Condition: Swift.Equatable {
        /// Before the specified timestamp
        case before(ClientRuntime.Date)
        /// After the specified timestamp.
        case after(ClientRuntime.Date)
        /// The value is equal to the provided string or integer.
        case equals(SSMIncidentsClientTypes.AttributeValueList)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
            self.retryAfter = output.retryAfter
        } else {
            self.message = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
            self.retryAfter = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The identifier of the requested resource
    public var resourceIdentifier: Swift.String?
    /// The resource type
    public var resourceType: SSMIncidentsClientTypes.ResourceType?
    /// If present in the output, the operation can be retried after this time
    public var retryAfter: ClientRuntime.Date?

    public init (
        message: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil,
        retryAfter: ClientRuntime.Date? = nil
    )
    {
        self.message = message
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.retryAfter = retryAfter
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceIdentifier: Swift.String?
    let resourceType: SSMIncidentsClientTypes.ResourceType?
    let retryAfter: ClientRuntime.Date?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceIdentifier
        case resourceType
        case retryAfter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let retryAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .retryAfter)
        retryAfter = retryAfterDecoded
    }
}

extension CreateReplicationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case regions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .regions)
            for (dictKey0, regionMapInput0) in regions {
                try regionsContainer.encode(regionMapInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateReplicationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createReplicationSet"
    }
}

public struct CreateReplicationSetInput: Swift.Equatable {
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The Regions that Incident Manager replicates your data to. You can have up to three Regions in your replication set.
    /// This member is required.
    public var regions: [Swift.String:SSMIncidentsClientTypes.RegionMapInputValue]?
    /// A list of tags to add to the replication set.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        regions: [Swift.String:SSMIncidentsClientTypes.RegionMapInputValue]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.regions = regions
        self.tags = tags
    }
}

struct CreateReplicationSetInputBody: Swift.Equatable {
    let regions: [Swift.String:SSMIncidentsClientTypes.RegionMapInputValue]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case regions
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String: SSMIncidentsClientTypes.RegionMapInputValue?].self, forKey: .regions)
        var regionsDecoded0: [Swift.String:SSMIncidentsClientTypes.RegionMapInputValue]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String:SSMIncidentsClientTypes.RegionMapInputValue]()
            for (key0, regionmapinputvalue0) in regionsContainer {
                if let regionmapinputvalue0 = regionmapinputvalue0 {
                    regionsDecoded0?[key0] = regionmapinputvalue0
                }
            }
        }
        regions = regionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReplicationSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReplicationSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateReplicationSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication set.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateReplicationSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateReplicationSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateResponsePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplate
        case integrations
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let chatChannel = self.chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let engagements = engagements {
            var engagementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engagements)
            for ssmcontactsarn0 in engagements {
                try engagementsContainer.encode(ssmcontactsarn0)
            }
        }
        if let incidentTemplate = self.incidentTemplate {
            try encodeContainer.encode(incidentTemplate, forKey: .incidentTemplate)
        }
        if let integrations = integrations {
            var integrationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integrations)
            for integration0 in integrations {
                try integrationsContainer.encode(integration0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateResponsePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createResponsePlan"
    }
}

public struct CreateResponsePlanInput: Swift.Equatable {
    /// The actions that the response plan starts at the beginning of an incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The Chatbot chat channel used for collaboration during an incident.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The long format of the response plan name. This field can contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// Details used to create an incident when using this response plan.
    /// This member is required.
    public var incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    /// Information about third-party services integrated into the response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?
    /// The short format name of the response plan. Can't include spaces.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags that you are adding to the response plan.
    public var tags: [Swift.String:Swift.String]?

    public init (
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.actions = actions
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.integrations = integrations
        self.name = name
        self.tags = tags
    }
}

struct CreateResponsePlanInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    let chatChannel: SSMIncidentsClientTypes.ChatChannel?
    let engagements: [Swift.String]?
    let actions: [SSMIncidentsClientTypes.Action]?
    let tags: [Swift.String:Swift.String]?
    let integrations: [SSMIncidentsClientTypes.Integration]?
}

extension CreateResponsePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplate
        case integrations
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentTemplate.self, forKey: .incidentTemplate)
        incidentTemplate = incidentTemplateDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .engagements)
        var engagementsDecoded0:[Swift.String]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [Swift.String]()
            for string0 in engagementsContainer {
                if let string0 = string0 {
                    engagementsDecoded0?.append(string0)
                }
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[SSMIncidentsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [SSMIncidentsClientTypes.Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let integrationsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Integration?].self, forKey: .integrations)
        var integrationsDecoded0:[SSMIncidentsClientTypes.Integration]? = nil
        if let integrationsContainer = integrationsContainer {
            integrationsDecoded0 = [SSMIncidentsClientTypes.Integration]()
            for union0 in integrationsContainer {
                if let union0 = union0 {
                    integrationsDecoded0?.append(union0)
                }
            }
        }
        integrations = integrationsDecoded0
    }
}

extension CreateResponsePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResponsePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResponsePlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResponsePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResponsePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateResponsePlanOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateResponsePlanOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateResponsePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateTimelineEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case eventData
        case eventReferences
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventReferences = eventReferences {
            var eventReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventReferences)
            for eventreference0 in eventReferences {
                try eventReferencesContainer.encode(eventreference0)
            }
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

extension CreateTimelineEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createTimelineEvent"
    }
}

public struct CreateTimelineEventInput: Swift.Equatable {
    /// A token ensuring that the action is called only once with the specified details.
    public var clientToken: Swift.String?
    /// A short description of the event.
    /// This member is required.
    public var eventData: Swift.String?
    /// Adds one or more references to the TimelineEvent. A reference can be an Amazon Web Services resource involved in the incident or in some way associated with it. When you specify a reference, you enter the Amazon Resource Name (ARN) of the resource. You can also specify a related item. As an example, you could specify the ARN of an Amazon DynamoDB (DynamoDB) table. The table for this example is the resource. You could also specify a Amazon CloudWatch metric for that table. The metric is the related item.
    public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
    /// The time that the event occurred.
    /// This member is required.
    public var eventTime: ClientRuntime.Date?
    /// The type of the event. You can create timeline events of type Custom Event.
    /// This member is required.
    public var eventType: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident record to which the event will be added.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eventData: Swift.String? = nil,
        eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
        eventTime: ClientRuntime.Date? = nil,
        eventType: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventReferences = eventReferences
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

struct CreateTimelineEventInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let incidentRecordArn: Swift.String?
    let eventTime: ClientRuntime.Date?
    let eventType: Swift.String?
    let eventData: Swift.String?
    let eventReferences: [SSMIncidentsClientTypes.EventReference]?
}

extension CreateTimelineEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case eventData
        case eventReferences
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventData)
        eventData = eventDataDecoded
        let eventReferencesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.EventReference?].self, forKey: .eventReferences)
        var eventReferencesDecoded0:[SSMIncidentsClientTypes.EventReference]? = nil
        if let eventReferencesContainer = eventReferencesContainer {
            eventReferencesDecoded0 = [SSMIncidentsClientTypes.EventReference]()
            for union0 in eventReferencesContainer {
                if let union0 = union0 {
                    eventReferencesDecoded0?.append(union0)
                }
            }
        }
        eventReferences = eventReferencesDecoded0
    }
}

extension CreateTimelineEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTimelineEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTimelineEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTimelineEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTimelineEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventId = output.eventId
            self.incidentRecordArn = output.incidentRecordArn
        } else {
            self.eventId = nil
            self.incidentRecordArn = nil
        }
    }
}

public struct CreateTimelineEventOutputResponse: Swift.Equatable {
    /// The ID of the event for easy reference later.
    /// This member is required.
    public var eventId: Swift.String?
    /// The ARN of the incident record that you added the event to.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct CreateTimelineEventOutputResponseBody: Swift.Equatable {
    let incidentRecordArn: Swift.String?
    let eventId: Swift.String?
}

extension CreateTimelineEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case incidentRecordArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension DeleteIncidentRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteIncidentRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteIncidentRecord"
    }
}

public struct DeleteIncidentRecordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident record you are deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteIncidentRecordInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteIncidentRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteIncidentRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIncidentRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIncidentRecordOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIncidentRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIncidentRecordOutputResponse: Swift.Equatable {

    public init () { }
}

extension SSMIncidentsClientTypes.DeleteRegionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Defines the information about the Amazon Web Services Region you're deleting from your replication set.
    public struct DeleteRegionAction: Swift.Equatable {
        /// The name of the Amazon Web Services Region you're deleting from the replication set.
        /// This member is required.
        public var regionName: Swift.String?

        public init (
            regionName: Swift.String? = nil
        )
        {
            self.regionName = regionName
        }
    }

}

extension DeleteReplicationSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension DeleteReplicationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteReplicationSet"
    }
}

public struct DeleteReplicationSetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication set you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteReplicationSetInputBody: Swift.Equatable {
}

extension DeleteReplicationSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReplicationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteResourcePolicy"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The ID of the resource policy you're deleting.
    /// This member is required.
    public var policyId: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource you're deleting the policy from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policyId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policyId: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResponsePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteResponsePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteResponsePlan"
    }
}

public struct DeleteResponsePlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteResponsePlanInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteResponsePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteResponsePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResponsePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResponsePlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResponsePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResponsePlanOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTimelineEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case incidentRecordArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

extension DeleteTimelineEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteTimelineEvent"
    }
}

public struct DeleteTimelineEventInput: Swift.Equatable {
    /// The ID of the event you are updating. You can find this by using ListTimelineEvents.
    /// This member is required.
    public var eventId: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct DeleteTimelineEventInputBody: Swift.Equatable {
    let incidentRecordArn: Swift.String?
    let eventId: Swift.String?
}

extension DeleteTimelineEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case incidentRecordArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension DeleteTimelineEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTimelineEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTimelineEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTimelineEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTimelineEventOutputResponse: Swift.Equatable {

    public init () { }
}

extension SSMIncidentsClientTypes.DynamicSsmParameterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case variable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .variable(variable):
                try container.encode(variable.rawValue, forKey: .variable)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let variableDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.VariableType.self, forKey: .variable)
        if let variable = variableDecoded {
            self = .variable(variable)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// The dynamic SSM parameter value.
    public enum DynamicSsmParameterValue: Swift.Equatable {
        /// Variable dynamic parameters. A parameter value is determined when an incident is created.
        case variable(SSMIncidentsClientTypes.VariableType)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.EmptyChatChannel: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SSMIncidentsClientTypes {
    /// Used to remove the chat channel from an incident record or response plan.
    public struct EmptyChatChannel: Swift.Equatable {

        public init () { }
    }

}

extension SSMIncidentsClientTypes.EventReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relateditemid = "relatedItemId"
        case resource
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .relateditemid(relateditemid):
                try container.encode(relateditemid, forKey: .relateditemid)
            case let .resource(resource):
                try container.encode(resource, forKey: .resource)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .resource)
        if let resource = resourceDecoded {
            self = .resource(resource)
            return
        }
        let relateditemidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .relateditemid)
        if let relateditemid = relateditemidDecoded {
            self = .relateditemid(relateditemid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// An item referenced in a TimelineEvent that is involved in or somehow associated with an incident. You can specify an Amazon Resource Name (ARN) for an Amazon Web Services resource or a RelatedItem ID.
    public enum EventReference: Swift.Equatable, Swift.Hashable {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services resource referenced in a TimelineEvent.
        case resource(Swift.String)
        /// The ID of a RelatedItem referenced in a TimelineEvent.
        case relateditemid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.EventSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case eventReferences
        case eventTime
        case eventType
        case eventUpdatedTime
        case incidentRecordArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReferences = eventReferences {
            var eventReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventReferences)
            for eventreference0 in eventReferences {
                try eventReferencesContainer.encode(eventreference0)
            }
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let eventUpdatedTime = self.eventUpdatedTime {
            try encodeContainer.encodeTimestamp(eventUpdatedTime, format: .epochSeconds, forKey: .eventUpdatedTime)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventUpdatedTime)
        eventUpdatedTime = eventUpdatedTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventReferencesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.EventReference?].self, forKey: .eventReferences)
        var eventReferencesDecoded0:[SSMIncidentsClientTypes.EventReference]? = nil
        if let eventReferencesContainer = eventReferencesContainer {
            eventReferencesDecoded0 = [SSMIncidentsClientTypes.EventReference]()
            for union0 in eventReferencesContainer {
                if let union0 = union0 {
                    eventReferencesDecoded0?.append(union0)
                }
            }
        }
        eventReferences = eventReferencesDecoded0
    }
}

extension SSMIncidentsClientTypes {
    /// Details about a timeline event during an incident.
    public struct EventSummary: Swift.Equatable {
        /// The timeline event ID.
        /// This member is required.
        public var eventId: Swift.String?
        /// A list of references in a TimelineEvent.
        public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
        /// The time that the event occurred.
        /// This member is required.
        public var eventTime: ClientRuntime.Date?
        /// The type of event. The timeline event must be Custom Event.
        /// This member is required.
        public var eventType: Swift.String?
        /// The time that the timeline event was last updated.
        /// This member is required.
        public var eventUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the incident that the event happened during.
        /// This member is required.
        public var incidentRecordArn: Swift.String?

        public init (
            eventId: Swift.String? = nil,
            eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
            eventTime: ClientRuntime.Date? = nil,
            eventType: Swift.String? = nil,
            eventUpdatedTime: ClientRuntime.Date? = nil,
            incidentRecordArn: Swift.String? = nil
        )
        {
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }
    }

}

extension SSMIncidentsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Filter the selection by using a condition.
    public struct Filter: Swift.Equatable {
        /// The condition accepts before or after a specified time, equal to a string, or equal to an integer.
        /// This member is required.
        public var condition: SSMIncidentsClientTypes.Condition?
        /// The key that you're filtering on.
        /// This member is required.
        public var key: Swift.String?

        public init (
            condition: SSMIncidentsClientTypes.Condition? = nil,
            key: Swift.String? = nil
        )
        {
            self.condition = condition
            self.key = key
        }
    }

}

extension GetIncidentRecordInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetIncidentRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getIncidentRecord"
    }
}

public struct GetIncidentRecordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident record.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetIncidentRecordInputBody: Swift.Equatable {
}

extension GetIncidentRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIncidentRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIncidentRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetIncidentRecordOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIncidentRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetIncidentRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.incidentRecord = output.incidentRecord
        } else {
            self.incidentRecord = nil
        }
    }
}

public struct GetIncidentRecordOutputResponse: Swift.Equatable {
    /// Details the structure of the incident record.
    /// This member is required.
    public var incidentRecord: SSMIncidentsClientTypes.IncidentRecord?

    public init (
        incidentRecord: SSMIncidentsClientTypes.IncidentRecord? = nil
    )
    {
        self.incidentRecord = incidentRecord
    }
}

struct GetIncidentRecordOutputResponseBody: Swift.Equatable {
    let incidentRecord: SSMIncidentsClientTypes.IncidentRecord?
}

extension GetIncidentRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentRecord
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecord.self, forKey: .incidentRecord)
        incidentRecord = incidentRecordDecoded
    }
}

extension GetReplicationSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetReplicationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getReplicationSet"
    }
}

public struct GetReplicationSetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication set you want to retrieve.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetReplicationSetInputBody: Swift.Equatable {
}

extension GetReplicationSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReplicationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension GetReplicationSetOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .accessDeniedException: return "AccessDeniedException"
        case .internalServerException: return "InternalServerException"
        case .resourceNotFoundException: return "ResourceNotFoundException"
        case .throttlingException: return "ThrottlingException"
        case .validationException: return "ValidationException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum GetReplicationSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReplicationSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationSet = output.replicationSet
        } else {
            self.replicationSet = nil
        }
    }
}

public struct GetReplicationSetOutputResponse: Swift.Equatable {
    /// Details of the replication set.
    /// This member is required.
    public var replicationSet: SSMIncidentsClientTypes.ReplicationSet?

    public init (
        replicationSet: SSMIncidentsClientTypes.ReplicationSet? = nil
    )
    {
        self.replicationSet = replicationSet
    }
}

struct GetReplicationSetOutputResponseBody: Swift.Equatable {
    let replicationSet: SSMIncidentsClientTypes.ReplicationSet?
}

extension GetReplicationSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSetDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ReplicationSet.self, forKey: .replicationSet)
        replicationSet = replicationSetDecoded
    }
}

extension GetResourcePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetResourcePoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension GetResourcePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getResourcePolicies"
    }
}

public struct GetResourcePoliciesInput: Swift.Equatable {
    /// The maximum number of resource policies to display for each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct GetResourcePoliciesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourcePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourcePolicies = output.resourcePolicies
        } else {
            self.nextToken = nil
            self.resourcePolicies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// Details about the resource policy attached to the response plan.
    /// This member is required.
    public var resourcePolicies: [SSMIncidentsClientTypes.ResourcePolicy]?

    public init (
        nextToken: Swift.String? = nil,
        resourcePolicies: [SSMIncidentsClientTypes.ResourcePolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

struct GetResourcePoliciesOutputResponseBody: Swift.Equatable {
    let resourcePolicies: [SSMIncidentsClientTypes.ResourcePolicy]?
    let nextToken: Swift.String?
}

extension GetResourcePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourcePolicies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePoliciesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.ResourcePolicy?].self, forKey: .resourcePolicies)
        var resourcePoliciesDecoded0:[SSMIncidentsClientTypes.ResourcePolicy]? = nil
        if let resourcePoliciesContainer = resourcePoliciesContainer {
            resourcePoliciesDecoded0 = [SSMIncidentsClientTypes.ResourcePolicy]()
            for structure0 in resourcePoliciesContainer {
                if let structure0 = structure0 {
                    resourcePoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourcePolicies = resourcePoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResponsePlanInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let arn = arn else {
                let message = "Creating a URL Query Item failed. arn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let arnQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
            items.append(arnQueryItem)
            return items
        }
    }
}

extension GetResponsePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getResponsePlan"
    }
}

public struct GetResponsePlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResponsePlanInputBody: Swift.Equatable {
}

extension GetResponsePlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResponsePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResponsePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResponsePlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResponsePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResponsePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.arn = output.arn
            self.chatChannel = output.chatChannel
            self.displayName = output.displayName
            self.engagements = output.engagements
            self.incidentTemplate = output.incidentTemplate
            self.integrations = output.integrations
            self.name = output.name
        } else {
            self.actions = nil
            self.arn = nil
            self.chatChannel = nil
            self.displayName = nil
            self.engagements = nil
            self.incidentTemplate = nil
            self.integrations = nil
            self.name = nil
        }
    }
}

public struct GetResponsePlanOutputResponse: Swift.Equatable {
    /// The actions that this response plan takes at the beginning of the incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The ARN of the response plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel used for collaboration during an incident.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// The long format name of the response plan. Can contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// Details used to create the incident when using this response plan.
    /// This member is required.
    public var incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    /// Information about third-party services integrated into the Incident Manager response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?
    /// The short format name of the response plan. The name can't contain spaces.
    /// This member is required.
    public var name: Swift.String?

    public init (
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil,
        name: Swift.String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.integrations = integrations
        self.name = name
    }
}

struct GetResponsePlanOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let incidentTemplate: SSMIncidentsClientTypes.IncidentTemplate?
    let chatChannel: SSMIncidentsClientTypes.ChatChannel?
    let engagements: [Swift.String]?
    let actions: [SSMIncidentsClientTypes.Action]?
    let integrations: [SSMIncidentsClientTypes.Integration]?
}

extension GetResponsePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case chatChannel
        case displayName
        case engagements
        case incidentTemplate
        case integrations
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentTemplate.self, forKey: .incidentTemplate)
        incidentTemplate = incidentTemplateDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .engagements)
        var engagementsDecoded0:[Swift.String]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [Swift.String]()
            for string0 in engagementsContainer {
                if let string0 = string0 {
                    engagementsDecoded0?.append(string0)
                }
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[SSMIncidentsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [SSMIncidentsClientTypes.Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let integrationsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Integration?].self, forKey: .integrations)
        var integrationsDecoded0:[SSMIncidentsClientTypes.Integration]? = nil
        if let integrationsContainer = integrationsContainer {
            integrationsDecoded0 = [SSMIncidentsClientTypes.Integration]()
            for union0 in integrationsContainer {
                if let union0 = union0 {
                    integrationsDecoded0?.append(union0)
                }
            }
        }
        integrations = integrationsDecoded0
    }
}

extension GetTimelineEventInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let eventId = eventId else {
                let message = "Creating a URL Query Item failed. eventId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let eventIdQueryItem = ClientRuntime.URLQueryItem(name: "eventId".urlPercentEncoding(), value: Swift.String(eventId).urlPercentEncoding())
            items.append(eventIdQueryItem)
            guard let incidentRecordArn = incidentRecordArn else {
                let message = "Creating a URL Query Item failed. incidentRecordArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let incidentRecordArnQueryItem = ClientRuntime.URLQueryItem(name: "incidentRecordArn".urlPercentEncoding(), value: Swift.String(incidentRecordArn).urlPercentEncoding())
            items.append(incidentRecordArnQueryItem)
            return items
        }
    }
}

extension GetTimelineEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getTimelineEvent"
    }
}

public struct GetTimelineEventInput: Swift.Equatable {
    /// The ID of the event. You can get an event's ID when you create it, or by using ListTimelineEvents.
    /// This member is required.
    public var eventId: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        eventId: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct GetTimelineEventInputBody: Swift.Equatable {
}

extension GetTimelineEventInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTimelineEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTimelineEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTimelineEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTimelineEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTimelineEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.event = output.event
        } else {
            self.event = nil
        }
    }
}

public struct GetTimelineEventOutputResponse: Swift.Equatable {
    /// Details about the timeline event.
    /// This member is required.
    public var event: SSMIncidentsClientTypes.TimelineEvent?

    public init (
        event: SSMIncidentsClientTypes.TimelineEvent? = nil
    )
    {
        self.event = event
    }
}

struct GetTimelineEventOutputResponseBody: Swift.Equatable {
    let event: SSMIncidentsClientTypes.TimelineEvent?
}

extension GetTimelineEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.TimelineEvent.self, forKey: .event)
        event = eventDecoded
    }
}

extension SSMIncidentsClientTypes.IncidentRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case automationExecutions
        case chatChannel
        case creationTime
        case dedupeString
        case impact
        case incidentRecordSource
        case lastModifiedBy
        case lastModifiedTime
        case notificationTargets
        case resolvedTime
        case status
        case summary
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let automationExecutions = automationExecutions {
            var automationExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automationExecutions)
            for automationexecution0 in automationExecutions {
                try automationExecutionsContainer.encode(automationexecution0)
            }
        }
        if let chatChannel = self.chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dedupeString = self.dedupeString {
            try encodeContainer.encode(dedupeString, forKey: .dedupeString)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let incidentRecordSource = self.incidentRecordSource {
            try encodeContainer.encode(incidentRecordSource, forKey: .incidentRecordSource)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetitem0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetitem0)
            }
        }
        if let resolvedTime = self.resolvedTime {
            try encodeContainer.encodeTimestamp(resolvedTime, format: .epochSeconds, forKey: .resolvedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .impact)
        impact = impactDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let resolvedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resolvedTime)
        resolvedTime = resolvedTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let automationExecutionsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.AutomationExecution?].self, forKey: .automationExecutions)
        var automationExecutionsDecoded0:[SSMIncidentsClientTypes.AutomationExecution]? = nil
        if let automationExecutionsContainer = automationExecutionsContainer {
            automationExecutionsDecoded0 = [SSMIncidentsClientTypes.AutomationExecution]()
            for union0 in automationExecutionsContainer {
                if let union0 = union0 {
                    automationExecutionsDecoded0?.append(union0)
                }
            }
        }
        automationExecutions = automationExecutionsDecoded0
        let incidentRecordSourceDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecordSource.self, forKey: .incidentRecordSource)
        incidentRecordSource = incidentRecordSourceDecoded
        let dedupeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedupeString)
        dedupeString = dedupeStringDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.NotificationTargetItem?].self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:[SSMIncidentsClientTypes.NotificationTargetItem]? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = [SSMIncidentsClientTypes.NotificationTargetItem]()
            for union0 in notificationTargetsContainer {
                if let union0 = union0 {
                    notificationTargetsDecoded0?.append(union0)
                }
            }
        }
        notificationTargets = notificationTargetsDecoded0
    }
}

extension SSMIncidentsClientTypes {
    /// The record of the incident that's created when an incident occurs.
    public struct IncidentRecord: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the incident record.
        /// This member is required.
        public var arn: Swift.String?
        /// The runbook, or automation document, that's run at the beginning of the incident.
        public var automationExecutions: [SSMIncidentsClientTypes.AutomationExecution]?
        /// The chat channel used for collaboration during an incident.
        public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
        /// The time that Incident Manager created the incident record.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
        /// This member is required.
        public var dedupeString: Swift.String?
        /// The impact of the incident on customers and applications.
        /// This member is required.
        public var impact: Swift.Int?
        /// Details about the action that started the incident.
        /// This member is required.
        public var incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource?
        /// Who modified the incident most recently.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// The time at which the incident was most recently modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
        /// The time at which the incident was resolved. This appears as a timeline event.
        public var resolvedTime: ClientRuntime.Date?
        /// The current status of the incident.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.
        public var summary: Swift.String?
        /// The title of the incident.
        /// This member is required.
        public var title: Swift.String?

        public init (
            arn: Swift.String? = nil,
            automationExecutions: [SSMIncidentsClientTypes.AutomationExecution]? = nil,
            chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
            creationTime: ClientRuntime.Date? = nil,
            dedupeString: Swift.String? = nil,
            impact: Swift.Int? = nil,
            incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
            resolvedTime: ClientRuntime.Date? = nil,
            status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
            summary: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.automationExecutions = automationExecutions
            self.chatChannel = chatChannel
            self.creationTime = creationTime
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notificationTargets = notificationTargets
            self.resolvedTime = resolvedTime
            self.status = status
            self.summary = summary
            self.title = title
        }
    }

}

extension SSMIncidentsClientTypes.IncidentRecordSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdBy
        case invokedBy
        case resourceArn
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let invokedBy = self.invokedBy {
            try encodeContainer.encode(invokedBy, forKey: .invokedBy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let invokedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokedBy)
        invokedBy = invokedByDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details about what created the incident record and when it was created.
    public struct IncidentRecordSource: Swift.Equatable {
        /// The principal that started the incident.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The service principal that assumed the role specified in createdBy. If no service principal assumed the role this will be left blank.
        public var invokedBy: Swift.String?
        /// The resource that caused the incident to be created.
        public var resourceArn: Swift.String?
        /// The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.
        /// This member is required.
        public var source: Swift.String?

        public init (
            createdBy: Swift.String? = nil,
            invokedBy: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.invokedBy = invokedBy
            self.resourceArn = resourceArn
            self.source = source
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum IncidentRecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `open`
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [IncidentRecordStatus] {
            return [
                .open,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .open: return "OPEN"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IncidentRecordStatus(rawValue: rawValue) ?? IncidentRecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.IncidentRecordSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case impact
        case incidentRecordSource
        case resolvedTime
        case status
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let incidentRecordSource = self.incidentRecordSource {
            try encodeContainer.encode(incidentRecordSource, forKey: .incidentRecordSource)
        }
        if let resolvedTime = self.resolvedTime {
            try encodeContainer.encodeTimestamp(resolvedTime, format: .epochSeconds, forKey: .resolvedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .impact)
        impact = impactDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let resolvedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .resolvedTime)
        resolvedTime = resolvedTimeDecoded
        let incidentRecordSourceDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecordSource.self, forKey: .incidentRecordSource)
        incidentRecordSource = incidentRecordSourceDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details describing an incident record.
    public struct IncidentRecordSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the incident.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the incident was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Defines the impact to customers and applications.
        /// This member is required.
        public var impact: Swift.Int?
        /// What caused Incident Manager to create the incident.
        /// This member is required.
        public var incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource?
        /// The time the incident was resolved.
        public var resolvedTime: ClientRuntime.Date?
        /// The current status of the incident.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
        /// The title of the incident. This value is either provided by the response plan or overwritten on creation.
        /// This member is required.
        public var title: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            impact: Swift.Int? = nil,
            incidentRecordSource: SSMIncidentsClientTypes.IncidentRecordSource? = nil,
            resolvedTime: ClientRuntime.Date? = nil,
            status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.resolvedTime = resolvedTime
            self.status = status
            self.title = title
        }
    }

}

extension SSMIncidentsClientTypes.IncidentTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedupeString
        case impact
        case incidentTags
        case notificationTargets
        case summary
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedupeString = self.dedupeString {
            try encodeContainer.encode(dedupeString, forKey: .dedupeString)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let incidentTags = incidentTags {
            var incidentTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .incidentTags)
            for (dictKey0, tagMap0) in incidentTags {
                try incidentTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetitem0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetitem0)
            }
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .impact)
        impact = impactDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let dedupeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedupeString)
        dedupeString = dedupeStringDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.NotificationTargetItem?].self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:[SSMIncidentsClientTypes.NotificationTargetItem]? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = [SSMIncidentsClientTypes.NotificationTargetItem]()
            for union0 in notificationTargetsContainer {
                if let union0 = union0 {
                    notificationTargetsDecoded0?.append(union0)
                }
            }
        }
        notificationTargets = notificationTargetsDecoded0
        let incidentTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .incidentTags)
        var incidentTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let incidentTagsContainer = incidentTagsContainer {
            incidentTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in incidentTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    incidentTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        incidentTags = incidentTagsDecoded0
    }
}

extension SSMIncidentsClientTypes {
    /// Basic details used in creating a response plan. The response plan is then used to create an incident record.
    public struct IncidentTemplate: Swift.Equatable {
        /// Used to stop Incident Manager from creating multiple incident records for the same incident.
        public var dedupeString: Swift.String?
        /// The impact of the incident on your customers and applications.
        /// This member is required.
        public var impact: Swift.Int?
        /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident.
        public var incidentTags: [Swift.String:Swift.String]?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.
        public var summary: Swift.String?
        /// The title of the incident.
        /// This member is required.
        public var title: Swift.String?

        public init (
            dedupeString: Swift.String? = nil,
            impact: Swift.Int? = nil,
            incidentTags: [Swift.String:Swift.String]? = nil,
            notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
            summary: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentTags = incidentTags
            self.notificationTargets = notificationTargets
            self.summary = summary
            self.title = title
        }
    }

}

extension SSMIncidentsClientTypes.Integration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pagerdutyconfiguration = "pagerDutyConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .pagerdutyconfiguration(pagerdutyconfiguration):
                try container.encode(pagerdutyconfiguration, forKey: .pagerdutyconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let pagerdutyconfigurationDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.PagerDutyConfiguration.self, forKey: .pagerdutyconfiguration)
        if let pagerdutyconfiguration = pagerdutyconfigurationDecoded {
            self = .pagerdutyconfiguration(pagerdutyconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// Information about third-party services integrated into a response plan.
    public enum Integration: Swift.Equatable {
        /// Information about the PagerDuty service where the response plan creates an incident.
        case pagerdutyconfiguration(SSMIncidentsClientTypes.PagerDutyConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSMIncidentsClientTypes.ItemIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ItemValue.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ItemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details and type of a related item.
    public struct ItemIdentifier: Swift.Equatable {
        /// The type of related item.
        /// This member is required.
        public var type: SSMIncidentsClientTypes.ItemType?
        /// Details about the related item.
        /// This member is required.
        public var value: SSMIncidentsClientTypes.ItemValue?

        public init (
            type: SSMIncidentsClientTypes.ItemType? = nil,
            value: SSMIncidentsClientTypes.ItemValue? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum ItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysis
        case attachment
        case automation
        case incident
        case involvedResource
        case metric
        case other
        case parent
        case task
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemType] {
            return [
                .analysis,
                .attachment,
                .automation,
                .incident,
                .involvedResource,
                .metric,
                .other,
                .parent,
                .task,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysis: return "ANALYSIS"
            case .attachment: return "ATTACHMENT"
            case .automation: return "AUTOMATION"
            case .incident: return "INCIDENT"
            case .involvedResource: return "INVOLVED_RESOURCE"
            case .metric: return "METRIC"
            case .other: return "OTHER"
            case .parent: return "PARENT"
            case .task: return "TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.ItemValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case metricdefinition = "metricDefinition"
        case pagerdutyincidentdetail = "pagerDutyIncidentDetail"
        case sdkUnknown
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arn(arn):
                try container.encode(arn, forKey: .arn)
            case let .metricdefinition(metricdefinition):
                try container.encode(metricdefinition, forKey: .metricdefinition)
            case let .pagerdutyincidentdetail(pagerdutyincidentdetail):
                try container.encode(pagerdutyincidentdetail, forKey: .pagerdutyincidentdetail)
            case let .url(url):
                try container.encode(url, forKey: .url)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .arn)
        if let arn = arnDecoded {
            self = .arn(arn)
            return
        }
        let urlDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let metricdefinitionDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .metricdefinition)
        if let metricdefinition = metricdefinitionDecoded {
            self = .metricdefinition(metricdefinition)
            return
        }
        let pagerdutyincidentdetailDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.PagerDutyIncidentDetail.self, forKey: .pagerdutyincidentdetail)
        if let pagerdutyincidentdetail = pagerdutyincidentdetailDecoded {
            self = .pagerdutyincidentdetail(pagerdutyincidentdetail)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// Describes a related item.
    public enum ItemValue: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon resource.
        case arn(Swift.String)
        /// The URL, if the related item is a non-Amazon Web Services resource.
        case url(Swift.String)
        /// The metric definition, if the related item is a metric in Amazon CloudWatch.
        case metricdefinition(Swift.String)
        /// Details about an incident that is associated with a PagerDuty incident.
        case pagerdutyincidentdetail(SSMIncidentsClientTypes.PagerDutyIncidentDetail)
        case sdkUnknown(Swift.String)
    }

}

extension ListIncidentRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIncidentRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listIncidentRecords"
    }
}

public struct ListIncidentRecordsInput: Swift.Equatable {
    /// Filters the list of incident records through which you are searching. You can filter on the following keys:
    ///
    /// * creationTime
    ///
    /// * impact
    ///
    /// * status
    ///
    /// * createdBy
    ///
    ///
    /// Note the following when deciding how to use Filters:
    ///
    /// * If you don't specify a Filter, the response includes all incident records.
    ///
    /// * If you specify more than one filter in a single request, the response returns incident records that match all filters.
    ///
    /// * If you specify a filter with more than one value, the response returns incident records that match any of the values provided.
    public var filters: [SSMIncidentsClientTypes.Filter]?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        filters: [SSMIncidentsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIncidentRecordsInputBody: Swift.Equatable {
    let filters: [SSMIncidentsClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIncidentRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[SSMIncidentsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SSMIncidentsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIncidentRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIncidentRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIncidentRecordsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIncidentRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIncidentRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.incidentRecordSummaries = output.incidentRecordSummaries
            self.nextToken = output.nextToken
        } else {
            self.incidentRecordSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIncidentRecordsOutputResponse: Swift.Equatable {
    /// The details of each listed incident record.
    /// This member is required.
    public var incidentRecordSummaries: [SSMIncidentsClientTypes.IncidentRecordSummary]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        incidentRecordSummaries: [SSMIncidentsClientTypes.IncidentRecordSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.incidentRecordSummaries = incidentRecordSummaries
        self.nextToken = nextToken
    }
}

struct ListIncidentRecordsOutputResponseBody: Swift.Equatable {
    let incidentRecordSummaries: [SSMIncidentsClientTypes.IncidentRecordSummary]?
    let nextToken: Swift.String?
}

extension ListIncidentRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentRecordSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordSummariesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.IncidentRecordSummary?].self, forKey: .incidentRecordSummaries)
        var incidentRecordSummariesDecoded0:[SSMIncidentsClientTypes.IncidentRecordSummary]? = nil
        if let incidentRecordSummariesContainer = incidentRecordSummariesContainer {
            incidentRecordSummariesDecoded0 = [SSMIncidentsClientTypes.IncidentRecordSummary]()
            for structure0 in incidentRecordSummariesContainer {
                if let structure0 = structure0 {
                    incidentRecordSummariesDecoded0?.append(structure0)
                }
            }
        }
        incidentRecordSummaries = incidentRecordSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRelatedItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentRecordArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRelatedItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRelatedItems"
    }
}

public struct ListRelatedItemsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident record containing the listed related items.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// The maximum number of related items per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        incidentRecordArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRelatedItemsInputBody: Swift.Equatable {
    let incidentRecordArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentRecordArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRelatedItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRelatedItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRelatedItemsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRelatedItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relatedItems = output.relatedItems
        } else {
            self.nextToken = nil
            self.relatedItems = nil
        }
    }
}

public struct ListRelatedItemsOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// Details about each related item.
    /// This member is required.
    public var relatedItems: [SSMIncidentsClientTypes.RelatedItem]?

    public init (
        nextToken: Swift.String? = nil,
        relatedItems: [SSMIncidentsClientTypes.RelatedItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

struct ListRelatedItemsOutputResponseBody: Swift.Equatable {
    let relatedItems: [SSMIncidentsClientTypes.RelatedItem]?
    let nextToken: Swift.String?
}

extension ListRelatedItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case relatedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.RelatedItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[SSMIncidentsClientTypes.RelatedItem]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [SSMIncidentsClientTypes.RelatedItem]()
            for structure0 in relatedItemsContainer {
                if let structure0 = structure0 {
                    relatedItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedItems = relatedItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReplicationSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListReplicationSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listReplicationSets"
    }
}

public struct ListReplicationSetsInput: Swift.Equatable {
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReplicationSetsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListReplicationSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReplicationSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReplicationSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReplicationSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReplicationSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReplicationSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replicationSetArns = output.replicationSetArns
        } else {
            self.nextToken = nil
            self.replicationSetArns = nil
        }
    }
}

public struct ListReplicationSetsOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the list replication set.
    /// This member is required.
    public var replicationSetArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        replicationSetArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationSetArns = replicationSetArns
    }
}

struct ListReplicationSetsOutputResponseBody: Swift.Equatable {
    let replicationSetArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListReplicationSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case replicationSetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationSetArns)
        var replicationSetArnsDecoded0:[Swift.String]? = nil
        if let replicationSetArnsContainer = replicationSetArnsContainer {
            replicationSetArnsDecoded0 = [Swift.String]()
            for string0 in replicationSetArnsContainer {
                if let string0 = string0 {
                    replicationSetArnsDecoded0?.append(string0)
                }
            }
        }
        replicationSetArns = replicationSetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResponsePlansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResponsePlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listResponsePlans"
    }
}

public struct ListResponsePlansInput: Swift.Equatable {
    /// The maximum number of response plans per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResponsePlansInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResponsePlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResponsePlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResponsePlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResponsePlansOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResponsePlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResponsePlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.responsePlanSummaries = output.responsePlanSummaries
        } else {
            self.nextToken = nil
            self.responsePlanSummaries = nil
        }
    }
}

public struct ListResponsePlansOutputResponse: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// Details of each response plan.
    /// This member is required.
    public var responsePlanSummaries: [SSMIncidentsClientTypes.ResponsePlanSummary]?

    public init (
        nextToken: Swift.String? = nil,
        responsePlanSummaries: [SSMIncidentsClientTypes.ResponsePlanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.responsePlanSummaries = responsePlanSummaries
    }
}

struct ListResponsePlansOutputResponseBody: Swift.Equatable {
    let responsePlanSummaries: [SSMIncidentsClientTypes.ResponsePlanSummary]?
    let nextToken: Swift.String?
}

extension ListResponsePlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case responsePlanSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsePlanSummariesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.ResponsePlanSummary?].self, forKey: .responsePlanSummaries)
        var responsePlanSummariesDecoded0:[SSMIncidentsClientTypes.ResponsePlanSummary]? = nil
        if let responsePlanSummariesContainer = responsePlanSummariesContainer {
            responsePlanSummariesDecoded0 = [SSMIncidentsClientTypes.ResponsePlanSummary]()
            for structure0 in responsePlanSummariesContainer {
                if let structure0 = structure0 {
                    responsePlanSummariesDecoded0?.append(structure0)
                }
            }
        }
        responsePlanSummaries = responsePlanSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags for the response plan.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTimelineEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case incidentRecordArn
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListTimelineEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTimelineEvents"
    }
}

public struct ListTimelineEventsInput: Swift.Equatable {
    /// Filters the timeline events based on the provided conditional values. You can filter timeline events using the following keys:
    ///
    /// * eventTime
    ///
    /// * eventType
    ///
    ///
    /// Note the following when deciding how to use Filters:
    ///
    /// * If you don't specify a Filter, the response includes all timeline events.
    ///
    /// * If you specify more than one filter in a single request, the response returns timeline events that match all filters.
    ///
    /// * If you specify a filter with more than one value, the response returns timeline events that match any of the values provided.
    public var filters: [SSMIncidentsClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// Sort by the specified key value pair.
    public var sortBy: SSMIncidentsClientTypes.TimelineEventSort?
    /// Sorts the order of timeline events by the value specified in the sortBy field.
    public var sortOrder: SSMIncidentsClientTypes.SortOrder?

    public init (
        filters: [SSMIncidentsClientTypes.Filter]? = nil,
        incidentRecordArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: SSMIncidentsClientTypes.TimelineEventSort? = nil,
        sortOrder: SSMIncidentsClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListTimelineEventsInputBody: Swift.Equatable {
    let incidentRecordArn: Swift.String?
    let filters: [SSMIncidentsClientTypes.Filter]?
    let sortBy: SSMIncidentsClientTypes.TimelineEventSort?
    let sortOrder: SSMIncidentsClientTypes.SortOrder?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTimelineEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case incidentRecordArn
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[SSMIncidentsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SSMIncidentsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.TimelineEventSort.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTimelineEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTimelineEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTimelineEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTimelineEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTimelineEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSummaries = output.eventSummaries
            self.nextToken = output.nextToken
        } else {
            self.eventSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTimelineEventsOutputResponse: Swift.Equatable {
    /// Details about each event that occurred during the incident.
    /// This member is required.
    public var eventSummaries: [SSMIncidentsClientTypes.EventSummary]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        eventSummaries: [SSMIncidentsClientTypes.EventSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSummaries = eventSummaries
        self.nextToken = nextToken
    }
}

struct ListTimelineEventsOutputResponseBody: Swift.Equatable {
    let eventSummaries: [SSMIncidentsClientTypes.EventSummary]?
    let nextToken: Swift.String?
}

extension ListTimelineEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSummariesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.EventSummary?].self, forKey: .eventSummaries)
        var eventSummariesDecoded0:[SSMIncidentsClientTypes.EventSummary]? = nil
        if let eventSummariesContainer = eventSummariesContainer {
            eventSummariesDecoded0 = [SSMIncidentsClientTypes.EventSummary]()
            for structure0 in eventSummariesContainer {
                if let structure0 = structure0 {
                    eventSummariesDecoded0?.append(structure0)
                }
            }
        }
        eventSummaries = eventSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SSMIncidentsClientTypes.NotificationTargetItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case snstopicarn = "snsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .snstopicarn(snstopicarn):
                try container.encode(snstopicarn, forKey: .snstopicarn)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let snstopicarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .snstopicarn)
        if let snstopicarn = snstopicarnDecoded {
            self = .snstopicarn(snstopicarn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// The SNS targets that are notified when updates are made to an incident.
    public enum NotificationTargetItem: Swift.Equatable, Swift.Hashable {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        case snstopicarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.PagerDutyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case pagerDutyIncidentConfiguration
        case secretId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pagerDutyIncidentConfiguration = self.pagerDutyIncidentConfiguration {
            try encodeContainer.encode(pagerDutyIncidentConfiguration, forKey: .pagerDutyIncidentConfiguration)
        }
        if let secretId = self.secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
        let pagerDutyIncidentConfigurationDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.PagerDutyIncidentConfiguration.self, forKey: .pagerDutyIncidentConfiguration)
        pagerDutyIncidentConfiguration = pagerDutyIncidentConfigurationDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details about the PagerDuty configuration for a response plan.
    public struct PagerDutyConfiguration: Swift.Equatable {
        /// The name of the PagerDuty configuration.
        /// This member is required.
        public var name: Swift.String?
        /// Details about the PagerDuty service associated with the configuration.
        /// This member is required.
        public var pagerDutyIncidentConfiguration: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration?
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        /// This member is required.
        public var secretId: Swift.String?

        public init (
            name: Swift.String? = nil,
            pagerDutyIncidentConfiguration: SSMIncidentsClientTypes.PagerDutyIncidentConfiguration? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.name = name
            self.pagerDutyIncidentConfiguration = pagerDutyIncidentConfiguration
            self.secretId = secretId
        }
    }

}

extension SSMIncidentsClientTypes.PagerDutyIncidentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details about the PagerDuty service where the response plan creates an incident.
    public struct PagerDutyIncidentConfiguration: Swift.Equatable {
        /// The ID of the PagerDuty service that the response plan associates with an incident when it launches.
        /// This member is required.
        public var serviceId: Swift.String?

        public init (
            serviceId: Swift.String? = nil
        )
        {
            self.serviceId = serviceId
        }
    }

}

extension SSMIncidentsClientTypes.PagerDutyIncidentDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoResolve
        case id
        case secretId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoResolve = self.autoResolve {
            try encodeContainer.encode(autoResolve, forKey: .autoResolve)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let secretId = self.secretId {
            try encodeContainer.encode(secretId, forKey: .secretId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let autoResolveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoResolve)
        autoResolve = autoResolveDecoded
        let secretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretId)
        secretId = secretIdDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details about the PagerDuty incident associated with an incident created by an Incident Manager response plan.
    public struct PagerDutyIncidentDetail: Swift.Equatable {
        /// Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.
        public var autoResolve: Swift.Bool?
        /// The ID of the incident associated with the PagerDuty service for the response plan.
        /// This member is required.
        public var id: Swift.String?
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        public var secretId: Swift.String?

        public init (
            autoResolve: Swift.Bool? = nil,
            id: Swift.String? = nil,
            secretId: Swift.String? = nil
        )
        {
            self.autoResolve = autoResolve
            self.id = id
            self.secretId = secretId
        }
    }

}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/putResourcePolicy"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// Details of the resource policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the response plan to add the resource policy to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyId = output.policyId
        } else {
            self.policyId = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {
    /// The ID of the resource policy.
    /// This member is required.
    public var policyId: Swift.String?

    public init (
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct PutResourcePolicyOutputResponseBody: Swift.Equatable {
    let policyId: Swift.String?
}

extension PutResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension SSMIncidentsClientTypes.RegionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sseKmsKeyId
        case status
        case statusMessage
        case statusUpdateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sseKmsKeyId = self.sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let statusUpdateDateTime = self.statusUpdateDateTime {
            try encodeContainer.encodeTimestamp(statusUpdateDateTime, format: .epochSeconds, forKey: .statusUpdateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.RegionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let statusUpdateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .statusUpdateDateTime)
        statusUpdateDateTime = statusUpdateDateTimeDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Information about a Amazon Web Services Region in your replication set.
    public struct RegionInfo: Swift.Equatable {
        /// The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.
        public var sseKmsKeyId: Swift.String?
        /// The status of the Amazon Web Services Region in the replication set.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.RegionStatus?
        /// Information displayed about the status of the Amazon Web Services Region.
        public var statusMessage: Swift.String?
        /// The most recent date and time that Incident Manager updated the Amazon Web Services Region's status.
        /// This member is required.
        public var statusUpdateDateTime: ClientRuntime.Date?

        public init (
            sseKmsKeyId: Swift.String? = nil,
            status: SSMIncidentsClientTypes.RegionStatus? = nil,
            statusMessage: Swift.String? = nil,
            statusUpdateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.sseKmsKeyId = sseKmsKeyId
            self.status = status
            self.statusMessage = statusMessage
            self.statusUpdateDateTime = statusUpdateDateTime
        }
    }

}

extension SSMIncidentsClientTypes.RegionMapInputValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sseKmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sseKmsKeyId = self.sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// The mapping between a Amazon Web Services Region and the key that's used to encrypt the data.
    public struct RegionMapInputValue: Swift.Equatable {
        /// The KMS key used to encrypt the data in your replication set.
        public var sseKmsKeyId: Swift.String?

        public init (
            sseKmsKeyId: Swift.String? = nil
        )
        {
            self.sseKmsKeyId = sseKmsKeyId
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum RegionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// All operations have completed successfully and the region is ready to use
        case active
        /// The region is in the process of being created.
        case creating
        /// The region is in the process of being deleted.
        case deleting
        /// The region is not healthy and we cannot automatically fix it.
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegionStatus(rawValue: rawValue) ?? RegionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.RelatedItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedId
        case identifier
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedId = self.generatedId {
            try encodeContainer.encode(generatedId, forKey: .generatedId)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ItemIdentifier.self, forKey: .identifier)
        identifier = identifierDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let generatedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedId)
        generatedId = generatedIdDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Resources that responders use to triage and mitigate the incident.
    public struct RelatedItem: Swift.Equatable {
        /// A unique ID for a RelatedItem. Don't specify this parameter when you add a RelatedItem by using the [UpdateRelatedItems] API action.
        public var generatedId: Swift.String?
        /// Details about the related item.
        /// This member is required.
        public var identifier: SSMIncidentsClientTypes.ItemIdentifier?
        /// The title of the related item.
        public var title: Swift.String?

        public init (
            generatedId: Swift.String? = nil,
            identifier: SSMIncidentsClientTypes.ItemIdentifier? = nil,
            title: Swift.String? = nil
        )
        {
            self.generatedId = generatedId
            self.identifier = identifier
            self.title = title
        }
    }

}

extension SSMIncidentsClientTypes.RelatedItemsUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemtoadd = "itemToAdd"
        case itemtoremove = "itemToRemove"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .itemtoadd(itemtoadd):
                try container.encode(itemtoadd, forKey: .itemtoadd)
            case let .itemtoremove(itemtoremove):
                try container.encode(itemtoremove, forKey: .itemtoremove)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let itemtoaddDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.RelatedItem.self, forKey: .itemtoadd)
        if let itemtoadd = itemtoaddDecoded {
            self = .itemtoadd(itemtoadd)
            return
        }
        let itemtoremoveDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.ItemIdentifier.self, forKey: .itemtoremove)
        if let itemtoremove = itemtoremoveDecoded {
            self = .itemtoremove(itemtoremove)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// Details about the related item you're adding.
    public enum RelatedItemsUpdate: Swift.Equatable {
        /// Details about the related item you're adding.
        case itemtoadd(SSMIncidentsClientTypes.RelatedItem)
        /// Details about the related item you're deleting.
        case itemtoremove(SSMIncidentsClientTypes.ItemIdentifier)
        case sdkUnknown(Swift.String)
    }

}

extension SSMIncidentsClientTypes.ReplicationSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case createdTime
        case deletionProtected
        case lastModifiedBy
        case lastModifiedTime
        case regionMap
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let deletionProtected = self.deletionProtected {
            try encodeContainer.encode(deletionProtected, forKey: .deletionProtected)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let regionMap = regionMap {
            var regionMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .regionMap)
            for (dictKey0, regionInfoMap0) in regionMap {
                try regionMapContainer.encode(regionInfoMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let regionMapContainer = try containerValues.decodeIfPresent([Swift.String: SSMIncidentsClientTypes.RegionInfo?].self, forKey: .regionMap)
        var regionMapDecoded0: [Swift.String:SSMIncidentsClientTypes.RegionInfo]? = nil
        if let regionMapContainer = regionMapContainer {
            regionMapDecoded0 = [Swift.String:SSMIncidentsClientTypes.RegionInfo]()
            for (key0, regioninfo0) in regionMapContainer {
                if let regioninfo0 = regioninfo0 {
                    regionMapDecoded0?[key0] = regioninfo0
                }
            }
        }
        regionMap = regionMapDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ReplicationSetStatus.self, forKey: .status)
        status = statusDecoded
        let deletionProtectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtected)
        deletionProtected = deletionProtectedDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// The set of Amazon Web Services Region that your Incident Manager data will be replicated to and the KMS key used to encrypt the data.
    public struct ReplicationSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the replication set.
        public var arn: Swift.String?
        /// Details about who created the replication set.
        /// This member is required.
        public var createdBy: Swift.String?
        /// When the replication set was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set.
        /// This member is required.
        public var deletionProtected: Swift.Bool?
        /// Who last modified the replication set.
        /// This member is required.
        public var lastModifiedBy: Swift.String?
        /// When the replication set was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.
        /// This member is required.
        public var regionMap: [Swift.String:SSMIncidentsClientTypes.RegionInfo]?
        /// The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.
        /// This member is required.
        public var status: SSMIncidentsClientTypes.ReplicationSetStatus?

        public init (
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            deletionProtected: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            regionMap: [Swift.String:SSMIncidentsClientTypes.RegionInfo]? = nil,
            status: SSMIncidentsClientTypes.ReplicationSetStatus? = nil
        )
        {
            self.arn = arn
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.deletionProtected = deletionProtected
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.regionMap = regionMap
            self.status = status
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum ReplicationSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// All operations have completed successfully and the replication set is ready to use
        case active
        /// Replication set is in the process of being created.
        case creating
        /// Replication set is in the process of being deleted.
        case deleting
        /// Replication set is not healthy and we cannot fix it.
        case failed
        /// Replication set is in the process of being updated.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationSetStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationSetStatus(rawValue: rawValue) ?? ReplicationSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource which doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The identifier for the requested resource
    public var resourceIdentifier: Swift.String?
    /// The resource type
    public var resourceType: SSMIncidentsClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceIdentifier: Swift.String?
    let resourceType: SSMIncidentsClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceIdentifier
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SSMIncidentsClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyId
        case ramResourceShareRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let ramResourceShareRegion = self.ramResourceShareRegion {
            try encodeContainer.encode(ramResourceShareRegion, forKey: .ramResourceShareRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let ramResourceShareRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramResourceShareRegion)
        ramResourceShareRegion = ramResourceShareRegionDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// The resource policy that allows Incident Manager to perform actions on resources on your behalf.
    public struct ResourcePolicy: Swift.Equatable {
        /// The JSON blob that describes the policy.
        /// This member is required.
        public var policyDocument: Swift.String?
        /// The ID of the resource policy.
        /// This member is required.
        public var policyId: Swift.String?
        /// The Amazon Web Services Region that policy allows resources to be used in.
        /// This member is required.
        public var ramResourceShareRegion: Swift.String?

        public init (
            policyDocument: Swift.String? = nil,
            policyId: Swift.String? = nil,
            ramResourceShareRegion: Swift.String? = nil
        )
        {
            self.policyDocument = policyDocument
            self.policyId = policyId
            self.ramResourceShareRegion = ramResourceShareRegion
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case incidentRecord
        case replicationSet
        case resourcePolicy
        case responsePlan
        case timelineEvent
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .incidentRecord,
                .replicationSet,
                .resourcePolicy,
                .responsePlan,
                .timelineEvent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .incidentRecord: return "INCIDENT_RECORD"
            case .replicationSet: return "REPLICATION_SET"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case .responsePlan: return "RESPONSE_PLAN"
            case .timelineEvent: return "TIMELINE_EVENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.ResponsePlanSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details of the response plan that are used when creating an incident.
    public struct ResponsePlanSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the response plan.
        /// This member is required.
        public var arn: Swift.String?
        /// The human readable name of the response plan. This can include spaces.
        public var displayName: Swift.String?
        /// The name of the response plan. This can't include spaces.
        /// This member is required.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.displayName = displayName
            self.name = name
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum ServiceCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssmIncidents
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceCode] {
            return [
                .ssmIncidents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssmIncidents: return "ssm-incidents"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceCode(rawValue: rawValue) ?? ServiceCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Originating quota code
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The identifier for the requested resource
    public var resourceIdentifier: Swift.String?
    /// The resource type
    public var resourceType: SSMIncidentsClientTypes.ResourceType?
    /// Originating service code
    /// This member is required.
    public var serviceCode: SSMIncidentsClientTypes.ServiceCode?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: SSMIncidentsClientTypes.ResourceType? = nil,
        serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceIdentifier: Swift.String?
    let resourceType: SSMIncidentsClientTypes.ResourceType?
    let serviceCode: SSMIncidentsClientTypes.ServiceCode?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceIdentifier
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension SSMIncidentsClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.SsmAutomation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentName
        case documentVersion
        case dynamicParameters
        case parameters
        case roleArn
        case targetAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = self.documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let dynamicParameters = dynamicParameters {
            var dynamicParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dynamicParameters)
            for (dictKey0, dynamicSsmParameters0) in dynamicParameters {
                try dynamicParametersContainer.encode(dynamicSsmParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmParameters0) in parameters {
                var ssmParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in ssmParameters0 {
                    try ssmParameters0Container.encode(string1)
                }
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetAccount = self.targetAccount {
            try encodeContainer.encode(targetAccount.rawValue, forKey: .targetAccount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetAccountDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.SsmTargetAccount.self, forKey: .targetAccount)
        targetAccount = targetAccountDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, ssmparametervalues0) in parametersContainer {
                var ssmparametervalues0Decoded0: [Swift.String]? = nil
                if let ssmparametervalues0 = ssmparametervalues0 {
                    ssmparametervalues0Decoded0 = [Swift.String]()
                    for string1 in ssmparametervalues0 {
                        if let string1 = string1 {
                            ssmparametervalues0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparametervalues0Decoded0
            }
        }
        parameters = parametersDecoded0
        let dynamicParametersContainer = try containerValues.decodeIfPresent([Swift.String: SSMIncidentsClientTypes.DynamicSsmParameterValue?].self, forKey: .dynamicParameters)
        var dynamicParametersDecoded0: [Swift.String:SSMIncidentsClientTypes.DynamicSsmParameterValue]? = nil
        if let dynamicParametersContainer = dynamicParametersContainer {
            dynamicParametersDecoded0 = [Swift.String:SSMIncidentsClientTypes.DynamicSsmParameterValue]()
            for (key0, dynamicssmparametervalue0) in dynamicParametersContainer {
                if let dynamicssmparametervalue0 = dynamicssmparametervalue0 {
                    dynamicParametersDecoded0?[key0] = dynamicssmparametervalue0
                }
            }
        }
        dynamicParameters = dynamicParametersDecoded0
    }
}

extension SSMIncidentsClientTypes {
    /// Details about the Systems Manager automation document that will be used as a runbook during an incident.
    public struct SsmAutomation: Swift.Equatable {
        /// The automation document's name.
        /// This member is required.
        public var documentName: Swift.String?
        /// The automation document's version to use when running.
        public var documentVersion: Swift.String?
        /// The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
        public var dynamicParameters: [Swift.String:SSMIncidentsClientTypes.DynamicSsmParameterValue]?
        /// The key-value pair parameters to use when running the automation document.
        public var parameters: [Swift.String:[Swift.String]]?
        /// The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The account that the automation document will be run in. This can be in either the management account or an application account.
        public var targetAccount: SSMIncidentsClientTypes.SsmTargetAccount?

        public init (
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            dynamicParameters: [Swift.String:SSMIncidentsClientTypes.DynamicSsmParameterValue]? = nil,
            parameters: [Swift.String:[Swift.String]]? = nil,
            roleArn: Swift.String? = nil,
            targetAccount: SSMIncidentsClientTypes.SsmTargetAccount? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.dynamicParameters = dynamicParameters
            self.parameters = parameters
            self.roleArn = roleArn
            self.targetAccount = targetAccount
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum SsmTargetAccount: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case impactedAccount
        case responsePlanOwnerAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmTargetAccount] {
            return [
                .impactedAccount,
                .responsePlanOwnerAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .impactedAccount: return "IMPACTED_ACCOUNT"
            case .responsePlanOwnerAccount: return "RESPONSE_PLAN_OWNER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SsmTargetAccount(rawValue: rawValue) ?? SsmTargetAccount.sdkUnknown(rawValue)
        }
    }
}

extension StartIncidentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case impact
        case relatedItems
        case responsePlanArn
        case title
        case triggerDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let relatedItems = relatedItems {
            var relatedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedItems)
            for relateditem0 in relatedItems {
                try relatedItemsContainer.encode(relateditem0)
            }
        }
        if let responsePlanArn = self.responsePlanArn {
            try encodeContainer.encode(responsePlanArn, forKey: .responsePlanArn)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let triggerDetails = self.triggerDetails {
            try encodeContainer.encode(triggerDetails, forKey: .triggerDetails)
        }
    }
}

extension StartIncidentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startIncident"
    }
}

public struct StartIncidentInput: Swift.Equatable {
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan. Possible impacts:
    ///
    /// * 1 - Critical impact, this typically relates to full application failure that impacts many to all customers.
    ///
    /// * 2 - High impact, partial application failure with impact to many customers.
    ///
    /// * 3 - Medium impact, the application is providing reduced service to customers.
    ///
    /// * 4 - Low impact, customer might aren't impacted by the problem yet.
    ///
    /// * 5 - No impact, customers aren't currently impacted but urgent action is needed to avoid impact.
    public var impact: Swift.Int?
    /// Add related items to the incident for other responders to use. Related items are AWS resources, external links, or files uploaded to an Amazon S3 bucket.
    public var relatedItems: [SSMIncidentsClientTypes.RelatedItem]?
    /// The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat channels, Amazon SNS topics, runbooks, title, and impact of the incident.
    /// This member is required.
    public var responsePlanArn: Swift.String?
    /// Provide a title for the incident. Providing a title overwrites the title provided by the response plan.
    public var title: Swift.String?
    /// Details of what created the incident record in Incident Manager.
    public var triggerDetails: SSMIncidentsClientTypes.TriggerDetails?

    public init (
        clientToken: Swift.String? = nil,
        impact: Swift.Int? = nil,
        relatedItems: [SSMIncidentsClientTypes.RelatedItem]? = nil,
        responsePlanArn: Swift.String? = nil,
        title: Swift.String? = nil,
        triggerDetails: SSMIncidentsClientTypes.TriggerDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.impact = impact
        self.relatedItems = relatedItems
        self.responsePlanArn = responsePlanArn
        self.title = title
        self.triggerDetails = triggerDetails
    }
}

struct StartIncidentInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let responsePlanArn: Swift.String?
    let title: Swift.String?
    let impact: Swift.Int?
    let triggerDetails: SSMIncidentsClientTypes.TriggerDetails?
    let relatedItems: [SSMIncidentsClientTypes.RelatedItem]?
}

extension StartIncidentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case impact
        case relatedItems
        case responsePlanArn
        case title
        case triggerDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let responsePlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responsePlanArn)
        responsePlanArn = responsePlanArnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .impact)
        impact = impactDecoded
        let triggerDetailsDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.TriggerDetails.self, forKey: .triggerDetails)
        triggerDetails = triggerDetailsDecoded
        let relatedItemsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.RelatedItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[SSMIncidentsClientTypes.RelatedItem]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [SSMIncidentsClientTypes.RelatedItem]()
            for structure0 in relatedItemsContainer {
                if let structure0 = structure0 {
                    relatedItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedItems = relatedItemsDecoded0
    }
}

extension StartIncidentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartIncidentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartIncidentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartIncidentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartIncidentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.incidentRecordArn = output.incidentRecordArn
        } else {
            self.incidentRecordArn = nil
        }
    }
}

public struct StartIncidentOutputResponse: Swift.Equatable {
    /// The ARN of the newly created incident record.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
    }
}

struct StartIncidentOutputResponseBody: Swift.Equatable {
    let incidentRecordArn: Swift.String?
}

extension StartIncidentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentRecordArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan you're adding the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add to the response plan.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Originating quota code
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Originating service code
    /// This member is required.
    public var serviceCode: SSMIncidentsClientTypes.ServiceCode?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: SSMIncidentsClientTypes.ServiceCode? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: SSMIncidentsClientTypes.ServiceCode?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension SSMIncidentsClientTypes.TimelineEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventData
        case eventId
        case eventReferences
        case eventTime
        case eventType
        case eventUpdatedTime
        case incidentRecordArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReferences = eventReferences {
            var eventReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventReferences)
            for eventreference0 in eventReferences {
                try eventReferencesContainer.encode(eventreference0)
            }
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let eventUpdatedTime = self.eventUpdatedTime {
            try encodeContainer.encodeTimestamp(eventUpdatedTime, format: .epochSeconds, forKey: .eventUpdatedTime)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventUpdatedTime)
        eventUpdatedTime = eventUpdatedTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventData)
        eventData = eventDataDecoded
        let eventReferencesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.EventReference?].self, forKey: .eventReferences)
        var eventReferencesDecoded0:[SSMIncidentsClientTypes.EventReference]? = nil
        if let eventReferencesContainer = eventReferencesContainer {
            eventReferencesDecoded0 = [SSMIncidentsClientTypes.EventReference]()
            for union0 in eventReferencesContainer {
                if let union0 = union0 {
                    eventReferencesDecoded0?.append(union0)
                }
            }
        }
        eventReferences = eventReferencesDecoded0
    }
}

extension SSMIncidentsClientTypes {
    /// A significant event that happened during the incident.
    public struct TimelineEvent: Swift.Equatable {
        /// A short description of the event.
        /// This member is required.
        public var eventData: Swift.String?
        /// The ID of the timeline event.
        /// This member is required.
        public var eventId: Swift.String?
        /// A list of references in a TimelineEvent.
        public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
        /// The time that the event occurred.
        /// This member is required.
        public var eventTime: ClientRuntime.Date?
        /// The type of event that occurred. Currently Incident Manager supports only the Custom Event type.
        /// This member is required.
        public var eventType: Swift.String?
        /// The time that the timeline event was last updated.
        /// This member is required.
        public var eventUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the incident that the event occurred during.
        /// This member is required.
        public var incidentRecordArn: Swift.String?

        public init (
            eventData: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
            eventTime: ClientRuntime.Date? = nil,
            eventType: Swift.String? = nil,
            eventUpdatedTime: ClientRuntime.Date? = nil,
            incidentRecordArn: Swift.String? = nil
        )
        {
            self.eventData = eventData
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }
    }

}

extension SSMIncidentsClientTypes {
    public enum TimelineEventSort: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventTime
        case sdkUnknown(Swift.String)

        public static var allCases: [TimelineEventSort] {
            return [
                .eventTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventTime: return "EVENT_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimelineEventSort(rawValue: rawValue) ?? TimelineEventSort.sdkUnknown(rawValue)
        }
    }
}

extension SSMIncidentsClientTypes.TriggerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rawData
        case source
        case timestamp
        case triggerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rawData = self.rawData {
            try encodeContainer.encode(rawData, forKey: .rawData)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let triggerArn = self.triggerArn {
            try encodeContainer.encode(triggerArn, forKey: .triggerArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let triggerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerArn)
        triggerArn = triggerArnDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let rawDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawData)
        rawData = rawDataDecoded
    }
}

extension SSMIncidentsClientTypes {
    /// Details about what caused the incident to be created in Incident Manager.
    public struct TriggerDetails: Swift.Equatable {
        /// Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.
        public var rawData: Swift.String?
        /// Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "aws." Customer-generated events can have any value here, as long as it doesn't begin with "aws." We recommend the use of Java package-name style reverse domain-name strings.
        /// This member is required.
        public var source: Swift.String?
        /// The time that the incident was detected.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the source that detected the incident.
        public var triggerArn: Swift.String?

        public init (
            rawData: Swift.String? = nil,
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            triggerArn: Swift.String? = nil
        )
        {
            self.rawData = rawData
            self.source = source
            self.timestamp = timestamp
            self.triggerArn = triggerArn
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the response plan you're removing a tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the tag to remove from the response plan.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDeletionProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientToken
        case deletionProtected
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtected = self.deletionProtected {
            try encodeContainer.encode(deletionProtected, forKey: .deletionProtected)
        }
    }
}

extension UpdateDeletionProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDeletionProtection"
    }
}

public struct UpdateDeletionProtectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication set to update.
    /// This member is required.
    public var arn: Swift.String?
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// Specifies if deletion protection is turned on or off in your account.
    /// This member is required.
    public var deletionProtected: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        deletionProtected: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.deletionProtected = deletionProtected
    }
}

struct UpdateDeletionProtectionInputBody: Swift.Equatable {
    let arn: Swift.String?
    let deletionProtected: Swift.Bool?
    let clientToken: Swift.String?
}

extension UpdateDeletionProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientToken
        case deletionProtected
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let deletionProtectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtected)
        deletionProtected = deletionProtectedDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDeletionProtectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeletionProtectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDeletionProtectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeletionProtectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeletionProtectionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateIncidentRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case chatChannel
        case clientToken
        case impact
        case notificationTargets
        case status
        case summary
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let chatChannel = self.chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetitem0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetitem0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension UpdateIncidentRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateIncidentRecord"
    }
}

public struct UpdateIncidentRecordInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident record you are updating.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel where responders can collaborate.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// Defines the impact of the incident to customers and applications. Providing an impact overwrites the impact provided by the response plan. Possible impacts:
    ///
    /// * 1 - Critical impact, full application failure that impacts many to all customers.
    ///
    /// * 2 - High impact, partial application failure with impact to many customers.
    ///
    /// * 3 - Medium impact, the application is providing reduced service to customers.
    ///
    /// * 4 - Low impact, customer aren't impacted by the problem yet.
    ///
    /// * 5 - No impact, customers aren't currently impacted but urgent action is needed to avoid impact.
    public var impact: Swift.Int?
    /// The Amazon SNS targets that are notified when updates are made to an incident. Using multiple SNS topics creates redundancy in the event that a Region is down during the incident.
    public var notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
    /// The status of the incident. An incident can be Open or Resolved.
    public var status: SSMIncidentsClientTypes.IncidentRecordStatus?
    /// A longer description of what occurred during the incident.
    public var summary: Swift.String?
    /// A brief description of the incident.
    public var title: Swift.String?

    public init (
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        impact: Swift.Int? = nil,
        notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
        status: SSMIncidentsClientTypes.IncidentRecordStatus? = nil,
        summary: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.impact = impact
        self.notificationTargets = notificationTargets
        self.status = status
        self.summary = summary
        self.title = title
    }
}

struct UpdateIncidentRecordInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let arn: Swift.String?
    let title: Swift.String?
    let summary: Swift.String?
    let impact: Swift.Int?
    let status: SSMIncidentsClientTypes.IncidentRecordStatus?
    let chatChannel: SSMIncidentsClientTypes.ChatChannel?
    let notificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
}

extension UpdateIncidentRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case chatChannel
        case clientToken
        case impact
        case notificationTargets
        case status
        case summary
        case title
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .impact)
        impact = impactDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.NotificationTargetItem?].self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:[SSMIncidentsClientTypes.NotificationTargetItem]? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = [SSMIncidentsClientTypes.NotificationTargetItem]()
            for union0 in notificationTargetsContainer {
                if let union0 = union0 {
                    notificationTargetsDecoded0?.append(union0)
                }
            }
        }
        notificationTargets = notificationTargetsDecoded0
    }
}

extension UpdateIncidentRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIncidentRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIncidentRecordOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIncidentRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIncidentRecordOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRelatedItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case incidentRecordArn
        case relatedItemsUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let relatedItemsUpdate = self.relatedItemsUpdate {
            try encodeContainer.encode(relatedItemsUpdate, forKey: .relatedItemsUpdate)
        }
    }
}

extension UpdateRelatedItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateRelatedItems"
    }
}

public struct UpdateRelatedItemsInput: Swift.Equatable {
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident record containing the related items you are updating.
    /// This member is required.
    public var incidentRecordArn: Swift.String?
    /// Details about the item you are adding or deleting.
    /// This member is required.
    public var relatedItemsUpdate: SSMIncidentsClientTypes.RelatedItemsUpdate?

    public init (
        clientToken: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil,
        relatedItemsUpdate: SSMIncidentsClientTypes.RelatedItemsUpdate? = nil
    )
    {
        self.clientToken = clientToken
        self.incidentRecordArn = incidentRecordArn
        self.relatedItemsUpdate = relatedItemsUpdate
    }
}

struct UpdateRelatedItemsInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let incidentRecordArn: Swift.String?
    let relatedItemsUpdate: SSMIncidentsClientTypes.RelatedItemsUpdate?
}

extension UpdateRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case incidentRecordArn
        case relatedItemsUpdate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let relatedItemsUpdateDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.RelatedItemsUpdate.self, forKey: .relatedItemsUpdate)
        relatedItemsUpdate = relatedItemsUpdateDecoded
    }
}

extension UpdateRelatedItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRelatedItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRelatedItemsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRelatedItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRelatedItemsOutputResponse: Swift.Equatable {

    public init () { }
}

extension SSMIncidentsClientTypes.UpdateReplicationSetAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addregionaction = "addRegionAction"
        case deleteregionaction = "deleteRegionAction"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .addregionaction(addregionaction):
                try container.encode(addregionaction, forKey: .addregionaction)
            case let .deleteregionaction(deleteregionaction):
                try container.encode(deleteregionaction, forKey: .deleteregionaction)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let addregionactionDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.AddRegionAction.self, forKey: .addregionaction)
        if let addregionaction = addregionactionDecoded {
            self = .addregionaction(addregionaction)
            return
        }
        let deleteregionactionDecoded = try values.decodeIfPresent(SSMIncidentsClientTypes.DeleteRegionAction.self, forKey: .deleteregionaction)
        if let deleteregionaction = deleteregionactionDecoded {
            self = .deleteregionaction(deleteregionaction)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSMIncidentsClientTypes {
    /// Details used when updating the replication set.
    public enum UpdateReplicationSetAction: Swift.Equatable {
        /// Details about the Amazon Web Services Region that you're adding to the replication set.
        case addregionaction(SSMIncidentsClientTypes.AddRegionAction)
        /// Details about the Amazon Web Services Region that you're deleting to the replication set.
        case deleteregionaction(SSMIncidentsClientTypes.DeleteRegionAction)
        case sdkUnknown(Swift.String)
    }

}

extension UpdateReplicationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for updatereplicationsetaction0 in actions {
                try actionsContainer.encode(updatereplicationsetaction0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateReplicationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateReplicationSet"
    }
}

public struct UpdateReplicationSetInput: Swift.Equatable {
    /// An action to add or delete a Region.
    /// This member is required.
    public var actions: [SSMIncidentsClientTypes.UpdateReplicationSetAction]?
    /// The Amazon Resource Name (ARN) of the replication set you're updating.
    /// This member is required.
    public var arn: Swift.String?
    /// A token that ensures that the operation is called only once with the specified details.
    public var clientToken: Swift.String?

    public init (
        actions: [SSMIncidentsClientTypes.UpdateReplicationSetAction]? = nil,
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.clientToken = clientToken
    }
}

struct UpdateReplicationSetInputBody: Swift.Equatable {
    let arn: Swift.String?
    let actions: [SSMIncidentsClientTypes.UpdateReplicationSetAction]?
    let clientToken: Swift.String?
}

extension UpdateReplicationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let actionsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.UpdateReplicationSetAction?].self, forKey: .actions)
        var actionsDecoded0:[SSMIncidentsClientTypes.UpdateReplicationSetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [SSMIncidentsClientTypes.UpdateReplicationSetAction]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateReplicationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReplicationSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateReplicationSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateResponsePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplateDedupeString
        case incidentTemplateImpact
        case incidentTemplateNotificationTargets
        case incidentTemplateSummary
        case incidentTemplateTags
        case incidentTemplateTitle
        case integrations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let chatChannel = self.chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let engagements = engagements {
            var engagementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engagements)
            for ssmcontactsarn0 in engagements {
                try engagementsContainer.encode(ssmcontactsarn0)
            }
        }
        if let incidentTemplateDedupeString = self.incidentTemplateDedupeString {
            try encodeContainer.encode(incidentTemplateDedupeString, forKey: .incidentTemplateDedupeString)
        }
        if let incidentTemplateImpact = self.incidentTemplateImpact {
            try encodeContainer.encode(incidentTemplateImpact, forKey: .incidentTemplateImpact)
        }
        if let incidentTemplateNotificationTargets = incidentTemplateNotificationTargets {
            var incidentTemplateNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .incidentTemplateNotificationTargets)
            for notificationtargetitem0 in incidentTemplateNotificationTargets {
                try incidentTemplateNotificationTargetsContainer.encode(notificationtargetitem0)
            }
        }
        if let incidentTemplateSummary = self.incidentTemplateSummary {
            try encodeContainer.encode(incidentTemplateSummary, forKey: .incidentTemplateSummary)
        }
        if let incidentTemplateTags = incidentTemplateTags {
            var incidentTemplateTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .incidentTemplateTags)
            for (dictKey0, tagMapUpdate0) in incidentTemplateTags {
                try incidentTemplateTagsContainer.encode(tagMapUpdate0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let incidentTemplateTitle = self.incidentTemplateTitle {
            try encodeContainer.encode(incidentTemplateTitle, forKey: .incidentTemplateTitle)
        }
        if let integrations = integrations {
            var integrationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integrations)
            for integration0 in integrations {
                try integrationsContainer.encode(integration0)
            }
        }
    }
}

extension UpdateResponsePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateResponsePlan"
    }
}

public struct UpdateResponsePlanInput: Swift.Equatable {
    /// The actions that this response plan takes at the beginning of an incident.
    public var actions: [SSMIncidentsClientTypes.Action]?
    /// The Amazon Resource Name (ARN) of the response plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The Chatbot chat channel used for collaboration during an incident. Use the empty structure to remove the chat channel from the response plan.
    public var chatChannel: SSMIncidentsClientTypes.ChatChannel?
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The long format name of the response plan. The display name can't contain spaces.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    public var engagements: [Swift.String]?
    /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
    public var incidentTemplateDedupeString: Swift.String?
    /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan. Possible impacts:
    ///
    /// * 5 - Severe impact
    ///
    /// * 4 - High impact
    ///
    /// * 3 - Medium impact
    ///
    /// * 2 - Low impact
    ///
    /// * 1 - No impact
    public var incidentTemplateImpact: Swift.Int?
    /// The Amazon SNS targets that are notified when updates are made to an incident.
    public var incidentTemplateNotificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
    /// A brief summary of the incident. This typically contains what has happened, what's currently happening, and next steps.
    public var incidentTemplateSummary: Swift.String?
    /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident. To call this action, you must also have permission to call the TagResource API action for the incident record resource.
    public var incidentTemplateTags: [Swift.String:Swift.String]?
    /// The short format name of the incident. The title can't contain spaces.
    public var incidentTemplateTitle: Swift.String?
    /// Information about third-party services integrated into the response plan.
    public var integrations: [SSMIncidentsClientTypes.Integration]?

    public init (
        actions: [SSMIncidentsClientTypes.Action]? = nil,
        arn: Swift.String? = nil,
        chatChannel: SSMIncidentsClientTypes.ChatChannel? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        engagements: [Swift.String]? = nil,
        incidentTemplateDedupeString: Swift.String? = nil,
        incidentTemplateImpact: Swift.Int? = nil,
        incidentTemplateNotificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]? = nil,
        incidentTemplateSummary: Swift.String? = nil,
        incidentTemplateTags: [Swift.String:Swift.String]? = nil,
        incidentTemplateTitle: Swift.String? = nil,
        integrations: [SSMIncidentsClientTypes.Integration]? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplateDedupeString = incidentTemplateDedupeString
        self.incidentTemplateImpact = incidentTemplateImpact
        self.incidentTemplateNotificationTargets = incidentTemplateNotificationTargets
        self.incidentTemplateSummary = incidentTemplateSummary
        self.incidentTemplateTags = incidentTemplateTags
        self.incidentTemplateTitle = incidentTemplateTitle
        self.integrations = integrations
    }
}

struct UpdateResponsePlanInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let arn: Swift.String?
    let displayName: Swift.String?
    let incidentTemplateTitle: Swift.String?
    let incidentTemplateImpact: Swift.Int?
    let incidentTemplateSummary: Swift.String?
    let incidentTemplateDedupeString: Swift.String?
    let incidentTemplateNotificationTargets: [SSMIncidentsClientTypes.NotificationTargetItem]?
    let chatChannel: SSMIncidentsClientTypes.ChatChannel?
    let engagements: [Swift.String]?
    let actions: [SSMIncidentsClientTypes.Action]?
    let incidentTemplateTags: [Swift.String:Swift.String]?
    let integrations: [SSMIncidentsClientTypes.Integration]?
}

extension UpdateResponsePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case arn
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplateDedupeString
        case incidentTemplateImpact
        case incidentTemplateNotificationTargets
        case incidentTemplateSummary
        case incidentTemplateTags
        case incidentTemplateTitle
        case integrations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentTemplateTitle)
        incidentTemplateTitle = incidentTemplateTitleDecoded
        let incidentTemplateImpactDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .incidentTemplateImpact)
        incidentTemplateImpact = incidentTemplateImpactDecoded
        let incidentTemplateSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentTemplateSummary)
        incidentTemplateSummary = incidentTemplateSummaryDecoded
        let incidentTemplateDedupeStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentTemplateDedupeString)
        incidentTemplateDedupeString = incidentTemplateDedupeStringDecoded
        let incidentTemplateNotificationTargetsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.NotificationTargetItem?].self, forKey: .incidentTemplateNotificationTargets)
        var incidentTemplateNotificationTargetsDecoded0:[SSMIncidentsClientTypes.NotificationTargetItem]? = nil
        if let incidentTemplateNotificationTargetsContainer = incidentTemplateNotificationTargetsContainer {
            incidentTemplateNotificationTargetsDecoded0 = [SSMIncidentsClientTypes.NotificationTargetItem]()
            for union0 in incidentTemplateNotificationTargetsContainer {
                if let union0 = union0 {
                    incidentTemplateNotificationTargetsDecoded0?.append(union0)
                }
            }
        }
        incidentTemplateNotificationTargets = incidentTemplateNotificationTargetsDecoded0
        let chatChannelDecoded = try containerValues.decodeIfPresent(SSMIncidentsClientTypes.ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .engagements)
        var engagementsDecoded0:[Swift.String]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [Swift.String]()
            for string0 in engagementsContainer {
                if let string0 = string0 {
                    engagementsDecoded0?.append(string0)
                }
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[SSMIncidentsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [SSMIncidentsClientTypes.Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let incidentTemplateTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .incidentTemplateTags)
        var incidentTemplateTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let incidentTemplateTagsContainer = incidentTemplateTagsContainer {
            incidentTemplateTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in incidentTemplateTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    incidentTemplateTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        incidentTemplateTags = incidentTemplateTagsDecoded0
        let integrationsContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.Integration?].self, forKey: .integrations)
        var integrationsDecoded0:[SSMIncidentsClientTypes.Integration]? = nil
        if let integrationsContainer = integrationsContainer {
            integrationsDecoded0 = [SSMIncidentsClientTypes.Integration]()
            for union0 in integrationsContainer {
                if let union0 = union0 {
                    integrationsDecoded0?.append(union0)
                }
            }
        }
        integrations = integrationsDecoded0
    }
}

extension UpdateResponsePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResponsePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResponsePlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResponsePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResponsePlanOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateTimelineEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case eventData
        case eventId
        case eventReferences
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReferences = eventReferences {
            var eventReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventReferences)
            for eventreference0 in eventReferences {
                try eventReferencesContainer.encode(eventreference0)
            }
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let incidentRecordArn = self.incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

extension UpdateTimelineEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateTimelineEvent"
    }
}

public struct UpdateTimelineEventInput: Swift.Equatable {
    /// A token ensuring that the operation is called only once with the specified details.
    public var clientToken: Swift.String?
    /// A short description of the event.
    public var eventData: Swift.String?
    /// The ID of the event you are updating. You can find this by using ListTimelineEvents.
    /// This member is required.
    public var eventId: Swift.String?
    /// Updates all existing references in a TimelineEvent. A reference can be an Amazon Web Services resource involved in the incident or in some way associated with it. When you specify a reference, you enter the Amazon Resource Name (ARN) of the resource. You can also specify a related item. As an example, you could specify the ARN of an Amazon DynamoDB (DynamoDB) table. The table for this example is the resource. You could also specify a Amazon CloudWatch metric for that table. The metric is the related item. This update action overrides all existing references. If you want to keep existing references, you must specify them in the call. If you don't, this action removes them and enters only new references.
    public var eventReferences: [SSMIncidentsClientTypes.EventReference]?
    /// The time that the event occurred.
    public var eventTime: ClientRuntime.Date?
    /// The type of the event. You can update events of type Custom Event.
    public var eventType: Swift.String?
    /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    /// This member is required.
    public var incidentRecordArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eventData: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventReferences: [SSMIncidentsClientTypes.EventReference]? = nil,
        eventTime: ClientRuntime.Date? = nil,
        eventType: Swift.String? = nil,
        incidentRecordArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventId = eventId
        self.eventReferences = eventReferences
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

struct UpdateTimelineEventInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let incidentRecordArn: Swift.String?
    let eventId: Swift.String?
    let eventTime: ClientRuntime.Date?
    let eventType: Swift.String?
    let eventData: Swift.String?
    let eventReferences: [SSMIncidentsClientTypes.EventReference]?
}

extension UpdateTimelineEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case eventData
        case eventId
        case eventReferences
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventData)
        eventData = eventDataDecoded
        let eventReferencesContainer = try containerValues.decodeIfPresent([SSMIncidentsClientTypes.EventReference?].self, forKey: .eventReferences)
        var eventReferencesDecoded0:[SSMIncidentsClientTypes.EventReference]? = nil
        if let eventReferencesContainer = eventReferencesContainer {
            eventReferencesDecoded0 = [SSMIncidentsClientTypes.EventReference]()
            for union0 in eventReferencesContainer {
                if let union0 = union0 {
                    eventReferencesDecoded0?.append(union0)
                }
            }
        }
        eventReferences = eventReferencesDecoded0
    }
}

extension UpdateTimelineEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTimelineEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTimelineEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTimelineEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTimelineEventOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSMIncidentsClientTypes {
    public enum VariableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case incidentRecordArn
        case involvedResources
        case sdkUnknown(Swift.String)

        public static var allCases: [VariableType] {
            return [
                .incidentRecordArn,
                .involvedResources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .incidentRecordArn: return "INCIDENT_RECORD_ARN"
            case .involvedResources: return "INVOLVED_RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VariableType(rawValue: rawValue) ?? VariableType.sdkUnknown(rawValue)
        }
    }
}
