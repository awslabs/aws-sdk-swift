// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DataPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataPoint(timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>A timestamp, and a single numerical value, which together represent a measurement at a particular point in time.</p>
public struct DataPoint: Equatable {
    /// <p>The time, in epoch format, associated with a particular <code>Value</code>.</p>
    public let timestamp: Date?
    /// <p>The actual value associated with a particular <code>Timestamp</code>.</p>
    public let value: Double?

    public init (
        timestamp: Date? = nil,
        value: Double? = nil
    )
    {
        self.timestamp = timestamp
        self.value = value
    }
}

public struct DescribeDimensionKeysInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDimensionKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDimensionKeysOutputError>
}

extension DescribeDimensionKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDimensionKeysInput(endTime: \(String(describing: endTime)), filter: \(String(describing: filter)), groupBy: \(String(describing: groupBy)), identifier: \(String(describing: identifier)), maxResults: \(String(describing: maxResults)), metric: \(String(describing: metric)), nextToken: \(String(describing: nextToken)), partitionBy: \(String(describing: partitionBy)), periodInSeconds: \(String(describing: periodInSeconds)), serviceType: \(String(describing: serviceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeDimensionKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let partitionBy = partitionBy {
            try encodeContainer.encode(partitionBy, forKey: .partitionBy)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeDimensionKeysInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDimensionKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDimensionKeysOutputError>
}

public struct DescribeDimensionKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDimensionKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDimensionKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDimensionKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDimensionKeysInput>
    public typealias MOutput = OperationOutput<DescribeDimensionKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDimensionKeysOutputError>
}

public struct DescribeDimensionKeysInput: Equatable {
    /// <p>The date and time specifying the end of the requested time series data. The value specified is
    ///       <i>exclusive</i>, which means that data points less than (but not equal to) <code>EndTime</code> are
    ///       returned.</p>
    ///          <p>The value for <code>EndTime</code> must be later than the value for
    ///       <code>StartTime</code>.</p>
    public let endTime: Date?
    /// <p>One or more filters to apply in the request.  Restrictions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any number of filters by the same dimension, as specified in the <code>GroupBy</code> or
    ///           <code>Partition</code> parameters.</p>
    ///             </li>
    ///             <li>
    ///                <p>A single filter for any other dimension in this dimension group.</p>
    ///             </li>
    ///          </ul>
    public let filter: [String:String]?
    /// <p>A specification for how to aggregate the data points from a query result. You must specify a valid dimension group.
    ///       Performance Insights returns all dimensions within this group, unless you provide the names of specific dimensions within this group.
    ///       You can also request that Performance Insights return a limited number of values for a dimension.</p>
    public let groupBy: DimensionGroup?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use an Amazon RDS instance as a data source, you specify its <code>DbiResourceId</code> value. For example,
    ///       specify <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>
    ///          </p>
    public let identifier: String?
    /// <p>The maximum number of items to return in the response.
    ///       If more items exist than the specified <code>MaxRecords</code> value, a pagination
    ///       token is included in the response so that the remaining
    ///       results can be retrieved.
    ///     </p>
    public let maxResults: Int?
    /// <p>The name of a Performance Insights metric to be measured.</p>
    ///          <p>Valid values for <code>Metric</code> are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
    ///           for the database engine.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
    ///           database engine.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
    ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
    ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
    ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
    public let metric: String?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: String?
    /// <p>For each dimension specified in
    ///       <code>GroupBy</code>, specify a secondary dimension to further subdivide the partition keys in the response.</p>
    public let partitionBy: DimensionGroup?
    /// <p>The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as
    ///       one second, or as long as one day (86400 seconds).  Valid values are:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>1</code> (one second)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>60</code> (one minute)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>300</code> (five minutes)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>3600</code> (one hour)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>86400</code> (twenty-four hours)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If you don't specify <code>PeriodInSeconds</code>, then Performance Insights chooses a value for you, with a goal of returning
    ///       roughly 100-200 data points in the response.</p>
    public let periodInSeconds: Int?
    /// <p>The AWS service for which Performance Insights will return metrics. The only valid value for <i>ServiceType</i> is
    ///         <code>RDS</code>.</p>
    public let serviceType: ServiceType?
    /// <p>The date and time specifying the beginning of the requested time series data. You must specify a
    ///         <code>StartTime</code> within the past 7 days. The value specified is <i>inclusive</i>, which means
    ///       that data points equal to or greater than <code>StartTime</code> are returned.</p>
    ///          <p>The value for <code>StartTime</code> must be earlier than the value for
    ///         <code>EndTime</code>.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        filter: [String:String]? = nil,
        groupBy: DimensionGroup? = nil,
        identifier: String? = nil,
        maxResults: Int? = nil,
        metric: String? = nil,
        nextToken: String? = nil,
        partitionBy: DimensionGroup? = nil,
        periodInSeconds: Int? = nil,
        serviceType: ServiceType? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.filter = filter
        self.groupBy = groupBy
        self.identifier = identifier
        self.maxResults = maxResults
        self.metric = metric
        self.nextToken = nextToken
        self.partitionBy = partitionBy
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct DescribeDimensionKeysInputBody: Equatable {
    public let serviceType: ServiceType?
    public let identifier: String?
    public let startTime: Date?
    public let endTime: Date?
    public let metric: String?
    public let periodInSeconds: Int?
    public let groupBy: DimensionGroup?
    public let partitionBy: DimensionGroup?
    public let filter: [String:String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDimensionKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filter = "Filter"
        case groupBy = "GroupBy"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metric = "Metric"
        case nextToken = "NextToken"
        case partitionBy = "PartitionBy"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let metricDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metric)
        metric = metricDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let partitionByDecoded = try containerValues.decodeIfPresent(DimensionGroup.self, forKey: .partitionBy)
        partitionBy = partitionByDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .filter)
        var filterDecoded0: [String:String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDimensionKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDimensionKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDimensionKeysOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDimensionKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDimensionKeysOutputResponse(alignedEndTime: \(String(describing: alignedEndTime)), alignedStartTime: \(String(describing: alignedStartTime)), keys: \(String(describing: keys)), nextToken: \(String(describing: nextToken)), partitionKeys: \(String(describing: partitionKeys)))"}
}

extension DescribeDimensionKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDimensionKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.keys = output.keys
            self.nextToken = output.nextToken
            self.partitionKeys = output.partitionKeys
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.keys = nil
            self.nextToken = nil
            self.partitionKeys = nil
        }
    }
}

public struct DescribeDimensionKeysOutputResponse: Equatable {
    /// <p>The end time for the returned dimension keys, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedEndTime</code> will be greater than
    ///       or equal to the value of the user-specified <code>Endtime</code>.</p>
    public let alignedEndTime: Date?
    /// <p>The start time for the returned dimension keys, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedStartTime</code> will be less than or
    ///       equal to the value of the user-specified <code>StartTime</code>.</p>
    public let alignedStartTime: Date?
    /// <p>The dimension keys that were requested.</p>
    public let keys: [DimensionKeyDescription]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: String?
    /// <p>If <code>PartitionBy</code> was present in the request, <code>PartitionKeys</code> contains the breakdown of dimension keys by the specified partitions.</p>
    public let partitionKeys: [ResponsePartitionKey]?

    public init (
        alignedEndTime: Date? = nil,
        alignedStartTime: Date? = nil,
        keys: [DimensionKeyDescription]? = nil,
        nextToken: String? = nil,
        partitionKeys: [ResponsePartitionKey]? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.keys = keys
        self.nextToken = nextToken
        self.partitionKeys = partitionKeys
    }
}

struct DescribeDimensionKeysOutputResponseBody: Equatable {
    public let alignedStartTime: Date?
    public let alignedEndTime: Date?
    public let partitionKeys: [ResponsePartitionKey]?
    public let keys: [DimensionKeyDescription]?
    public let nextToken: String?
}

extension DescribeDimensionKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case keys = "Keys"
        case nextToken = "NextToken"
        case partitionKeys = "PartitionKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let partitionKeysContainer = try containerValues.decodeIfPresent([ResponsePartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[ResponsePartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [ResponsePartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let keysContainer = try containerValues.decodeIfPresent([DimensionKeyDescription?].self, forKey: .keys)
        var keysDecoded0:[DimensionKeyDescription]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [DimensionKeyDescription]()
            for structure0 in keysContainer {
                if let structure0 = structure0 {
                    keysDecoded0?.append(structure0)
                }
            }
        }
        keys = keysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum DetailStatus {
    case available
    case processing
    case unavailable
    case sdkUnknown(String)
}

extension DetailStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetailStatus] {
        return [
            .available,
            .processing,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .processing: return "PROCESSING"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetailStatus(rawValue: rawValue) ?? DetailStatus.sdkUnknown(rawValue)
    }
}

extension DimensionGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for requeststringlist0 in dimensions {
                try dimensionsContainer.encode(requeststringlist0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DimensionGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionGroup(dimensions: \(String(describing: dimensions)), group: \(String(describing: group)), limit: \(String(describing: limit)))"}
}

/// <p>A logical grouping of Performance Insights metrics for a related subject area. For example, the
///         <code>db.sql</code> dimension group consists of the following dimensions:
///         <code>db.sql.id</code>, <code>db.sql.db_id</code>, <code>db.sql.statement</code>, and
///         <code>db.sql.tokenized_id</code>.</p>
///          <note>
///             <p>Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements,
///         only the first 500 bytes are returned.</p>
///          </note>
public struct DimensionGroup: Equatable {
    /// <p>A list of specific dimensions from a dimension group. If this parameter is not present,
    ///       then it signifies that all of the dimensions in the group were requested, or are present in
    ///       the response.</p>
    ///          <p>Valid values for elements in the <code>Dimensions</code> array are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db.application.name</code> - The name of the application that is connected to the database (only
    ///       Aurora PostgreSQL and RDS PostgreSQL)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.host.id</code> - The host ID of the connected client (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.host.name</code> - The host name of the connected client (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.name</code> - The name of the database to which the client is connected (only Aurora
    ///       PostgreSQL, RDS PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.session_type.name</code> - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql.id</code> - The SQL ID generated by Performance Insights (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql.db_id</code> - The SQL ID generated by the database (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql.statement</code> - The SQL text that is being executed (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql.tokenized_id</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql_tokenized.id</code> - The SQL digest ID generated by Performance Insights (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql_tokenized.db_id</code> - SQL digest ID generated by the database (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql_tokenized.statement</code> - The SQL digest text (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.user.id</code> - The ID of the user logged in to the database (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.user.name</code> - The name of the user logged in to the database (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.wait_event.name</code> - The event for which the backend is waiting (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.wait_event.type</code> - The type of event for which the backend is waiting (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.wait_event_type.name</code> - The name of the event type for which the backend is waiting (all
    ///       engines)</p>
    ///             </li>
    ///          </ul>
    public let dimensions: [String]?
    /// <p>The name of the dimension group.  Valid values are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db</code> - The name of the database to which the client is connected (only Aurora PostgreSQL, RDS
    ///         PostgreSQL, Aurora MySQL, RDS MySQL, and MariaDB)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.application</code> - The name of the application that is connected to the database (only Aurora
    ///         PostgreSQL and RDS PostgreSQL)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.host</code> - The host name of the connected client (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.session_type</code> - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql</code> - The SQL that is currently executing (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sql_tokenized</code> - The SQL digest (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.wait_event</code> - The event for which the database backend is waiting  (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.wait_event_type</code> - The type of event for which the database backend is waiting (all engines)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.user</code> - The user logged in to the database (all engines)</p>
    ///             </li>
    ///          </ul>
    public let group: String?
    /// <p>The maximum number of items to fetch for this dimension group.</p>
    public let limit: Int?

    public init (
        dimensions: [String]? = nil,
        group: String? = nil,
        limit: Int? = nil
    )
    {
        self.dimensions = dimensions
        self.group = group
        self.limit = limit
    }
}

extension DimensionKeyDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case partitions = "Partitions"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let partitions = partitions {
            var partitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitions)
            for metricvalueslist0 in partitions {
                try partitionsContainer.encode(metricvalueslist0)
            }
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [String:String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [String:String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .total)
        total = totalDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .partitions)
        var partitionsDecoded0:[Double]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Double]()
            for double0 in partitionsContainer {
                if let double0 = double0 {
                    partitionsDecoded0?.append(double0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

extension DimensionKeyDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionKeyDescription(dimensions: \(String(describing: dimensions)), partitions: \(String(describing: partitions)), total: \(String(describing: total)))"}
}

/// <p>An array of descriptions and aggregated values for
///       each dimension within a dimension group.</p>
public struct DimensionKeyDescription: Equatable {
    /// <p>A map of name-value pairs for the dimensions in the group.</p>
    public let dimensions: [String:String]?
    /// <p>If <code>PartitionBy</code> was specified, <code>PartitionKeys</code> contains the dimensions that were.</p>
    public let partitions: [Double]?
    /// <p>The aggregated metric value for the dimension(s), over the requested time range.</p>
    public let total: Double?

    public init (
        dimensions: [String:String]? = nil,
        partitions: [Double]? = nil,
        total: Double? = nil
    )
    {
        self.dimensions = dimensions
        self.partitions = partitions
        self.total = total
    }
}

extension DimensionKeyDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimension = "Dimension"
        case status = "Status"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetailStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DimensionKeyDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionKeyDetail(dimension: \(String(describing: dimension)), status: \(String(describing: status)), value: \(String(describing: value)))"}
}

/// <p>An object that describes the details for a specified dimension.</p>
public struct DimensionKeyDetail: Equatable {
    /// <p>The full name of the dimension. The full name includes the group name and key name. The only valid value is
    ///         <code>db.sql.statement</code>. </p>
    public let dimension: String?
    /// <p>The status of the dimension detail data. Possible values include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The dimension detail data is ready to be retrieved.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PROCESSING</code> - The dimension detail data isn't ready to be retrieved because more processing time is
    ///           required. If the requested detail data for <code>db.sql.statement</code> has the status <code>PROCESSING</code>,
    ///           Performance Insights returns the truncated query.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNAVAILABLE</code> - The dimension detail data could not be collected successfully.</p>
    ///             </li>
    ///          </ul>
    public let status: DetailStatus?
    /// <p>The value of the dimension detail data. For the <code>db.sql.statement</code> dimension, this value is either the
    ///       full or truncated SQL query, depending on the return status.</p>
    public let value: String?

    public init (
        dimension: String? = nil,
        status: DetailStatus? = nil,
        value: String? = nil
    )
    {
        self.dimension = dimension
        self.status = status
        self.value = value
    }
}

public struct GetDimensionKeyDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetDimensionKeyDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionKeyDetailsOutputError>
}

extension GetDimensionKeyDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDimensionKeyDetailsInput(group: \(String(describing: group)), groupIdentifier: \(String(describing: groupIdentifier)), identifier: \(String(describing: identifier)), requestedDimensions: \(String(describing: requestedDimensions)), serviceType: \(String(describing: serviceType)))"}
}

extension GetDimensionKeyDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let groupIdentifier = groupIdentifier {
            try encodeContainer.encode(groupIdentifier, forKey: .groupIdentifier)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let requestedDimensions = requestedDimensions {
            var requestedDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestedDimensions)
            for requesteddimensionlist0 in requestedDimensions {
                try requestedDimensionsContainer.encode(requesteddimensionlist0)
            }
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }
}

public struct GetDimensionKeyDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDimensionKeyDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionKeyDetailsOutputError>
}

public struct GetDimensionKeyDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDimensionKeyDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionKeyDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionKeyDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionKeyDetailsInput>
    public typealias MOutput = OperationOutput<GetDimensionKeyDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionKeyDetailsOutputError>
}

public struct GetDimensionKeyDetailsInput: Equatable {
    /// <p>The name of the dimension group. The only valid value is <code>db.sql</code>. Performance Insights searches the
    ///       specified group for the dimension group ID.</p>
    public let group: String?
    /// <p>The ID of the dimension group from which to retrieve dimension details. For dimension group <code>db.sql</code>,
    ///       the group ID is <code>db.sql.id</code>.</p>
    public let groupIdentifier: String?
    /// <p>The ID for a data source from which to gather dimension data. This ID must be immutable and unique within an AWS
    ///       Region. When a DB instance is the data source, specify its <code>DbiResourceId</code> value. For example, specify
    ///         <code>db-ABCDEFGHIJKLMNOPQRSTU1VW2X</code>. </p>
    public let identifier: String?
    /// <p>A list of dimensions to retrieve the detail data for within the given dimension group. For the dimension group
    ///                 <code>db.sql</code>, specify either the full dimension name <code>db.sql.statement</code> or the short
    ///             dimension name <code>statement</code>. If you don't specify this parameter, Performance Insights returns all
    ///             dimension data within the specified dimension group.</p>
    public let requestedDimensions: [String]?
    /// <p>The AWS service for which Performance Insights returns data. The only valid value is <code>RDS</code>.</p>
    public let serviceType: ServiceType?

    public init (
        group: String? = nil,
        groupIdentifier: String? = nil,
        identifier: String? = nil,
        requestedDimensions: [String]? = nil,
        serviceType: ServiceType? = nil
    )
    {
        self.group = group
        self.groupIdentifier = groupIdentifier
        self.identifier = identifier
        self.requestedDimensions = requestedDimensions
        self.serviceType = serviceType
    }
}

struct GetDimensionKeyDetailsInputBody: Equatable {
    public let serviceType: ServiceType?
    public let identifier: String?
    public let group: String?
    public let groupIdentifier: String?
    public let requestedDimensions: [String]?
}

extension GetDimensionKeyDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case groupIdentifier = "GroupIdentifier"
        case identifier = "Identifier"
        case requestedDimensions = "RequestedDimensions"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
        let groupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupIdentifier)
        groupIdentifier = groupIdentifierDecoded
        let requestedDimensionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .requestedDimensions)
        var requestedDimensionsDecoded0:[String]? = nil
        if let requestedDimensionsContainer = requestedDimensionsContainer {
            requestedDimensionsDecoded0 = [String]()
            for string0 in requestedDimensionsContainer {
                if let string0 = string0 {
                    requestedDimensionsDecoded0?.append(string0)
                }
            }
        }
        requestedDimensions = requestedDimensionsDecoded0
    }
}

extension GetDimensionKeyDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionKeyDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDimensionKeyDetailsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionKeyDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDimensionKeyDetailsOutputResponse(dimensions: \(String(describing: dimensions)))"}
}

extension GetDimensionKeyDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDimensionKeyDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dimensions = output.dimensions
        } else {
            self.dimensions = nil
        }
    }
}

public struct GetDimensionKeyDetailsOutputResponse: Equatable {
    /// <p>The details for the requested dimensions.</p>
    public let dimensions: [DimensionKeyDetail]?

    public init (
        dimensions: [DimensionKeyDetail]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

struct GetDimensionKeyDetailsOutputResponseBody: Equatable {
    public let dimensions: [DimensionKeyDetail]?
}

extension GetDimensionKeyDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([DimensionKeyDetail?].self, forKey: .dimensions)
        var dimensionsDecoded0:[DimensionKeyDetail]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [DimensionKeyDetail]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

public struct GetResourceMetricsInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceMetricsOutputError>
}

extension GetResourceMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceMetricsInput(endTime: \(String(describing: endTime)), identifier: \(String(describing: identifier)), maxResults: \(String(describing: maxResults)), metricQueries: \(String(describing: metricQueries)), nextToken: \(String(describing: nextToken)), periodInSeconds: \(String(describing: periodInSeconds)), serviceType: \(String(describing: serviceType)), startTime: \(String(describing: startTime)))"}
}

extension GetResourceMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricQueries = metricQueries {
            var metricQueriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricQueries)
            for metricquerylist0 in metricQueries {
                try metricQueriesContainer.encode(metricquerylist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetResourceMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceMetricsOutputError>
}

public struct GetResourceMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceMetricsInput>
    public typealias MOutput = OperationOutput<GetResourceMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceMetricsOutputError>
}

public struct GetResourceMetricsInput: Equatable {
    /// <p>The date and time specifying the end of the requested time series data.  The value specified is
    ///       <i>exclusive</i> - data points less than (but not equal to) <code>EndTime</code> will be returned.</p>
    ///          <p>The value for <code>EndTime</code> must be later than the value for <code>StartTime</code>.</p>
    public let endTime: Date?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use a DB instance as a data source, specify its <code>DbiResourceId</code> value. For example, specify
    ///         <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>.</p>
    public let identifier: String?
    /// <p>The maximum number of items to return in the response.
    ///       If more items exist than the specified <code>MaxRecords</code> value, a pagination
    ///       token is included in the response so that the remaining
    ///       results can be retrieved.
    ///     </p>
    public let maxResults: Int?
    /// <p>An array of one or more queries to perform. Each query must specify a Performance Insights metric, and
    ///       can optionally specify aggregation and filtering criteria.</p>
    public let metricQueries: [MetricQuery]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: String?
    /// <p>The granularity, in seconds, of the data points returned from Performance Insights. A period can be as short as
    ///       one second, or as long as one day (86400 seconds).  Valid values are:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>1</code> (one second)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>60</code> (one minute)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>300</code> (five minutes)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>3600</code> (one hour)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>86400</code> (twenty-four hours)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If you don't specify <code>PeriodInSeconds</code>, then Performance Insights will choose a value for
    ///       you, with a goal of returning roughly 100-200 data points in the response.</p>
    public let periodInSeconds: Int?
    /// <p>The AWS service for which Performance Insights returns metrics. The only valid value for <i>ServiceType</i> is
    ///         <code>RDS</code>.</p>
    public let serviceType: ServiceType?
    /// <p>The date and time specifying the beginning of the requested time series data. You can't
    ///       specify a <code>StartTime</code> that's earlier than 7 days ago. The value specified is
    ///         <i>inclusive</i> - data points equal to or greater than <code>StartTime</code>
    ///       will be returned.</p>
    ///          <p>The value for <code>StartTime</code> must be earlier than the value for <code>EndTime</code>.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        identifier: String? = nil,
        maxResults: Int? = nil,
        metricQueries: [MetricQuery]? = nil,
        nextToken: String? = nil,
        periodInSeconds: Int? = nil,
        serviceType: ServiceType? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.identifier = identifier
        self.maxResults = maxResults
        self.metricQueries = metricQueries
        self.nextToken = nextToken
        self.periodInSeconds = periodInSeconds
        self.serviceType = serviceType
        self.startTime = startTime
    }
}

struct GetResourceMetricsInputBody: Equatable {
    public let serviceType: ServiceType?
    public let identifier: String?
    public let metricQueries: [MetricQuery]?
    public let startTime: Date?
    public let endTime: Date?
    public let periodInSeconds: Int?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetResourceMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case identifier = "Identifier"
        case maxResults = "MaxResults"
        case metricQueries = "MetricQueries"
        case nextToken = "NextToken"
        case periodInSeconds = "PeriodInSeconds"
        case serviceType = "ServiceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricQueriesContainer = try containerValues.decodeIfPresent([MetricQuery?].self, forKey: .metricQueries)
        var metricQueriesDecoded0:[MetricQuery]? = nil
        if let metricQueriesContainer = metricQueriesContainer {
            metricQueriesDecoded0 = [MetricQuery]()
            for structure0 in metricQueriesContainer {
                if let structure0 = structure0 {
                    metricQueriesDecoded0?.append(structure0)
                }
            }
        }
        metricQueries = metricQueriesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceMetricsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceMetricsOutputResponse(alignedEndTime: \(String(describing: alignedEndTime)), alignedStartTime: \(String(describing: alignedStartTime)), identifier: \(String(describing: identifier)), metricList: \(String(describing: metricList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetResourceMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alignedEndTime = output.alignedEndTime
            self.alignedStartTime = output.alignedStartTime
            self.identifier = output.identifier
            self.metricList = output.metricList
            self.nextToken = output.nextToken
        } else {
            self.alignedEndTime = nil
            self.alignedStartTime = nil
            self.identifier = nil
            self.metricList = nil
            self.nextToken = nil
        }
    }
}

public struct GetResourceMetricsOutputResponse: Equatable {
    /// <p>The end time for the returned metrics, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedEndTime</code> will be greater than
    ///       or equal to the value of the user-specified <code>Endtime</code>.</p>
    public let alignedEndTime: Date?
    /// <p>The start time for the returned metrics, after alignment to a granular boundary (as
    ///       specified by <code>PeriodInSeconds</code>). <code>AlignedStartTime</code> will be less than or
    ///       equal to the value of the user-specified <code>StartTime</code>.</p>
    public let alignedStartTime: Date?
    /// <p>An immutable, AWS Region-unique identifier for a data source. Performance Insights gathers metrics from
    ///       this data source.</p>
    ///          <p>To use a DB instance as a data source, you specify its
    ///       <code>DbiResourceId</code> value - for example:
    ///       <code>db-FAIHNTYBKTGAUSUZQYPDS2GW4A</code>
    ///          </p>
    public let identifier: String?
    /// <p>An array of metric results,, where each array element contains all of the data points for a particular dimension.</p>
    public let metricList: [MetricKeyDataPoints]?
    /// <p>An optional pagination token provided by a previous request. If
    ///       this parameter is specified, the response includes only records beyond the token, up to the
    ///       value specified by <code>MaxRecords</code>.</p>
    public let nextToken: String?

    public init (
        alignedEndTime: Date? = nil,
        alignedStartTime: Date? = nil,
        identifier: String? = nil,
        metricList: [MetricKeyDataPoints]? = nil,
        nextToken: String? = nil
    )
    {
        self.alignedEndTime = alignedEndTime
        self.alignedStartTime = alignedStartTime
        self.identifier = identifier
        self.metricList = metricList
        self.nextToken = nextToken
    }
}

struct GetResourceMetricsOutputResponseBody: Equatable {
    public let alignedStartTime: Date?
    public let alignedEndTime: Date?
    public let identifier: String?
    public let metricList: [MetricKeyDataPoints]?
    public let nextToken: String?
}

extension GetResourceMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alignedEndTime = "AlignedEndTime"
        case alignedStartTime = "AlignedStartTime"
        case identifier = "Identifier"
        case metricList = "MetricList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .alignedStartTime)
        alignedStartTime = alignedStartTimeDecoded
        let alignedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .alignedEndTime)
        alignedEndTime = alignedEndTimeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let metricListContainer = try containerValues.decodeIfPresent([MetricKeyDataPoints?].self, forKey: .metricList)
        var metricListDecoded0:[MetricKeyDataPoints]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [MetricKeyDataPoints]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceError(message: \(String(describing: message)))"}
}

extension InternalServiceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed due to an unknown error.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the arguments provided is invalid for this request.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MetricKeyDataPoints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataPoints = "DataPoints"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPoints = dataPoints {
            var dataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPoints)
            for datapointslist0 in dataPoints {
                try dataPointsContainer.encode(datapointslist0)
            }
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ResponseResourceMetricKey.self, forKey: .key)
        key = keyDecoded
        let dataPointsContainer = try containerValues.decodeIfPresent([DataPoint?].self, forKey: .dataPoints)
        var dataPointsDecoded0:[DataPoint]? = nil
        if let dataPointsContainer = dataPointsContainer {
            dataPointsDecoded0 = [DataPoint]()
            for structure0 in dataPointsContainer {
                if let structure0 = structure0 {
                    dataPointsDecoded0?.append(structure0)
                }
            }
        }
        dataPoints = dataPointsDecoded0
    }
}

extension MetricKeyDataPoints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricKeyDataPoints(dataPoints: \(String(describing: dataPoints)), key: \(String(describing: key)))"}
}

/// <p>A time-ordered series of data points, corresponding to a dimension of a Performance Insights
///       metric.</p>
public struct MetricKeyDataPoints: Equatable {
    /// <p>An array of timestamp-value pairs, representing measurements over a period of time.</p>
    public let dataPoints: [DataPoint]?
    /// <p>The dimension(s) to which the data points apply.</p>
    public let key: ResponseResourceMetricKey?

    public init (
        dataPoints: [DataPoint]? = nil,
        key: ResponseResourceMetricKey? = nil
    )
    {
        self.dataPoints = dataPoints
        self.key = key
    }
}

extension MetricQuery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, metricqueryfiltermap0) in filter {
                try filterContainer.encode(metricqueryfiltermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(DimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .filter)
        var filterDecoded0: [String:String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:String]()
            for (key0, requeststring0) in filterContainer {
                if let requeststring0 = requeststring0 {
                    filterDecoded0?[key0] = requeststring0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension MetricQuery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricQuery(filter: \(String(describing: filter)), groupBy: \(String(describing: groupBy)), metric: \(String(describing: metric)))"}
}

/// <p>A single query to be processed. You must provide the metric to query. If no other
///       parameters are specified, Performance Insights returns all of the data points for that metric. You can
///       optionally request that the data points be aggregated by dimension group (
///       <code>GroupBy</code>), and return only those data points that match your criteria (<code>Filter</code>).</p>
public struct MetricQuery: Equatable {
    /// <p>One or more filters to apply in the request.  Restrictions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Any number of filters by the same dimension, as specified in the <code>GroupBy</code> parameter.</p>
    ///             </li>
    ///             <li>
    ///                <p>A single filter for any other dimension in this dimension group.</p>
    ///             </li>
    ///          </ul>
    public let filter: [String:String]?
    /// <p>A specification for how to aggregate the data points from a query result. You must
    ///       specify a valid dimension group.  Performance Insights will return all of the dimensions within that group,
    ///       unless you provide the names of specific dimensions within that group. You can also request
    ///       that Performance Insights return a limited number of values for a dimension.</p>
    public let groupBy: DimensionGroup?
    /// <p>The name of a Performance Insights metric to be measured.</p>
    ///          <p>Valid values for <code>Metric</code> are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
    ///           for the database engine.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
    ///           database engine.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
    ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
    ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
    ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
    public let metric: String?

    public init (
        filter: [String:String]? = nil,
        groupBy: DimensionGroup? = nil,
        metric: String? = nil
    )
    {
        self.filter = filter
        self.groupBy = groupBy
        self.metric = metric
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user is not authorized to perform this request.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResponsePartitionKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [String:String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [String:String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension ResponsePartitionKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponsePartitionKey(dimensions: \(String(describing: dimensions)))"}
}

/// <p>If <code>PartitionBy</code> was specified in a <code>DescribeDimensionKeys</code>
///       request, the dimensions are returned in an array. Each element in the array specifies one
///       dimension. </p>
public struct ResponsePartitionKey: Equatable {
    /// <p>A dimension map that contains the dimension(s) for this partition.</p>
    public let dimensions: [String:String]?

    public init (
        dimensions: [String:String]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

extension ResponseResourceMetricKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case metric = "Metric"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .dimensions)
            for (dictKey0, dimensionmap0) in dimensions {
                try dimensionsContainer.encode(dimensionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metric)
        metric = metricDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .dimensions)
        var dimensionsDecoded0: [String:String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [String:String]()
            for (key0, requeststring0) in dimensionsContainer {
                if let requeststring0 = requeststring0 {
                    dimensionsDecoded0?[key0] = requeststring0
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension ResponseResourceMetricKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseResourceMetricKey(dimensions: \(String(describing: dimensions)), metric: \(String(describing: metric)))"}
}

/// <p>An object describing a Performance Insights metric and one or more dimensions for that metric.</p>
public struct ResponseResourceMetricKey: Equatable {
    /// <p>The valid dimensions for the metric.</p>
    public let dimensions: [String:String]?
    /// <p>The name of a Performance Insights metric to be measured.</p>
    ///          <p>Valid values for <code>Metric</code> are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>db.load.avg</code> - a scaled representation of the number of active sessions
    ///           for the database engine.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>db.sampledload.avg</code> - the raw number of active sessions for the
    ///           database engine.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the number of active sessions is less than an internal Performance Insights threshold, <code>db.load.avg</code> and <code>db.sampledload.avg</code>
    ///           are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with <code>db.load.avg</code>
    ///           showing the scaled values, <code>db.sampledload.avg</code> showing the raw values, and <code>db.sampledload.avg</code> less than <code>db.load.avg</code>.
    ///           For most use cases, you can query <code>db.load.avg</code> only. </p>
    public let metric: String?

    public init (
        dimensions: [String:String]? = nil,
        metric: String? = nil
    )
    {
        self.dimensions = dimensions
        self.metric = metric
    }
}

public enum ServiceType {
    case rds
    case sdkUnknown(String)
}

extension ServiceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceType] {
        return [
            .rds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rds: return "RDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
    }
}
