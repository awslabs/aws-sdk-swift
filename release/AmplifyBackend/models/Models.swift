// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AdditionalConstraintsElement {
    case requireDigit
    case requireLowercase
    case requireSymbol
    case requireUppercase
    case sdkUnknown(String)
}

extension AdditionalConstraintsElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdditionalConstraintsElement] {
        return [
            .requireDigit,
            .requireLowercase,
            .requireSymbol,
            .requireUppercase,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .requireDigit: return "REQUIRE_DIGIT"
        case .requireLowercase: return "REQUIRE_LOWERCASE"
        case .requireSymbol: return "REQUIRE_SYMBOL"
        case .requireUppercase: return "REQUIRE_UPPERCASE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdditionalConstraintsElement(rawValue: rawValue) ?? AdditionalConstraintsElement.sdkUnknown(rawValue)
    }
}

public enum AuthResources {
    case identityPoolAndUserPool
    case userPoolOnly
    case sdkUnknown(String)
}

extension AuthResources : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthResources] {
        return [
            .identityPoolAndUserPool,
            .userPoolOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .identityPoolAndUserPool: return "IDENTITY_POOL_AND_USER_POOL"
        case .userPoolOnly: return "USER_POOL_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthResources(rawValue: rawValue) ?? AuthResources.sdkUnknown(rawValue)
    }
}

extension BackendAPIAppSyncAuthSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cognitoUserPoolId = "cognitoUserPoolId"
        case description = "description"
        case expirationTime = "expirationTime"
        case openIDAuthTTL = "openIDAuthTTL"
        case openIDClientId = "openIDClientId"
        case openIDIatTTL = "openIDIatTTL"
        case openIDIssueURL = "openIDIssueURL"
        case openIDProviderName = "openIDProviderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoUserPoolId = cognitoUserPoolId {
            try encodeContainer.encode(cognitoUserPoolId, forKey: .cognitoUserPoolId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expirationTime != 0.0 {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let openIDAuthTTL = openIDAuthTTL {
            try encodeContainer.encode(openIDAuthTTL, forKey: .openIDAuthTTL)
        }
        if let openIDClientId = openIDClientId {
            try encodeContainer.encode(openIDClientId, forKey: .openIDClientId)
        }
        if let openIDIatTTL = openIDIatTTL {
            try encodeContainer.encode(openIDIatTTL, forKey: .openIDIatTTL)
        }
        if let openIDIssueURL = openIDIssueURL {
            try encodeContainer.encode(openIDIssueURL, forKey: .openIDIssueURL)
        }
        if let openIDProviderName = openIDProviderName {
            try encodeContainer.encode(openIDProviderName, forKey: .openIDProviderName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cognitoUserPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cognitoUserPoolId)
        cognitoUserPoolId = cognitoUserPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decode(Double.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let openIDAuthTTLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDAuthTTL)
        openIDAuthTTL = openIDAuthTTLDecoded
        let openIDClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDClientId)
        openIDClientId = openIDClientIdDecoded
        let openIDIatTTLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDIatTTL)
        openIDIatTTL = openIDIatTTLDecoded
        let openIDIssueURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDIssueURL)
        openIDIssueURL = openIDIssueURLDecoded
        let openIDProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openIDProviderName)
        openIDProviderName = openIDProviderNameDecoded
    }
}

extension BackendAPIAppSyncAuthSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendAPIAppSyncAuthSettings(cognitoUserPoolId: \(String(describing: cognitoUserPoolId)), description: \(String(describing: description)), expirationTime: \(String(describing: expirationTime)), openIDAuthTTL: \(String(describing: openIDAuthTTL)), openIDClientId: \(String(describing: openIDClientId)), openIDIatTTL: \(String(describing: openIDIatTTL)), openIDIssueURL: \(String(describing: openIDIssueURL)), openIDProviderName: \(String(describing: openIDProviderName)))"}
}

/// <p>The authentication settings for accessing provisioned data models in your Amplify project.</p>
public struct BackendAPIAppSyncAuthSettings: Equatable {
    /// <p>The Amazon Cognito user pool ID, if Amazon Cognito is used as an authentication setting to access your data models.</p>
    public let cognitoUserPoolId: String?
    /// <p>The API key description for API_KEY, if it is used as an authentication mechanism to access your data models.</p>
    public let description: String?
    /// <p>The API key expiration time for API_KEY, if it is used as an authentication mechanism to access your data models.</p>
    public let expirationTime: Double
    /// <p>The expiry time for the OpenID authentication mechanism.</p>
    public let openIDAuthTTL: String?
    /// <p>The clientID for openID, if openID is used as an authentication setting to access your data models.</p>
    public let openIDClientId: String?
    /// <p>The expiry time for the OpenID authentication mechanism.</p>
    public let openIDIatTTL: String?
    /// <p>The openID issuer URL, if openID is used as an authentication setting to access your data models.</p>
    public let openIDIssueURL: String?
    /// <p>The openID provider name, if openID is used as an authentication mechanism to access your data models.</p>
    public let openIDProviderName: String?

    public init (
        cognitoUserPoolId: String? = nil,
        description: String? = nil,
        expirationTime: Double = 0.0,
        openIDAuthTTL: String? = nil,
        openIDClientId: String? = nil,
        openIDIatTTL: String? = nil,
        openIDIssueURL: String? = nil,
        openIDProviderName: String? = nil
    )
    {
        self.cognitoUserPoolId = cognitoUserPoolId
        self.description = description
        self.expirationTime = expirationTime
        self.openIDAuthTTL = openIDAuthTTL
        self.openIDClientId = openIDClientId
        self.openIDIatTTL = openIDIatTTL
        self.openIDIssueURL = openIDIssueURL
        self.openIDProviderName = openIDProviderName
    }
}

extension BackendAPIAuthType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "mode"
        case settings = "settings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(BackendAPIAppSyncAuthSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension BackendAPIAuthType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendAPIAuthType(mode: \(String(describing: mode)), settings: \(String(describing: settings)))"}
}

/// <p>Describes the auth types for your configured data models.</p>
public struct BackendAPIAuthType: Equatable {
    /// <p>Describes the authentication mode.</p>
    public let mode: Mode?
    /// <p>Describes settings for the authentication mode.</p>
    public let settings: BackendAPIAppSyncAuthSettings?

    public init (
        mode: Mode? = nil,
        settings: BackendAPIAppSyncAuthSettings? = nil
    )
    {
        self.mode = mode
        self.settings = settings
    }
}

extension BackendAPIConflictResolution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resolutionStrategy = "resolutionStrategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolutionStrategy = resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(ResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
    }
}

extension BackendAPIConflictResolution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendAPIConflictResolution(resolutionStrategy: \(String(describing: resolutionStrategy)))"}
}

/// <p>Describes the conflict resolution configuration for the data model configured in your Amplify project.</p>
public struct BackendAPIConflictResolution: Equatable {
    /// <p>The strategy for conflict resolution.</p>
    public let resolutionStrategy: ResolutionStrategy?

    public init (
        resolutionStrategy: ResolutionStrategy? = nil
    )
    {
        self.resolutionStrategy = resolutionStrategy
    }
}

extension BackendAPIResourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalAuthTypes = "additionalAuthTypes"
        case apiName = "apiName"
        case conflictResolution = "conflictResolution"
        case defaultAuthType = "defaultAuthType"
        case service = "service"
        case transformSchema = "transformSchema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthTypes = additionalAuthTypes {
            var additionalAuthTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthTypes)
            for listofbackendapiauthtype0 in additionalAuthTypes {
                try additionalAuthTypesContainer.encode(listofbackendapiauthtype0)
            }
        }
        if let apiName = apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let defaultAuthType = defaultAuthType {
            try encodeContainer.encode(defaultAuthType, forKey: .defaultAuthType)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let transformSchema = transformSchema {
            try encodeContainer.encode(transformSchema, forKey: .transformSchema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalAuthTypesContainer = try containerValues.decodeIfPresent([BackendAPIAuthType?].self, forKey: .additionalAuthTypes)
        var additionalAuthTypesDecoded0:[BackendAPIAuthType]? = nil
        if let additionalAuthTypesContainer = additionalAuthTypesContainer {
            additionalAuthTypesDecoded0 = [BackendAPIAuthType]()
            for structure0 in additionalAuthTypesContainer {
                if let structure0 = structure0 {
                    additionalAuthTypesDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthTypes = additionalAuthTypesDecoded0
        let apiNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(BackendAPIConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let defaultAuthTypeDecoded = try containerValues.decodeIfPresent(BackendAPIAuthType.self, forKey: .defaultAuthType)
        defaultAuthType = defaultAuthTypeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let transformSchemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transformSchema)
        transformSchema = transformSchemaDecoded
    }
}

extension BackendAPIResourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendAPIResourceConfig(additionalAuthTypes: \(String(describing: additionalAuthTypes)), apiName: \(String(describing: apiName)), conflictResolution: \(String(describing: conflictResolution)), defaultAuthType: \(String(describing: defaultAuthType)), service: \(String(describing: service)), transformSchema: \(String(describing: transformSchema)))"}
}

/// <p>The resource configuration for the data model, configured as a part of the Amplify project.</p>
public struct BackendAPIResourceConfig: Equatable {
    /// <p>Additional authentication methods used to interact with your data models.</p>
    public let additionalAuthTypes: [BackendAPIAuthType]?
    /// <p>The API name used to interact with the data model, configured as a part of the Amplify project.</p>
    public let apiName: String?
    /// <p>The conflict resolution strategy for your data stored in the data models.</p>
    public let conflictResolution: BackendAPIConflictResolution?
    /// <p>The default authentication type for interacting with the configured data models in your Amplify project.</p>
    public let defaultAuthType: BackendAPIAuthType?
    /// <p>The service used to provision and interact with the data model.</p>
    public let service: String?
    /// <p>The definition of the data model in the annotated transform of the GraphQL schema.</p>
    public let transformSchema: String?

    public init (
        additionalAuthTypes: [BackendAPIAuthType]? = nil,
        apiName: String? = nil,
        conflictResolution: BackendAPIConflictResolution? = nil,
        defaultAuthType: BackendAPIAuthType? = nil,
        service: String? = nil,
        transformSchema: String? = nil
    )
    {
        self.additionalAuthTypes = additionalAuthTypes
        self.apiName = apiName
        self.conflictResolution = conflictResolution
        self.defaultAuthType = defaultAuthType
        self.service = service
        self.transformSchema = transformSchema
    }
}

extension BackendAuthSocialProviderConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "client_id"
        case clientSecret = "client_secret"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension BackendAuthSocialProviderConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendAuthSocialProviderConfig(clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)))"}
}

/// <p>Describes third-party social federation configurations for allowing your app users to sign in using OAuth.</p>
public struct BackendAuthSocialProviderConfig: Equatable {
    /// <p>Describes the client_id that can be obtained from the third-party social federation provider.</p>
    public let clientId: String?
    /// <p>Describes the client_secret that can be obtained from third-party social federation providers.</p>
    public let clientSecret: String?

    public init (
        clientId: String? = nil,
        clientSecret: String? = nil
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
    }
}

extension BackendJobRespObj: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension BackendJobRespObj: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendJobRespObj(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), createTime: \(String(describing: createTime)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)), updateTime: \(String(describing: updateTime)))"}
}

/// <p>The response object for this operation.</p>
public struct BackendJobRespObj: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The time when the job was created.</p>
    public let createTime: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?
    /// <p>The time when the job was last updated.</p>
    public let updateTime: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        createTime: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil,
        updateTime: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error returned if a request is not formed properly.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>An error message to inform that the request failed.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CloneBackendInputBodyMiddleware: Middleware {
    public let id: String = "CloneBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneBackendInput>
    public typealias MOutput = OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneBackendOutputError>
}

extension CloneBackendInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneBackendInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), targetEnvironmentName: \(String(describing: targetEnvironmentName)))"}
}

extension CloneBackendInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetEnvironmentName = targetEnvironmentName {
            try encodeContainer.encode(targetEnvironmentName, forKey: .targetEnvironmentName)
        }
    }
}

public struct CloneBackendInputHeadersMiddleware: Middleware {
    public let id: String = "CloneBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneBackendInput>
    public typealias MOutput = OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneBackendOutputError>
}

public struct CloneBackendInputQueryItemMiddleware: Middleware {
    public let id: String = "CloneBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneBackendInput>
    public typealias MOutput = OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneBackendOutputError>
}

/// <p>The request body for CloneBackend.</p>
public struct CloneBackendInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The name of the destination backend environment to be created.</p>
    public let targetEnvironmentName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        targetEnvironmentName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.targetEnvironmentName = targetEnvironmentName
    }
}

struct CloneBackendInputBody: Equatable {
    public let targetEnvironmentName: String?
}

extension CloneBackendInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetEnvironmentName)
        targetEnvironmentName = targetEnvironmentNameDecoded
    }
}

extension CloneBackendOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloneBackendOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloneBackendOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneBackendOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneBackendOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension CloneBackendOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloneBackendOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CloneBackendOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CloneBackendOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension CloneBackendOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateBackendAPIInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAPIOutputError>
}

extension CreateBackendAPIInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAPIInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension CreateBackendAPIInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendAPIInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAPIOutputError>
}

public struct CreateBackendAPIInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAPIOutputError>
}

/// <p>The request body for CreateBackendAPI.</p>
public struct CreateBackendAPIInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The resource configuration for this request.</p>
    public let resourceConfig: BackendAPIResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: BackendAPIResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAPIInputBody: Equatable {
    public let backendEnvironmentName: String?
    public let resourceConfig: BackendAPIResourceConfig?
    public let resourceName: String?
}

extension CreateBackendAPIInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendAPIOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAPIOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendAPIOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAPIOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAPIOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension CreateBackendAPIOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAPIOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAPIOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension CreateBackendAPIOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateBackendAuthForgotPasswordConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension CreateBackendAuthForgotPasswordConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthForgotPasswordConfig(deliveryMethod: \(String(describing: deliveryMethod)), emailSettings: \(String(describing: emailSettings)), smsSettings: \(String(describing: smsSettings)))"}
}

/// <p>Describes the forgot password policy for authenticating into the Amplify app.</p>
public struct CreateBackendAuthForgotPasswordConfig: Equatable {
    /// <p>Describes which method to use (either SMS or email) to deliver messages to app users that want to recover their password.</p>
    public let deliveryMethod: DeliveryMethod?
    /// <p>The configuration for the email sent when an app user forgets their password.</p>
    public let emailSettings: EmailSettings?
    /// <p>The configuration for the SMS message sent when an app user forgets their password.</p>
    public let smsSettings: SmsSettings?

    public init (
        deliveryMethod: DeliveryMethod? = nil,
        emailSettings: EmailSettings? = nil,
        smsSettings: SmsSettings? = nil
    )
    {
        self.deliveryMethod = deliveryMethod
        self.emailSettings = emailSettings
        self.smsSettings = smsSettings
    }
}

extension CreateBackendAuthIdentityPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolName = "identityPoolName"
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if unauthenticatedLogin != false {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let unauthenticatedLoginDecoded = try containerValues.decode(Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension CreateBackendAuthIdentityPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthIdentityPoolConfig(identityPoolName: \(String(describing: identityPoolName)), unauthenticatedLogin: \(String(describing: unauthenticatedLogin)))"}
}

/// <p>Describes authorization configurations for the auth resources, configured as a part of your Amplify project.</p>
public struct CreateBackendAuthIdentityPoolConfig: Equatable {
    /// <p>Name of the identity pool used for authorization.</p>
    public let identityPoolName: String?
    /// <p>Set to true or false based on whether you want to enable guest authorization to your Amplify app.</p>
    public let unauthenticatedLogin: Bool

    public init (
        identityPoolName: String? = nil,
        unauthenticatedLogin: Bool = false
    )
    {
        self.identityPoolName = identityPoolName
        self.unauthenticatedLogin = unauthenticatedLogin
    }
}

public struct CreateBackendAuthInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAuthOutputError>
}

extension CreateBackendAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension CreateBackendAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendAuthInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAuthOutputError>
}

public struct CreateBackendAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendAuthOutputError>
}

/// <p>The request body for CreateBackendAuth.</p>
public struct CreateBackendAuthInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The resource configuration for this request object.</p>
    public let resourceConfig: CreateBackendAuthResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: CreateBackendAuthResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAuthInputBody: Equatable {
    public let backendEnvironmentName: String?
    public let resourceConfig: CreateBackendAuthResourceConfig?
    public let resourceName: String?
}

extension CreateBackendAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendAuthMFAConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mFAMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mFAMode = mFAMode {
            try encodeContainer.encode(mFAMode.rawValue, forKey: .mFAMode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFAModeDecoded = try containerValues.decodeIfPresent(MFAMode.self, forKey: .mFAMode)
        mFAMode = mFAModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension CreateBackendAuthMFAConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthMFAConfig(mFAMode: \(String(describing: mFAMode)), settings: \(String(describing: settings)))"}
}

/// <p>Describes whether to apply multi-factor authentication (MFA) policies for your Amazon Cognito user pool that's configured as a part of your Amplify project.</p>
public struct CreateBackendAuthMFAConfig: Equatable {
    /// <p>Describes whether MFA should be [ON, OFF, or OPTIONAL] for authentication in your Amplify project.</p>
    public let mFAMode: MFAMode?
    /// <p>Describes the configuration settings and methods for your Amplify app users to use MFA.</p>
    public let settings: Settings?

    public init (
        mFAMode: MFAMode? = nil,
        settings: Settings? = nil
    )
    {
        self.mFAMode = mFAMode
        self.settings = settings
    }
}

extension CreateBackendAuthOAuthConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for listofoauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(listofoauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for listof__string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(listof__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for listof__string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(listof__string0)
            }
        }
        if let socialProviderSettings = socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [OAuthScopesElement]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension CreateBackendAuthOAuthConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthOAuthConfig(domainPrefix: \(String(describing: domainPrefix)), oAuthGrantType: \(String(describing: oAuthGrantType)), oAuthScopes: \(String(describing: oAuthScopes)), redirectSignInURIs: \(String(describing: redirectSignInURIs)), redirectSignOutURIs: \(String(describing: redirectSignOutURIs)), socialProviderSettings: \(String(describing: socialProviderSettings)))"}
}

/// <p>Creates the OAuth configuration for your Amplify project.</p>
public struct CreateBackendAuthOAuthConfig: Equatable {
    /// <p>The domain prefix for your Amplify app.</p>
    public let domainPrefix: String?
    /// <p>The OAuth grant type that you use to allow app users to authenticate from your Amplify app.</p>
    public let oAuthGrantType: OAuthGrantType?
    /// <p>List of OAuth-related flows that allow your app users to authenticate from your Amplify app.</p>
    public let oAuthScopes: [OAuthScopesElement]?
    /// <p>The redirected URI for signing in to your Amplify app.</p>
    public let redirectSignInURIs: [String]?
    /// <p>Redirect URLs that OAuth uses when a user signs out of an Amplify app.</p>
    public let redirectSignOutURIs: [String]?
    /// <p>The settings for using social identity providers for access to your Amplify app.</p>
    public let socialProviderSettings: SocialProviderSettings?

    public init (
        domainPrefix: String? = nil,
        oAuthGrantType: OAuthGrantType? = nil,
        oAuthScopes: [OAuthScopesElement]? = nil,
        redirectSignInURIs: [String]? = nil,
        redirectSignOutURIs: [String]? = nil,
        socialProviderSettings: SocialProviderSettings? = nil
    )
    {
        self.domainPrefix = domainPrefix
        self.oAuthGrantType = oAuthGrantType
        self.oAuthScopes = oAuthScopes
        self.redirectSignInURIs = redirectSignInURIs
        self.redirectSignOutURIs = redirectSignOutURIs
        self.socialProviderSettings = socialProviderSettings
    }
}

extension CreateBackendAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendAuthOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension CreateBackendAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAuthOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAuthOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension CreateBackendAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateBackendAuthPasswordPolicyConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for listofadditionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(listofadditionalconstraintselement0.rawValue)
            }
        }
        if minimumLength != 0.0 {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AdditionalConstraintsElement]()
            for string0 in additionalConstraintsContainer {
                if let string0 = string0 {
                    additionalConstraintsDecoded0?.append(string0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decode(Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension CreateBackendAuthPasswordPolicyConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthPasswordPolicyConfig(additionalConstraints: \(String(describing: additionalConstraints)), minimumLength: \(String(describing: minimumLength)))"}
}

/// <p>The password policy configuration for the backend of your Amplify project.</p>
public struct CreateBackendAuthPasswordPolicyConfig: Equatable {
    /// <p>Additional constraints for the password used to access the backend of your Amplify project.</p>
    public let additionalConstraints: [AdditionalConstraintsElement]?
    /// <p>The minimum length of the password used to access the backend of your Amplify project.</p>
    public let minimumLength: Double

    public init (
        additionalConstraints: [AdditionalConstraintsElement]? = nil,
        minimumLength: Double = 0.0
    )
    {
        self.additionalConstraints = additionalConstraints
        self.minimumLength = minimumLength
    }
}

extension CreateBackendAuthResourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(CreateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(CreateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension CreateBackendAuthResourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthResourceConfig(authResources: \(String(describing: authResources)), identityPoolConfigs: \(String(describing: identityPoolConfigs)), service: \(String(describing: service)), userPoolConfigs: \(String(describing: userPoolConfigs)))"}
}

/// <p>Defines the resource configuration when creating an auth resource in your Amplify project.</p>
public struct CreateBackendAuthResourceConfig: Equatable {
    /// <p>Defines whether you want to configure only authentication or both authentication and authorization settings.</p>
    public let authResources: AuthResources?
    /// <p>Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of the auth resource in your Amplify project.</p>
    public let identityPoolConfigs: CreateBackendAuthIdentityPoolConfig?
    /// <p>Defines the service name to use when configuring an authentication resource in your Amplify project.</p>
    public let service: Service?
    /// <p>Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of the auth resource in your Amplify project.</p>
    public let userPoolConfigs: CreateBackendAuthUserPoolConfig?

    public init (
        authResources: AuthResources? = nil,
        identityPoolConfigs: CreateBackendAuthIdentityPoolConfig? = nil,
        service: Service? = nil,
        userPoolConfigs: CreateBackendAuthUserPoolConfig? = nil
    )
    {
        self.authResources = authResources
        self.identityPoolConfigs = identityPoolConfigs
        self.service = service
        self.userPoolConfigs = userPoolConfigs
    }
}

extension CreateBackendAuthUserPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case requiredSignUpAttributes = "requiredSignUpAttributes"
        case signInMethod = "signInMethod"
        case userPoolName = "userPoolName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let requiredSignUpAttributes = requiredSignUpAttributes {
            var requiredSignUpAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredSignUpAttributes)
            for listofrequiredsignupattributeselement0 in requiredSignUpAttributes {
                try requiredSignUpAttributesContainer.encode(listofrequiredsignupattributeselement0.rawValue)
            }
        }
        if let signInMethod = signInMethod {
            try encodeContainer.encode(signInMethod.rawValue, forKey: .signInMethod)
        }
        if let userPoolName = userPoolName {
            try encodeContainer.encode(userPoolName, forKey: .userPoolName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(CreateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(CreateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(CreateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(CreateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let requiredSignUpAttributesContainer = try containerValues.decodeIfPresent([RequiredSignUpAttributesElement?].self, forKey: .requiredSignUpAttributes)
        var requiredSignUpAttributesDecoded0:[RequiredSignUpAttributesElement]? = nil
        if let requiredSignUpAttributesContainer = requiredSignUpAttributesContainer {
            requiredSignUpAttributesDecoded0 = [RequiredSignUpAttributesElement]()
            for string0 in requiredSignUpAttributesContainer {
                if let string0 = string0 {
                    requiredSignUpAttributesDecoded0?.append(string0)
                }
            }
        }
        requiredSignUpAttributes = requiredSignUpAttributesDecoded0
        let signInMethodDecoded = try containerValues.decodeIfPresent(SignInMethod.self, forKey: .signInMethod)
        signInMethod = signInMethodDecoded
        let userPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolName)
        userPoolName = userPoolNameDecoded
    }
}

extension CreateBackendAuthUserPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendAuthUserPoolConfig(forgotPassword: \(String(describing: forgotPassword)), mfa: \(String(describing: mfa)), oAuth: \(String(describing: oAuth)), passwordPolicy: \(String(describing: passwordPolicy)), requiredSignUpAttributes: \(String(describing: requiredSignUpAttributes)), signInMethod: \(String(describing: signInMethod)), userPoolName: \(String(describing: userPoolName)))"}
}

/// <p>Describes the Amazon Cognito user pool configuration for the auth resource to be configured for your Amplify project.</p>
public struct CreateBackendAuthUserPoolConfig: Equatable {
    /// <p>Describes the forgotten password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let forgotPassword: CreateBackendAuthForgotPasswordConfig?
    /// <p>Describes whether to apply multi-factor authentication (MFA) policies for your Amazon Cognito user pool that's configured as a part of your Amplify project.</p>
    public let mfa: CreateBackendAuthMFAConfig?
    /// <p>Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let oAuth: CreateBackendAuthOAuthConfig?
    /// <p>Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let passwordPolicy: CreateBackendAuthPasswordPolicyConfig?
    /// <p>The required attributes to sign up new users in the Amazon Cognito user pool.</p>
    public let requiredSignUpAttributes: [RequiredSignUpAttributesElement]?
    /// <p>Describes the sign-in methods that your Amplify app users to log in using the Amazon Cognito user pool that's configured as a part of your Amplify project.</p>
    public let signInMethod: SignInMethod?
    /// <p>The Amazon Cognito user pool name.</p>
    public let userPoolName: String?

    public init (
        forgotPassword: CreateBackendAuthForgotPasswordConfig? = nil,
        mfa: CreateBackendAuthMFAConfig? = nil,
        oAuth: CreateBackendAuthOAuthConfig? = nil,
        passwordPolicy: CreateBackendAuthPasswordPolicyConfig? = nil,
        requiredSignUpAttributes: [RequiredSignUpAttributesElement]? = nil,
        signInMethod: SignInMethod? = nil,
        userPoolName: String? = nil
    )
    {
        self.forgotPassword = forgotPassword
        self.mfa = mfa
        self.oAuth = oAuth
        self.passwordPolicy = passwordPolicy
        self.requiredSignUpAttributes = requiredSignUpAttributes
        self.signInMethod = signInMethod
        self.userPoolName = userPoolName
    }
}

public struct CreateBackendConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackendConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendConfigOutputError>
}

extension CreateBackendConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendConfigInput(appId: \(String(describing: appId)), backendManagerAppId: \(String(describing: backendManagerAppId)))"}
}

extension CreateBackendConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendManagerAppId = backendManagerAppId {
            try encodeContainer.encode(backendManagerAppId, forKey: .backendManagerAppId)
        }
    }
}

public struct CreateBackendConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendConfigOutputError>
}

public struct CreateBackendConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendConfigOutputError>
}

/// <p>The request body for CreateBackendConfig.</p>
public struct CreateBackendConfigInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The app ID for the backend manager.</p>
    public let backendManagerAppId: String?

    public init (
        appId: String? = nil,
        backendManagerAppId: String? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
    }
}

struct CreateBackendConfigInputBody: Equatable {
    public let backendManagerAppId: String?
}

extension CreateBackendConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
    }
}

extension CreateBackendConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendConfigOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendConfigOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), jobId: \(String(describing: jobId)), status: \(String(describing: status)))"}
}

extension CreateBackendConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendConfigOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        jobId: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendConfigOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let jobId: String?
    public let status: String?
}

extension CreateBackendConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateBackendInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendInput>
    public typealias MOutput = OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendOutputError>
}

extension CreateBackendInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendInput(appId: \(String(describing: appId)), appName: \(String(describing: appName)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension CreateBackendInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appName = appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendInput>
    public typealias MOutput = OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendOutputError>
}

public struct CreateBackendInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendInput>
    public typealias MOutput = OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendOutputError>
}

/// <p>The request body for CreateBackend.</p>
public struct CreateBackendInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the app.</p>
    public let appName: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The resource configuration for the backend creation request.</p>
    public let resourceConfig: ResourceConfig?
    /// <p>The name of the resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        appName: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: ResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendInputBody: Equatable {
    public let appId: String?
    public let appName: String?
    public let backendEnvironmentName: String?
    public let resourceConfig: ResourceConfig?
    public let resourceName: String?
}

extension CreateBackendInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(ResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension CreateBackendOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackendOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension CreateBackendOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenInput(appId: \(String(describing: appId)))"}
}

extension CreateTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateTokenInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTokenInput>
    public typealias MOutput = OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTokenOutputError>
}

public struct CreateTokenInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateTokenInputBody: Equatable {
}

extension CreateTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTokenOutputResponse(appId: \(String(describing: appId)), challengeCode: \(String(describing: challengeCode)), sessionId: \(String(describing: sessionId)), ttl: \(String(describing: ttl)))"}
}

extension CreateTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct CreateTokenOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>One-time challenge code for authenticating into the Amplify Admin UI.</p>
    public let challengeCode: String?
    /// <p>A unique ID provided when creating a new challenge token.</p>
    public let sessionId: String?
    /// <p>The expiry time for the one-time generated token code.</p>
    public let ttl: String?

    public init (
        appId: String? = nil,
        challengeCode: String? = nil,
        sessionId: String? = nil,
        ttl: String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct CreateTokenOutputResponseBody: Equatable {
    public let appId: String?
    public let challengeCode: String?
    public let sessionId: String?
    public let ttl: String?
}

extension CreateTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

public struct DeleteBackendAPIInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAPIOutputError>
}

extension DeleteBackendAPIInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendAPIInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension DeleteBackendAPIInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct DeleteBackendAPIInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAPIOutputError>
}

public struct DeleteBackendAPIInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAPIOutputError>
}

/// <p>The request body for DeleteBackendAPI.</p>
public struct DeleteBackendAPIInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>Defines the resource configuration for the data model in your Amplify project.</p>
    public let resourceConfig: BackendAPIResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: BackendAPIResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct DeleteBackendAPIInputBody: Equatable {
    public let resourceConfig: BackendAPIResourceConfig?
    public let resourceName: String?
}

extension DeleteBackendAPIInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAPIOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAPIOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendAPIOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAPIOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendAPIOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension DeleteBackendAPIOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAPIOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAPIOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension DeleteBackendAPIOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteBackendAuthInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAuthOutputError>
}

extension DeleteBackendAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendAuthInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceName: \(String(describing: resourceName)))"}
}

extension DeleteBackendAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct DeleteBackendAuthInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAuthOutputError>
}

public struct DeleteBackendAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendAuthOutputError>
}

/// <p>The request body for DeleteBackendAuth.</p>
public struct DeleteBackendAuthInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct DeleteBackendAuthInputBody: Equatable {
    public let resourceName: String?
}

extension DeleteBackendAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendAuthOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendAuthOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension DeleteBackendAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAuthOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAuthOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension DeleteBackendAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteBackendInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)))"}
}

extension DeleteBackendInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackendInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendInput>
    public typealias MOutput = OperationOutput<DeleteBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendOutputError>
}

public struct DeleteBackendInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendInput>
    public typealias MOutput = OperationOutput<DeleteBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendOutputError>
}

public struct DeleteBackendInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct DeleteBackendInputBody: Equatable {
}

extension DeleteBackendInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackendOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension DeleteBackendOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackendOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension DeleteBackendOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTokenInput(appId: \(String(describing: appId)), sessionId: \(String(describing: sessionId)))"}
}

extension DeleteTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTokenInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The session ID.</p>
    public let sessionId: String?

    public init (
        appId: String? = nil,
        sessionId: String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct DeleteTokenInputBody: Equatable {
}

extension DeleteTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTokenOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTokenOutputResponse(isSuccess: \(String(describing: isSuccess)))"}
}

extension DeleteTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isSuccess = output.isSuccess
        } else {
            self.isSuccess = false
        }
    }
}

public struct DeleteTokenOutputResponse: Equatable {
    /// <p>Indicates whether the request succeeded or failed.</p>
    public let isSuccess: Bool

    public init (
        isSuccess: Bool = false
    )
    {
        self.isSuccess = isSuccess
    }
}

struct DeleteTokenOutputResponseBody: Equatable {
    public let isSuccess: Bool
}

extension DeleteTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isSuccess = "isSuccess"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSuccessDecoded = try containerValues.decode(Bool.self, forKey: .isSuccess)
        isSuccess = isSuccessDecoded
    }
}

public enum DeliveryMethod {
    case email
    case sms
    case sdkUnknown(String)
}

extension DeliveryMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliveryMethod] {
        return [
            .email,
            .sms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .sms: return "SMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliveryMethod(rawValue: rawValue) ?? DeliveryMethod.sdkUnknown(rawValue)
    }
}

extension EmailSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailMessage = "emailMessage"
        case emailSubject = "emailSubject"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailSubject = emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
    }
}

extension EmailSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailSettings(emailMessage: \(String(describing: emailMessage)), emailSubject: \(String(describing: emailSubject)))"}
}

/// <p>The configuration for the email sent when an app user forgets their password.</p>
public struct EmailSettings: Equatable {
    /// <p>The body of the email.</p>
    public let emailMessage: String?
    /// <p>The subject of the email.</p>
    public let emailSubject: String?

    public init (
        emailMessage: String? = nil,
        emailSubject: String? = nil
    )
    {
        self.emailMessage = emailMessage
        self.emailSubject = emailSubject
    }
}

extension GatewayTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayTimeoutException(message: \(String(describing: message)))"}
}

extension GatewayTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GatewayTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error returned if there's a temporary issue with the service.</p>
public struct GatewayTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>An error message to inform that the request failed.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GatewayTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension GatewayTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GenerateBackendAPIModelsInputBodyMiddleware: Middleware {
    public let id: String = "GenerateBackendAPIModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateBackendAPIModelsOutputError>
}

extension GenerateBackendAPIModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateBackendAPIModelsInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceName: \(String(describing: resourceName)))"}
}

extension GenerateBackendAPIModelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GenerateBackendAPIModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateBackendAPIModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateBackendAPIModelsOutputError>
}

public struct GenerateBackendAPIModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateBackendAPIModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateBackendAPIModelsOutputError>
}

/// <p>The request body for GenerateBackendAPIModels.</p>
public struct GenerateBackendAPIModelsInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GenerateBackendAPIModelsInputBody: Equatable {
    public let resourceName: String?
}

extension GenerateBackendAPIModelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GenerateBackendAPIModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateBackendAPIModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateBackendAPIModelsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateBackendAPIModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateBackendAPIModelsOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension GenerateBackendAPIModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct GenerateBackendAPIModelsOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct GenerateBackendAPIModelsOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension GenerateBackendAPIModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct GetBackendAPIInputBodyMiddleware: Middleware {
    public let id: String = "GetBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIOutputError>
}

extension GetBackendAPIInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAPIInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension GetBackendAPIInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAPIInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIOutputError>
}

public struct GetBackendAPIInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIOutputError>
}

/// <p>The request body for GetBackendAPI.</p>
public struct GetBackendAPIInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>Defines the resource configuration for the data model in your Amplify project.</p>
    public let resourceConfig: BackendAPIResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: BackendAPIResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIInputBody: Equatable {
    public let resourceConfig: BackendAPIResourceConfig?
    public let resourceName: String?
}

extension GetBackendAPIInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendAPIModelsInputBodyMiddleware: Middleware {
    public let id: String = "GetBackendAPIModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIModelsOutputError>
}

extension GetBackendAPIModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAPIModelsInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceName: \(String(describing: resourceName)))"}
}

extension GetBackendAPIModelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAPIModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendAPIModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIModelsOutputError>
}

public struct GetBackendAPIModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendAPIModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAPIModelsOutputError>
}

/// <p>The request body for GetBackendAPIModels.</p>
public struct GetBackendAPIModelsInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAPIModelsInputBody: Equatable {
    public let resourceName: String?
}

extension GetBackendAPIModelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAPIModelsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAPIModelsOutputResponse(models: \(String(describing: models)), status: \(String(describing: status)))"}
}

extension GetBackendAPIModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.models = output.models
            self.status = output.status
        } else {
            self.models = nil
            self.status = nil
        }
    }
}

public struct GetBackendAPIModelsOutputResponse: Equatable {
    /// <p>Stringified JSON of the DataStore model.</p>
    public let models: String?
    /// <p>The current status of the request.</p>
    public let status: Status?

    public init (
        models: String? = nil,
        status: Status? = nil
    )
    {
        self.models = models
        self.status = status
    }
}

struct GetBackendAPIModelsOutputResponseBody: Equatable {
    public let models: String?
    public let status: Status?
}

extension GetBackendAPIModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case models = "models"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .models)
        models = modelsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetBackendAPIOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAPIOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAPIOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension GetBackendAPIOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAPIOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The resource configuration for this response object.</p>
    public let resourceConfig: BackendAPIResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        resourceConfig: BackendAPIResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let resourceConfig: BackendAPIResourceConfig?
    public let resourceName: String?
}

extension GetBackendAPIOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendAuthInputBodyMiddleware: Middleware {
    public let id: String = "GetBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAuthOutputError>
}

extension GetBackendAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAuthInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceName: \(String(describing: resourceName)))"}
}

extension GetBackendAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAuthInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAuthOutputError>
}

public struct GetBackendAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendAuthOutputError>
}

/// <p>The request body for GetBackendAuth.</p>
public struct GetBackendAuthInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAuthInputBody: Equatable {
    public let resourceName: String?
}

extension GetBackendAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAuthOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendAuthOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension GetBackendAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAuthOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The resource configuration for authorization requests to the backend of your Amplify project.</p>
    public let resourceConfig: CreateBackendAuthResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        resourceConfig: CreateBackendAuthResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAuthOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let resourceConfig: CreateBackendAuthResourceConfig?
    public let resourceName: String?
}

extension GetBackendAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendInputBodyMiddleware: Middleware {
    public let id: String = "GetBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendInput>
    public typealias MOutput = OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendOutputError>
}

extension GetBackendInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)))"}
}

extension GetBackendInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
    }
}

public struct GetBackendInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendInput>
    public typealias MOutput = OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendOutputError>
}

public struct GetBackendInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendInput>
    public typealias MOutput = OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendOutputError>
}

/// <p>The request body for GetBackend.</p>
public struct GetBackendInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct GetBackendInputBody: Equatable {
    public let backendEnvironmentName: String?
}

extension GetBackendInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
    }
}

extension GetBackendJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendJobInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), jobId: \(String(describing: jobId)))"}
}

extension GetBackendJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackendJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendJobInput>
    public typealias MOutput = OperationOutput<GetBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendJobOutputError>
}

public struct GetBackendJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendJobInput>
    public typealias MOutput = OperationOutput<GetBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendJobOutputError>
}

public struct GetBackendJobInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        jobId: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
    }
}

struct GetBackendJobInputBody: Equatable {
}

extension GetBackendJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackendJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendJobOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), createTime: \(String(describing: createTime)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)), updateTime: \(String(describing: updateTime)))"}
}

extension GetBackendJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetBackendJobOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The time when the job was created.</p>
    public let createTime: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?
    /// <p>The time when the job was last updated.</p>
    public let updateTime: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        createTime: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil,
        updateTime: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetBackendJobOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let createTime: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
    public let updateTime: String?
}

extension GetBackendJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GetBackendOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendOutputResponse(amplifyMetaConfig: \(String(describing: amplifyMetaConfig)), appId: \(String(describing: appId)), appName: \(String(describing: appName)), backendEnvironmentList: \(String(describing: backendEnvironmentList)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)))"}
}

extension GetBackendOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.amplifyMetaConfig = output.amplifyMetaConfig
            self.appId = output.appId
            self.appName = output.appName
            self.backendEnvironmentList = output.backendEnvironmentList
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
        } else {
            self.amplifyMetaConfig = nil
            self.appId = nil
            self.appName = nil
            self.backendEnvironmentList = nil
            self.backendEnvironmentName = nil
            self.error = nil
        }
    }
}

public struct GetBackendOutputResponse: Equatable {
    /// <p>A stringified version of the current configurations for your Amplify project.</p>
    public let amplifyMetaConfig: String?
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the app.</p>
    public let appName: String?
    /// <p>A list of backend environments in an array.</p>
    public let backendEnvironmentList: [String]?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?

    public init (
        amplifyMetaConfig: String? = nil,
        appId: String? = nil,
        appName: String? = nil,
        backendEnvironmentList: [String]? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil
    )
    {
        self.amplifyMetaConfig = amplifyMetaConfig
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentList = backendEnvironmentList
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
    }
}

struct GetBackendOutputResponseBody: Equatable {
    public let amplifyMetaConfig: String?
    public let appId: String?
    public let appName: String?
    public let backendEnvironmentList: [String]?
    public let backendEnvironmentName: String?
    public let error: String?
}

extension GetBackendOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case amplifyMetaConfig = "amplifyMetaConfig"
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentList = "backendEnvironmentList"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplifyMetaConfigDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amplifyMetaConfig)
        amplifyMetaConfig = amplifyMetaConfigDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .backendEnvironmentList)
        var backendEnvironmentListDecoded0:[String]? = nil
        if let backendEnvironmentListContainer = backendEnvironmentListContainer {
            backendEnvironmentListDecoded0 = [String]()
            for string0 in backendEnvironmentListContainer {
                if let string0 = string0 {
                    backendEnvironmentListDecoded0?.append(string0)
                }
            }
        }
        backendEnvironmentList = backendEnvironmentListDecoded0
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

extension GetTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTokenInput(appId: \(String(describing: appId)), sessionId: \(String(describing: sessionId)))"}
}

extension GetTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTokenInput>
    public typealias MOutput = OperationOutput<GetTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTokenOutputError>
}

public struct GetTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTokenInput>
    public typealias MOutput = OperationOutput<GetTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTokenOutputError>
}

public struct GetTokenInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The session ID.</p>
    public let sessionId: String?

    public init (
        appId: String? = nil,
        sessionId: String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct GetTokenInputBody: Equatable {
}

extension GetTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTokenOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTokenOutputResponse(appId: \(String(describing: appId)), challengeCode: \(String(describing: challengeCode)), sessionId: \(String(describing: sessionId)), ttl: \(String(describing: ttl)))"}
}

extension GetTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct GetTokenOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The one-time challenge code for authenticating into the Amplify Admin UI.</p>
    public let challengeCode: String?
    /// <p>A unique ID provided when creating a new challenge token.</p>
    public let sessionId: String?
    /// <p>The expiry time for the one-time generated token code.</p>
    public let ttl: String?

    public init (
        appId: String? = nil,
        challengeCode: String? = nil,
        sessionId: String? = nil,
        ttl: String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct GetTokenOutputResponseBody: Equatable {
    public let appId: String?
    public let challengeCode: String?
    public let sessionId: String?
    public let ttl: String?
}

extension GetTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

public struct ListBackendJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListBackendJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackendJobsOutputError>
}

extension ListBackendJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackendJobsInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension ListBackendJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct ListBackendJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackendJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackendJobsOutputError>
}

public struct ListBackendJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackendJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackendJobsOutputError>
}

/// <p>The request body for ListBackendJobs.</p>
public struct ListBackendJobsInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The maximum number of results that you want in the response.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>Filters the list of response objects to include only those with the specified operation name.</p>
    public let operation: String?
    /// <p>Filters the list of response objects to include only those with the specified status.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        jobId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operation = operation
        self.status = status
    }
}

struct ListBackendJobsInputBody: Equatable {
    public let jobId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let operation: String?
    public let status: String?
}

extension ListBackendJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListBackendJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackendJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackendJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackendJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackendJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackendJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackendJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackendJobsOutputResponse: Equatable {
    /// <p>An array of jobs and their properties.</p>
    public let jobs: [BackendJobRespObj]?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        jobs: [BackendJobRespObj]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListBackendJobsOutputResponseBody: Equatable {
    public let jobs: [BackendJobRespObj]?
    public let nextToken: String?
}

extension ListBackendJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "jobs"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([BackendJobRespObj?].self, forKey: .jobs)
        var jobsDecoded0:[BackendJobRespObj]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [BackendJobRespObj]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LoginAuthConfigReqObj: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsCognitoIdentityPoolId = "aws_cognito_identity_pool_id"
        case awsCognitoRegion = "aws_cognito_region"
        case awsUserPoolsId = "aws_user_pools_id"
        case awsUserPoolsWebClientId = "aws_user_pools_web_client_id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCognitoIdentityPoolId = awsCognitoIdentityPoolId {
            try encodeContainer.encode(awsCognitoIdentityPoolId, forKey: .awsCognitoIdentityPoolId)
        }
        if let awsCognitoRegion = awsCognitoRegion {
            try encodeContainer.encode(awsCognitoRegion, forKey: .awsCognitoRegion)
        }
        if let awsUserPoolsId = awsUserPoolsId {
            try encodeContainer.encode(awsUserPoolsId, forKey: .awsUserPoolsId)
        }
        if let awsUserPoolsWebClientId = awsUserPoolsWebClientId {
            try encodeContainer.encode(awsUserPoolsWebClientId, forKey: .awsUserPoolsWebClientId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsCognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsCognitoIdentityPoolId)
        awsCognitoIdentityPoolId = awsCognitoIdentityPoolIdDecoded
        let awsCognitoRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsCognitoRegion)
        awsCognitoRegion = awsCognitoRegionDecoded
        let awsUserPoolsIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsUserPoolsId)
        awsUserPoolsId = awsUserPoolsIdDecoded
        let awsUserPoolsWebClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsUserPoolsWebClientId)
        awsUserPoolsWebClientId = awsUserPoolsWebClientIdDecoded
    }
}

extension LoginAuthConfigReqObj: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoginAuthConfigReqObj(awsCognitoIdentityPoolId: \(String(describing: awsCognitoIdentityPoolId)), awsCognitoRegion: \(String(describing: awsCognitoRegion)), awsUserPoolsId: \(String(describing: awsUserPoolsId)), awsUserPoolsWebClientId: \(String(describing: awsUserPoolsWebClientId)))"}
}

/// <p>The request object for this operation.</p>
public struct LoginAuthConfigReqObj: Equatable {
    /// <p>The Amazon Cognito identity pool ID used for Amplify Admin UI login authorization.</p>
    public let awsCognitoIdentityPoolId: String?
    /// <p>The AWS Region for the Amplify Admin UI login.</p>
    public let awsCognitoRegion: String?
    /// <p>The Amazon Cognito user pool ID used for Amplify Admin UI login authentication.</p>
    public let awsUserPoolsId: String?
    /// <p>The web client ID for the Amazon Cognito user pools.</p>
    public let awsUserPoolsWebClientId: String?

    public init (
        awsCognitoIdentityPoolId: String? = nil,
        awsCognitoRegion: String? = nil,
        awsUserPoolsId: String? = nil,
        awsUserPoolsWebClientId: String? = nil
    )
    {
        self.awsCognitoIdentityPoolId = awsCognitoIdentityPoolId
        self.awsCognitoRegion = awsCognitoRegion
        self.awsUserPoolsId = awsUserPoolsId
        self.awsUserPoolsWebClientId = awsUserPoolsWebClientId
    }
}

public enum MFAMode {
    case off
    case on
    case `optional`
    case sdkUnknown(String)
}

extension MFAMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MFAMode] {
        return [
            .off,
            .on,
            .optional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .on: return "ON"
        case .optional: return "OPTIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MFAMode(rawValue: rawValue) ?? MFAMode.sdkUnknown(rawValue)
    }
}

public enum MfaTypesElement {
    case sms
    case totp
    case sdkUnknown(String)
}

extension MfaTypesElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MfaTypesElement] {
        return [
            .sms,
            .totp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sms: return "SMS"
        case .totp: return "TOTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MfaTypesElement(rawValue: rawValue) ?? MfaTypesElement.sdkUnknown(rawValue)
    }
}

public enum Mode {
    case amazonCognitoUserPools
    case apiKey
    case awsIam
    case openidConnect
    case sdkUnknown(String)
}

extension Mode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mode] {
        return [
            .amazonCognitoUserPools,
            .apiKey,
            .awsIam,
            .openidConnect,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
        case .apiKey: return "API_KEY"
        case .awsIam: return "AWS_IAM"
        case .openidConnect: return "OPENID_CONNECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error returned when a specific resource type is not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>An error message to inform that the request failed.</p>
    public var message: String?
    /// <p>The type of resource that wasn't found.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum OAuthGrantType {
    case code
    case implicit
    case sdkUnknown(String)
}

extension OAuthGrantType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OAuthGrantType] {
        return [
            .code,
            .implicit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .code: return "CODE"
        case .implicit: return "IMPLICIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OAuthGrantType(rawValue: rawValue) ?? OAuthGrantType.sdkUnknown(rawValue)
    }
}

public enum OAuthScopesElement {
    case awsCognitoSigninUserAdmin
    case email
    case openid
    case phone
    case profile
    case sdkUnknown(String)
}

extension OAuthScopesElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OAuthScopesElement] {
        return [
            .awsCognitoSigninUserAdmin,
            .email,
            .openid,
            .phone,
            .profile,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsCognitoSigninUserAdmin: return "AWS_COGNITO_SIGNIN_USER_ADMIN"
        case .email: return "EMAIL"
        case .openid: return "OPENID"
        case .phone: return "PHONE"
        case .profile: return "PROFILE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OAuthScopesElement(rawValue: rawValue) ?? OAuthScopesElement.sdkUnknown(rawValue)
    }
}

public struct RemoveAllBackendsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveAllBackendsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAllBackendsOutputError>
}

extension RemoveAllBackendsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAllBackendsInput(appId: \(String(describing: appId)), cleanAmplifyApp: \(String(describing: cleanAmplifyApp)))"}
}

extension RemoveAllBackendsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cleanAmplifyApp != false {
            try encodeContainer.encode(cleanAmplifyApp, forKey: .cleanAmplifyApp)
        }
    }
}

public struct RemoveAllBackendsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveAllBackendsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAllBackendsOutputError>
}

public struct RemoveAllBackendsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveAllBackendsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAllBackendsOutputError>
}

/// <p>The request body for RemoveAllBackends.</p>
public struct RemoveAllBackendsInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>Cleans up the Amplify Console app if this value is set to true.</p>
    public let cleanAmplifyApp: Bool

    public init (
        appId: String? = nil,
        cleanAmplifyApp: Bool = false
    )
    {
        self.appId = appId
        self.cleanAmplifyApp = cleanAmplifyApp
    }
}

struct RemoveAllBackendsInputBody: Equatable {
    public let cleanAmplifyApp: Bool
}

extension RemoveAllBackendsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cleanAmplifyAppDecoded = try containerValues.decode(Bool.self, forKey: .cleanAmplifyApp)
        cleanAmplifyApp = cleanAmplifyAppDecoded
    }
}

extension RemoveAllBackendsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAllBackendsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAllBackendsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAllBackendsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAllBackendsOutputResponse(appId: \(String(describing: appId)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension RemoveAllBackendsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveAllBackendsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct RemoveAllBackendsOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct RemoveAllBackendsOutputResponseBody: Equatable {
    public let appId: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension RemoveAllBackendsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RemoveBackendConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveBackendConfigInput(appId: \(String(describing: appId)))"}
}

extension RemoveBackendConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveBackendConfigInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveBackendConfigInput>
    public typealias MOutput = OperationOutput<RemoveBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveBackendConfigOutputError>
}

public struct RemoveBackendConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveBackendConfigInput>
    public typealias MOutput = OperationOutput<RemoveBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveBackendConfigOutputError>
}

public struct RemoveBackendConfigInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct RemoveBackendConfigInputBody: Equatable {
}

extension RemoveBackendConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveBackendConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveBackendConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveBackendConfigOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveBackendConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveBackendConfigOutputResponse(error: \(String(describing: error)))"}
}

extension RemoveBackendConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
        } else {
            self.error = nil
        }
    }
}

public struct RemoveBackendConfigOutputResponse: Equatable {
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?

    public init (
        error: String? = nil
    )
    {
        self.error = error
    }
}

struct RemoveBackendConfigOutputResponseBody: Equatable {
    public let error: String?
}

extension RemoveBackendConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error = "error"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

public enum RequiredSignUpAttributesElement {
    case address
    case birthdate
    case email
    case familyName
    case gender
    case givenName
    case locale
    case middleName
    case name
    case nickname
    case phoneNumber
    case picture
    case preferredUsername
    case profile
    case updatedAt
    case website
    case zoneInfo
    case sdkUnknown(String)
}

extension RequiredSignUpAttributesElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequiredSignUpAttributesElement] {
        return [
            .address,
            .birthdate,
            .email,
            .familyName,
            .gender,
            .givenName,
            .locale,
            .middleName,
            .name,
            .nickname,
            .phoneNumber,
            .picture,
            .preferredUsername,
            .profile,
            .updatedAt,
            .website,
            .zoneInfo,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .address: return "ADDRESS"
        case .birthdate: return "BIRTHDATE"
        case .email: return "EMAIL"
        case .familyName: return "FAMILY_NAME"
        case .gender: return "GENDER"
        case .givenName: return "GIVEN_NAME"
        case .locale: return "LOCALE"
        case .middleName: return "MIDDLE_NAME"
        case .name: return "NAME"
        case .nickname: return "NICKNAME"
        case .phoneNumber: return "PHONE_NUMBER"
        case .picture: return "PICTURE"
        case .preferredUsername: return "PREFERRED_USERNAME"
        case .profile: return "PROFILE"
        case .updatedAt: return "UPDATED_AT"
        case .website: return "WEBSITE"
        case .zoneInfo: return "ZONE_INFO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequiredSignUpAttributesElement(rawValue: rawValue) ?? RequiredSignUpAttributesElement.sdkUnknown(rawValue)
    }
}

public enum ResolutionStrategy {
    case automerge
    case lambda
    case `none`
    case optimisticConcurrency
    case sdkUnknown(String)
}

extension ResolutionStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolutionStrategy] {
        return [
            .automerge,
            .lambda,
            .none,
            .optimisticConcurrency,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automerge: return "AUTOMERGE"
        case .lambda: return "LAMBDA"
        case .none: return "NONE"
        case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolutionStrategy(rawValue: rawValue) ?? ResolutionStrategy.sdkUnknown(rawValue)
    }
}

extension ResourceConfig: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConfig()"}
}

/// <p>Defines the resource configuration for the data model in your Amplify project.</p>
public struct ResourceConfig: Equatable {

    public init() {}
}

public enum Service {
    case cognito
    case sdkUnknown(String)
}

extension Service : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Service] {
        return [
            .cognito,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cognito: return "COGNITO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
    }
}

extension Settings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mfaTypes = "mfaTypes"
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaTypes = mfaTypes {
            var mfaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mfaTypes)
            for listofmfatypeselement0 in mfaTypes {
                try mfaTypesContainer.encode(listofmfatypeselement0.rawValue)
            }
        }
        if let smsMessage = smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaTypesContainer = try containerValues.decodeIfPresent([MfaTypesElement?].self, forKey: .mfaTypes)
        var mfaTypesDecoded0:[MfaTypesElement]? = nil
        if let mfaTypesContainer = mfaTypesContainer {
            mfaTypesDecoded0 = [MfaTypesElement]()
            for string0 in mfaTypesContainer {
                if let string0 = string0 {
                    mfaTypesDecoded0?.append(string0)
                }
            }
        }
        mfaTypes = mfaTypesDecoded0
        let smsMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension Settings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Settings(mfaTypes: \(String(describing: mfaTypes)), smsMessage: \(String(describing: smsMessage)))"}
}

/// <p>The settings of your MFA configuration for the backend of your Amplify project.</p>
public struct Settings: Equatable {
    /// <p>The supported MFA types.</p>
    public let mfaTypes: [MfaTypesElement]?
    /// <p>The body of the SMS message.</p>
    public let smsMessage: String?

    public init (
        mfaTypes: [MfaTypesElement]? = nil,
        smsMessage: String? = nil
    )
    {
        self.mfaTypes = mfaTypes
        self.smsMessage = smsMessage
    }
}

public enum SignInMethod {
    case email
    case emailAndPhoneNumber
    case phoneNumber
    case username
    case sdkUnknown(String)
}

extension SignInMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SignInMethod] {
        return [
            .email,
            .emailAndPhoneNumber,
            .phoneNumber,
            .username,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .emailAndPhoneNumber: return "EMAIL_AND_PHONE_NUMBER"
        case .phoneNumber: return "PHONE_NUMBER"
        case .username: return "USERNAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SignInMethod(rawValue: rawValue) ?? SignInMethod.sdkUnknown(rawValue)
    }
}

extension SmsSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let smsMessage = smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension SmsSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SmsSettings(smsMessage: \(String(describing: smsMessage)))"}
}

/// <p>SMS settings for authentication.</p>
public struct SmsSettings: Equatable {
    /// <p>The body of the SMS message.</p>
    public let smsMessage: String?

    public init (
        smsMessage: String? = nil
    )
    {
        self.smsMessage = smsMessage
    }
}

extension SocialProviderSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facebook = facebook {
            try encodeContainer.encode(facebook, forKey: .facebook)
        }
        if let google = google {
            try encodeContainer.encode(google, forKey: .google)
        }
        if let loginWithAmazon = loginWithAmazon {
            try encodeContainer.encode(loginWithAmazon, forKey: .loginWithAmazon)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facebookDecoded = try containerValues.decodeIfPresent(BackendAuthSocialProviderConfig.self, forKey: .facebook)
        facebook = facebookDecoded
        let googleDecoded = try containerValues.decodeIfPresent(BackendAuthSocialProviderConfig.self, forKey: .google)
        google = googleDecoded
        let loginWithAmazonDecoded = try containerValues.decodeIfPresent(BackendAuthSocialProviderConfig.self, forKey: .loginWithAmazon)
        loginWithAmazon = loginWithAmazonDecoded
    }
}

extension SocialProviderSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SocialProviderSettings(facebook: \(String(describing: facebook)), google: \(String(describing: google)), loginWithAmazon: \(String(describing: loginWithAmazon)))"}
}

/// <p>The settings for using the social identity providers for access to your Amplify app.</p>
public struct SocialProviderSettings: Equatable {
    /// <p>Describes third-party social federation configurations for allowing your app users to sign in using OAuth.</p>
    public let facebook: BackendAuthSocialProviderConfig?
    /// <p>Describes third-party social federation configurations for allowing your app users to sign in using OAuth.</p>
    public let google: BackendAuthSocialProviderConfig?
    /// <p>Describes third-party social federation configurations for allowing your app users to sign in using OAuth.</p>
    public let loginWithAmazon: BackendAuthSocialProviderConfig?

    public init (
        facebook: BackendAuthSocialProviderConfig? = nil,
        google: BackendAuthSocialProviderConfig? = nil,
        loginWithAmazon: BackendAuthSocialProviderConfig? = nil
    )
    {
        self.facebook = facebook
        self.google = google
        self.loginWithAmazon = loginWithAmazon
    }
}

public enum Status {
    case latest
    case stale
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .latest,
            .stale,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .latest: return "LATEST"
        case .stale: return "STALE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(limitType: \(String(describing: limitType)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limitType = output.limitType
            self.message = output.message
        } else {
            self.limitType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error that is returned when a limit of a specific type is exceeded.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The type of limit that was exceeded.</p>
    public var limitType: String?
    /// <p>An error message to inform that the request failed.</p>
    public var message: String?

    public init (
        limitType: String? = nil,
        message: String? = nil
    )
    {
        self.limitType = limitType
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let limitType: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateBackendAPIInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAPIOutputError>
}

extension UpdateBackendAPIInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAPIInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension UpdateBackendAPIInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct UpdateBackendAPIInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAPIOutputError>
}

public struct UpdateBackendAPIInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAPIOutputError>
}

/// <p>The request body for UpdateBackendAPI.</p>
public struct UpdateBackendAPIInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>Defines the resource configuration for the data model in your Amplify project.</p>
    public let resourceConfig: BackendAPIResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: BackendAPIResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAPIInputBody: Equatable {
    public let resourceConfig: BackendAPIResourceConfig?
    public let resourceName: String?
}

extension UpdateBackendAPIInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendAPIOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAPIOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendAPIOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAPIOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAPIOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension UpdateBackendAPIOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAPIOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAPIOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension UpdateBackendAPIOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendAuthForgotPasswordConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension UpdateBackendAuthForgotPasswordConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthForgotPasswordConfig(deliveryMethod: \(String(describing: deliveryMethod)), emailSettings: \(String(describing: emailSettings)), smsSettings: \(String(describing: smsSettings)))"}
}

/// <p>Describes the forgot password policy for authenticating into the Amplify app.</p>
public struct UpdateBackendAuthForgotPasswordConfig: Equatable {
    /// <p>Describes which method to use (either SMS or email) to deliver messages to app users that want to recover their password.</p>
    public let deliveryMethod: DeliveryMethod?
    /// <p>The configuration for the email sent when an app user forgets their password.</p>
    public let emailSettings: EmailSettings?
    /// <p>The configuration for the SMS message sent when an Amplify app user forgets their password.</p>
    public let smsSettings: SmsSettings?

    public init (
        deliveryMethod: DeliveryMethod? = nil,
        emailSettings: EmailSettings? = nil,
        smsSettings: SmsSettings? = nil
    )
    {
        self.deliveryMethod = deliveryMethod
        self.emailSettings = emailSettings
        self.smsSettings = smsSettings
    }
}

extension UpdateBackendAuthIdentityPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if unauthenticatedLogin != false {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unauthenticatedLoginDecoded = try containerValues.decode(Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension UpdateBackendAuthIdentityPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthIdentityPoolConfig(unauthenticatedLogin: \(String(describing: unauthenticatedLogin)))"}
}

/// <p>Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.</p>
public struct UpdateBackendAuthIdentityPoolConfig: Equatable {
    /// <p>A Boolean value that you can set to allow or disallow guest-level authorization into your Amplify app.</p>
    public let unauthenticatedLogin: Bool

    public init (
        unauthenticatedLogin: Bool = false
    )
    {
        self.unauthenticatedLogin = unauthenticatedLogin
    }
}

public struct UpdateBackendAuthInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAuthOutputError>
}

extension UpdateBackendAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), resourceConfig: \(String(describing: resourceConfig)), resourceName: \(String(describing: resourceName)))"}
}

extension UpdateBackendAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct UpdateBackendAuthInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAuthOutputError>
}

public struct UpdateBackendAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendAuthOutputError>
}

/// <p>The request body for UpdateBackendAuth.</p>
public struct UpdateBackendAuthInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The resource configuration for this request object.</p>
    public let resourceConfig: UpdateBackendAuthResourceConfig?
    /// <p>The name of this resource.</p>
    public let resourceName: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        resourceConfig: UpdateBackendAuthResourceConfig? = nil,
        resourceName: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAuthInputBody: Equatable {
    public let resourceConfig: UpdateBackendAuthResourceConfig?
    public let resourceName: String?
}

extension UpdateBackendAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendAuthMFAConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mFAMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mFAMode = mFAMode {
            try encodeContainer.encode(mFAMode.rawValue, forKey: .mFAMode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFAModeDecoded = try containerValues.decodeIfPresent(MFAMode.self, forKey: .mFAMode)
        mFAMode = mFAModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension UpdateBackendAuthMFAConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthMFAConfig(mFAMode: \(String(describing: mFAMode)), settings: \(String(describing: settings)))"}
}

/// <p>Updates the multi-factor authentication (MFA) configuration for the backend of your Amplify project.</p>
public struct UpdateBackendAuthMFAConfig: Equatable {
    /// <p>The MFA mode for the backend of your Amplify project.</p>
    public let mFAMode: MFAMode?
    /// <p>The settings of your MFA configuration for the backend of your Amplify project.</p>
    public let settings: Settings?

    public init (
        mFAMode: MFAMode? = nil,
        settings: Settings? = nil
    )
    {
        self.mFAMode = mFAMode
        self.settings = settings
    }
}

extension UpdateBackendAuthOAuthConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for listofoauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(listofoauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for listof__string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(listof__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for listof__string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(listof__string0)
            }
        }
        if let socialProviderSettings = socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [OAuthScopesElement]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension UpdateBackendAuthOAuthConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthOAuthConfig(domainPrefix: \(String(describing: domainPrefix)), oAuthGrantType: \(String(describing: oAuthGrantType)), oAuthScopes: \(String(describing: oAuthScopes)), redirectSignInURIs: \(String(describing: redirectSignInURIs)), redirectSignOutURIs: \(String(describing: redirectSignOutURIs)), socialProviderSettings: \(String(describing: socialProviderSettings)))"}
}

/// <p>The OAuth configurations for authenticating users into your Amplify app.</p>
public struct UpdateBackendAuthOAuthConfig: Equatable {
    /// <p>The Amazon Cognito domain prefix used to create a hosted UI for authentication.</p>
    public let domainPrefix: String?
    /// <p>The OAuth grant type to allow app users to authenticate from your Amplify app.</p>
    public let oAuthGrantType: OAuthGrantType?
    /// <p>The list of OAuth-related flows that can allow users to authenticate from your Amplify app.</p>
    public let oAuthScopes: [OAuthScopesElement]?
    /// <p>Redirect URLs that OAuth uses when a user signs in to an Amplify app.</p>
    public let redirectSignInURIs: [String]?
    /// <p>Redirect URLs that OAuth uses when a user signs out of an Amplify app.</p>
    public let redirectSignOutURIs: [String]?
    /// <p>Describes third-party social federation configurations for allowing your users to sign in with OAuth.</p>
    public let socialProviderSettings: SocialProviderSettings?

    public init (
        domainPrefix: String? = nil,
        oAuthGrantType: OAuthGrantType? = nil,
        oAuthScopes: [OAuthScopesElement]? = nil,
        redirectSignInURIs: [String]? = nil,
        redirectSignOutURIs: [String]? = nil,
        socialProviderSettings: SocialProviderSettings? = nil
    )
    {
        self.domainPrefix = domainPrefix
        self.oAuthGrantType = oAuthGrantType
        self.oAuthScopes = oAuthScopes
        self.redirectSignInURIs = redirectSignInURIs
        self.redirectSignOutURIs = redirectSignOutURIs
        self.socialProviderSettings = socialProviderSettings
    }
}

extension UpdateBackendAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendAuthOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension UpdateBackendAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAuthOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAuthOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
}

extension UpdateBackendAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendAuthPasswordPolicyConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for listofadditionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(listofadditionalconstraintselement0.rawValue)
            }
        }
        if minimumLength != 0.0 {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AdditionalConstraintsElement]()
            for string0 in additionalConstraintsContainer {
                if let string0 = string0 {
                    additionalConstraintsDecoded0?.append(string0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decode(Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension UpdateBackendAuthPasswordPolicyConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthPasswordPolicyConfig(additionalConstraints: \(String(describing: additionalConstraints)), minimumLength: \(String(describing: minimumLength)))"}
}

/// <p>Describes the password policy for your Amazon Cognito user pool that's configured as a part of your Amplify project.</p>
public struct UpdateBackendAuthPasswordPolicyConfig: Equatable {
    /// <p>Describes additional constrains on the password requirements to sign in to the auth resource, configured as a part of your Amplify project.</p>
    public let additionalConstraints: [AdditionalConstraintsElement]?
    /// <p>Describes the minimum length of the password required to sign in to the auth resource, configured as a part of your Amplify project.</p>
    public let minimumLength: Double

    public init (
        additionalConstraints: [AdditionalConstraintsElement]? = nil,
        minimumLength: Double = 0.0
    )
    {
        self.additionalConstraints = additionalConstraints
        self.minimumLength = minimumLength
    }
}

extension UpdateBackendAuthResourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension UpdateBackendAuthResourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthResourceConfig(authResources: \(String(describing: authResources)), identityPoolConfigs: \(String(describing: identityPoolConfigs)), service: \(String(describing: service)), userPoolConfigs: \(String(describing: userPoolConfigs)))"}
}

/// <p>Defines the resource configuration when updating an authentication resource in your Amplify project.</p>
public struct UpdateBackendAuthResourceConfig: Equatable {
    /// <p>Defines the service name to use when configuring an authentication resource in your Amplify project.</p>
    public let authResources: AuthResources?
    /// <p>Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of the auth resource in your Amplify project.</p>
    public let identityPoolConfigs: UpdateBackendAuthIdentityPoolConfig?
    /// <p>Defines the service name to use when configuring an authentication resource in your Amplify project.</p>
    public let service: Service?
    /// <p>Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of the auth resource in your Amplify project.</p>
    public let userPoolConfigs: UpdateBackendAuthUserPoolConfig?

    public init (
        authResources: AuthResources? = nil,
        identityPoolConfigs: UpdateBackendAuthIdentityPoolConfig? = nil,
        service: Service? = nil,
        userPoolConfigs: UpdateBackendAuthUserPoolConfig? = nil
    )
    {
        self.authResources = authResources
        self.identityPoolConfigs = identityPoolConfigs
        self.service = service
        self.userPoolConfigs = userPoolConfigs
    }
}

extension UpdateBackendAuthUserPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(UpdateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

extension UpdateBackendAuthUserPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendAuthUserPoolConfig(forgotPassword: \(String(describing: forgotPassword)), mfa: \(String(describing: mfa)), oAuth: \(String(describing: oAuth)), passwordPolicy: \(String(describing: passwordPolicy)))"}
}

/// <p>Describes the Amazon Cognito user pool configuration to configure the authorization resource for your Amplify project on an update.</p>
public struct UpdateBackendAuthUserPoolConfig: Equatable {
    /// <p>Describes the forgot password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let forgotPassword: UpdateBackendAuthForgotPasswordConfig?
    /// <p>Describes whether to apply multi-factor authentication (MFA) policies for your Amazon Cognito user pool that's configured as a part of your Amplify project.</p>
    public let mfa: UpdateBackendAuthMFAConfig?
    /// <p>Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let oAuth: UpdateBackendAuthOAuthConfig?
    /// <p>Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.</p>
    public let passwordPolicy: UpdateBackendAuthPasswordPolicyConfig?

    public init (
        forgotPassword: UpdateBackendAuthForgotPasswordConfig? = nil,
        mfa: UpdateBackendAuthMFAConfig? = nil,
        oAuth: UpdateBackendAuthOAuthConfig? = nil,
        passwordPolicy: UpdateBackendAuthPasswordPolicyConfig? = nil
    )
    {
        self.forgotPassword = forgotPassword
        self.mfa = mfa
        self.oAuth = oAuth
        self.passwordPolicy = passwordPolicy
    }
}

public struct UpdateBackendConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBackendConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendConfigOutputError>
}

extension UpdateBackendConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendConfigInput(appId: \(String(describing: appId)), loginAuthConfig: \(String(describing: loginAuthConfig)))"}
}

extension UpdateBackendConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loginAuthConfig = loginAuthConfig {
            try encodeContainer.encode(loginAuthConfig, forKey: .loginAuthConfig)
        }
    }
}

public struct UpdateBackendConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendConfigOutputError>
}

public struct UpdateBackendConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendConfigOutputError>
}

/// <p>The request body for UpdateBackendConfig.</p>
public struct UpdateBackendConfigInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>Describes the Amazon Cognito configuration for Admin UI access.</p>
    public let loginAuthConfig: LoginAuthConfigReqObj?

    public init (
        appId: String? = nil,
        loginAuthConfig: LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigInputBody: Equatable {
    public let loginAuthConfig: LoginAuthConfigReqObj?
}

extension UpdateBackendConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

extension UpdateBackendConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendConfigOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendConfigOutputResponse(appId: \(String(describing: appId)), backendManagerAppId: \(String(describing: backendManagerAppId)), error: \(String(describing: error)), loginAuthConfig: \(String(describing: loginAuthConfig)))"}
}

extension UpdateBackendConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendManagerAppId = output.backendManagerAppId
            self.error = output.error
            self.loginAuthConfig = output.loginAuthConfig
        } else {
            self.appId = nil
            self.backendManagerAppId = nil
            self.error = nil
            self.loginAuthConfig = nil
        }
    }
}

public struct UpdateBackendConfigOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The app ID for the backend manager.</p>
    public let backendManagerAppId: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>Describes the Amazon Cognito configurations for the Admin UI auth resource to log in with.</p>
    public let loginAuthConfig: LoginAuthConfigReqObj?

    public init (
        appId: String? = nil,
        backendManagerAppId: String? = nil,
        error: String? = nil,
        loginAuthConfig: LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
        self.error = error
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigOutputResponseBody: Equatable {
    public let appId: String?
    public let backendManagerAppId: String?
    public let error: String?
    public let loginAuthConfig: LoginAuthConfigReqObj?
}

extension UpdateBackendConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendManagerAppId = "backendManagerAppId"
        case error = "error"
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

public struct UpdateBackendJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBackendJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendJobOutputError>
}

extension UpdateBackendJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendJobInput(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)))"}
}

extension UpdateBackendJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct UpdateBackendJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBackendJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendJobOutputError>
}

public struct UpdateBackendJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBackendJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBackendJobOutputError>
}

/// <p>The request body for GetBackendJob.</p>
public struct UpdateBackendJobInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>Filters the list of response objects to include only those with the specified operation name.</p>
    public let operation: String?
    /// <p>Filters the list of response objects to include only those with the specified status.</p>
    public let status: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendJobInputBody: Equatable {
    public let operation: String?
    public let status: String?
}

extension UpdateBackendJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBackendJobOutputResponse(appId: \(String(describing: appId)), backendEnvironmentName: \(String(describing: backendEnvironmentName)), createTime: \(String(describing: createTime)), error: \(String(describing: error)), jobId: \(String(describing: jobId)), operation: \(String(describing: operation)), status: \(String(describing: status)), updateTime: \(String(describing: updateTime)))"}
}

extension UpdateBackendJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateBackendJobOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>The name of the backend environment.</p>
    public let backendEnvironmentName: String?
    /// <p>The time when the job was created.</p>
    public let createTime: String?
    /// <p>If the request failed, this is the returned error.</p>
    public let error: String?
    /// <p>The ID for the job.</p>
    public let jobId: String?
    /// <p>The name of the operation.</p>
    public let operation: String?
    /// <p>The current status of the request.</p>
    public let status: String?
    /// <p>The time when the job was last updated.</p>
    public let updateTime: String?

    public init (
        appId: String? = nil,
        backendEnvironmentName: String? = nil,
        createTime: String? = nil,
        error: String? = nil,
        jobId: String? = nil,
        operation: String? = nil,
        status: String? = nil,
        updateTime: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateBackendJobOutputResponseBody: Equatable {
    public let appId: String?
    public let backendEnvironmentName: String?
    public let createTime: String?
    public let error: String?
    public let jobId: String?
    public let operation: String?
    public let status: String?
    public let updateTime: String?
}

extension UpdateBackendJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}
