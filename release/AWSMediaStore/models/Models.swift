// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaStoreClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case accessLoggingEnabled = "AccessLoggingEnabled"
        case creationTime = "CreationTime"
        case endpoint = "Endpoint"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accessLoggingEnabled = self.accessLoggingEnabled {
            try encodeContainer.encode(accessLoggingEnabled, forKey: .accessLoggingEnabled)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.ContainerStatus.self, forKey: .status)
        status = statusDecoded
        let accessLoggingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessLoggingEnabled)
        accessLoggingEnabled = accessLoggingEnabledDecoded
    }
}

extension MediaStoreClientTypes {
    /// This section describes operations that you can perform on an AWS Elemental MediaStore container.
    public struct Container: Swift.Equatable {
        /// The state of access logging on the container. This value is false by default, indicating that AWS Elemental MediaStore does not send access logs to Amazon CloudWatch Logs. When you enable access logging on the container, MediaStore changes this value to true, indicating that the service delivers access logs for objects stored in that container to CloudWatch Logs.
        public var accessLoggingEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the container. The ARN has the following format: arn:aws:::container/ For example: arn:aws:mediastore:us-west-2:111122223333:container/movies
        public var arn: Swift.String?
        /// Unix timestamp.
        public var creationTime: ClientRuntime.Date?
        /// The DNS endpoint of the container. Use the endpoint to identify the specific container when sending requests to the data plane. The service assigns this value when the container is created. Once the value has been assigned, it does not change.
        public var endpoint: Swift.String?
        /// The name of the container.
        public var name: Swift.String?
        /// The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When the endpoint is available, the status changes to ACTIVE.
        public var status: MediaStoreClientTypes.ContainerStatus?

        public init (
            accessLoggingEnabled: Swift.Bool? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endpoint: Swift.String? = nil,
            name: Swift.String? = nil,
            status: MediaStoreClientTypes.ContainerStatus? = nil
        )
        {
            self.accessLoggingEnabled = accessLoggingEnabled
            self.arn = arn
            self.creationTime = creationTime
            self.endpoint = endpoint
            self.name = name
            self.status = status
        }
    }

}

extension ContainerInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ContainerInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The container that you specified in the request already exists or is being updated.
public struct ContainerInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes {
    public enum ContainerLevelMetrics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerLevelMetrics] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerLevelMetrics(rawValue: rawValue) ?? ContainerLevelMetrics.sdkUnknown(rawValue)
        }
    }
}

extension ContainerNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The container that you specified in the request does not exist.
public struct ContainerNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes {
    public enum ContainerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerStatus(rawValue: rawValue) ?? ContainerStatus.sdkUnknown(rawValue)
        }
    }
}

extension CorsPolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CorsPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CORS policy that you specified in the request does not exist.
public struct CorsPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CorsPolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CorsPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreClientTypes.CorsRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedHeaders = "AllowedHeaders"
        case allowedMethods = "AllowedMethods"
        case allowedOrigins = "AllowedOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedHeaders = allowedHeaders {
            var allowedHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedHeaders)
            for header0 in allowedHeaders {
                try allowedHeadersContainer.encode(header0)
            }
        }
        if let allowedMethods = allowedMethods {
            var allowedMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedMethods)
            for methodname0 in allowedMethods {
                try allowedMethodsContainer.encode(methodname0.rawValue)
            }
        }
        if let allowedOrigins = allowedOrigins {
            var allowedOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOrigins)
            for origin0 in allowedOrigins {
                try allowedOriginsContainer.encode(origin0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for header0 in exposeHeaders {
                try exposeHeadersContainer.encode(header0)
            }
        }
        if maxAgeSeconds != 0 {
            try encodeContainer.encode(maxAgeSeconds, forKey: .maxAgeSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedOrigins)
        var allowedOriginsDecoded0:[Swift.String]? = nil
        if let allowedOriginsContainer = allowedOriginsContainer {
            allowedOriginsDecoded0 = [Swift.String]()
            for string0 in allowedOriginsContainer {
                if let string0 = string0 {
                    allowedOriginsDecoded0?.append(string0)
                }
            }
        }
        allowedOrigins = allowedOriginsDecoded0
        let allowedMethodsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.MethodName?].self, forKey: .allowedMethods)
        var allowedMethodsDecoded0:[MediaStoreClientTypes.MethodName]? = nil
        if let allowedMethodsContainer = allowedMethodsContainer {
            allowedMethodsDecoded0 = [MediaStoreClientTypes.MethodName]()
            for string0 in allowedMethodsContainer {
                if let string0 = string0 {
                    allowedMethodsDecoded0?.append(string0)
                }
            }
        }
        allowedMethods = allowedMethodsDecoded0
        let allowedHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedHeaders)
        var allowedHeadersDecoded0:[Swift.String]? = nil
        if let allowedHeadersContainer = allowedHeadersContainer {
            allowedHeadersDecoded0 = [Swift.String]()
            for string0 in allowedHeadersContainer {
                if let string0 = string0 {
                    allowedHeadersDecoded0?.append(string0)
                }
            }
        }
        allowedHeaders = allowedHeadersDecoded0
        let maxAgeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAgeSeconds) ?? 0
        maxAgeSeconds = maxAgeSecondsDecoded
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
    }
}

extension MediaStoreClientTypes {
    /// A rule for a CORS policy. You can add up to 100 rules to a CORS policy. If more than one rule applies, the service uses the first applicable rule listed.
    public struct CorsRule: Swift.Equatable {
        /// Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header. Each header name that is specified in Access-Control-Request-Headers must have a corresponding entry in the rule. Only the headers that were requested are sent back. This element can contain only one wildcard character (*).
        /// This member is required.
        public var allowedHeaders: [Swift.String]?
        /// Identifies an HTTP method that the origin that is specified in the rule is allowed to execute. Each CORS rule must contain at least one AllowedMethods and one AllowedOrigins element.
        public var allowedMethods: [MediaStoreClientTypes.MethodName]?
        /// One or more response headers that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). Each CORS rule must have at least one AllowedOrigins element. The string value can include only one wildcard character (*), for example, http://*.example.com. Additionally, you can specify only one wildcard character to allow cross-origin access for all origins.
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// One or more headers in the response that you want users to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object). This element is optional for each rule.
        public var exposeHeaders: [Swift.String]?
        /// The time in seconds that your browser caches the preflight response for the specified resource. A CORS rule can have only one MaxAgeSeconds element.
        public var maxAgeSeconds: Swift.Int

        public init (
            allowedHeaders: [Swift.String]? = nil,
            allowedMethods: [MediaStoreClientTypes.MethodName]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAgeSeconds: Swift.Int = 0
        )
        {
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
            self.allowedOrigins = allowedOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAgeSeconds = maxAgeSeconds
        }
    }

}

extension CreateContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContainerInput: Swift.Equatable {
    /// The name for the container. The name must be from 1 to 255 characters. Container names must be unique to your AWS account within a specific region. As an example, you could create a container named movies in every region, as long as you don’t have an existing container with that name.
    /// This member is required.
    public var containerName: Swift.String?
    /// An array of key:value pairs that you define. These values can be anything that you want. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public var tags: [MediaStoreClientTypes.Tag]?

    public init (
        containerName: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.containerName = containerName
        self.tags = tags
    }
}

struct CreateContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let tags: [MediaStoreClientTypes.Tag]?
}

extension CreateContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContainerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContainerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateContainerOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case internalServerError(InternalServerError)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContainerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateContainerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct CreateContainerOutputResponse: Swift.Equatable {
    /// ContainerARN: The Amazon Resource Name (ARN) of the newly created container. The ARN has the following format: arn:aws:::container/. For example: arn:aws:mediastore:us-west-2:111122223333:container/movies ContainerName: The container name as specified in the request. CreationTime: Unix time stamp. Status: The status of container creation or deletion. The status is one of the following: CREATING, ACTIVE, or DELETING. While the service is creating the container, the status is CREATING. When an endpoint is available, the status changes to ACTIVE. The return value does not include the container's endpoint. To make downstream requests, you must obtain this value by using [DescribeContainer] or [ListContainers].
    /// This member is required.
    public var container: MediaStoreClientTypes.Container?

    public init (
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

struct CreateContainerOutputResponseBody: Swift.Equatable {
    let container: MediaStoreClientTypes.Container?
}

extension CreateContainerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case container = "Container"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.Container.self, forKey: .container)
        container = containerDecoded
    }
}

extension DeleteContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContainerInput: Swift.Equatable {
    /// The name of the container to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteContainerOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContainerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContainerPolicyInput: Swift.Equatable {
    /// The name of the container that holds the policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteContainerPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteContainerPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContainerPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCorsPolicyInput: Swift.Equatable {
    /// The name of the container to remove the policy from.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteCorsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCorsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CorsPolicyNotFoundException" : self = .corsPolicyNotFoundException(try CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCorsPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case corsPolicyNotFoundException(CorsPolicyNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCorsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCorsPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that holds the object lifecycle policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DeleteMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMetricPolicyInput: Swift.Equatable {
    /// The name of the container that is associated with the metric policy that you want to delete.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DeleteMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DeleteMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DeleteMetricPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMetricPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMetricPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMetricPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMetricPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeContainerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension DescribeContainerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeContainerInput: Swift.Equatable {
    /// The name of the container to query.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct DescribeContainerInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension DescribeContainerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension DescribeContainerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContainerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeContainerOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContainerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeContainerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.container = output.container
        } else {
            self.container = nil
        }
    }
}

public struct DescribeContainerOutputResponse: Swift.Equatable {
    /// The name of the queried container.
    public var container: MediaStoreClientTypes.Container?

    public init (
        container: MediaStoreClientTypes.Container? = nil
    )
    {
        self.container = container
    }
}

struct DescribeContainerOutputResponseBody: Swift.Equatable {
    let container: MediaStoreClientTypes.Container?
}

extension DescribeContainerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case container = "Container"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.Container.self, forKey: .container)
        container = containerDecoded
    }
}

extension GetContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContainerPolicyInput: Swift.Equatable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetContainerPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContainerPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContainerPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetContainerPolicyOutputResponse: Swift.Equatable {
    /// The contents of the access policy.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetContainerPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetContainerPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCorsPolicyInput: Swift.Equatable {
    /// The name of the container that the policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetCorsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCorsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CorsPolicyNotFoundException" : self = .corsPolicyNotFoundException(try CorsPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCorsPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case corsPolicyNotFoundException(CorsPolicyNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCorsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCorsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.corsPolicy = output.corsPolicy
        } else {
            self.corsPolicy = nil
        }
    }
}

public struct GetCorsPolicyOutputResponse: Swift.Equatable {
    /// The CORS policy assigned to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init (
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.corsPolicy = corsPolicy
    }
}

struct GetCorsPolicyOutputResponseBody: Swift.Equatable {
    let corsPolicy: [MediaStoreClientTypes.CorsRule]?
}

extension GetCorsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case corsPolicy = "CorsPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let corsPolicyContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[MediaStoreClientTypes.CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [MediaStoreClientTypes.CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

extension GetLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that the object lifecycle policy is assigned to.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicy = output.lifecyclePolicy
        } else {
            self.lifecyclePolicy = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Swift.Equatable {
    /// The object lifecycle policy that is assigned to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init (
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct GetLifecyclePolicyOutputResponseBody: Swift.Equatable {
    let lifecyclePolicy: Swift.String?
}

extension GetLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

extension GetMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension GetMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetMetricPolicyInput: Swift.Equatable {
    /// The name of the container that is associated with the metric policy.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct GetMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension GetMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension GetMetricPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMetricPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFoundException" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMetricPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMetricPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMetricPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricPolicy = output.metricPolicy
        } else {
            self.metricPolicy = nil
        }
    }
}

public struct GetMetricPolicyOutputResponse: Swift.Equatable {
    /// The metric policy that is associated with the specific container.
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init (
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.metricPolicy = metricPolicy
    }
}

struct GetMetricPolicyOutputResponseBody: Swift.Equatable {
    let metricPolicy: MediaStoreClientTypes.MetricPolicy?
}

extension GetMetricPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricPolicy = "MetricPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service limit has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListContainersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListContainersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContainersInput: Swift.Equatable {
    /// Enter the maximum number of containers in the response. Use from 1 to 255 characters.
    public var maxResults: Swift.Int?
    /// Only if you used MaxResults in the first command, enter the token (which was included in the previous response) to obtain the next set of containers. This token is included in a response only if there actually are more containers to list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContainersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListContainersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContainersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContainersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListContainersOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContainersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListContainersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containers = output.containers
            self.nextToken = output.nextToken
        } else {
            self.containers = nil
            self.nextToken = nil
        }
    }
}

public struct ListContainersOutputResponse: Swift.Equatable {
    /// The names of the containers.
    /// This member is required.
    public var containers: [MediaStoreClientTypes.Container]?
    /// NextToken is the token to use in the next call to ListContainers. This token is returned only if you included the MaxResults tag in the original command, and only if there are still containers to return.
    public var nextToken: Swift.String?

    public init (
        containers: [MediaStoreClientTypes.Container]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.containers = containers
        self.nextToken = nextToken
    }
}

struct ListContainersOutputResponseBody: Swift.Equatable {
    let containers: [MediaStoreClientTypes.Container]?
    let nextToken: Swift.String?
}

extension ListContainersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containers = "Containers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containersContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[MediaStoreClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [MediaStoreClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// An array of key:value pairs that are assigned to the container.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init (
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [MediaStoreClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaStoreClientTypes {
    public enum MethodName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [MethodName] {
            return [
                .delete,
                .get,
                .head,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MethodName(rawValue: rawValue) ?? MethodName.sdkUnknown(rawValue)
        }
    }
}

extension MediaStoreClientTypes.MetricPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerLevelMetrics = "ContainerLevelMetrics"
        case metricPolicyRules = "MetricPolicyRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerLevelMetrics = self.containerLevelMetrics {
            try encodeContainer.encode(containerLevelMetrics.rawValue, forKey: .containerLevelMetrics)
        }
        if let metricPolicyRules = metricPolicyRules {
            var metricPolicyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricPolicyRules)
            for metricpolicyrule0 in metricPolicyRules {
                try metricPolicyRulesContainer.encode(metricpolicyrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerLevelMetricsDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.ContainerLevelMetrics.self, forKey: .containerLevelMetrics)
        containerLevelMetrics = containerLevelMetricsDecoded
        let metricPolicyRulesContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.MetricPolicyRule?].self, forKey: .metricPolicyRules)
        var metricPolicyRulesDecoded0:[MediaStoreClientTypes.MetricPolicyRule]? = nil
        if let metricPolicyRulesContainer = metricPolicyRulesContainer {
            metricPolicyRulesDecoded0 = [MediaStoreClientTypes.MetricPolicyRule]()
            for structure0 in metricPolicyRulesContainer {
                if let structure0 = structure0 {
                    metricPolicyRulesDecoded0?.append(structure0)
                }
            }
        }
        metricPolicyRules = metricPolicyRulesDecoded0
    }
}

extension MediaStoreClientTypes {
    /// The metric policy that is associated with the container. A metric policy allows AWS Elemental MediaStore to send metrics to Amazon CloudWatch. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include rules to define groups of objects that you want MediaStore to send object-level metrics for. To view examples of how to construct a metric policy for your use case, see [Example Metric Policies](https://docs.aws.amazon.com/mediastore/latest/ug/policies-metric-examples.html).
    public struct MetricPolicy: Swift.Equatable {
        /// A setting to enable or disable metrics at the container level.
        /// This member is required.
        public var containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics?
        /// A parameter that holds an array of rules that enable metrics at the object level. This parameter is optional, but if you choose to include it, you must also include at least one rule. By default, you can include up to five rules. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
        public var metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]?

        public init (
            containerLevelMetrics: MediaStoreClientTypes.ContainerLevelMetrics? = nil,
            metricPolicyRules: [MediaStoreClientTypes.MetricPolicyRule]? = nil
        )
        {
            self.containerLevelMetrics = containerLevelMetrics
            self.metricPolicyRules = metricPolicyRules
        }
    }

}

extension MediaStoreClientTypes.MetricPolicyRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectGroup = "ObjectGroup"
        case objectGroupName = "ObjectGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectGroup = self.objectGroup {
            try encodeContainer.encode(objectGroup, forKey: .objectGroup)
        }
        if let objectGroupName = self.objectGroupName {
            try encodeContainer.encode(objectGroupName, forKey: .objectGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectGroup)
        objectGroup = objectGroupDecoded
        let objectGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectGroupName)
        objectGroupName = objectGroupNameDecoded
    }
}

extension MediaStoreClientTypes {
    /// A setting that enables metrics at the object level. Each rule contains an object group and an object group name. If the policy includes the MetricPolicyRules parameter, you must include at least one rule. Each metric policy can include up to five rules by default. You can also [request a quota increase](https://console.aws.amazon.com/servicequotas/home?region=us-east-1#!/services/mediastore/quotas) to allow up to 300 rules per policy.
    public struct MetricPolicyRule: Swift.Equatable {
        /// A path or file name that defines which objects to include in the group. Wildcards (*) are acceptable.
        /// This member is required.
        public var objectGroup: Swift.String?
        /// A name that allows you to refer to the object group.
        /// This member is required.
        public var objectGroupName: Swift.String?

        public init (
            objectGroup: Swift.String? = nil,
            objectGroupName: Swift.String? = nil
        )
        {
            self.objectGroup = objectGroup
            self.objectGroupName = objectGroupName
        }
    }

}

extension PolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The policy that you specified in the request does not exist.
public struct PolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutContainerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContainerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutContainerPolicyInput: Swift.Equatable {
    /// The name of the container.
    /// This member is required.
    public var containerName: Swift.String?
    /// The contents of the policy, which includes the following:
    ///
    /// * One Version tag
    ///
    /// * One Statement tag that contains the standard tags for the policy.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        containerName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.policy = policy
    }
}

struct PutContainerPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let policy: Swift.String?
}

extension PutContainerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContainerPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutContainerPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContainerPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutContainerPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutCorsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let corsPolicy = corsPolicy {
            var corsPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .corsPolicy)
            for corsrule0 in corsPolicy {
                try corsPolicyContainer.encode(corsrule0)
            }
        }
    }
}

extension PutCorsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutCorsPolicyInput: Swift.Equatable {
    /// The name of the container that you want to assign the CORS policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The CORS policy to apply to the container.
    /// This member is required.
    public var corsPolicy: [MediaStoreClientTypes.CorsRule]?

    public init (
        containerName: Swift.String? = nil,
        corsPolicy: [MediaStoreClientTypes.CorsRule]? = nil
    )
    {
        self.containerName = containerName
        self.corsPolicy = corsPolicy
    }
}

struct PutCorsPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let corsPolicy: [MediaStoreClientTypes.CorsRule]?
}

extension PutCorsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case corsPolicy = "CorsPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let corsPolicyContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.CorsRule?].self, forKey: .corsPolicy)
        var corsPolicyDecoded0:[MediaStoreClientTypes.CorsRule]? = nil
        if let corsPolicyContainer = corsPolicyContainer {
            corsPolicyDecoded0 = [MediaStoreClientTypes.CorsRule]()
            for structure0 in corsPolicyContainer {
                if let structure0 = structure0 {
                    corsPolicyDecoded0?.append(structure0)
                }
            }
        }
        corsPolicy = corsPolicyDecoded0
    }
}

extension PutCorsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCorsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutCorsPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCorsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutCorsPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let lifecyclePolicy = self.lifecyclePolicy {
            try encodeContainer.encode(lifecyclePolicy, forKey: .lifecyclePolicy)
        }
    }
}

extension PutLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLifecyclePolicyInput: Swift.Equatable {
    /// The name of the container that you want to assign the object lifecycle policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The object lifecycle policy to apply to the container.
    /// This member is required.
    public var lifecyclePolicy: Swift.String?

    public init (
        containerName: Swift.String? = nil,
        lifecyclePolicy: Swift.String? = nil
    )
    {
        self.containerName = containerName
        self.lifecyclePolicy = lifecyclePolicy
    }
}

struct PutLifecyclePolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let lifecyclePolicy: Swift.String?
}

extension PutLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case lifecyclePolicy = "LifecyclePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
    }
}

extension PutLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLifecyclePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutMetricPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let metricPolicy = self.metricPolicy {
            try encodeContainer.encode(metricPolicy, forKey: .metricPolicy)
        }
    }
}

extension PutMetricPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutMetricPolicyInput: Swift.Equatable {
    /// The name of the container that you want to add the metric policy to.
    /// This member is required.
    public var containerName: Swift.String?
    /// The metric policy that you want to associate with the container. In the policy, you must indicate whether you want MediaStore to send container-level metrics. You can also include up to five rules to define groups of objects that you want MediaStore to send object-level metrics for. If you include rules in the policy, construct each rule with both of the following:
    ///
    /// * An object group that defines which objects to include in the group. The definition can be a path or a file name, but it can't have more than 900 characters. Valid characters are: a-z, A-Z, 0-9, _ (underscore), = (equal), : (colon), . (period), - (hyphen), ~ (tilde), / (forward slash), and * (asterisk). Wildcards (*) are acceptable.
    ///
    /// * An object group name that allows you to refer to the object group. The name can't have more than 30 characters. Valid characters are: a-z, A-Z, 0-9, and _ (underscore).
    /// This member is required.
    public var metricPolicy: MediaStoreClientTypes.MetricPolicy?

    public init (
        containerName: Swift.String? = nil,
        metricPolicy: MediaStoreClientTypes.MetricPolicy? = nil
    )
    {
        self.containerName = containerName
        self.metricPolicy = metricPolicy
    }
}

struct PutMetricPolicyInputBody: Swift.Equatable {
    let containerName: Swift.String?
    let metricPolicy: MediaStoreClientTypes.MetricPolicy?
}

extension PutMetricPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case metricPolicy = "MetricPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let metricPolicyDecoded = try containerValues.decodeIfPresent(MediaStoreClientTypes.MetricPolicy.self, forKey: .metricPolicy)
        metricPolicy = metricPolicyDecoded
    }
}

extension PutMetricPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetricPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMetricPolicyOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetricPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMetricPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartAccessLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension StartAccessLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAccessLoggingInput: Swift.Equatable {
    /// The name of the container that you want to start access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StartAccessLoggingInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension StartAccessLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StartAccessLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAccessLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAccessLoggingOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAccessLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartAccessLoggingOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopAccessLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }
}

extension StopAccessLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAccessLoggingInput: Swift.Equatable {
    /// The name of the container that you want to stop access logging on.
    /// This member is required.
    public var containerName: Swift.String?

    public init (
        containerName: Swift.String? = nil
    )
    {
        self.containerName = containerName
    }
}

struct StopAccessLoggingInputBody: Swift.Equatable {
    let containerName: Swift.String?
}

extension StopAccessLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension StopAccessLoggingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAccessLoggingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopAccessLoggingOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAccessLoggingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAccessLoggingOutputResponse: Swift.Equatable {

    public init () { }
}

extension MediaStoreClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MediaStoreClientTypes {
    /// A collection of tags associated with a container. Each tag consists of a key:value pair, which can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each container. For more information about tagging, including naming and usage conventions, see [Tagging Resources in MediaStore](https://docs.aws.amazon.com/mediastore/latest/ug/tagging.html).
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// An array of key:value pairs that you want to add to the container. You need to specify only the tags that you want to add or update. For example, suppose a container already has two tags (customer:CompanyA and priority:High). You want to change the priority tag and also add a third tag (type:Contract). For TagResource, you specify the following tags: priority:Medium, type:Contract. The result is that your container has three tags: customer:CompanyA, priority:Medium, and type:Contract.
    /// This member is required.
    public var tags: [MediaStoreClientTypes.Tag]?

    public init (
        resource: Swift.String? = nil,
        tags: [MediaStoreClientTypes.Tag]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
    let tags: [MediaStoreClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MediaStoreClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MediaStoreClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MediaStoreClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the container.
    /// This member is required.
    public var resource: Swift.String?
    /// A comma-separated list of keys for tags that you want to remove from the container. For example, if your container has two tags (customer:CompanyA and priority:High) and you want to remove one of the tags (priority:High), you specify the key for the tag that you want to remove (priority).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resource: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resource: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerInUseException" : self = .containerInUseException(try ContainerInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case containerInUseException(ContainerInUseException)
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}
