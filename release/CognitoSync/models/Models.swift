// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyStreamedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyStreamedException(message: \(String(describing: message)))"}
}

extension AlreadyStreamedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyStreamedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception thrown when a bulk publish operation is requested less than 24 hours after a previous bulk publish operation completed successfully.
public struct AlreadyStreamedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The message associated with the AlreadyStreamedException exception.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyStreamedExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyStreamedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BulkPublishInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkPublishInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension BulkPublishInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct BulkPublishInputHeadersMiddleware: Middleware {
    public let id: String = "BulkPublishInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BulkPublishInput>,
                  next: H) -> Swift.Result<OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BulkPublishInput>
    public typealias MOutput = OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BulkPublishOutputError>
}

public struct BulkPublishInputQueryItemMiddleware: Middleware {
    public let id: String = "BulkPublishInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BulkPublishInput>,
                  next: H) -> Swift.Result<OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BulkPublishInput>
    public typealias MOutput = OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BulkPublishOutputError>
}

/// The input for the BulkPublish operation.
public struct BulkPublishInput: Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishInputBody: Equatable {
}

extension BulkPublishInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension BulkPublishOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BulkPublishOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyStreamedException" : self = .alreadyStreamedException(try AlreadyStreamedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequestException" : self = .duplicateRequestException(try DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BulkPublishOutputError: Swift.Error, Equatable {
    case alreadyStreamedException(AlreadyStreamedException)
    case duplicateRequestException(DuplicateRequestException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BulkPublishOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkPublishOutputResponse(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension BulkPublishOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BulkPublishOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPoolId = output.identityPoolId
        } else {
            self.identityPoolId = nil
        }
    }
}

/// The output for the BulkPublish operation.
public struct BulkPublishOutputResponse: Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishOutputResponseBody: Equatable {
    public let identityPoolId: String?
}

extension BulkPublishOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

public enum BulkPublishStatus {
    case failed
    case inProgress
    case notStarted
    case succeeded
    case sdkUnknown(String)
}

extension BulkPublishStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BulkPublishStatus] {
        return [
            .failed,
            .inProgress,
            .notStarted,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BulkPublishStatus(rawValue: rawValue) ?? BulkPublishStatus.sdkUnknown(rawValue)
    }
}

extension CognitoStreams: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case streamingStatus = "StreamingStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamingStatus = streamingStatus {
            try encodeContainer.encode(streamingStatus.rawValue, forKey: .streamingStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
    }
}

extension CognitoStreams: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CognitoStreams(roleArn: \(String(describing: roleArn)), streamName: \(String(describing: streamName)), streamingStatus: \(String(describing: streamingStatus)))"}
}

/// Configuration options for configure Cognito streams.
public struct CognitoStreams: Equatable {
    /// The ARN of the role Amazon Cognito can assume in order to publish to the stream. This role must grant access to Amazon Cognito (cognito-sync) to invoke PutRecord on your Cognito stream.
    public let roleArn: String?
    /// The name of the Cognito stream to receive updates. This stream must be in the developers account and in the same region as the identity pool.
    public let streamName: String?
    /// Status of the Cognito streams. Valid values are:
    ///       <p>ENABLED - Streaming of updates to identity pool is enabled.</p>
    ///       <p>DISABLED - Streaming of updates to identity pool is disabled. Bulk publish will also fail if StreamingStatus is DISABLED.</p>
    public let streamingStatus: StreamingStatus?

    public init (
        roleArn: String? = nil,
        streamName: String? = nil,
        streamingStatus: StreamingStatus? = nil
    )
    {
        self.roleArn = roleArn
        self.streamName = streamName
        self.streamingStatus = streamingStatus
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown if there are parallel requests to modify a resource.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a ConcurrentModicationException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Dataset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case dataStorage = "DataStorage"
        case datasetName = "DatasetName"
        case identityId = "IdentityId"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case numRecords = "NumRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let numRecords = numRecords {
            try encodeContainer.encode(numRecords, forKey: .numRecords)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let numRecordsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numRecords)
        numRecords = numRecordsDecoded
    }
}

extension Dataset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dataset(creationDate: \(String(describing: creationDate)), dataStorage: \(String(describing: dataStorage)), datasetName: \(String(describing: datasetName)), identityId: \(String(describing: identityId)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), numRecords: \(String(describing: numRecords)))"}
}

/// A collection of data for an identity pool. An identity pool can
///       have multiple datasets. A dataset is per identity and can be general or associated with a
///       particular entity in an application (like a saved game). Datasets are automatically created if
///       they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value
///       pairs.
public struct Dataset: Equatable {
    /// Date on which the dataset was
    ///       created.
    public let creationDate: Date?
    /// Total size in bytes of the records in this
    ///       dataset.
    public let dataStorage: Int?
    /// A string of up to 128 characters. Allowed characters
    ///       are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    public let datasetName: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// The device that made the last change to this
    ///       dataset.
    public let lastModifiedBy: String?
    /// Date when the dataset was last
    ///       modified.
    public let lastModifiedDate: Date?
    /// Number of records in this dataset.
    public let numRecords: Int?

    public init (
        creationDate: Date? = nil,
        dataStorage: Int? = nil,
        datasetName: String? = nil,
        identityId: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        numRecords: Int? = nil
    )
    {
        self.creationDate = creationDate
        self.dataStorage = dataStorage
        self.datasetName = datasetName
        self.identityId = identityId
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.numRecords = numRecords
    }
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(datasetName: \(String(describing: datasetName)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

/// A request to delete the specific
///       dataset.
public struct DeleteDatasetInput: Equatable {
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    public let datasetName: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        datasetName: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DeleteDatasetInputBody: Equatable {
}

extension DeleteDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse(dataset: \(String(describing: dataset)))"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DeleteDataset
///       request.
public struct DeleteDatasetOutputResponse: Equatable {
    /// A collection of data for an identity pool.
    ///       An identity pool can have multiple datasets. A dataset is per identity and can be general or
    ///       associated with a particular entity in an application (like a saved game). Datasets are
    ///       automatically created if they don't exist. Data is synced by dataset, and a dataset can hold
    ///       up to 1MB of key-value pairs.
    public let dataset: Dataset?

    public init (
        dataset: Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DeleteDatasetOutputResponseBody: Equatable {
    public let dataset: Dataset?
}

extension DeleteDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataset = "Dataset"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetName: \(String(describing: datasetName)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

/// A request for meta data about a dataset (creation
///       date, number of records, size) by owner and dataset name.
public struct DescribeDatasetInput: Equatable {
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    public let datasetName: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        datasetName: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeDatasetInputBody: Equatable {
}

extension DescribeDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(dataset: \(String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DescribeDataset
///       request.
public struct DescribeDatasetOutputResponse: Equatable {
    /// Meta data for a collection of data for an
    ///       identity. An identity can have multiple datasets. A dataset can be general or associated with
    ///       a particular entity in an application (like a saved game). Datasets are automatically created
    ///       if they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value
    ///       pairs.
    public let dataset: Dataset?

    public init (
        dataset: Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let dataset: Dataset?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataset = "Dataset"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeIdentityPoolUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityPoolUsageInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DescribeIdentityPoolUsageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIdentityPoolUsageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityPoolUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityPoolUsageInput>
    public typealias MOutput = OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityPoolUsageOutputError>
}

public struct DescribeIdentityPoolUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityPoolUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityPoolUsageInput>
    public typealias MOutput = OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityPoolUsageOutputError>
}

/// A request for usage information about
///       the identity pool.
public struct DescribeIdentityPoolUsageInput: Equatable {
    /// A name-spaced GUID (for
    ///       example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID
    ///       generation is unique within a region.
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolUsageInputBody: Equatable {
}

extension DescribeIdentityPoolUsageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIdentityPoolUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityPoolUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityPoolUsageOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityPoolUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityPoolUsageOutputResponse(identityPoolUsage: \(String(describing: identityPoolUsage)))"}
}

extension DescribeIdentityPoolUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityPoolUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPoolUsage = output.identityPoolUsage
        } else {
            self.identityPoolUsage = nil
        }
    }
}

/// Response to a successful
///       DescribeIdentityPoolUsage request.
public struct DescribeIdentityPoolUsageOutputResponse: Equatable {
    /// Information about the
    ///       usage of the identity pool.
    public let identityPoolUsage: IdentityPoolUsage?

    public init (
        identityPoolUsage: IdentityPoolUsage? = nil
    )
    {
        self.identityPoolUsage = identityPoolUsage
    }
}

struct DescribeIdentityPoolUsageOutputResponseBody: Equatable {
    public let identityPoolUsage: IdentityPoolUsage?
}

extension DescribeIdentityPoolUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolUsage = "IdentityPoolUsage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsageDecoded = try containerValues.decodeIfPresent(IdentityPoolUsage.self, forKey: .identityPoolUsage)
        identityPoolUsage = identityPoolUsageDecoded
    }
}

extension DescribeIdentityUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityUsageInput(identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DescribeIdentityUsageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeIdentityUsageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityUsageInput>
    public typealias MOutput = OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityUsageOutputError>
}

public struct DescribeIdentityUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityUsageInput>
    public typealias MOutput = OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityUsageOutputError>
}

/// A request for information about the usage of
///       an identity pool.
public struct DescribeIdentityUsageInput: Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for
    ///       example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID
    ///       generation is unique within a region.
    public let identityPoolId: String?

    public init (
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityUsageInputBody: Equatable {
}

extension DescribeIdentityUsageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeIdentityUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityUsageOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityUsageOutputResponse(identityUsage: \(String(describing: identityUsage)))"}
}

extension DescribeIdentityUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityUsage = output.identityUsage
        } else {
            self.identityUsage = nil
        }
    }
}

/// The response to a successful
///       DescribeIdentityUsage request.
public struct DescribeIdentityUsageOutputResponse: Equatable {
    /// Usage information for the
    ///       identity.
    public let identityUsage: IdentityUsage?

    public init (
        identityUsage: IdentityUsage? = nil
    )
    {
        self.identityUsage = identityUsage
    }
}

struct DescribeIdentityUsageOutputResponseBody: Equatable {
    public let identityUsage: IdentityUsage?
}

extension DescribeIdentityUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityUsage = "IdentityUsage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityUsageDecoded = try containerValues.decodeIfPresent(IdentityUsage.self, forKey: .identityUsage)
        identityUsage = identityUsageDecoded
    }
}

extension DuplicateRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateRequestException(message: \(String(describing: message)))"}
}

extension DuplicateRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception thrown when there is an IN_PROGRESS bulk publish operation for the given identity pool.
public struct DuplicateRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The message associated with the DuplicateRequestException exception.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBulkPublishDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBulkPublishDetailsInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension GetBulkPublishDetailsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBulkPublishDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBulkPublishDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBulkPublishDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBulkPublishDetailsInput>
    public typealias MOutput = OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBulkPublishDetailsOutputError>
}

public struct GetBulkPublishDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBulkPublishDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBulkPublishDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBulkPublishDetailsInput>
    public typealias MOutput = OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBulkPublishDetailsOutputError>
}

/// The input for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsInput: Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsInputBody: Equatable {
}

extension GetBulkPublishDetailsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBulkPublishDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBulkPublishDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBulkPublishDetailsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBulkPublishDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBulkPublishDetailsOutputResponse(bulkPublishCompleteTime: \(String(describing: bulkPublishCompleteTime)), bulkPublishStartTime: \(String(describing: bulkPublishStartTime)), bulkPublishStatus: \(String(describing: bulkPublishStatus)), failureMessage: \(String(describing: failureMessage)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension GetBulkPublishDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBulkPublishDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bulkPublishCompleteTime = output.bulkPublishCompleteTime
            self.bulkPublishStartTime = output.bulkPublishStartTime
            self.bulkPublishStatus = output.bulkPublishStatus
            self.failureMessage = output.failureMessage
            self.identityPoolId = output.identityPoolId
        } else {
            self.bulkPublishCompleteTime = nil
            self.bulkPublishStartTime = nil
            self.bulkPublishStatus = nil
            self.failureMessage = nil
            self.identityPoolId = nil
        }
    }
}

/// The output for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsOutputResponse: Equatable {
    /// If BulkPublishStatus is SUCCEEDED, the time the last bulk publish operation completed.
    public let bulkPublishCompleteTime: Date?
    /// The date/time at which the last bulk publish was initiated.
    public let bulkPublishStartTime: Date?
    /// Status of the last bulk publish operation, valid values are:
    ///       <p>NOT_STARTED - No bulk publish has been requested for this identity pool</p>
    ///       <p>IN_PROGRESS - Data is being published to the configured stream</p>
    ///       <p>SUCCEEDED - All data for the identity pool has been published to the configured stream</p>
    ///       <p>FAILED - Some portion of the data has failed to publish, check FailureMessage for the cause.</p>
    public let bulkPublishStatus: BulkPublishStatus?
    /// If BulkPublishStatus is FAILED this field will contain the error message that caused the bulk publish to fail.
    public let failureMessage: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?

    public init (
        bulkPublishCompleteTime: Date? = nil,
        bulkPublishStartTime: Date? = nil,
        bulkPublishStatus: BulkPublishStatus? = nil,
        failureMessage: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.bulkPublishCompleteTime = bulkPublishCompleteTime
        self.bulkPublishStartTime = bulkPublishStartTime
        self.bulkPublishStatus = bulkPublishStatus
        self.failureMessage = failureMessage
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let bulkPublishStartTime: Date?
    public let bulkPublishCompleteTime: Date?
    public let bulkPublishStatus: BulkPublishStatus?
    public let failureMessage: String?
}

extension GetBulkPublishDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bulkPublishCompleteTime = "BulkPublishCompleteTime"
        case bulkPublishStartTime = "BulkPublishStartTime"
        case bulkPublishStatus = "BulkPublishStatus"
        case failureMessage = "FailureMessage"
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let bulkPublishStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .bulkPublishStartTime)
        bulkPublishStartTime = bulkPublishStartTimeDecoded
        let bulkPublishCompleteTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .bulkPublishCompleteTime)
        bulkPublishCompleteTime = bulkPublishCompleteTimeDecoded
        let bulkPublishStatusDecoded = try containerValues.decodeIfPresent(BulkPublishStatus.self, forKey: .bulkPublishStatus)
        bulkPublishStatus = bulkPublishStatusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension GetCognitoEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCognitoEventsInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension GetCognitoEventsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCognitoEventsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCognitoEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCognitoEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCognitoEventsInput>
    public typealias MOutput = OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCognitoEventsOutputError>
}

public struct GetCognitoEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCognitoEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCognitoEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCognitoEventsInput>
    public typealias MOutput = OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCognitoEventsOutputError>
}

/// <p>A request for a list of the configured Cognito Events</p>
public struct GetCognitoEventsInput: Equatable {
    /// <p>The Cognito Identity Pool ID for the request</p>
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetCognitoEventsInputBody: Equatable {
}

extension GetCognitoEventsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCognitoEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCognitoEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCognitoEventsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCognitoEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCognitoEventsOutputResponse(events: \(String(describing: events)))"}
}

extension GetCognitoEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCognitoEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
        } else {
            self.events = nil
        }
    }
}

/// <p>The response from the GetCognitoEvents request</p>
public struct GetCognitoEventsOutputResponse: Equatable {
    /// <p>The Cognito Events returned from the GetCognitoEvents request</p>
    public let events: [String:String]?

    public init (
        events: [String:String]? = nil
    )
    {
        self.events = events
    }
}

struct GetCognitoEventsOutputResponseBody: Equatable {
    public let events: [String:String]?
}

extension GetCognitoEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .events)
        var eventsDecoded0: [String:String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [String:String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GetIdentityPoolConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoolConfigurationInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension GetIdentityPoolConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIdentityPoolConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityPoolConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoolConfigurationInput>
    public typealias MOutput = OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoolConfigurationOutputError>
}

public struct GetIdentityPoolConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityPoolConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoolConfigurationInput>
    public typealias MOutput = OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoolConfigurationOutputError>
}

/// <p>The input for the GetIdentityPoolConfiguration operation.</p>
public struct GetIdentityPoolConfigurationInput: Equatable {
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. This is the ID of the pool for which to return a configuration.</p>
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolConfigurationInputBody: Equatable {
}

extension GetIdentityPoolConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIdentityPoolConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityPoolConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoolConfigurationOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoolConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoolConfigurationOutputResponse(cognitoStreams: \(String(describing: cognitoStreams)), identityPoolId: \(String(describing: identityPoolId)), pushSync: \(String(describing: pushSync)))"}
}

extension GetIdentityPoolConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityPoolConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// <p>The output for the GetIdentityPoolConfiguration operation.</p>
public struct GetIdentityPoolConfigurationOutputResponse: Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public let cognitoStreams: CognitoStreams?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito.</p>
    public let identityPoolId: String?
    /// <p>Options to apply to this identity pool for push synchronization.</p>
    public let pushSync: PushSync?

    public init (
        cognitoStreams: CognitoStreams? = nil,
        identityPoolId: String? = nil,
        pushSync: PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct GetIdentityPoolConfigurationOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let pushSync: PushSync?
    public let cognitoStreams: CognitoStreams?
}

extension GetIdentityPoolConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension IdentityPoolUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataStorage = "DataStorage"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
        case syncSessionsCount = "SyncSessionsCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let syncSessionsCount = syncSessionsCount {
            try encodeContainer.encode(syncSessionsCount, forKey: .syncSessionsCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let syncSessionsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .syncSessionsCount)
        syncSessionsCount = syncSessionsCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension IdentityPoolUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityPoolUsage(dataStorage: \(String(describing: dataStorage)), identityPoolId: \(String(describing: identityPoolId)), lastModifiedDate: \(String(describing: lastModifiedDate)), syncSessionsCount: \(String(describing: syncSessionsCount)))"}
}

/// Usage information for the identity
///       pool.
public struct IdentityPoolUsage: Equatable {
    /// Data storage information for the identity
    ///       pool.
    public let dataStorage: Int?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?
    /// Date on which the identity pool was
    ///       last modified.
    public let lastModifiedDate: Date?
    /// Number of sync sessions for the
    ///       identity pool.
    public let syncSessionsCount: Int?

    public init (
        dataStorage: Int? = nil,
        identityPoolId: String? = nil,
        lastModifiedDate: Date? = nil,
        syncSessionsCount: Int? = nil
    )
    {
        self.dataStorage = dataStorage
        self.identityPoolId = identityPoolId
        self.lastModifiedDate = lastModifiedDate
        self.syncSessionsCount = syncSessionsCount
    }
}

extension IdentityUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataStorage = "DataStorage"
        case datasetCount = "DatasetCount"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if datasetCount != 0 {
            try encodeContainer.encode(datasetCount, forKey: .datasetCount)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let datasetCountDecoded = try containerValues.decode(Int.self, forKey: .datasetCount)
        datasetCount = datasetCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
    }
}

extension IdentityUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityUsage(dataStorage: \(String(describing: dataStorage)), datasetCount: \(String(describing: datasetCount)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), lastModifiedDate: \(String(describing: lastModifiedDate)))"}
}

/// Usage information for the identity.
public struct IdentityUsage: Equatable {
    /// Total data storage for this
    ///       identity.
    public let dataStorage: Int?
    /// Number of datasets for the
    ///       identity.
    public let datasetCount: Int
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?
    /// Date on which the identity was last
    ///       modified.
    public let lastModifiedDate: Date?

    public init (
        dataStorage: Int? = nil,
        datasetCount: Int = 0,
        identityId: String? = nil,
        identityPoolId: String? = nil,
        lastModifiedDate: Date? = nil
    )
    {
        self.dataStorage = dataStorage
        self.datasetCount = datasetCount
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.lastModifiedDate = lastModifiedDate
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates an internal service
///       error.
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// Message returned by
    ///       InternalErrorException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InvalidConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Message returned by
    ///       InvalidConfigurationException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionOutputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLambdaFunctionOutputException(message: \(String(describing: message)))"}
}

extension InvalidLambdaFunctionOutputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLambdaFunctionOutputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Lambda function returned invalid output or an exception.</p>
public struct InvalidLambdaFunctionOutputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message returned when an InvalidLambdaFunctionOutputException occurs</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionOutputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLambdaFunctionOutputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a request parameter does not comply
///       with the associated constraints.
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Message returned by
    ///       InvalidParameterException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaThrottledException(message: \(String(describing: message)))"}
}

extension LambdaThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LambdaThrottledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda throttled your account, please contact AWS Support</p>
public struct LambdaThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message returned when an LambdaThrottledException is thrown</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LambdaThrottledExceptionBody: Equatable {
    public let message: String?
}

extension LambdaThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the limit on the number of objects or
///       operations has been exceeded.
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Message returned by
    ///       LimitExceededException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

/// Request for a list of datasets for an
///       identity.
public struct ListDatasetsInput: Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?
    /// The maximum number of results to be
    ///       returned.
    public let maxResults: Int
    /// A pagination token for obtaining the next
    ///       page of results.
    public let nextToken: String?

    public init (
        identityId: String? = nil,
        identityPoolId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
}

extension ListDatasetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(count: \(String(describing: count)), datasets: \(String(describing: datasets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.count = output.count
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Returned for a successful ListDatasets
///       request.
public struct ListDatasetsOutputResponse: Equatable {
    /// Number of datasets returned.
    public let count: Int
    /// A set of datasets.
    public let datasets: [Dataset]?
    /// A pagination token for obtaining the next
    ///       page of results.
    public let nextToken: String?

    public init (
        count: Int = 0,
        datasets: [Dataset]? = nil,
        nextToken: String? = nil
    )
    {
        self.count = count
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let datasets: [Dataset]?
    public let count: Int
    public let nextToken: String?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoolUsageInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentityPoolUsageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIdentityPoolUsageInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentityPoolUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoolUsageInput>
    public typealias MOutput = OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoolUsageOutputError>
}

public struct ListIdentityPoolUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentityPoolUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoolUsageInput>
    public typealias MOutput = OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoolUsageOutputError>
}

/// A request for usage information on an
///       identity pool.
public struct ListIdentityPoolUsageInput: Equatable {
    /// The maximum number of results to
    ///       be returned.
    public let maxResults: Int
    /// A pagination token for obtaining
    ///       the next page of results.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageInputBody: Equatable {
}

extension ListIdentityPoolUsageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIdentityPoolUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityPoolUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoolUsageOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoolUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoolUsageOutputResponse(count: \(String(describing: count)), identityPoolUsages: \(String(describing: identityPoolUsages)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentityPoolUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentityPoolUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.count = output.count
            self.identityPoolUsages = output.identityPoolUsages
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.identityPoolUsages = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

/// Returned for a successful
///       ListIdentityPoolUsage request.
public struct ListIdentityPoolUsageOutputResponse: Equatable {
    /// Total number of identities for the
    ///       identity pool.
    public let count: Int
    /// Usage information for
    ///       the identity pools.
    public let identityPoolUsages: [IdentityPoolUsage]?
    /// The maximum number of results to
    ///       be returned.
    public let maxResults: Int
    /// A pagination token for obtaining
    ///       the next page of results.
    public let nextToken: String?

    public init (
        count: Int = 0,
        identityPoolUsages: [IdentityPoolUsage]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.count = count
        self.identityPoolUsages = identityPoolUsages
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageOutputResponseBody: Equatable {
    public let identityPoolUsages: [IdentityPoolUsage]?
    public let maxResults: Int
    public let count: Int
    public let nextToken: String?
}

extension ListIdentityPoolUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case identityPoolUsages = "IdentityPoolUsages"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsagesContainer = try containerValues.decodeIfPresent([IdentityPoolUsage?].self, forKey: .identityPoolUsages)
        var identityPoolUsagesDecoded0:[IdentityPoolUsage]? = nil
        if let identityPoolUsagesContainer = identityPoolUsagesContainer {
            identityPoolUsagesDecoded0 = [IdentityPoolUsage]()
            for structure0 in identityPoolUsagesContainer {
                if let structure0 = structure0 {
                    identityPoolUsagesDecoded0?.append(structure0)
                }
            }
        }
        identityPoolUsages = identityPoolUsagesDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordsInput(datasetName: \(String(describing: datasetName)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), lastSyncCount: \(String(describing: lastSyncCount)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), syncSessionToken: \(String(describing: syncSessionToken)))"}
}

extension ListRecordsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordsInput>
    public typealias MOutput = OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordsOutputError>
}

public struct ListRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let syncSessionToken = input.operationInput.syncSessionToken {
            let syncSessionTokenQueryItem = URLQueryItem(name: "syncSessionToken".urlPercentEncoding(), value: String(syncSessionToken).urlPercentEncoding())
            input.builder.withQueryItem(syncSessionTokenQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let lastSyncCount = input.operationInput.lastSyncCount {
            let lastSyncCountQueryItem = URLQueryItem(name: "lastSyncCount".urlPercentEncoding(), value: String(lastSyncCount).urlPercentEncoding())
            input.builder.withQueryItem(lastSyncCountQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordsInput>
    public typealias MOutput = OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordsOutputError>
}

/// A request for a list of records.
public struct ListRecordsInput: Equatable {
    /// A string of up to 128 characters. Allowed
    ///       characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    public let datasetName: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?
    /// The last server sync count for this
    ///       record.
    public let lastSyncCount: Int?
    /// The maximum number of results to be
    ///       returned.
    public let maxResults: Int
    /// A pagination token for obtaining the next
    ///       page of results.
    public let nextToken: String?
    /// A token containing a session ID,
    ///       identity ID, and expiration.
    public let syncSessionToken: String?

    public init (
        datasetName: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil,
        lastSyncCount: Int? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        syncSessionToken: String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.lastSyncCount = lastSyncCount
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsInputBody: Equatable {
}

extension ListRecordsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordsOutputResponse(count: \(String(describing: count)), datasetDeletedAfterRequestedSyncCount: \(String(describing: datasetDeletedAfterRequestedSyncCount)), datasetExists: \(String(describing: datasetExists)), datasetSyncCount: \(String(describing: datasetSyncCount)), lastModifiedBy: \(String(describing: lastModifiedBy)), mergedDatasetNames: \(String(describing: mergedDatasetNames)), nextToken: \(String(describing: nextToken)), records: \(String(describing: records)), syncSessionToken: \(String(describing: syncSessionToken)))"}
}

extension ListRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecordsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.count = output.count
            self.datasetDeletedAfterRequestedSyncCount = output.datasetDeletedAfterRequestedSyncCount
            self.datasetExists = output.datasetExists
            self.datasetSyncCount = output.datasetSyncCount
            self.lastModifiedBy = output.lastModifiedBy
            self.mergedDatasetNames = output.mergedDatasetNames
            self.nextToken = output.nextToken
            self.records = output.records
            self.syncSessionToken = output.syncSessionToken
        } else {
            self.count = 0
            self.datasetDeletedAfterRequestedSyncCount = false
            self.datasetExists = false
            self.datasetSyncCount = nil
            self.lastModifiedBy = nil
            self.mergedDatasetNames = nil
            self.nextToken = nil
            self.records = nil
            self.syncSessionToken = nil
        }
    }
}

/// Returned for a successful
///       ListRecordsRequest.
public struct ListRecordsOutputResponse: Equatable {
    /// Total number of records.
    public let count: Int
    /// A boolean value
    ///       specifying whether to delete the dataset locally.
    public let datasetDeletedAfterRequestedSyncCount: Bool
    /// Indicates whether the dataset
    ///       exists.
    public let datasetExists: Bool
    /// Server sync count for this
    ///       dataset.
    public let datasetSyncCount: Int?
    /// The user/device that made the last
    ///       change to this record.
    public let lastModifiedBy: String?
    /// Names of merged
    ///       datasets.
    public let mergedDatasetNames: [String]?
    /// A pagination token for obtaining the next
    ///       page of results.
    public let nextToken: String?
    /// A list of all records.
    public let records: [Record]?
    /// A token containing a session ID,
    ///       identity ID, and expiration.
    public let syncSessionToken: String?

    public init (
        count: Int = 0,
        datasetDeletedAfterRequestedSyncCount: Bool = false,
        datasetExists: Bool = false,
        datasetSyncCount: Int? = nil,
        lastModifiedBy: String? = nil,
        mergedDatasetNames: [String]? = nil,
        nextToken: String? = nil,
        records: [Record]? = nil,
        syncSessionToken: String? = nil
    )
    {
        self.count = count
        self.datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCount
        self.datasetExists = datasetExists
        self.datasetSyncCount = datasetSyncCount
        self.lastModifiedBy = lastModifiedBy
        self.mergedDatasetNames = mergedDatasetNames
        self.nextToken = nextToken
        self.records = records
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsOutputResponseBody: Equatable {
    public let records: [Record]?
    public let nextToken: String?
    public let count: Int
    public let datasetSyncCount: Int?
    public let lastModifiedBy: String?
    public let mergedDatasetNames: [String]?
    public let datasetExists: Bool
    public let datasetDeletedAfterRequestedSyncCount: Bool
    public let syncSessionToken: String?
}

extension ListRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case datasetDeletedAfterRequestedSyncCount = "DatasetDeletedAfterRequestedSyncCount"
        case datasetExists = "DatasetExists"
        case datasetSyncCount = "DatasetSyncCount"
        case lastModifiedBy = "LastModifiedBy"
        case mergedDatasetNames = "MergedDatasetNames"
        case nextToken = "NextToken"
        case records = "Records"
        case syncSessionToken = "SyncSessionToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let datasetSyncCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .datasetSyncCount)
        datasetSyncCount = datasetSyncCountDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let mergedDatasetNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .mergedDatasetNames)
        var mergedDatasetNamesDecoded0:[String]? = nil
        if let mergedDatasetNamesContainer = mergedDatasetNamesContainer {
            mergedDatasetNamesDecoded0 = [String]()
            for string0 in mergedDatasetNamesContainer {
                if let string0 = string0 {
                    mergedDatasetNamesDecoded0?.append(string0)
                }
            }
        }
        mergedDatasetNames = mergedDatasetNamesDecoded0
        let datasetExistsDecoded = try containerValues.decode(Bool.self, forKey: .datasetExists)
        datasetExists = datasetExistsDecoded
        let datasetDeletedAfterRequestedSyncCountDecoded = try containerValues.decode(Bool.self, forKey: .datasetDeletedAfterRequestedSyncCount)
        datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCountDecoded
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a user is not authorized to access the
///       requested resource.
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The message returned by a
    ///       NotAuthorizedException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Operation {
    case remove
    case replace
    case sdkUnknown(String)
}

extension Operation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Operation] {
        return [
            .remove,
            .replace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .remove: return "remove"
        case .replace: return "replace"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
    }
}

public enum Platform {
    case adm
    case apns
    case apnsSandbox
    case gcm
    case sdkUnknown(String)
}

extension Platform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Platform] {
        return [
            .adm,
            .apns,
            .apnsSandbox,
            .gcm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adm: return "ADM"
        case .apns: return "APNS"
        case .apnsSandbox: return "APNS_SANDBOX"
        case .gcm: return "GCM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
    }
}

extension PushSync: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationArns = "ApplicationArns"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArns = applicationArns {
            var applicationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationArns)
            for applicationarnlist0 in applicationArns {
                try applicationArnsContainer.encode(applicationarnlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .applicationArns)
        var applicationArnsDecoded0:[String]? = nil
        if let applicationArnsContainer = applicationArnsContainer {
            applicationArnsDecoded0 = [String]()
            for string0 in applicationArnsContainer {
                if let string0 = string0 {
                    applicationArnsDecoded0?.append(string0)
                }
            }
        }
        applicationArns = applicationArnsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension PushSync: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PushSync(applicationArns: \(String(describing: applicationArns)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Configuration options to be applied to the identity pool.</p>
public struct PushSync: Equatable {
    /// <p>List of SNS platform application ARNs that could be used by clients.</p>
    public let applicationArns: [String]?
    /// <p>A role configured to allow Cognito to call SNS on behalf of the developer.</p>
    public let roleArn: String?

    public init (
        applicationArns: [String]? = nil,
        roleArn: String? = nil
    )
    {
        self.applicationArns = applicationArns
        self.roleArn = roleArn
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = deviceLastModifiedDate {
            try encodeContainer.encode(deviceLastModifiedDate.timeIntervalSince1970, forKey: .deviceLastModifiedDate)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let syncCount = syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(deviceLastModifiedDate: \(String(describing: deviceLastModifiedDate)), key: \(String(describing: key)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), syncCount: \(String(describing: syncCount)), value: \(String(describing: value)))"}
}

/// The basic data structure of a dataset.
public struct Record: Equatable {
    /// The last modified date of the client
    ///       device.
    public let deviceLastModifiedDate: Date?
    /// The key for the record.
    public let key: String?
    /// The user/device that made the last change to this
    ///       record.
    public let lastModifiedBy: String?
    /// The date on which the record was last
    ///       modified.
    public let lastModifiedDate: Date?
    /// The server sync count for this record.
    public let syncCount: Int?
    /// The value for the record.
    public let value: String?

    public init (
        deviceLastModifiedDate: Date? = nil,
        key: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        syncCount: Int? = nil,
        value: String? = nil
    )
    {
        self.deviceLastModifiedDate = deviceLastModifiedDate
        self.key = key
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.syncCount = syncCount
        self.value = value
    }
}

extension RecordPatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case op = "Op"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = deviceLastModifiedDate {
            try encodeContainer.encode(deviceLastModifiedDate.timeIntervalSince1970, forKey: .deviceLastModifiedDate)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let op = op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let syncCount = syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(Operation.self, forKey: .op)
        op = opDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension RecordPatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordPatch(deviceLastModifiedDate: \(String(describing: deviceLastModifiedDate)), key: \(String(describing: key)), op: \(String(describing: op)), syncCount: \(String(describing: syncCount)), value: \(String(describing: value)))"}
}

/// An update operation for a record.
public struct RecordPatch: Equatable {
    /// The last modified date of the client
    ///       device.
    public let deviceLastModifiedDate: Date?
    /// The key associated with the record patch.
    public let key: String?
    /// An operation, either replace or remove.
    public let op: Operation?
    /// Last known server sync count for this record. Set
    ///       to 0 if unknown.
    public let syncCount: Int?
    /// The value associated with the record
    ///       patch.
    public let value: String?

    public init (
        deviceLastModifiedDate: Date? = nil,
        key: String? = nil,
        op: Operation? = nil,
        syncCount: Int? = nil,
        value: String? = nil
    )
    {
        self.deviceLastModifiedDate = deviceLastModifiedDate
        self.key = key
        self.op = op
        self.syncCount = syncCount
        self.value = value
    }
}

public struct RegisterDeviceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDeviceOutputError>
}

extension RegisterDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDeviceInput(identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), platform: \(String(describing: platform)), token: \(String(describing: token)))"}
}

extension RegisterDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

public struct RegisterDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDeviceOutputError>
}

public struct RegisterDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDeviceOutputError>
}

/// <p>A request to RegisterDevice.</p>
public struct RegisterDeviceInput: Equatable {
    /// <p>The unique ID for this identity.</p>
    public let identityId: String?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. Here, the ID of the pool that the identity belongs to.</p>
    public let identityPoolId: String?
    /// <p>The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).</p>
    public let platform: Platform?
    /// <p>The push token.</p>
    public let token: String?

    public init (
        identityId: String? = nil,
        identityPoolId: String? = nil,
        platform: Platform? = nil,
        token: String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.platform = platform
        self.token = token
    }
}

struct RegisterDeviceInputBody: Equatable {
    public let platform: Platform?
    public let token: String?
}

extension RegisterDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension RegisterDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDeviceOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDeviceOutputResponse(deviceId: \(String(describing: deviceId)))"}
}

extension RegisterDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

/// <p>Response to a RegisterDevice request.</p>
public struct RegisterDeviceOutputResponse: Equatable {
    /// <p>The unique ID generated for this device by Cognito.</p>
    public let deviceId: String?

    public init (
        deviceId: String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct RegisterDeviceOutputResponseBody: Equatable {
    public let deviceId: String?
}

extension RegisterDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if an update can't be applied because
///       the resource was changed by another call and this would result in a conflict.
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The message returned by a
    ///       ResourceConflictException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let message: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if the resource doesn't
///       exist.
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Message returned by a
    ///       ResourceNotFoundException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetCognitoEventsInputBodyMiddleware: Middleware {
    public let id: String = "SetCognitoEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetCognitoEventsOutputError>
}

extension SetCognitoEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetCognitoEventsInput(events: \(String(describing: events)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension SetCognitoEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .events)
            for (dictKey0, events0) in events {
                try eventsContainer.encode(events0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct SetCognitoEventsInputHeadersMiddleware: Middleware {
    public let id: String = "SetCognitoEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetCognitoEventsOutputError>
}

public struct SetCognitoEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetCognitoEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetCognitoEventsOutputError>
}

/// <p>A request to configure Cognito Events"</p>"
public struct SetCognitoEventsInput: Equatable {
    /// <p>The events to configure</p>
    public let events: [String:String]?
    /// <p>The Cognito Identity Pool to use when configuring Cognito Events</p>
    public let identityPoolId: String?

    public init (
        events: [String:String]? = nil,
        identityPoolId: String? = nil
    )
    {
        self.events = events
        self.identityPoolId = identityPoolId
    }
}

struct SetCognitoEventsInputBody: Equatable {
    public let events: [String:String]?
}

extension SetCognitoEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .events)
        var eventsDecoded0: [String:String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [String:String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension SetCognitoEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetCognitoEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetCognitoEventsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetCognitoEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetCognitoEventsOutputResponse()"}
}

extension SetCognitoEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetCognitoEventsOutputResponse: Equatable {

    public init() {}
}

struct SetCognitoEventsOutputResponseBody: Equatable {
}

extension SetCognitoEventsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityPoolConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityPoolConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolConfigurationOutputError>
}

extension SetIdentityPoolConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityPoolConfigurationInput(cognitoStreams: \(String(describing: cognitoStreams)), identityPoolId: \(String(describing: identityPoolId)), pushSync: \(String(describing: pushSync)))"}
}

extension SetIdentityPoolConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoStreams = cognitoStreams {
            try encodeContainer.encode(cognitoStreams, forKey: .cognitoStreams)
        }
        if let pushSync = pushSync {
            try encodeContainer.encode(pushSync, forKey: .pushSync)
        }
    }
}

public struct SetIdentityPoolConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityPoolConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolConfigurationOutputError>
}

public struct SetIdentityPoolConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityPoolConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolConfigurationOutputError>
}

/// <p>The input for the SetIdentityPoolConfiguration operation.</p>
public struct SetIdentityPoolConfigurationInput: Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public let cognitoStreams: CognitoStreams?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. This is the ID of the pool to modify.</p>
    public let identityPoolId: String?
    /// <p>Options to apply to this identity pool for push synchronization.</p>
    public let pushSync: PushSync?

    public init (
        cognitoStreams: CognitoStreams? = nil,
        identityPoolId: String? = nil,
        pushSync: PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationInputBody: Equatable {
    public let pushSync: PushSync?
    public let cognitoStreams: CognitoStreams?
}

extension SetIdentityPoolConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushSyncDecoded = try containerValues.decodeIfPresent(PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension SetIdentityPoolConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetIdentityPoolConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityPoolConfigurationOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityPoolConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityPoolConfigurationOutputResponse(cognitoStreams: \(String(describing: cognitoStreams)), identityPoolId: \(String(describing: identityPoolId)), pushSync: \(String(describing: pushSync)))"}
}

extension SetIdentityPoolConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetIdentityPoolConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// <p>The output for the SetIdentityPoolConfiguration operation</p>
public struct SetIdentityPoolConfigurationOutputResponse: Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public let cognitoStreams: CognitoStreams?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito.</p>
    public let identityPoolId: String?
    /// <p>Options to apply to this identity pool for push synchronization.</p>
    public let pushSync: PushSync?

    public init (
        cognitoStreams: CognitoStreams? = nil,
        identityPoolId: String? = nil,
        pushSync: PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let pushSync: PushSync?
    public let cognitoStreams: CognitoStreams?
}

extension SetIdentityPoolConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

public enum StreamingStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension StreamingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
    }
}

extension SubscribeToDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToDatasetInput(datasetName: \(String(describing: datasetName)), deviceId: \(String(describing: deviceId)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension SubscribeToDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct SubscribeToDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "SubscribeToDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToDatasetInput>
    public typealias MOutput = OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToDatasetOutputError>
}

public struct SubscribeToDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "SubscribeToDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToDatasetInput>
    public typealias MOutput = OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToDatasetOutputError>
}

/// <p>A request to SubscribeToDatasetRequest.</p>
public struct SubscribeToDatasetInput: Equatable {
    /// <p>The name of the dataset to subcribe to.</p>
    public let datasetName: String?
    /// <p>The unique ID generated for this device by Cognito.</p>
    public let deviceId: String?
    /// <p>Unique ID for this identity.</p>
    public let identityId: String?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. The ID of the pool to which the identity belongs.</p>
    public let identityPoolId: String?

    public init (
        datasetName: String? = nil,
        deviceId: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct SubscribeToDatasetInputBody: Equatable {
}

extension SubscribeToDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SubscribeToDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToDatasetOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToDatasetOutputResponse()"}
}

extension SubscribeToDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Response to a SubscribeToDataset request.</p>
public struct SubscribeToDatasetOutputResponse: Equatable {

    public init() {}
}

struct SubscribeToDatasetOutputResponseBody: Equatable {
}

extension SubscribeToDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if the request is
///       throttled.
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Message returned by a
    ///       TooManyRequestsException.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsubscribeFromDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeFromDatasetInput(datasetName: \(String(describing: datasetName)), deviceId: \(String(describing: deviceId)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension UnsubscribeFromDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UnsubscribeFromDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "UnsubscribeFromDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeFromDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeFromDatasetInput>
    public typealias MOutput = OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeFromDatasetOutputError>
}

public struct UnsubscribeFromDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "UnsubscribeFromDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeFromDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeFromDatasetInput>
    public typealias MOutput = OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeFromDatasetOutputError>
}

/// <p>A request to UnsubscribeFromDataset.</p>
public struct UnsubscribeFromDatasetInput: Equatable {
    /// <p>The name of the dataset from which to unsubcribe.</p>
    public let datasetName: String?
    /// <p>The unique ID generated for this device by Cognito.</p>
    public let deviceId: String?
    /// <p>Unique ID for this identity.</p>
    public let identityId: String?
    /// <p>A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. The ID of the pool to which this identity belongs.</p>
    public let identityPoolId: String?

    public init (
        datasetName: String? = nil,
        deviceId: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnsubscribeFromDatasetInputBody: Equatable {
}

extension UnsubscribeFromDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnsubscribeFromDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeFromDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeFromDatasetOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeFromDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeFromDatasetOutputResponse()"}
}

extension UnsubscribeFromDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Response to an UnsubscribeFromDataset request.</p>
public struct UnsubscribeFromDatasetOutputResponse: Equatable {

    public init() {}
}

struct UnsubscribeFromDatasetOutputResponseBody: Equatable {
}

extension UnsubscribeFromDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRecordsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecordsOutputError>
}

extension UpdateRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecordsInput(clientContext: \(String(describing: clientContext)), datasetName: \(String(describing: datasetName)), deviceId: \(String(describing: deviceId)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), recordPatches: \(String(describing: recordPatches)), syncSessionToken: \(String(describing: syncSessionToken)))"}
}

extension UpdateRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let recordPatches = recordPatches {
            var recordPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordPatches)
            for recordpatchlist0 in recordPatches {
                try recordPatchesContainer.encode(recordpatchlist0)
            }
        }
        if let syncSessionToken = syncSessionToken {
            try encodeContainer.encode(syncSessionToken, forKey: .syncSessionToken)
        }
    }
}

public struct UpdateRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientContext = input.operationInput.clientContext {
            input.builder.withHeader(name: "x-amz-Client-Context", value: String(clientContext))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecordsOutputError>
}

public struct UpdateRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecordsOutputError>
}

/// A request to post updates to records or add and
///       delete records for a dataset and user.
public struct UpdateRecordsInput: Equatable {
    /// Intended to supply a device ID that
    ///       will populate the lastModifiedBy field referenced in other methods. The
    ///          ClientContext field is not yet implemented.
    public let clientContext: String?
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    public let datasetName: String?
    /// <p>The unique ID generated for this device by Cognito.</p>
    public let deviceId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityId: String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public let identityPoolId: String?
    /// A list of patch
    ///       operations.
    public let recordPatches: [RecordPatch]?
    /// The SyncSessionToken returned by a
    ///       previous call to ListRecords for this dataset and identity.
    public let syncSessionToken: String?

    public init (
        clientContext: String? = nil,
        datasetName: String? = nil,
        deviceId: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil,
        recordPatches: [RecordPatch]? = nil,
        syncSessionToken: String? = nil
    )
    {
        self.clientContext = clientContext
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.recordPatches = recordPatches
        self.syncSessionToken = syncSessionToken
    }
}

struct UpdateRecordsInputBody: Equatable {
    public let deviceId: String?
    public let recordPatches: [RecordPatch]?
    public let syncSessionToken: String?
}

extension UpdateRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let recordPatchesContainer = try containerValues.decodeIfPresent([RecordPatch?].self, forKey: .recordPatches)
        var recordPatchesDecoded0:[RecordPatch]? = nil
        if let recordPatchesContainer = recordPatchesContainer {
            recordPatchesDecoded0 = [RecordPatch]()
            for structure0 in recordPatchesContainer {
                if let structure0 = structure0 {
                    recordPatchesDecoded0?.append(structure0)
                }
            }
        }
        recordPatches = recordPatchesDecoded0
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

extension UpdateRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionOutputException" : self = .invalidLambdaFunctionOutputException(try InvalidLambdaFunctionOutputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LambdaThrottledException" : self = .lambdaThrottledException(try LambdaThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecordsOutputError: Swift.Error, Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaFunctionOutputException(InvalidLambdaFunctionOutputException)
    case invalidParameterException(InvalidParameterException)
    case lambdaThrottledException(LambdaThrottledException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecordsOutputResponse(records: \(String(describing: records)))"}
}

extension UpdateRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRecordsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.records = output.records
        } else {
            self.records = nil
        }
    }
}

/// Returned for a successful
///       UpdateRecordsRequest.
public struct UpdateRecordsOutputResponse: Equatable {
    /// A list of records that have been
    ///       updated.
    public let records: [Record]?

    public init (
        records: [Record]? = nil
    )
    {
        self.records = records
    }
}

struct UpdateRecordsOutputResponseBody: Equatable {
    public let records: [Record]?
}

extension UpdateRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case records = "Records"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}
