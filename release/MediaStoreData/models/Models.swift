// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ContainerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerNotFoundException(message: \(String(describing: message)))"}
}

extension ContainerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified container was not found for the specified account.</p>
public struct ContainerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ContainerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectInput(path: \(String(describing: path)))"}
}

extension DeleteObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteObjectInput>
    public typealias MOutput = OperationOutput<DeleteObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteObjectOutputError>
}

public struct DeleteObjectInput: Equatable {
    /// <p>The path (including the file name) where the object is stored in the container.
    ///          Format: <folder name>/<folder name>/<file name></p>
    public let path: String?

    public init (
        path: String? = nil
    )
    {
        self.path = path
    }
}

struct DeleteObjectInputBody: Equatable {
}

extension DeleteObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteObjectOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteObjectOutputResponse()"}
}

extension DeleteObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteObjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteObjectOutputResponseBody: Equatable {
}

extension DeleteObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObjectInput(path: \(String(describing: path)))"}
}

extension DescribeObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeObjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObjectInput>
    public typealias MOutput = OperationOutput<DescribeObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObjectOutputError>
}

public struct DescribeObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObjectInput>
    public typealias MOutput = OperationOutput<DescribeObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObjectOutputError>
}

public struct DescribeObjectInput: Equatable {
    /// <p>The path (including the file name) where the object is stored in the container.
    ///          Format: <folder name>/<folder name>/<file name></p>
    public let path: String?

    public init (
        path: String? = nil
    )
    {
        self.path = path
    }
}

struct DescribeObjectInputBody: Equatable {
}

extension DescribeObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeObjectOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObjectOutputResponse(cacheControl: \(String(describing: cacheControl)), contentLength: \(String(describing: contentLength)), contentType: \(String(describing: contentType)), eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)))"}
}

extension DescribeObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
    }
}

public struct DescribeObjectOutputResponse: Equatable {
    /// <p>An optional <code>CacheControl</code> header that allows the caller to control the
    ///          object's cache behavior. Headers can be passed in as specified in the HTTP at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    ///          <p>Headers with a custom user-defined value are also accepted.</p>
    public let cacheControl: String?
    /// <p>The length of the object in bytes.</p>
    public let contentLength: Int?
    /// <p>The content type of the object.</p>
    public let contentType: String?
    /// <p>The ETag that represents a unique instance of the object.</p>
    public let eTag: String?
    /// <p>The date and time that the object was last modified.</p>
    public let lastModified: Date?

    public init (
        cacheControl: String? = nil,
        contentLength: Int? = nil,
        contentType: String? = nil,
        eTag: String? = nil,
        lastModified: Date? = nil
    )
    {
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
    }
}

struct DescribeObjectOutputResponseBody: Equatable {
}

extension DescribeObjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectInput(path: \(String(describing: path)), range: \(String(describing: range)))"}
}

extension GetObjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetObjectInputHeadersMiddleware: Middleware {
    public let id: String = "GetObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Range", value: String(range))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInput>
    public typealias MOutput = OperationOutput<GetObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectOutputError>
}

public struct GetObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetObjectInput>
    public typealias MOutput = OperationOutput<GetObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetObjectOutputError>
}

public struct GetObjectInput: Equatable {
    /// <p>The path (including the file name) where the object is stored in the container.
    ///          Format: <folder name>/<folder name>/<file name></p>
    ///          <p>For example, to upload the file <code>mlaw.avi</code> to the folder path
    ///             <code>premium\canada</code> in the container <code>movies</code>, enter the path
    ///             <code>premium/canada/mlaw.avi</code>.</p>
    ///          <p>Do not include the container name in this path.</p>
    ///          <p>If the path includes any folders that don't exist yet, the service creates them. For
    ///          example, suppose you have an existing <code>premium/usa</code> subfolder. If you specify
    ///             <code>premium/canada</code>, the service creates a <code>canada</code> subfolder in the
    ///             <code>premium</code> folder. You then have two subfolders, <code>usa</code> and
    ///             <code>canada</code>, in the <code>premium</code> folder. </p>
    ///          <p>There is no correlation between the path to the source and the path (folders) in the
    ///          container in AWS Elemental MediaStore.</p>
    ///          <p>For more information about folders and how they exist in a container, see the <a href="http://docs.aws.amazon.com/mediastore/latest/ug/">AWS Elemental MediaStore User
    ///             Guide</a>.</p>
    ///          <p>The file name is the name that is assigned to the file that you upload. The file can
    ///          have the same name inside and outside of AWS Elemental MediaStore, or it can have the same
    ///          name. The file name can include or omit an extension. </p>
    public let path: String?
    /// <p>The range bytes of an object to retrieve. For more information about the
    ///           <code>Range</code> header, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a>. AWS Elemental MediaStore ignores this header for partially uploaded objects that have streaming upload availability.</p>
    public let range: String?

    public init (
        path: String? = nil,
        range: String? = nil
    )
    {
        self.path = path
        self.range = range
    }
}

struct GetObjectInputBody: Equatable {
}

extension GetObjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestedRangeNotSatisfiableException" : self = .requestedRangeNotSatisfiableException(try RequestedRangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetObjectOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case requestedRangeNotSatisfiableException(RequestedRangeNotSatisfiableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetObjectOutputResponse(body: \(String(describing: body)), cacheControl: \(String(describing: cacheControl)), contentLength: \(String(describing: contentLength)), contentRange: \(String(describing: contentRange)), contentType: \(String(describing: contentType)), eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)), statusCode: \(String(describing: statusCode)))"}
}

extension GetObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = DateFormatter.rfc5322DateFormatter.date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct GetObjectOutputResponse: Equatable {
    /// <p>The bytes of the object. </p>
    public let body: Data?
    /// <p>An optional <code>CacheControl</code> header that allows the caller to control the
    ///          object's cache behavior. Headers can be passed in as specified in the HTTP spec at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    ///          <p>Headers with a custom user-defined value are also accepted.</p>
    public let cacheControl: String?
    /// <p>The length of the object in bytes.</p>
    public let contentLength: Int?
    /// <p>The range of bytes to retrieve.</p>
    public let contentRange: String?
    /// <p>The content type of the object.</p>
    public let contentType: String?
    /// <p>The ETag that represents a unique instance of the object.</p>
    public let eTag: String?
    /// <p>The date and time that the object was last modified.</p>
    public let lastModified: Date?
    /// <p>The HTML status code of the request. Status codes ranging from 200 to 299 indicate
    ///          success. All other status codes indicate the type of error that occurred.</p>
    public let statusCode: Int

    public init (
        body: Data? = nil,
        cacheControl: String? = nil,
        contentLength: Int? = nil,
        contentRange: String? = nil,
        contentType: String? = nil,
        eTag: String? = nil,
        lastModified: Date? = nil,
        statusCode: Int = 0
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
        self.statusCode = statusCode
    }
}

struct GetObjectOutputResponseBody: Equatable {
    public let body: Data?
    public let statusCode: Int
}

extension GetObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case statusCode = "StatusCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Item: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentLength = "ContentLength"
        case contentType = "ContentType"
        case eTag = "ETag"
        case lastModified = "LastModified"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentLength = contentLength {
            try encodeContainer.encode(contentLength, forKey: .contentLength)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eTag = eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ItemType.self, forKey: .type)
        type = typeDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentLengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
    }
}

extension Item: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Item(contentLength: \(String(describing: contentLength)), contentType: \(String(describing: contentType)), eTag: \(String(describing: eTag)), lastModified: \(String(describing: lastModified)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>A metadata entry for a folder or object.</p>
public struct Item: Equatable {
    /// <p>The length of the item in bytes.</p>
    public let contentLength: Int?
    /// <p>The content type of the item.</p>
    public let contentType: String?
    /// <p>The ETag that represents a unique instance of the item.</p>
    public let eTag: String?
    /// <p>The date and time that the item was last modified.</p>
    public let lastModified: Date?
    /// <p>The name of the item.</p>
    public let name: String?
    /// <p>The item type (folder or object).</p>
    public let type: ItemType?

    public init (
        contentLength: Int? = nil,
        contentType: String? = nil,
        eTag: String? = nil,
        lastModified: Date? = nil,
        name: String? = nil,
        type: ItemType? = nil
    )
    {
        self.contentLength = contentLength
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
        self.name = name
        self.type = type
    }
}

public enum ItemType {
    case folder
    case object
    case sdkUnknown(String)
}

extension ItemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ItemType] {
        return [
            .folder,
            .object,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .folder: return "FOLDER"
        case .object: return "OBJECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
    }
}

extension ListItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListItemsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), path: \(String(describing: path)))"}
}

extension ListItemsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListItemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListItemsInput>
    public typealias MOutput = OperationOutput<ListItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListItemsOutputError>
}

public struct ListItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let path = input.operationInput.path {
            let pathQueryItem = URLQueryItem(name: "Path".urlPercentEncoding(), value: String(path).urlPercentEncoding())
            input.builder.withQueryItem(pathQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListItemsInput>
    public typealias MOutput = OperationOutput<ListItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListItemsOutputError>
}

public struct ListItemsInput: Equatable {
    /// <p>The maximum number of results to return per API request. For example, you submit a
    ///             <code>ListItems</code> request with <code>MaxResults</code> set at 500. Although 2,000
    ///          items match your request, the service returns no more than the first 500 items. (The
    ///          service also returns a <code>NextToken</code> value that you can use to fetch the next
    ///          batch of results.) The service might return fewer results than the <code>MaxResults</code>
    ///          value.</p>
    ///          <p>If <code>MaxResults</code> is not included in the request, the service defaults to
    ///          pagination with a maximum of 1,000 results per page.</p>
    public let maxResults: Int?
    /// <p>The token that identifies which batch of results that you want to see. For example,
    ///          you submit a <code>ListItems</code> request with <code>MaxResults</code> set at 500. The
    ///          service returns the first batch of results (up to 500) and a <code>NextToken</code> value.
    ///          To see the next batch of results, you can submit the <code>ListItems</code> request a
    ///          second time and specify the <code>NextToken</code> value.</p>
    ///          <p>Tokens expire after 15 minutes.</p>
    public let nextToken: String?
    /// <p>The path in the container from which to retrieve items. Format: <folder
    ///          name>/<folder name>/<file name></p>
    public let path: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        path: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.path = path
    }
}

struct ListItemsInputBody: Equatable {
}

extension ListItemsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListItemsOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListItemsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListItemsOutputResponse: Equatable {
    /// <p>The metadata entries for the folders and objects at the requested path.</p>
    public let items: [Item]?
    /// <p>The token that can be used in a request to view the next set of results. For example,
    ///          you submit a <code>ListItems</code> request that matches 2,000 items with
    ///             <code>MaxResults</code> set at 500. The service returns the first batch of results (up
    ///          to 500) and a <code>NextToken</code> value that can be used to fetch the next batch of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [Item]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListItemsOutputResponseBody: Equatable {
    public let items: [Item]?
    public let nextToken: String?
}

extension ListItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Item?].self, forKey: .items)
        var itemsDecoded0:[Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ObjectNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectNotFoundException(message: \(String(describing: message)))"}
}

extension ObjectNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ObjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Could not perform an operation on an object that does not exist.</p>
public struct ObjectNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ObjectNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutObjectInputBodyMiddleware: Middleware {
    public let id: String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

extension PutObjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectInput(body: \(String(describing: body)), cacheControl: \(String(describing: cacheControl)), contentType: \(String(describing: contentType)), path: \(String(describing: path)), storageClass: \(String(describing: storageClass)), uploadAvailability: \(String(describing: uploadAvailability)))"}
}

extension PutObjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct PutObjectInputHeadersMiddleware: Middleware {
    public let id: String = "PutObjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cacheControl = input.operationInput.cacheControl {
            input.builder.withHeader(name: "Cache-Control", value: String(cacheControl))
        }
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let storageClass = input.operationInput.storageClass {
            input.builder.withHeader(name: "x-amz-storage-class", value: String(storageClass.rawValue))
        }
        if let uploadAvailability = input.operationInput.uploadAvailability {
            input.builder.withHeader(name: "x-amz-upload-availability", value: String(uploadAvailability.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

public struct PutObjectInputQueryItemMiddleware: Middleware {
    public let id: String = "PutObjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutObjectInput>,
                  next: H) -> Swift.Result<OperationOutput<PutObjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutObjectInput>
    public typealias MOutput = OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutObjectOutputError>
}

public struct PutObjectInput: Equatable {
    /// <p>The bytes to be stored. </p>
    public let body: Data?
    /// <p>An optional <code>CacheControl</code> header that allows the caller to control the
    ///          object's cache behavior. Headers can be passed in as specified in the HTTP at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9</a>.</p>
    ///          <p>Headers with a custom user-defined value are also accepted.</p>
    public let cacheControl: String?
    /// <p>The content type of the object.</p>
    public let contentType: String?
    /// <p>The path (including the file name) where the object is stored in the container.
    ///          Format: <folder name>/<folder name>/<file name></p>
    ///          <p>For example, to upload the file <code>mlaw.avi</code> to the folder path
    ///             <code>premium\canada</code> in the container <code>movies</code>, enter the path
    ///             <code>premium/canada/mlaw.avi</code>.</p>
    ///          <p>Do not include the container name in this path.</p>
    ///          <p>If the path includes any folders that don't exist yet, the service creates them. For
    ///          example, suppose you have an existing <code>premium/usa</code> subfolder. If you specify
    ///             <code>premium/canada</code>, the service creates a <code>canada</code> subfolder in the
    ///             <code>premium</code> folder. You then have two subfolders, <code>usa</code> and
    ///             <code>canada</code>, in the <code>premium</code> folder. </p>
    ///          <p>There is no correlation between the path to the source and the path (folders) in the
    ///          container in AWS Elemental MediaStore.</p>
    ///          <p>For more information about folders and how they exist in a container, see the <a href="http://docs.aws.amazon.com/mediastore/latest/ug/">AWS Elemental MediaStore User
    ///             Guide</a>.</p>
    ///          <p>The file name is the name that is assigned to the file that you upload. The file can
    ///          have the same name inside and outside of AWS Elemental MediaStore, or it can have the same
    ///          name. The file name can include or omit an extension. </p>
    public let path: String?
    /// <p>Indicates the storage class of a <code>Put</code> request. Defaults to
    ///          high-performance temporal storage class, and objects are persisted into durable storage
    ///          shortly after being received.</p>
    public let storageClass: StorageClass?
    /// <p>Indicates the availability of an object while it is still uploading. If the value is set to <code>streaming</code>, the object is available for
    ///             downloading after some initial buffering but before the object is uploaded completely. If the value is set to <code>standard</code>, the object is
    ///             available for downloading only when it is uploaded completely. The default value for this header is <code>standard</code>.</p>
    ///         <p>To use this header, you must also set the HTTP <code>Transfer-Encoding</code> header to <code>chunked</code>.</p>
    public let uploadAvailability: UploadAvailability?

    public init (
        body: Data? = nil,
        cacheControl: String? = nil,
        contentType: String? = nil,
        path: String? = nil,
        storageClass: StorageClass? = nil,
        uploadAvailability: UploadAvailability? = nil
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.path = path
        self.storageClass = storageClass
        self.uploadAvailability = uploadAvailability
    }
}

struct PutObjectInputBody: Equatable {
    public let body: Data?
}

extension PutObjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutObjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutObjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutObjectOutputError: Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutObjectOutputResponse(contentSHA256: \(String(describing: contentSHA256)), eTag: \(String(describing: eTag)), storageClass: \(String(describing: storageClass)))"}
}

extension PutObjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutObjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentSHA256 = output.contentSHA256
            self.eTag = output.eTag
            self.storageClass = output.storageClass
        } else {
            self.contentSHA256 = nil
            self.eTag = nil
            self.storageClass = nil
        }
    }
}

public struct PutObjectOutputResponse: Equatable {
    /// <p>The SHA256 digest of the object that is persisted.</p>
    public let contentSHA256: String?
    /// <p>Unique identifier of the object in the container.</p>
    public let eTag: String?
    /// <p>The storage class where the object was persisted. The class should be
    ///          “Temporal”.</p>
    public let storageClass: StorageClass?

    public init (
        contentSHA256: String? = nil,
        eTag: String? = nil,
        storageClass: StorageClass? = nil
    )
    {
        self.contentSHA256 = contentSHA256
        self.eTag = eTag
        self.storageClass = storageClass
    }
}

struct PutObjectOutputResponseBody: Equatable {
    public let contentSHA256: String?
    public let eTag: String?
    public let storageClass: StorageClass?
}

extension PutObjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentSHA256 = "ContentSHA256"
        case eTag = "ETag"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSHA256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .contentSHA256)
        contentSHA256 = contentSHA256Decoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension RequestedRangeNotSatisfiableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestedRangeNotSatisfiableException(message: \(String(describing: message)))"}
}

extension RequestedRangeNotSatisfiableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestedRangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested content range is not valid.</p>
public struct RequestedRangeNotSatisfiableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestedRangeNotSatisfiableExceptionBody: Equatable {
    public let message: String?
}

extension RequestedRangeNotSatisfiableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum StorageClass {
    case temporal
    case sdkUnknown(String)
}

extension StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClass] {
        return [
            .temporal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .temporal: return "TEMPORAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
    }
}

public enum UploadAvailability {
    case standard
    case streaming
    case sdkUnknown(String)
}

extension UploadAvailability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadAvailability] {
        return [
            .standard,
            .streaming,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .standard: return "STANDARD"
        case .streaming: return "STREAMING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadAvailability(rawValue: rawValue) ?? UploadAvailability.sdkUnknown(rawValue)
    }
}
