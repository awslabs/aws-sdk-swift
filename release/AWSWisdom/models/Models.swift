// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.AppIntegrationsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIntegrationArn
        case objectFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIntegrationArn = self.appIntegrationArn {
            try encodeContainer.encode(appIntegrationArn, forKey: .appIntegrationArn)
        }
        if let objectFields = objectFields {
            var objectFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectFields)
            for nonemptystring0 in objectFields {
                try objectFieldsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIntegrationArn)
        appIntegrationArn = appIntegrationArnDecoded
        let objectFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectFields)
        var objectFieldsDecoded0:[Swift.String]? = nil
        if let objectFieldsContainer = objectFieldsContainer {
            objectFieldsDecoded0 = [Swift.String]()
            for string0 in objectFieldsContainer {
                if let string0 = string0 {
                    objectFieldsDecoded0?.append(string0)
                }
            }
        }
        objectFields = objectFieldsDecoded0
    }
}

extension WisdomClientTypes {
    /// Configuration information for Amazon AppIntegrations to automatically ingest content.
    public struct AppIntegrationsConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        /// This member is required.
        public var appIntegrationArn: Swift.String?
        /// The fields from the source that are made available to your agents in Wisdom.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), you must include at least number, short_description, sys_mod_count, workflow_state, and active.
        ///
        ///
        /// Make sure to include additional fields. These fields are indexed and used to source recommendations.
        /// This member is required.
        public var objectFields: [Swift.String]?

        public init (
            appIntegrationArn: Swift.String? = nil,
            objectFields: [Swift.String]? = nil
        )
        {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }
    }

}

extension WisdomClientTypes.AssistantAssociationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = self.assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = self.assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = self.associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Information about the assistant association.
    public struct AssistantAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A union type that currently has a single argument, the knowledge base ID.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.AssistantAssociationInputData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseid = "knowledgeBaseId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseid(knowledgebaseid):
                try container.encode(knowledgebaseid, forKey: .knowledgebaseid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .knowledgebaseid)
        if let knowledgebaseid = knowledgebaseidDecoded {
            self = .knowledgebaseid(knowledgebaseid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// The data that is input into Wisdom as a result of the assistant association.
    public enum AssistantAssociationInputData: Swift.Equatable, Swift.Hashable {
        /// The identifier of the knowledge base.
        case knowledgebaseid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes.AssistantAssociationOutputData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseassociation = "knowledgeBaseAssociation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseassociation(knowledgebaseassociation):
                try container.encode(knowledgebaseassociation, forKey: .knowledgebaseassociation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseassociationDecoded = try values.decodeIfPresent(WisdomClientTypes.KnowledgeBaseAssociationData.self, forKey: .knowledgebaseassociation)
        if let knowledgebaseassociation = knowledgebaseassociationDecoded {
            self = .knowledgebaseassociation(knowledgebaseassociation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// The data that is output as a result of the assistant association.
    public enum AssistantAssociationOutputData: Swift.Equatable {
        /// The knowledge base where output data is sent.
        case knowledgebaseassociation(WisdomClientTypes.KnowledgeBaseAssociationData)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes.AssistantAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = self.assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = self.assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = self.associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Summary information about the assistant association.
    public struct AssistantAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The association data.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.AssistantData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case description
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension WisdomClientTypes {
    /// The assistant data.
    public struct AssistantData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name.
        /// This member is required.
        public var name: Swift.String?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    public enum AssistantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantStatus(rawValue: rawValue) ?? AssistantStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.AssistantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case description
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension WisdomClientTypes {
    /// Summary information about the assistant.
    public struct AssistantSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description of the assistant.
        public var description: Swift.String?
        /// The name of the assistant.
        /// This member is required.
        public var name: Swift.String?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    public enum AssistantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantType] {
            return [
                .agent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantType(rawValue: rawValue) ?? AssistantType.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationType(rawValue: rawValue) ?? AssociationType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.ContentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case linkOutUri
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
        case url
        case urlExpiry
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let linkOutUri = self.linkOutUri {
            try encodeContainer.encode(linkOutUri, forKey: .linkOutUri)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = self.urlExpiry {
            try encodeContainer.encodeTimestamp(urlExpiry, format: .epochSeconds, forKey: .urlExpiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let linkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkOutUri)
        linkOutUri = linkOutUriDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

extension WisdomClientTypes.ContentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentData(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), linkOutUri: \(Swift.String(describing: linkOutUri)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// Information about the content.
    public struct ContentData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The URI of the content.
        public var linkOutUri: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the content revision.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?
        /// The URL of the content.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: ClientRuntime.Date?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            linkOutUri: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: ClientRuntime.Date? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension WisdomClientTypes.ContentReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
    }
}

extension WisdomClientTypes {
    /// Reference information about the content.
    public struct ContentReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        public var knowledgeBaseId: Swift.String?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes {
    public enum ContentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentStatus(rawValue: rawValue) ?? ContentStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.ContentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = self.contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = self.contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Summary information about the content.
    public struct ContentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the revision of the content.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

extension CreateAssistantAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let association = self.association {
            try encodeContainer.encode(association, forKey: .association)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

public struct CreateAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: WisdomClientTypes.AssistantAssociationInputData?
    /// The type of association.
    /// This member is required.
    public var associationType: WisdomClientTypes.AssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assistantId: Swift.String? = nil,
        association: WisdomClientTypes.AssistantAssociationInputData? = nil,
        associationType: WisdomClientTypes.AssociationType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssistantAssociationInputBody: Swift.Equatable {
    let associationType: WisdomClientTypes.AssociationType?
    let association: WisdomClientTypes.AssistantAssociationInputData?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssistantAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationInputData.self, forKey: .association)
        association = associationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssistantAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct CreateAssistantAssociationOutputResponse: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init (
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct CreateAssistantAssociationOutputResponseBody: Swift.Equatable {
    let assistantAssociation: WisdomClientTypes.AssistantAssociationData?
}

extension CreateAssistantAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

extension CreateAssistantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assistants"
    }
}

public struct CreateAssistantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the assistant.
    public var description: Swift.String?
    /// The name of the assistant.
    /// This member is required.
    public var name: Swift.String?
    /// The KMS key used for encryption.
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of assistant.
    /// This member is required.
    public var type: WisdomClientTypes.AssistantType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: WisdomClientTypes.AssistantType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.type = type
    }
}

struct CreateAssistantInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let type: WisdomClientTypes.AssistantType?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
}

extension CreateAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension CreateAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct CreateAssistantOutputResponse: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init (
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct CreateAssistantOutputResponseBody: Swift.Equatable {
    let assistant: WisdomClientTypes.AssistantData?
}

extension CreateAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

extension CreateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideLinkOutUri = self.overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension CreateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

public struct CreateContentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the [SearchContent](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_SearchContent.html) API.
    /// This member is required.
    public var name: Swift.String?
    /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
    public var overrideLinkOutUri: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The title of the content. If not set, the title is equal to the name.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.name = name
        self.overrideLinkOutUri = overrideLinkOutUri
        self.tags = tags
        self.title = title
        self.uploadId = uploadId
    }
}

struct CreateContentInputBody: Swift.Equatable {
    let name: Swift.String?
    let title: Swift.String?
    let overrideLinkOutUri: Swift.String?
    let metadata: [Swift.String:Swift.String]?
    let uploadId: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct CreateContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct CreateContentOutputResponseBody: Swift.Equatable {
    let content: WisdomClientTypes.ContentData?
}

extension CreateContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/knowledgeBases"
    }
}

public struct CreateKnowledgeBaseInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
    /// This member is required.
    public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
    /// The name of the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Information about how to render the content.
    public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
    /// The KMS key used for encryption.
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
    public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
        name: Swift.String? = nil,
        renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseType = knowledgeBaseType
        self.name = name
        self.renderingConfiguration = renderingConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateKnowledgeBaseInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
    let sourceConfiguration: WisdomClientTypes.SourceConfiguration?
    let renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
    let serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateKnowledgeBaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct CreateKnowledgeBaseOutputResponse: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct CreateKnowledgeBaseOutputResponseBody: Swift.Equatable {
    let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension CreateKnowledgeBaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

extension CreateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions"
    }
}

public struct CreateSessionInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the session.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateSessionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSessionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init (
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct CreateSessionOutputResponseBody: Swift.Equatable {
    let session: WisdomClientTypes.SessionData?
}

extension CreateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

extension DeleteAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let assistantAssociationId = assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

public struct DeleteAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct DeleteAssistantAssociationInputBody: Swift.Equatable {
}

extension DeleteAssistantAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssistantAssociationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

public struct DeleteAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct DeleteAssistantInputBody: Swift.Equatable {
}

extension DeleteAssistantInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssistantOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct DeleteContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteContentInputBody: Swift.Equatable {
}

extension DeleteContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContentOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DeleteKnowledgeBaseInput: Swift.Equatable {
    /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteKnowledgeBaseInputBody: Swift.Equatable {
}

extension DeleteKnowledgeBaseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKnowledgeBaseOutputResponse: Swift.Equatable {

    public init () { }
}

extension WisdomClientTypes.Document: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentReference
        case excerpt
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentReference = self.contentReference {
            try encodeContainer.encode(contentReference, forKey: .contentReference)
        }
        if let excerpt = self.excerpt {
            try encodeContainer.encode(excerpt, forKey: .excerpt)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentReferenceDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentReference.self, forKey: .contentReference)
        contentReference = contentReferenceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.DocumentText.self, forKey: .title)
        title = titleDecoded
        let excerptDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.DocumentText.self, forKey: .excerpt)
        excerpt = excerptDecoded
    }
}

extension WisdomClientTypes {
    /// The document.
    public struct Document: Swift.Equatable {
        /// A reference to the content resource.
        /// This member is required.
        public var contentReference: WisdomClientTypes.ContentReference?
        /// The excerpt from the document.
        public var excerpt: WisdomClientTypes.DocumentText?
        /// The title of the document.
        public var title: WisdomClientTypes.DocumentText?

        public init (
            contentReference: WisdomClientTypes.ContentReference? = nil,
            excerpt: WisdomClientTypes.DocumentText? = nil,
            title: WisdomClientTypes.DocumentText? = nil
        )
        {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }
    }

}

extension WisdomClientTypes.DocumentText: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highlights
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for highlight0 in highlights {
                try highlightsContainer.encode(highlight0)
            }
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.Highlight?].self, forKey: .highlights)
        var highlightsDecoded0:[WisdomClientTypes.Highlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [WisdomClientTypes.Highlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension WisdomClientTypes.DocumentText: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentText(highlights: \(Swift.String(describing: highlights)), text: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// The text of the document.
    public struct DocumentText: Swift.Equatable {
        /// Highlights in the document text.
        public var highlights: [WisdomClientTypes.Highlight]?
        /// Text in the document.
        public var text: Swift.String?

        public init (
            highlights: [WisdomClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension WisdomClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.FilterField.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WisdomClientTypes {
    /// A search filter.
    public struct Filter: Swift.Equatable {
        /// The field on which to filter.
        /// This member is required.
        public var field: WisdomClientTypes.FilterField?
        /// The operator to use for comparing the field’s value with the provided value.
        /// This member is required.
        public var `operator`: WisdomClientTypes.FilterOperator?
        /// The desired field value on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            field: WisdomClientTypes.FilterField? = nil,
            `operator`: WisdomClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension WisdomClientTypes {
    public enum FilterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterField(rawValue: rawValue) ?? FilterField.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension GetAssistantAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let assistantAssociationId = assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

public struct GetAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct GetAssistantAssociationInputBody: Swift.Equatable {
}

extension GetAssistantAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssistantAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct GetAssistantAssociationOutputResponse: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init (
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct GetAssistantAssociationOutputResponseBody: Swift.Equatable {
    let assistantAssociation: WisdomClientTypes.AssistantAssociationData?
}

extension GetAssistantAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

extension GetAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

public struct GetAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct GetAssistantInputBody: Swift.Equatable {
}

extension GetAssistantInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct GetAssistantOutputResponse: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init (
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct GetAssistantOutputResponseBody: Swift.Equatable {
    let assistant: WisdomClientTypes.AssistantData?
}

extension GetAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

extension GetContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct GetContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentInputBody: Swift.Equatable {
}

extension GetContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct GetContentOutputResponseBody: Swift.Equatable {
    let content: WisdomClientTypes.ContentData?
}

extension GetContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetContentSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/summary"
    }
}

public struct GetContentSummaryInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentSummaryInputBody: Swift.Equatable {
}

extension GetContentSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContentSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContentSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContentSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContentSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContentSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummary = output.contentSummary
        } else {
            self.contentSummary = nil
        }
    }
}

public struct GetContentSummaryOutputResponse: Swift.Equatable {
    /// The content summary.
    public var contentSummary: WisdomClientTypes.ContentSummary?

    public init (
        contentSummary: WisdomClientTypes.ContentSummary? = nil
    )
    {
        self.contentSummary = contentSummary
    }
}

struct GetContentSummaryOutputResponseBody: Swift.Equatable {
    let contentSummary: WisdomClientTypes.ContentSummary?
}

extension GetContentSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummaryDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentSummary.self, forKey: .contentSummary)
        contentSummary = contentSummaryDecoded
    }
}

extension GetKnowledgeBaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetKnowledgeBaseInput: Swift.Equatable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetKnowledgeBaseInputBody: Swift.Equatable {
}

extension GetKnowledgeBaseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetKnowledgeBaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct GetKnowledgeBaseOutputResponse: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct GetKnowledgeBaseOutputResponseBody: Swift.Equatable {
    let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension GetKnowledgeBaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

extension GetRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if waitTimeSeconds != 0 {
                let waitTimeSecondsQueryItem = ClientRuntime.URLQueryItem(name: "waitTimeSeconds".urlPercentEncoding(), value: Swift.String(waitTimeSeconds).urlPercentEncoding())
                items.append(waitTimeSecondsQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations"
    }
}

public struct GetRecommendationsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
    public var waitTimeSeconds: Swift.Int

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        waitTimeSeconds: Swift.Int = 0
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.sessionId = sessionId
        self.waitTimeSeconds = waitTimeSeconds
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
}

extension GetRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendations = output.recommendations
            self.triggers = output.triggers
        } else {
            self.recommendations = nil
            self.triggers = nil
        }
    }
}

public struct GetRecommendationsOutputResponse: Swift.Equatable {
    /// The recommendations.
    /// This member is required.
    public var recommendations: [WisdomClientTypes.RecommendationData]?
    /// The triggers corresponding to recommendations.
    public var triggers: [WisdomClientTypes.RecommendationTrigger]?

    public init (
        recommendations: [WisdomClientTypes.RecommendationData]? = nil,
        triggers: [WisdomClientTypes.RecommendationTrigger]? = nil
    )
    {
        self.recommendations = recommendations
        self.triggers = triggers
    }
}

struct GetRecommendationsOutputResponseBody: Swift.Equatable {
    let recommendations: [WisdomClientTypes.RecommendationData]?
    let triggers: [WisdomClientTypes.RecommendationTrigger]?
}

extension GetRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendations
        case triggers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.RecommendationData?].self, forKey: .recommendations)
        var recommendationsDecoded0:[WisdomClientTypes.RecommendationData]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [WisdomClientTypes.RecommendationData]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([WisdomClientTypes.RecommendationTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[WisdomClientTypes.RecommendationTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [WisdomClientTypes.RecommendationTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init (
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    let session: WisdomClientTypes.SessionData?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

extension WisdomClientTypes.Highlight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffsetInclusive
        case endOffsetExclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetInclusive != 0 {
            try encodeContainer.encode(beginOffsetInclusive, forKey: .beginOffsetInclusive)
        }
        if endOffsetExclusive != 0 {
            try encodeContainer.encode(endOffsetExclusive, forKey: .endOffsetExclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffsetInclusive) ?? 0
        beginOffsetInclusive = beginOffsetInclusiveDecoded
        let endOffsetExclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffsetExclusive) ?? 0
        endOffsetExclusive = endOffsetExclusiveDecoded
    }
}

extension WisdomClientTypes {
    /// Offset specification to describe highlighting of document excerpts for rendering search results and recommendations.
    public struct Highlight: Swift.Equatable {
        /// The offset for the start of the highlight.
        public var beginOffsetInclusive: Swift.Int
        /// The offset for the end of the highlight.
        public var endOffsetExclusive: Swift.Int

        public init (
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        )
        {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }

}

extension WisdomClientTypes.KnowledgeBaseAssociationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
    }
}

extension WisdomClientTypes {
    /// Association information about the knowledge base.
    public struct KnowledgeBaseAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        public var knowledgeBaseId: Swift.String?

        public init (
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes.KnowledgeBaseData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case lastContentModificationTime
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let lastContentModificationTime = self.lastContentModificationTime {
            try encodeContainer.encodeTimestamp(lastContentModificationTime, format: .epochSeconds, forKey: .lastContentModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let lastContentModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastContentModificationTime)
        lastContentModificationTime = lastContentModificationTimeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Information about the knowledge base.
    public struct KnowledgeBaseData: Swift.Equatable {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public var lastContentModificationTime: ClientRuntime.Date?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            lastContentModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes {
    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStatus(rawValue: rawValue) ?? KnowledgeBaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.KnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = self.knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = self.renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Summary information about the knowledge base.
    public struct KnowledgeBaseSummary: Swift.Equatable {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base summary.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes {
    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case external
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .custom,
                .external,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .external: return "EXTERNAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseType(rawValue: rawValue) ?? KnowledgeBaseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAssistantAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssistantAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

public struct ListAssistantAssociationsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsInputBody: Swift.Equatable {
}

extension ListAssistantAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssistantAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssistantAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssistantAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssistantAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociationSummaries = output.assistantAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantAssociationsOutputResponse: Swift.Equatable {
    /// Summary information about assistant associations.
    /// This member is required.
    public var assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantAssociationSummaries = assistantAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsOutputResponseBody: Swift.Equatable {
    let assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListAssistantAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociationSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.AssistantAssociationSummary?].self, forKey: .assistantAssociationSummaries)
        var assistantAssociationSummariesDecoded0:[WisdomClientTypes.AssistantAssociationSummary]? = nil
        if let assistantAssociationSummariesContainer = assistantAssociationSummariesContainer {
            assistantAssociationSummariesDecoded0 = [WisdomClientTypes.AssistantAssociationSummary]()
            for structure0 in assistantAssociationSummariesContainer {
                if let structure0 = structure0 {
                    assistantAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantAssociationSummaries = assistantAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssistantsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssistantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assistants"
    }
}

public struct ListAssistantsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantsInputBody: Swift.Equatable {
}

extension ListAssistantsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssistantsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssistantsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssistantsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssistantsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantSummaries = output.assistantSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantsOutputResponse: Swift.Equatable {
    /// Information about the assistants.
    /// This member is required.
    public var assistantSummaries: [WisdomClientTypes.AssistantSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantSummaries: [WisdomClientTypes.AssistantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantSummaries = assistantSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantsOutputResponseBody: Swift.Equatable {
    let assistantSummaries: [WisdomClientTypes.AssistantSummary]?
    let nextToken: Swift.String?
}

extension ListAssistantsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.AssistantSummary?].self, forKey: .assistantSummaries)
        var assistantSummariesDecoded0:[WisdomClientTypes.AssistantSummary]? = nil
        if let assistantSummariesContainer = assistantSummariesContainer {
            assistantSummariesDecoded0 = [WisdomClientTypes.AssistantSummary]()
            for structure0 in assistantSummariesContainer {
                if let structure0 = structure0 {
                    assistantSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantSummaries = assistantSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

public struct ListContentsInput: Swift.Equatable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContentsInputBody: Swift.Equatable {
}

extension ListContentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListContentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListContentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListContentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListContentsOutputResponse: Swift.Equatable {
    /// Information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct ListContentsOutputResponseBody: Swift.Equatable {
    let contentSummaries: [WisdomClientTypes.ContentSummary]?
    let nextToken: Swift.String?
}

extension ListContentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[WisdomClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [WisdomClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKnowledgeBasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListKnowledgeBasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/knowledgeBases"
    }
}

public struct ListKnowledgeBasesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesInputBody: Swift.Equatable {
}

extension ListKnowledgeBasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKnowledgeBasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKnowledgeBasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListKnowledgeBasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKnowledgeBasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListKnowledgeBasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseSummaries = output.knowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.knowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKnowledgeBasesOutputResponse: Swift.Equatable {
    /// Information about the knowledge bases.
    /// This member is required.
    public var knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesOutputResponseBody: Swift.Equatable {
    let knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.KnowledgeBaseSummary?].self, forKey: .knowledgeBaseSummaries)
        var knowledgeBaseSummariesDecoded0:[WisdomClientTypes.KnowledgeBaseSummary]? = nil
        if let knowledgeBaseSummariesContainer = knowledgeBaseSummariesContainer {
            knowledgeBaseSummariesDecoded0 = [WisdomClientTypes.KnowledgeBaseSummary]()
            for structure0 in knowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    knowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        knowledgeBaseSummaries = knowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.NotifyRecommendationsReceivedError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case recommendationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes {
    /// An error occurred when creating a recommendation.
    public struct NotifyRecommendationsReceivedError: Swift.Equatable {
        /// A recommendation is causing an error.
        public var message: Swift.String?
        /// The identifier of the recommendation that is in error.
        public var recommendationId: Swift.String?

        public init (
            message: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.message = message
            self.recommendationId = recommendationId
        }
    }

}

extension NotifyRecommendationsReceivedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for string0 in recommendationIds {
                try recommendationIdsContainer.encode(string0)
            }
        }
    }
}

extension NotifyRecommendationsReceivedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations/notify"
    }
}

public struct NotifyRecommendationsReceivedInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifiers of the recommendations.
    /// This member is required.
    public var recommendationIds: [Swift.String]?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.recommendationIds = recommendationIds
        self.sessionId = sessionId
    }
}

struct NotifyRecommendationsReceivedInputBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
}

extension NotifyRecommendationsReceivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension NotifyRecommendationsReceivedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyRecommendationsReceivedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum NotifyRecommendationsReceivedOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyRecommendationsReceivedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotifyRecommendationsReceivedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.recommendationIds = output.recommendationIds
        } else {
            self.errors = nil
            self.recommendationIds = nil
        }
    }
}

public struct NotifyRecommendationsReceivedOutputResponse: Swift.Equatable {
    /// The identifiers of recommendations that are causing errors.
    public var errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]?
    /// The identifiers of the recommendations.
    public var recommendationIds: [Swift.String]?

    public init (
        errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]? = nil,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.recommendationIds = recommendationIds
    }
}

struct NotifyRecommendationsReceivedOutputResponseBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
    let errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]?
}

extension NotifyRecommendationsReceivedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case recommendationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.NotifyRecommendationsReceivedError?].self, forKey: .errors)
        var errorsDecoded0:[WisdomClientTypes.NotifyRecommendationsReceivedError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [WisdomClientTypes.NotifyRecommendationsReceivedError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided revisionId does not match, indicating the content has been modified since it was last read.
public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QueryAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), queryText: \"CONTENT_REDACTED\")"}
}

extension QueryAssistantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryText = self.queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
    }
}

extension QueryAssistantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/query"
    }
}

public struct QueryAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The text to search for.
    /// This member is required.
    public var queryText: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryText = queryText
    }
}

struct QueryAssistantInputBody: Swift.Equatable {
    let queryText: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension QueryAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryText
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension QueryAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum QueryAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QueryAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct QueryAssistantOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the query.
    /// This member is required.
    public var results: [WisdomClientTypes.ResultData]?

    public init (
        nextToken: Swift.String? = nil,
        results: [WisdomClientTypes.ResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct QueryAssistantOutputResponseBody: Swift.Equatable {
    let results: [WisdomClientTypes.ResultData]?
    let nextToken: Swift.String?
}

extension QueryAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ResultData?].self, forKey: .results)
        var resultsDecoded0:[WisdomClientTypes.ResultData]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [WisdomClientTypes.ResultData]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.QueryRecommendationTriggerData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension WisdomClientTypes.QueryRecommendationTriggerData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryRecommendationTriggerData(text: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// Data associated with the QUERY RecommendationTriggerType.
    public struct QueryRecommendationTriggerData: Swift.Equatable {
        /// The text associated with the recommendation trigger.
        public var text: Swift.String?

        public init (
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension WisdomClientTypes.RecommendationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case recommendationId
        case relevanceLevel
        case relevanceScore
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let relevanceLevel = self.relevanceLevel {
            try encodeContainer.encode(relevanceLevel.rawValue, forKey: .relevanceLevel)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevanceScore) ?? 0.0
        relevanceScore = relevanceScoreDecoded
        let relevanceLevelDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RelevanceLevel.self, forKey: .relevanceLevel)
        relevanceLevel = relevanceLevelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WisdomClientTypes {
    /// Information about the recommendation.
    public struct RecommendationData: Swift.Equatable {
        /// The recommended document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The identifier of the recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The relevance level of the recommendation.
        public var relevanceLevel: WisdomClientTypes.RelevanceLevel?
        /// The relevance score of the recommendation.
        public var relevanceScore: Swift.Double
        /// The type of recommendation.
        public var type: WisdomClientTypes.RecommendationType?

        public init (
            document: WisdomClientTypes.Document? = nil,
            recommendationId: Swift.String? = nil,
            relevanceLevel: WisdomClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0,
            type: WisdomClientTypes.RecommendationType? = nil
        )
        {
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    public enum RecommendationSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case issueDetection
        case other
        case ruleEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSourceType] {
            return [
                .issueDetection,
                .other,
                .ruleEvaluation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .issueDetection: return "ISSUE_DETECTION"
            case .other: return "OTHER"
            case .ruleEvaluation: return "RULE_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationSourceType(rawValue: rawValue) ?? RecommendationSourceType.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.RecommendationTrigger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case id
        case recommendationIds
        case source
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for string0 in recommendationIds {
                try recommendationIdsContainer.encode(string0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RecommendationTriggerType.self, forKey: .type)
        type = typeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RecommendationSourceType.self, forKey: .source)
        source = sourceDecoded
        let dataDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RecommendationTriggerData.self, forKey: .data)
        data = dataDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension WisdomClientTypes {
    /// A recommendation trigger provides context on the event that produced the referenced recommendations. Recommendations are only referenced in recommendationIds by a single RecommendationTrigger.
    public struct RecommendationTrigger: Swift.Equatable {
        /// A union type containing information related to the trigger.
        /// This member is required.
        public var data: WisdomClientTypes.RecommendationTriggerData?
        /// The identifier of the recommendation trigger.
        /// This member is required.
        public var id: Swift.String?
        /// The identifiers of the recommendations.
        /// This member is required.
        public var recommendationIds: [Swift.String]?
        /// The source of the recommendation trigger.
        ///
        /// * ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.
        ///
        /// * RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        /// This member is required.
        public var source: WisdomClientTypes.RecommendationSourceType?
        /// The type of recommendation trigger.
        /// This member is required.
        public var type: WisdomClientTypes.RecommendationTriggerType?

        public init (
            data: WisdomClientTypes.RecommendationTriggerData? = nil,
            id: Swift.String? = nil,
            recommendationIds: [Swift.String]? = nil,
            source: WisdomClientTypes.RecommendationSourceType? = nil,
            type: WisdomClientTypes.RecommendationTriggerType? = nil
        )
        {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }
    }

}

extension WisdomClientTypes.RecommendationTriggerData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case query
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .query(query):
                try container.encode(query, forKey: .query)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try values.decodeIfPresent(WisdomClientTypes.QueryRecommendationTriggerData.self, forKey: .query)
        if let query = queryDecoded {
            self = .query(query)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// A union type containing information related to the trigger.
    public enum RecommendationTriggerData: Swift.Equatable {
        /// Data associated with the QUERY RecommendationTriggerType.
        case query(WisdomClientTypes.QueryRecommendationTriggerData)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {
    public enum RecommendationTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTriggerType] {
            return [
                .query,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .query: return "QUERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTriggerType(rawValue: rawValue) ?? RecommendationTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .knowledgeContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationType(rawValue: rawValue) ?? RecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum RelevanceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceLevel] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelevanceLevel(rawValue: rawValue) ?? RelevanceLevel.sdkUnknown(rawValue)
        }
    }
}

extension RemoveKnowledgeBaseTemplateUriInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

public struct RemoveKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct RemoveKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
}

extension RemoveKnowledgeBaseTemplateUriInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveKnowledgeBaseTemplateUriOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveKnowledgeBaseTemplateUriOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveKnowledgeBaseTemplateUriOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveKnowledgeBaseTemplateUriOutputResponse: Swift.Equatable {

    public init () { }
}

extension WisdomClientTypes.RenderingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = self.templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension WisdomClientTypes {
    /// Information about how to render the content.
    public struct RenderingConfiguration: Swift.Equatable {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce and ServiceNow, the variable must be one of the following:
        ///
        /// * Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted
        ///
        /// * ServiceNow: number, short_description, sys_mod_count, workflow_state, or active
        ///
        ///
        /// The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_GetContent.html).
        public var templateUri: Swift.String?

        public init (
            templateUri: Swift.String? = nil
        )
        {
            self.templateUri = templateUri
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The specified resource name.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WisdomClientTypes.ResultData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case relevanceScore
        case resultId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
        if let resultId = self.resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .relevanceScore) ?? 0.0
        relevanceScore = relevanceScoreDecoded
    }
}

extension WisdomClientTypes {
    /// Information about the result.
    public struct ResultData: Swift.Equatable {
        /// The document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The relevance score of the results.
        public var relevanceScore: Swift.Double
        /// The identifier of the result data.
        /// This member is required.
        public var resultId: Swift.String?

        public init (
            document: WisdomClientTypes.Document? = nil,
            relevanceScore: Swift.Double = 0.0,
            resultId: Swift.String? = nil
        )
        {
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
        }
    }

}

extension SearchContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = self.searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

extension SearchContentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search"
    }
}

public struct SearchContentInput: Swift.Equatable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchContentInputBody: Swift.Equatable {
    let searchExpression: WisdomClientTypes.SearchExpression?
}

extension SearchContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct SearchContentOutputResponse: Swift.Equatable {
    /// Summary information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct SearchContentOutputResponseBody: Swift.Equatable {
    let contentSummaries: [WisdomClientTypes.ContentSummary]?
    let nextToken: Swift.String?
}

extension SearchContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[WisdomClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [WisdomClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.SearchExpression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([WisdomClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[WisdomClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [WisdomClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension WisdomClientTypes {
    /// The search expression.
    public struct SearchExpression: Swift.Equatable {
        /// The search expression filters.
        /// This member is required.
        public var filters: [WisdomClientTypes.Filter]?

        public init (
            filters: [WisdomClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension SearchSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = self.searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

extension SearchSessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assistantId = assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/searchSessions"
    }
}

public struct SearchSessionsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchSessionsInputBody: Swift.Equatable {
    let searchExpression: WisdomClientTypes.SearchExpression?
}

extension SearchSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchSessionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessionSummaries = output.sessionSummaries
        } else {
            self.nextToken = nil
            self.sessionSummaries = nil
        }
    }
}

public struct SearchSessionsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the sessions.
    /// This member is required.
    public var sessionSummaries: [WisdomClientTypes.SessionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        sessionSummaries: [WisdomClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

struct SearchSessionsOutputResponseBody: Swift.Equatable {
    let sessionSummaries: [WisdomClientTypes.SessionSummary]?
    let nextToken: Swift.String?
}

extension SearchSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessionSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.SessionSummary?].self, forKey: .sessionSummaries)
        var sessionSummariesDecoded0:[WisdomClientTypes.SessionSummary]? = nil
        if let sessionSummariesContainer = sessionSummariesContainer {
            sessionSummariesDecoded0 = [WisdomClientTypes.SessionSummary]()
            for structure0 in sessionSummariesContainer {
                if let structure0 = structure0 {
                    sessionSummariesDecoded0?.append(structure0)
                }
            }
        }
        sessionSummaries = sessionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension WisdomClientTypes {
    /// The KMS key used for encryption.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The KMS key. For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id).
        public var kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.SessionData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sessionArn
        case sessionId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes {
    /// Information about the session.
    public struct SessionData: Swift.Equatable {
        /// The description of the session.
        public var description: Swift.String?
        /// The name of the session.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.SessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = self.assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = self.assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let sessionArn = self.sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
    }
}

extension WisdomClientTypes {
    /// Summary information about the session.
    public struct SessionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }
    }

}

extension WisdomClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appintegrations = "appIntegrations"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .appintegrations(appintegrations):
                try container.encode(appintegrations, forKey: .appintegrations)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let appintegrationsDecoded = try values.decodeIfPresent(WisdomClientTypes.AppIntegrationsConfiguration.self, forKey: .appintegrations)
        if let appintegrations = appintegrationsDecoded {
            self = .appintegrations(appintegrations)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// Configuration information about the external data source.
    public enum SourceConfiguration: Swift.Equatable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appintegrations(WisdomClientTypes.AppIntegrationsConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension StartContentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension StartContentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/upload"
    }
}

public struct StartContentUploadInput: Swift.Equatable {
    /// The type of content to upload.
    /// This member is required.
    public var contentType: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct StartContentUploadInputBody: Swift.Equatable {
    let contentType: Swift.String?
}

extension StartContentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension StartContentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartContentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContentUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadOutputResponse(headersToInclude: \(Swift.String(describing: headersToInclude)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension StartContentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartContentUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.headersToInclude = output.headersToInclude
            self.uploadId = output.uploadId
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.headersToInclude = nil
            self.uploadId = nil
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct StartContentUploadOutputResponse: Swift.Equatable {
    /// The headers to include in the upload.
    /// This member is required.
    public var headersToInclude: [Swift.String:Swift.String]?
    /// The identifier of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The URL of the upload.
    /// This member is required.
    public var url: Swift.String?
    /// The expiration time of the URL as an epoch timestamp.
    /// This member is required.
    public var urlExpiry: ClientRuntime.Date?

    public init (
        headersToInclude: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil,
        url: Swift.String? = nil,
        urlExpiry: ClientRuntime.Date? = nil
    )
    {
        self.headersToInclude = headersToInclude
        self.uploadId = uploadId
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct StartContentUploadOutputResponseBody: Swift.Equatable {
    let uploadId: Swift.String?
    let url: Swift.String?
    let urlExpiry: ClientRuntime.Date?
    let headersToInclude: [Swift.String:Swift.String]?
}

extension StartContentUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude
        case uploadId
        case url
        case urlExpiry
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in headersToIncludeContainer {
                if let nonemptystring0 = nonemptystring0 {
                    headersToIncludeDecoded0?[key0] = nonemptystring0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Connect Wisdom throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The specified resource name.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentMetadata0) in metadata {
                try metadataContainer.encode(contentMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overrideLinkOutUri = self.overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let removeOverrideLinkOutUri = self.removeOverrideLinkOutUri {
            try encodeContainer.encode(removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension UpdateContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        guard let contentId = contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

public struct UpdateContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. Can be either the ID or the ARN
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
    public var overrideLinkOutUri: Swift.String?
    /// Unset the existing overrideLinkOutUri if it exists.
    public var removeOverrideLinkOutUri: Swift.Bool?
    /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
    public var revisionId: Swift.String?
    /// The title of the content.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    public var uploadId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        removeOverrideLinkOutUri: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.overrideLinkOutUri = overrideLinkOutUri
        self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
        self.revisionId = revisionId
        self.title = title
        self.uploadId = uploadId
    }
}

struct UpdateContentInputBody: Swift.Equatable {
    let revisionId: Swift.String?
    let title: Swift.String?
    let overrideLinkOutUri: Swift.String?
    let removeOverrideLinkOutUri: Swift.Bool?
    let metadata: [Swift.String:Swift.String]?
    let uploadId: Swift.String?
}

extension UpdateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let removeOverrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOverrideLinkOutUri)
        removeOverrideLinkOutUri = removeOverrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension UpdateContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct UpdateContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct UpdateContentOutputResponseBody: Swift.Equatable {
    let content: WisdomClientTypes.ContentData?
}

extension UpdateContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateKnowledgeBaseTemplateUriInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = self.templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }
}

extension UpdateKnowledgeBaseTemplateUriInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

public struct UpdateKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The template URI to update.
    /// This member is required.
    public var templateUri: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        templateUri: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.templateUri = templateUri
    }
}

struct UpdateKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
    let templateUri: Swift.String?
}

extension UpdateKnowledgeBaseTemplateUriInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension UpdateKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateKnowledgeBaseTemplateUriOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateKnowledgeBaseTemplateUriOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKnowledgeBaseTemplateUriOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateKnowledgeBaseTemplateUriOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct UpdateKnowledgeBaseTemplateUriOutputResponse: Swift.Equatable {
    /// The knowledge base to update.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct UpdateKnowledgeBaseTemplateUriOutputResponseBody: Swift.Equatable {
    let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension UpdateKnowledgeBaseTemplateUriOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by a service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
