// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>A notebook execution. An execution is a specific instance that an EMR Notebook is run
///          using the <code>StartNotebookExecution</code> action.</p>
public struct NotebookExecution: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    public let arn: String?
    /// <p>The unique identifier of the EMR Notebook that is used for the notebook
    ///          execution.</p>
    public let editorId: String?
    /// <p>The timestamp when notebook execution ended.</p>
    public let endTime: Date?
    /// <p>The execution engine, such as an EMR cluster, used to run the EMR notebook and perform
    ///          the notebook execution.</p>
    public let executionEngine: ExecutionEngineConfig?
    /// <p>The reason for the latest status change of the notebook execution.</p>
    public let lastStateChangeReason: String?
    /// <p>The unique identifier of a notebook execution.</p>
    public let notebookExecutionId: String?
    /// <p>A name for the notebook execution.</p>
    public let notebookExecutionName: String?
    /// <p>The unique identifier of the EC2 security group associated with the EMR Notebook
    ///          instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying
    ///             EC2 Security Groups for EMR Notebooks</a> in the <i>EMR Management
    ///             Guide</i>.</p>
    public let notebookInstanceSecurityGroupId: String?
    /// <p>Input parameters in JSON format passed to the EMR Notebook at runtime for
    ///          execution.</p>
    public let notebookParams: String?
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    public let outputNotebookURI: String?
    /// <p>The timestamp when notebook execution started.</p>
    public let startTime: Date?
    /// <p>The status of the notebook execution.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>START_PENDING</code> indicates that the cluster has received the execution
    ///                request but execution has not begun.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STARTING</code> indicates that the execution is starting on the
    ///                cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RUNNING</code> indicates that the execution is being processed by the
    ///                cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FINISHING</code> indicates that execution processing is in the final
    ///                stages.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FINISHED</code> indicates that the execution has completed without
    ///                error.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILING</code> indicates that the execution is failing and will not finish
    ///                successfully.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> indicates that the execution failed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOP_PENDING</code> indicates that the cluster has received a
    ///                   <code>StopNotebookExecution</code> request and the stop is pending.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPING</code> indicates that the cluster is in the process of stopping the
    ///                execution as a result of a <code>StopNotebookExecution</code> request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code> indicates that the execution stopped because of a
    ///                   <code>StopNotebookExecution</code> request.</p>
    ///             </li>
    ///          </ul>
    public let status: NotebookExecutionStatus?
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value
    ///          pairs that consist of a required key string with a maximum of 128 characters and an
    ///          optional value string with a maximum of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        editorId: String? = nil,
        endTime: Date? = nil,
        executionEngine: ExecutionEngineConfig? = nil,
        lastStateChangeReason: String? = nil,
        notebookExecutionId: String? = nil,
        notebookExecutionName: String? = nil,
        notebookInstanceSecurityGroupId: String? = nil,
        notebookParams: String? = nil,
        outputNotebookURI: String? = nil,
        startTime: Date? = nil,
        status: NotebookExecutionStatus? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.editorId = editorId
        self.endTime = endTime
        self.executionEngine = executionEngine
        self.lastStateChangeReason = lastStateChangeReason
        self.notebookExecutionId = notebookExecutionId
        self.notebookExecutionName = notebookExecutionName
        self.notebookInstanceSecurityGroupId = notebookInstanceSecurityGroupId
        self.notebookParams = notebookParams
        self.outputNotebookURI = outputNotebookURI
        self.startTime = startTime
        self.status = status
        self.tags = tags
    }
}

extension NotebookExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotebookExecution(arn: \(String(describing: arn)), editorId: \(String(describing: editorId)), endTime: \(String(describing: endTime)), executionEngine: \(String(describing: executionEngine)), lastStateChangeReason: \(String(describing: lastStateChangeReason)), notebookExecutionId: \(String(describing: notebookExecutionId)), notebookExecutionName: \(String(describing: notebookExecutionName)), notebookInstanceSecurityGroupId: \(String(describing: notebookInstanceSecurityGroupId)), notebookParams: \(String(describing: notebookParams)), outputNotebookURI: \(String(describing: outputNotebookURI)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}
