// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p> The EC2 unit limits for a managed scaling policy. The managed scaling activity of a
///          cluster can not be above or below these limits. The limit only applies to the core and task
///          nodes. The master node cannot be scaled after initial configuration. </p>
public struct ComputeLimits: Equatable {
    /// <p> The upper boundary of EC2 units. It is measured through vCPU cores or instances for
    ///          instance groups and measured through units for instance fleets. Managed scaling activities
    ///          are not allowed beyond this boundary. The limit only applies to the core and task nodes.
    ///          The master node cannot be scaled after initial configuration. </p>
    public let maximumCapacityUnits: Int?
    /// <p> The upper boundary of EC2 units for core node type in a cluster. It is measured through
    ///          vCPU cores or instances for instance groups and measured through units for instance fleets.
    ///          The core units are not allowed to scale beyond this boundary. The parameter is used to
    ///          split capacity allocation between core and task nodes. </p>
    public let maximumCoreCapacityUnits: Int?
    /// <p> The upper boundary of On-Demand EC2 units. It is measured through vCPU cores or
    ///          instances for instance groups and measured through units for instance fleets. The On-Demand
    ///          units are not allowed to scale beyond this boundary. The parameter is used to split
    ///          capacity allocation between On-Demand and Spot Instances. </p>
    public let maximumOnDemandCapacityUnits: Int?
    /// <p> The lower boundary of EC2 units. It is measured through vCPU cores or instances for
    ///          instance groups and measured through units for instance fleets. Managed scaling activities
    ///          are not allowed beyond this boundary. The limit only applies to the core and task nodes.
    ///          The master node cannot be scaled after initial configuration. </p>
    public let minimumCapacityUnits: Int?
    /// <p> The unit type used for specifying a managed scaling policy. </p>
    public let unitType: ComputeLimitsUnitType?

    public init (
        maximumCapacityUnits: Int? = nil,
        maximumCoreCapacityUnits: Int? = nil,
        maximumOnDemandCapacityUnits: Int? = nil,
        minimumCapacityUnits: Int? = nil,
        unitType: ComputeLimitsUnitType? = nil
    )
    {
        self.maximumCapacityUnits = maximumCapacityUnits
        self.maximumCoreCapacityUnits = maximumCoreCapacityUnits
        self.maximumOnDemandCapacityUnits = maximumOnDemandCapacityUnits
        self.minimumCapacityUnits = minimumCapacityUnits
        self.unitType = unitType
    }
}

extension ComputeLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeLimits(maximumCapacityUnits: \(String(describing: maximumCapacityUnits)), maximumCoreCapacityUnits: \(String(describing: maximumCoreCapacityUnits)), maximumOnDemandCapacityUnits: \(String(describing: maximumOnDemandCapacityUnits)), minimumCapacityUnits: \(String(describing: minimumCapacityUnits)), unitType: \(String(describing: unitType)))"}
}
