// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MetricAlarm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionsEnabled = "ActionsEnabled"
        case alarmActions = "AlarmActions"
        case alarmArn = "AlarmArn"
        case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
        case alarmDescription = "AlarmDescription"
        case alarmName = "AlarmName"
        case comparisonOperator = "ComparisonOperator"
        case datapointsToAlarm = "DatapointsToAlarm"
        case dimensions = "Dimensions"
        case evaluateLowSampleCountPercentile = "EvaluateLowSampleCountPercentile"
        case evaluationPeriods = "EvaluationPeriods"
        case extendedStatistic = "ExtendedStatistic"
        case insufficientDataActions = "InsufficientDataActions"
        case metricName = "MetricName"
        case metrics = "Metrics"
        case namespace = "Namespace"
        case oKActions = "OKActions"
        case period = "Period"
        case stateReason = "StateReason"
        case stateReasonData = "StateReasonData"
        case stateUpdatedTimestamp = "StateUpdatedTimestamp"
        case stateValue = "StateValue"
        case statistic = "Statistic"
        case threshold = "Threshold"
        case thresholdMetricId = "ThresholdMetricId"
        case treatMissingData = "TreatMissingData"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionsEnabled = actionsEnabled {
            try container.encode(actionsEnabled, forKey: Key("ActionsEnabled"))
        }
        if let alarmActions = alarmActions {
            var alarmActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AlarmActions"))
            for (index0, resourcename0) in alarmActions.enumerated() {
                try alarmActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let alarmArn = alarmArn {
            try container.encode(alarmArn, forKey: Key("AlarmArn"))
        }
        if let alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp {
            try container.encode(TimestampWrapper(alarmConfigurationUpdatedTimestamp, format: .dateTime), forKey: Key("alarmConfigurationUpdatedTimestamp"))
        }
        if let alarmDescription = alarmDescription {
            try container.encode(alarmDescription, forKey: Key("AlarmDescription"))
        }
        if let alarmName = alarmName {
            try container.encode(alarmName, forKey: Key("AlarmName"))
        }
        if let comparisonOperator = comparisonOperator {
            try container.encode(comparisonOperator, forKey: Key("ComparisonOperator"))
        }
        if let datapointsToAlarm = datapointsToAlarm {
            try container.encode(datapointsToAlarm, forKey: Key("DatapointsToAlarm"))
        }
        if let dimensions = dimensions {
            var dimensionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Dimensions"))
            for (index0, dimension0) in dimensions.enumerated() {
                try dimensionsContainer.encode(dimension0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile {
            try container.encode(evaluateLowSampleCountPercentile, forKey: Key("EvaluateLowSampleCountPercentile"))
        }
        if let evaluationPeriods = evaluationPeriods {
            try container.encode(evaluationPeriods, forKey: Key("EvaluationPeriods"))
        }
        if let extendedStatistic = extendedStatistic {
            try container.encode(extendedStatistic, forKey: Key("ExtendedStatistic"))
        }
        if let insufficientDataActions = insufficientDataActions {
            var insufficientDataActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("InsufficientDataActions"))
            for (index0, resourcename0) in insufficientDataActions.enumerated() {
                try insufficientDataActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let metricName = metricName {
            try container.encode(metricName, forKey: Key("MetricName"))
        }
        if let metrics = metrics {
            var metricsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Metrics"))
            for (index0, metricdataquery0) in metrics.enumerated() {
                try metricsContainer.encode(metricdataquery0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let namespace = namespace {
            try container.encode(namespace, forKey: Key("Namespace"))
        }
        if let oKActions = oKActions {
            var oKActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OKActions"))
            for (index0, resourcename0) in oKActions.enumerated() {
                try oKActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let period = period {
            try container.encode(period, forKey: Key("Period"))
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: Key("StateReason"))
        }
        if let stateReasonData = stateReasonData {
            try container.encode(stateReasonData, forKey: Key("StateReasonData"))
        }
        if let stateUpdatedTimestamp = stateUpdatedTimestamp {
            try container.encode(TimestampWrapper(stateUpdatedTimestamp, format: .dateTime), forKey: Key("stateUpdatedTimestamp"))
        }
        if let stateValue = stateValue {
            try container.encode(stateValue, forKey: Key("StateValue"))
        }
        if let statistic = statistic {
            try container.encode(statistic, forKey: Key("Statistic"))
        }
        if let threshold = threshold {
            try container.encode(threshold, forKey: Key("Threshold"))
        }
        if let thresholdMetricId = thresholdMetricId {
            try container.encode(thresholdMetricId, forKey: Key("ThresholdMetricId"))
        }
        if let treatMissingData = treatMissingData {
            try container.encode(treatMissingData, forKey: Key("TreatMissingData"))
        }
        if let unit = unit {
            try container.encode(unit, forKey: Key("Unit"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let alarmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmDescription)
        alarmDescription = alarmDescriptionDecoded
        let alarmConfigurationUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmConfigurationUpdatedTimestamp)
        var alarmConfigurationUpdatedTimestampBuffer:Date? = nil
        if let alarmConfigurationUpdatedTimestampDecoded = alarmConfigurationUpdatedTimestampDecoded {
            alarmConfigurationUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(alarmConfigurationUpdatedTimestampDecoded, format: .dateTime)
        }
        alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestampBuffer
        let actionsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .actionsEnabled)
        actionsEnabled = actionsEnabledDecoded
        if containerValues.contains(.oKActions) {
            struct KeyVal0{struct member{}}
            let oKActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .oKActions)
            if let oKActionsWrappedContainer = oKActionsWrappedContainer {
                let oKActionsContainer = try oKActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var oKActionsBuffer:[String]? = nil
                if let oKActionsContainer = oKActionsContainer {
                    oKActionsBuffer = [String]()
                    for stringContainer0 in oKActionsContainer {
                        oKActionsBuffer?.append(stringContainer0)
                    }
                }
                oKActions = oKActionsBuffer
            } else {
                oKActions = []
            }
        } else {
            oKActions = nil
        }
        if containerValues.contains(.alarmActions) {
            struct KeyVal0{struct member{}}
            let alarmActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alarmActions)
            if let alarmActionsWrappedContainer = alarmActionsWrappedContainer {
                let alarmActionsContainer = try alarmActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var alarmActionsBuffer:[String]? = nil
                if let alarmActionsContainer = alarmActionsContainer {
                    alarmActionsBuffer = [String]()
                    for stringContainer0 in alarmActionsContainer {
                        alarmActionsBuffer?.append(stringContainer0)
                    }
                }
                alarmActions = alarmActionsBuffer
            } else {
                alarmActions = []
            }
        } else {
            alarmActions = nil
        }
        if containerValues.contains(.insufficientDataActions) {
            struct KeyVal0{struct member{}}
            let insufficientDataActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .insufficientDataActions)
            if let insufficientDataActionsWrappedContainer = insufficientDataActionsWrappedContainer {
                let insufficientDataActionsContainer = try insufficientDataActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var insufficientDataActionsBuffer:[String]? = nil
                if let insufficientDataActionsContainer = insufficientDataActionsContainer {
                    insufficientDataActionsBuffer = [String]()
                    for stringContainer0 in insufficientDataActionsContainer {
                        insufficientDataActionsBuffer?.append(stringContainer0)
                    }
                }
                insufficientDataActions = insufficientDataActionsBuffer
            } else {
                insufficientDataActions = []
            }
        } else {
            insufficientDataActions = nil
        }
        let stateValueDecoded = try containerValues.decodeIfPresent(StateValue.self, forKey: .stateValue)
        stateValue = stateValueDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReasonData)
        stateReasonData = stateReasonDataDecoded
        let stateUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateUpdatedTimestamp)
        var stateUpdatedTimestampBuffer:Date? = nil
        if let stateUpdatedTimestampDecoded = stateUpdatedTimestampDecoded {
            stateUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(stateUpdatedTimestampDecoded, format: .dateTime)
        }
        stateUpdatedTimestamp = stateUpdatedTimestampBuffer
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let extendedStatisticDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extendedStatistic)
        extendedStatistic = extendedStatisticDecoded
        if containerValues.contains(.dimensions) {
            struct KeyVal0{struct member{}}
            let dimensionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dimensions)
            if let dimensionsWrappedContainer = dimensionsWrappedContainer {
                let dimensionsContainer = try dimensionsWrappedContainer.decodeIfPresent([Dimension].self, forKey: .member)
                var dimensionsBuffer:[Dimension]? = nil
                if let dimensionsContainer = dimensionsContainer {
                    dimensionsBuffer = [Dimension]()
                    for structureContainer0 in dimensionsContainer {
                        dimensionsBuffer?.append(structureContainer0)
                    }
                }
                dimensions = dimensionsBuffer
            } else {
                dimensions = []
            }
        } else {
            dimensions = nil
        }
        let periodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .period)
        period = periodDecoded
        let unitDecoded = try containerValues.decodeIfPresent(StandardUnit.self, forKey: .unit)
        unit = unitDecoded
        let evaluationPeriodsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .evaluationPeriods)
        evaluationPeriods = evaluationPeriodsDecoded
        let datapointsToAlarmDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .datapointsToAlarm)
        datapointsToAlarm = datapointsToAlarmDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let treatMissingDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatMissingData)
        treatMissingData = treatMissingDataDecoded
        let evaluateLowSampleCountPercentileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evaluateLowSampleCountPercentile)
        evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentileDecoded
        if containerValues.contains(.metrics) {
            struct KeyVal0{struct member{}}
            let metricsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .metrics)
            if let metricsWrappedContainer = metricsWrappedContainer {
                let metricsContainer = try metricsWrappedContainer.decodeIfPresent([MetricDataQuery].self, forKey: .member)
                var metricsBuffer:[MetricDataQuery]? = nil
                if let metricsContainer = metricsContainer {
                    metricsBuffer = [MetricDataQuery]()
                    for structureContainer0 in metricsContainer {
                        metricsBuffer?.append(structureContainer0)
                    }
                }
                metrics = metricsBuffer
            } else {
                metrics = []
            }
        } else {
            metrics = nil
        }
        let thresholdMetricIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thresholdMetricId)
        thresholdMetricId = thresholdMetricIdDecoded
    }
}
