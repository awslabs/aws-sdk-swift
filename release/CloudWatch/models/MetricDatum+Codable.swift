// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MetricDatum: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case counts = "Counts"
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case statisticValues = "StatisticValues"
        case storageResolution = "StorageResolution"
        case timestamp = "Timestamp"
        case unit = "Unit"
        case value = "Value"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let counts = counts {
            var countsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Counts"))
            for (index0, datapointvalue0) in counts.enumerated() {
                try countsContainer.encode(datapointvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dimensions = dimensions {
            var dimensionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Dimensions"))
            for (index0, dimension0) in dimensions.enumerated() {
                try dimensionsContainer.encode(dimension0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let metricName = metricName {
            try container.encode(metricName, forKey: Key("MetricName"))
        }
        if let statisticValues = statisticValues {
            try container.encode(statisticValues, forKey: Key("StatisticValues"))
        }
        if let storageResolution = storageResolution {
            try container.encode(storageResolution, forKey: Key("StorageResolution"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
        if let unit = unit {
            try container.encode(unit, forKey: Key("Unit"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, datapointvalue0) in values.enumerated() {
                try valuesContainer.encode(datapointvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        if containerValues.contains(.dimensions) {
            struct KeyVal0{struct member{}}
            let dimensionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dimensions)
            if let dimensionsWrappedContainer = dimensionsWrappedContainer {
                let dimensionsContainer = try dimensionsWrappedContainer.decodeIfPresent([Dimension].self, forKey: .member)
                var dimensionsBuffer:[Dimension]? = nil
                if let dimensionsContainer = dimensionsContainer {
                    dimensionsBuffer = [Dimension]()
                    for structureContainer0 in dimensionsContainer {
                        dimensionsBuffer?.append(structureContainer0)
                    }
                }
                dimensions = dimensionsBuffer
            } else {
                dimensions = []
            }
        } else {
            dimensions = nil
        }
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let statisticValuesDecoded = try containerValues.decodeIfPresent(StatisticSet.self, forKey: .statisticValues)
        statisticValues = statisticValuesDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Double].self, forKey: .member)
                var valuesBuffer:[Double]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Double]()
                    for doubleContainer0 in valuesContainer {
                        valuesBuffer?.append(doubleContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
        if containerValues.contains(.counts) {
            struct KeyVal0{struct member{}}
            let countsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .counts)
            if let countsWrappedContainer = countsWrappedContainer {
                let countsContainer = try countsWrappedContainer.decodeIfPresent([Double].self, forKey: .member)
                var countsBuffer:[Double]? = nil
                if let countsContainer = countsContainer {
                    countsBuffer = [Double]()
                    for doubleContainer0 in countsContainer {
                        countsBuffer?.append(doubleContainer0)
                    }
                }
                counts = countsBuffer
            } else {
                counts = []
            }
        } else {
            counts = nil
        }
        let unitDecoded = try containerValues.decodeIfPresent(StandardUnit.self, forKey: .unit)
        unit = unitDecoded
        let storageResolutionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageResolution)
        storageResolution = storageResolutionDecoded
    }
}
