// Code generated by smithy-swift-codegen. DO NOT EDIT!



public enum StandardUnit {
    case bits
    case bitsSecond
    case bytes
    case bytesSecond
    case count
    case countSecond
    case gigabits
    case gigabitsSecond
    case gigabytes
    case gigabytesSecond
    case kilobits
    case kilobitsSecond
    case kilobytes
    case kilobytesSecond
    case megabits
    case megabitsSecond
    case megabytes
    case megabytesSecond
    case microseconds
    case milliseconds
    case `none`
    case percent
    case seconds
    case terabits
    case terabitsSecond
    case terabytes
    case terabytesSecond
    case sdkUnknown(String)
}

extension StandardUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StandardUnit] {
        return [
            .bits,
            .bitsSecond,
            .bytes,
            .bytesSecond,
            .count,
            .countSecond,
            .gigabits,
            .gigabitsSecond,
            .gigabytes,
            .gigabytesSecond,
            .kilobits,
            .kilobitsSecond,
            .kilobytes,
            .kilobytesSecond,
            .megabits,
            .megabitsSecond,
            .megabytes,
            .megabytesSecond,
            .microseconds,
            .milliseconds,
            .none,
            .percent,
            .seconds,
            .terabits,
            .terabitsSecond,
            .terabytes,
            .terabytesSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bits: return "Bits"
        case .bitsSecond: return "Bits/Second"
        case .bytes: return "Bytes"
        case .bytesSecond: return "Bytes/Second"
        case .count: return "Count"
        case .countSecond: return "Count/Second"
        case .gigabits: return "Gigabits"
        case .gigabitsSecond: return "Gigabits/Second"
        case .gigabytes: return "Gigabytes"
        case .gigabytesSecond: return "Gigabytes/Second"
        case .kilobits: return "Kilobits"
        case .kilobitsSecond: return "Kilobits/Second"
        case .kilobytes: return "Kilobytes"
        case .kilobytesSecond: return "Kilobytes/Second"
        case .megabits: return "Megabits"
        case .megabitsSecond: return "Megabits/Second"
        case .megabytes: return "Megabytes"
        case .megabytesSecond: return "Megabytes/Second"
        case .microseconds: return "Microseconds"
        case .milliseconds: return "Milliseconds"
        case .none: return "None"
        case .percent: return "Percent"
        case .seconds: return "Seconds"
        case .terabits: return "Terabits"
        case .terabitsSecond: return "Terabits/Second"
        case .terabytes: return "Terabytes"
        case .terabytesSecond: return "Terabytes/Second"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StandardUnit(rawValue: rawValue) ?? StandardUnit.sdkUnknown(rawValue)
    }
}
