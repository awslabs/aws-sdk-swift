// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>Encapsulates the information sent to either create a metric or add new values
/// 			to be aggregated into an existing metric.</p>
public struct MetricDatum: Equatable {
    /// <p>Array of numbers that is used along with the <code>Values</code> array. Each number in the <code>Count</code> array
    /// 			is the number of times the corresponding value in the <code>Values</code> array occurred during the period. </p>
    /// 		       <p>If you omit the <code>Counts</code> array, the default of 1 is used as the value for each count. If you
    /// 		include a <code>Counts</code> array, it must include the same amount of values as the <code>Values</code> array.</p>
    public let counts: [Double]?
    /// <p>The dimensions associated with the metric.</p>
    public let dimensions: [Dimension]?
    /// <p>The name of the metric.</p>
    public let metricName: String?
    /// <p>The statistical values for the metric.</p>
    public let statisticValues: StatisticSet?
    /// <p>Valid values are 1 and 60. Setting this to 1 specifies this metric as a high-resolution metric, so that CloudWatch stores the metric with
    /// 			sub-minute resolution down to one second.
    /// 		Setting this to 60 specifies this metric as a regular-resolution metric, which CloudWatch stores at 1-minute resolution. Currently, high resolution is available
    /// 		only for custom metrics. For more information about high-resolution metrics,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#high-resolution-metrics">High-Resolution Metrics</a> in the
    /// 			<i>Amazon CloudWatch User Guide</i>.
    /// 		</p>
    /// 	        <p>This field is optional, if you do not specify it the default of 60 is used.</p>
    public let storageResolution: Int?
    /// <p>The time the metric data was received, expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.</p>
    public let timestamp: Date?
    /// <p>When you are using a <code>Put</code> operation, this defines what unit you want to use when storing the metric.</p>
    /// 		       <p>In
    /// 		a <code>Get</code> operation, this displays the unit that is used for the metric.</p>
    public let unit: StandardUnit?
    /// <p>The value for the metric.</p>
    /// 		       <p>Although the parameter accepts numbers of type Double, CloudWatch rejects values that are either too small or
    /// 			too large. Values must be in the range of -2^360 to 2^360. In addition, special values (for example, NaN, +Infinity, -Infinity)
    /// 			are not supported.</p>
    public let value: Double?
    /// <p>Array of numbers representing the values for the metric during the period. Each unique value is listed just once
    /// 		in this array, and the corresponding number in the <code>Counts</code> array specifies the number of times that value occurred during the period.
    /// 		You can include up to 150 unique values in each <code>PutMetricData</code> action that specifies a <code>Values</code> array.</p>
    /// 		       <p>Although the <code>Values</code> array accepts numbers of type
    /// 			<code>Double</code>, CloudWatch rejects values that are either too small
    /// 			or too large. Values must be in the range of -2^360 to 2^360. In addition, special values (for example, NaN, +Infinity,
    /// 			-Infinity) are not supported.</p>
    public let values: [Double]?

    public init (
        counts: [Double]? = nil,
        dimensions: [Dimension]? = nil,
        metricName: String? = nil,
        statisticValues: StatisticSet? = nil,
        storageResolution: Int? = nil,
        timestamp: Date? = nil,
        unit: StandardUnit? = nil,
        value: Double? = nil,
        values: [Double]? = nil
    )
    {
        self.counts = counts
        self.dimensions = dimensions
        self.metricName = metricName
        self.statisticValues = statisticValues
        self.storageResolution = storageResolution
        self.timestamp = timestamp
        self.unit = unit
        self.value = value
        self.values = values
    }
}

extension MetricDatum: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDatum(counts: \(String(describing: counts)), dimensions: \(String(describing: dimensions)), metricName: \(String(describing: metricName)), statisticValues: \(String(describing: statisticValues)), storageResolution: \(String(describing: storageResolution)), timestamp: \(String(describing: timestamp)), unit: \(String(describing: unit)), value: \(String(describing: value)), values: \(String(describing: values)))"}
}
