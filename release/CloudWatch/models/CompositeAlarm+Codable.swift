// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CompositeAlarm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionsEnabled = "ActionsEnabled"
        case alarmActions = "AlarmActions"
        case alarmArn = "AlarmArn"
        case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
        case alarmDescription = "AlarmDescription"
        case alarmName = "AlarmName"
        case alarmRule = "AlarmRule"
        case insufficientDataActions = "InsufficientDataActions"
        case oKActions = "OKActions"
        case stateReason = "StateReason"
        case stateReasonData = "StateReasonData"
        case stateUpdatedTimestamp = "StateUpdatedTimestamp"
        case stateValue = "StateValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actionsEnabled = actionsEnabled {
            try container.encode(actionsEnabled, forKey: Key("ActionsEnabled"))
        }
        if let alarmActions = alarmActions {
            var alarmActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AlarmActions"))
            for (index0, resourcename0) in alarmActions.enumerated() {
                try alarmActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let alarmArn = alarmArn {
            try container.encode(alarmArn, forKey: Key("AlarmArn"))
        }
        if let alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp {
            try container.encode(TimestampWrapper(alarmConfigurationUpdatedTimestamp, format: .dateTime), forKey: Key("alarmConfigurationUpdatedTimestamp"))
        }
        if let alarmDescription = alarmDescription {
            try container.encode(alarmDescription, forKey: Key("AlarmDescription"))
        }
        if let alarmName = alarmName {
            try container.encode(alarmName, forKey: Key("AlarmName"))
        }
        if let alarmRule = alarmRule {
            try container.encode(alarmRule, forKey: Key("AlarmRule"))
        }
        if let insufficientDataActions = insufficientDataActions {
            var insufficientDataActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("InsufficientDataActions"))
            for (index0, resourcename0) in insufficientDataActions.enumerated() {
                try insufficientDataActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let oKActions = oKActions {
            var oKActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("OKActions"))
            for (index0, resourcename0) in oKActions.enumerated() {
                try oKActionsContainer.encode(resourcename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: Key("StateReason"))
        }
        if let stateReasonData = stateReasonData {
            try container.encode(stateReasonData, forKey: Key("StateReasonData"))
        }
        if let stateUpdatedTimestamp = stateUpdatedTimestamp {
            try container.encode(TimestampWrapper(stateUpdatedTimestamp, format: .dateTime), forKey: Key("stateUpdatedTimestamp"))
        }
        if let stateValue = stateValue {
            try container.encode(stateValue, forKey: Key("StateValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .actionsEnabled)
        actionsEnabled = actionsEnabledDecoded
        if containerValues.contains(.alarmActions) {
            struct KeyVal0{struct member{}}
            let alarmActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alarmActions)
            if let alarmActionsWrappedContainer = alarmActionsWrappedContainer {
                let alarmActionsContainer = try alarmActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var alarmActionsBuffer:[String]? = nil
                if let alarmActionsContainer = alarmActionsContainer {
                    alarmActionsBuffer = [String]()
                    for stringContainer0 in alarmActionsContainer {
                        alarmActionsBuffer?.append(stringContainer0)
                    }
                }
                alarmActions = alarmActionsBuffer
            } else {
                alarmActions = []
            }
        } else {
            alarmActions = nil
        }
        let alarmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmConfigurationUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmConfigurationUpdatedTimestamp)
        var alarmConfigurationUpdatedTimestampBuffer:Date? = nil
        if let alarmConfigurationUpdatedTimestampDecoded = alarmConfigurationUpdatedTimestampDecoded {
            alarmConfigurationUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(alarmConfigurationUpdatedTimestampDecoded, format: .dateTime)
        }
        alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestampBuffer
        let alarmDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmDescription)
        alarmDescription = alarmDescriptionDecoded
        let alarmNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        if containerValues.contains(.insufficientDataActions) {
            struct KeyVal0{struct member{}}
            let insufficientDataActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .insufficientDataActions)
            if let insufficientDataActionsWrappedContainer = insufficientDataActionsWrappedContainer {
                let insufficientDataActionsContainer = try insufficientDataActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var insufficientDataActionsBuffer:[String]? = nil
                if let insufficientDataActionsContainer = insufficientDataActionsContainer {
                    insufficientDataActionsBuffer = [String]()
                    for stringContainer0 in insufficientDataActionsContainer {
                        insufficientDataActionsBuffer?.append(stringContainer0)
                    }
                }
                insufficientDataActions = insufficientDataActionsBuffer
            } else {
                insufficientDataActions = []
            }
        } else {
            insufficientDataActions = nil
        }
        if containerValues.contains(.oKActions) {
            struct KeyVal0{struct member{}}
            let oKActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .oKActions)
            if let oKActionsWrappedContainer = oKActionsWrappedContainer {
                let oKActionsContainer = try oKActionsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var oKActionsBuffer:[String]? = nil
                if let oKActionsContainer = oKActionsContainer {
                    oKActionsBuffer = [String]()
                    for stringContainer0 in oKActionsContainer {
                        oKActionsBuffer?.append(stringContainer0)
                    }
                }
                oKActions = oKActionsBuffer
            } else {
                oKActions = []
            }
        } else {
            oKActions = nil
        }
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReasonData)
        stateReasonData = stateReasonDataDecoded
        let stateUpdatedTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateUpdatedTimestamp)
        var stateUpdatedTimestampBuffer:Date? = nil
        if let stateUpdatedTimestampDecoded = stateUpdatedTimestampDecoded {
            stateUpdatedTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(stateUpdatedTimestampDecoded, format: .dateTime)
        }
        stateUpdatedTimestamp = stateUpdatedTimestampBuffer
        let stateValueDecoded = try containerValues.decodeIfPresent(StateValue.self, forKey: .stateValue)
        stateValue = stateValueDecoded
    }
}
