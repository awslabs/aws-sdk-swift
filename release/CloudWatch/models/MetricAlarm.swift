// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>The details about a metric alarm.</p>
public struct MetricAlarm: Equatable {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state.</p>
    public let actionsEnabled: Bool?
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state
    /// 			from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    public let alarmActions: [String]?
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    public let alarmArn: String?
    /// <p>The time stamp of the last update to the alarm configuration.</p>
    public let alarmConfigurationUpdatedTimestamp: Date?
    /// <p>The description of the alarm.</p>
    public let alarmDescription: String?
    /// <p>The name of the alarm.</p>
    public let alarmName: String?
    /// <p>The arithmetic operation to use when comparing the specified
    /// 			statistic and threshold. The specified statistic value is used as the first operand.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>The number of data points that must be breaching to trigger the alarm.</p>
    public let datapointsToAlarm: Int?
    /// <p>The dimensions for the metric associated with the alarm.</p>
    public let dimensions: [Dimension]?
    /// <p>Used only for alarms based on percentiles. If <code>ignore</code>, the alarm state does not change
    /// 			during periods with too few data points to be statistically significant. If <code>evaluate</code> or this
    /// 			parameter is not used, the alarm is always evaluated and possibly changes state no matter
    /// 			how many data points are available.</p>
    public let evaluateLowSampleCountPercentile: String?
    /// <p>The number of periods over which data is compared to the specified threshold.</p>
    public let evaluationPeriods: Int?
    /// <p>The percentile statistic for the metric associated with the alarm. Specify a value between
    /// 			p0.0 and p100.</p>
    public let extendedStatistic: String?
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state
    /// 			from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    public let insufficientDataActions: [String]?
    /// <p>The name of the metric associated with the alarm, if this is an alarm
    /// 		based on a single metric.</p>
    public let metricName: String?
    /// <p>An array of MetricDataQuery structures, used in an alarm based on a
    /// 			metric math expression. Each structure either retrieves a
    /// 			metric or performs a math expression.
    /// 			
    /// 			One item in the Metrics array is the math expression that the alarm watches.
    /// 			This expression by designated by having <code>ReturnData</code> set to
    /// 			true.</p>
    public let metrics: [MetricDataQuery]?
    /// <p>The namespace of the metric associated with the alarm.</p>
    public let namespace: String?
    /// <p>The actions to execute when this alarm transitions to the <code>OK</code> state
    /// 			from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    public let oKActions: [String]?
    /// <p>The period, in seconds, over which the statistic is applied.</p>
    public let period: Int?
    /// <p>An explanation for the alarm state, in text format.</p>
    public let stateReason: String?
    /// <p>An explanation for the alarm state, in JSON format.</p>
    public let stateReasonData: String?
    /// <p>The time stamp of the last update to the alarm state.</p>
    public let stateUpdatedTimestamp: Date?
    /// <p>The state value for the alarm.</p>
    public let stateValue: StateValue?
    /// <p>The statistic for the metric associated with the alarm, other than percentile.
    /// 		    For percentile statistics, use <code>ExtendedStatistic</code>.</p>
    public let statistic: Statistic?
    /// <p>The value to compare with the specified statistic.</p>
    public let threshold: Double?
    /// <p>In an alarm based on an anomaly detection model, this is the ID of the
    /// 			<code>ANOMALY_DETECTION_BAND</code> function
    /// 			used as the threshold for the alarm.</p>
    public let thresholdMetricId: String?
    /// <p>Sets how this alarm is to handle missing data points. If this parameter is omitted, the default behavior of <code>missing</code> is used.</p>
    public let treatMissingData: String?
    /// <p>The unit of the metric associated with the alarm.</p>
    public let unit: StandardUnit?

    public init (
        actionsEnabled: Bool? = nil,
        alarmActions: [String]? = nil,
        alarmArn: String? = nil,
        alarmConfigurationUpdatedTimestamp: Date? = nil,
        alarmDescription: String? = nil,
        alarmName: String? = nil,
        comparisonOperator: ComparisonOperator? = nil,
        datapointsToAlarm: Int? = nil,
        dimensions: [Dimension]? = nil,
        evaluateLowSampleCountPercentile: String? = nil,
        evaluationPeriods: Int? = nil,
        extendedStatistic: String? = nil,
        insufficientDataActions: [String]? = nil,
        metricName: String? = nil,
        metrics: [MetricDataQuery]? = nil,
        namespace: String? = nil,
        oKActions: [String]? = nil,
        period: Int? = nil,
        stateReason: String? = nil,
        stateReasonData: String? = nil,
        stateUpdatedTimestamp: Date? = nil,
        stateValue: StateValue? = nil,
        statistic: Statistic? = nil,
        threshold: Double? = nil,
        thresholdMetricId: String? = nil,
        treatMissingData: String? = nil,
        unit: StandardUnit? = nil
    )
    {
        self.actionsEnabled = actionsEnabled
        self.alarmActions = alarmActions
        self.alarmArn = alarmArn
        self.alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp
        self.alarmDescription = alarmDescription
        self.alarmName = alarmName
        self.comparisonOperator = comparisonOperator
        self.datapointsToAlarm = datapointsToAlarm
        self.dimensions = dimensions
        self.evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile
        self.evaluationPeriods = evaluationPeriods
        self.extendedStatistic = extendedStatistic
        self.insufficientDataActions = insufficientDataActions
        self.metricName = metricName
        self.metrics = metrics
        self.namespace = namespace
        self.oKActions = oKActions
        self.period = period
        self.stateReason = stateReason
        self.stateReasonData = stateReasonData
        self.stateUpdatedTimestamp = stateUpdatedTimestamp
        self.stateValue = stateValue
        self.statistic = statistic
        self.threshold = threshold
        self.thresholdMetricId = thresholdMetricId
        self.treatMissingData = treatMissingData
        self.unit = unit
    }
}

extension MetricAlarm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricAlarm(actionsEnabled: \(String(describing: actionsEnabled)), alarmActions: \(String(describing: alarmActions)), alarmArn: \(String(describing: alarmArn)), alarmConfigurationUpdatedTimestamp: \(String(describing: alarmConfigurationUpdatedTimestamp)), alarmDescription: \(String(describing: alarmDescription)), alarmName: \(String(describing: alarmName)), comparisonOperator: \(String(describing: comparisonOperator)), datapointsToAlarm: \(String(describing: datapointsToAlarm)), dimensions: \(String(describing: dimensions)), evaluateLowSampleCountPercentile: \(String(describing: evaluateLowSampleCountPercentile)), evaluationPeriods: \(String(describing: evaluationPeriods)), extendedStatistic: \(String(describing: extendedStatistic)), insufficientDataActions: \(String(describing: insufficientDataActions)), metricName: \(String(describing: metricName)), metrics: \(String(describing: metrics)), namespace: \(String(describing: namespace)), oKActions: \(String(describing: oKActions)), period: \(String(describing: period)), stateReason: \(String(describing: stateReason)), stateReasonData: \(String(describing: stateReasonData)), stateUpdatedTimestamp: \(String(describing: stateUpdatedTimestamp)), stateValue: \(String(describing: stateValue)), statistic: \(String(describing: statistic)), threshold: \(String(describing: threshold)), thresholdMetricId: \(String(describing: thresholdMetricId)), treatMissingData: \(String(describing: treatMissingData)), unit: \(String(describing: unit)))"}
}
