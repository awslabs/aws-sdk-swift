// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TableDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archivalSummary = "ArchivalSummary"
        case attributeDefinitions = "AttributeDefinitions"
        case billingModeSummary = "BillingModeSummary"
        case creationDateTime = "CreationDateTime"
        case globalSecondaryIndexes = "GlobalSecondaryIndexes"
        case globalTableVersion = "GlobalTableVersion"
        case itemCount = "ItemCount"
        case keySchema = "KeySchema"
        case latestStreamArn = "LatestStreamArn"
        case latestStreamLabel = "LatestStreamLabel"
        case localSecondaryIndexes = "LocalSecondaryIndexes"
        case provisionedThroughput = "ProvisionedThroughput"
        case replicas = "Replicas"
        case restoreSummary = "RestoreSummary"
        case sSEDescription = "SSEDescription"
        case streamSpecification = "StreamSpecification"
        case tableArn = "TableArn"
        case tableId = "TableId"
        case tableName = "TableName"
        case tableSizeBytes = "TableSizeBytes"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archivalSummary = archivalSummary {
            try encodeContainer.encode(archivalSummary, forKey: .archivalSummary)
        }
        if let attributeDefinitions = attributeDefinitions {
            var attributeDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeDefinitions)
            for attributedefinitions0 in attributeDefinitions {
                try attributeDefinitionsContainer.encode(attributedefinitions0)
            }
        }
        if let billingModeSummary = billingModeSummary {
            try encodeContainer.encode(billingModeSummary, forKey: .billingModeSummary)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let globalSecondaryIndexes = globalSecondaryIndexes {
            var globalSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .globalSecondaryIndexes)
            for globalsecondaryindexdescriptionlist0 in globalSecondaryIndexes {
                try globalSecondaryIndexesContainer.encode(globalsecondaryindexdescriptionlist0)
            }
        }
        if let globalTableVersion = globalTableVersion {
            try encodeContainer.encode(globalTableVersion, forKey: .globalTableVersion)
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for keyschema0 in keySchema {
                try keySchemaContainer.encode(keyschema0)
            }
        }
        if let latestStreamArn = latestStreamArn {
            try encodeContainer.encode(latestStreamArn, forKey: .latestStreamArn)
        }
        if let latestStreamLabel = latestStreamLabel {
            try encodeContainer.encode(latestStreamLabel, forKey: .latestStreamLabel)
        }
        if let localSecondaryIndexes = localSecondaryIndexes {
            var localSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localSecondaryIndexes)
            for localsecondaryindexdescriptionlist0 in localSecondaryIndexes {
                try localSecondaryIndexesContainer.encode(localsecondaryindexdescriptionlist0)
            }
        }
        if let provisionedThroughput = provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let replicas = replicas {
            var replicasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicas)
            for replicadescriptionlist0 in replicas {
                try replicasContainer.encode(replicadescriptionlist0)
            }
        }
        if let restoreSummary = restoreSummary {
            try encodeContainer.encode(restoreSummary, forKey: .restoreSummary)
        }
        if let sSEDescription = sSEDescription {
            try encodeContainer.encode(sSEDescription, forKey: .sSEDescription)
        }
        if let streamSpecification = streamSpecification {
            try encodeContainer.encode(streamSpecification, forKey: .streamSpecification)
        }
        if let tableArn = tableArn {
            try encodeContainer.encode(tableArn, forKey: .tableArn)
        }
        if let tableId = tableId {
            try encodeContainer.encode(tableId, forKey: .tableId)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if tableSizeBytes != 0 {
            try encodeContainer.encode(tableSizeBytes, forKey: .tableSizeBytes)
        }
        if let tableStatus = tableStatus {
            try encodeContainer.encode(tableStatus.rawValue, forKey: .tableStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDefinitionsContainer = try containerValues.decodeIfPresent([AttributeDefinition?].self, forKey: .attributeDefinitions)
        var attributeDefinitionsDecoded0:[AttributeDefinition]? = nil
        if let attributeDefinitionsContainer = attributeDefinitionsContainer {
            attributeDefinitionsDecoded0 = [AttributeDefinition]()
            for structure0 in attributeDefinitionsContainer {
                if let structure0 = structure0 {
                    attributeDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        attributeDefinitions = attributeDefinitionsDecoded0
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([KeySchemaElement?].self, forKey: .keySchema)
        var keySchemaDecoded0:[KeySchemaElement]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [KeySchemaElement]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let tableStatusDecoded = try containerValues.decodeIfPresent(TableStatus.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(ProvisionedThroughputDescription.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let tableSizeBytesDecoded = try containerValues.decode(Int.self, forKey: .tableSizeBytes)
        tableSizeBytes = tableSizeBytesDecoded
        let itemCountDecoded = try containerValues.decode(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let tableArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableArn)
        tableArn = tableArnDecoded
        let tableIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableId)
        tableId = tableIdDecoded
        let billingModeSummaryDecoded = try containerValues.decodeIfPresent(BillingModeSummary.self, forKey: .billingModeSummary)
        billingModeSummary = billingModeSummaryDecoded
        let localSecondaryIndexesContainer = try containerValues.decodeIfPresent([LocalSecondaryIndexDescription?].self, forKey: .localSecondaryIndexes)
        var localSecondaryIndexesDecoded0:[LocalSecondaryIndexDescription]? = nil
        if let localSecondaryIndexesContainer = localSecondaryIndexesContainer {
            localSecondaryIndexesDecoded0 = [LocalSecondaryIndexDescription]()
            for structure0 in localSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    localSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        localSecondaryIndexes = localSecondaryIndexesDecoded0
        let globalSecondaryIndexesContainer = try containerValues.decodeIfPresent([GlobalSecondaryIndexDescription?].self, forKey: .globalSecondaryIndexes)
        var globalSecondaryIndexesDecoded0:[GlobalSecondaryIndexDescription]? = nil
        if let globalSecondaryIndexesContainer = globalSecondaryIndexesContainer {
            globalSecondaryIndexesDecoded0 = [GlobalSecondaryIndexDescription]()
            for structure0 in globalSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    globalSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        globalSecondaryIndexes = globalSecondaryIndexesDecoded0
        let streamSpecificationDecoded = try containerValues.decodeIfPresent(StreamSpecification.self, forKey: .streamSpecification)
        streamSpecification = streamSpecificationDecoded
        let latestStreamLabelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestStreamLabel)
        latestStreamLabel = latestStreamLabelDecoded
        let latestStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestStreamArn)
        latestStreamArn = latestStreamArnDecoded
        let globalTableVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalTableVersion)
        globalTableVersion = globalTableVersionDecoded
        let replicasContainer = try containerValues.decodeIfPresent([ReplicaDescription?].self, forKey: .replicas)
        var replicasDecoded0:[ReplicaDescription]? = nil
        if let replicasContainer = replicasContainer {
            replicasDecoded0 = [ReplicaDescription]()
            for structure0 in replicasContainer {
                if let structure0 = structure0 {
                    replicasDecoded0?.append(structure0)
                }
            }
        }
        replicas = replicasDecoded0
        let restoreSummaryDecoded = try containerValues.decodeIfPresent(RestoreSummary.self, forKey: .restoreSummary)
        restoreSummary = restoreSummaryDecoded
        let sSEDescriptionDecoded = try containerValues.decodeIfPresent(SSEDescription.self, forKey: .sSEDescription)
        sSEDescription = sSEDescriptionDecoded
        let archivalSummaryDecoded = try containerValues.decodeIfPresent(ArchivalSummary.self, forKey: .archivalSummary)
        archivalSummary = archivalSummaryDecoded
    }
}
