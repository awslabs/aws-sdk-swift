// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateRoleToGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateRoleToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct AssociateRoleToGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.roleArn = roleArn
    }
}

struct AssociateRoleToGroupInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateRoleToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateRoleToGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRoleToGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateRoleToGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRoleToGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateRoleToGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateRoleToGroupOutputResponse: Swift.Equatable {
    /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
    public var associatedAt: Swift.String?

    public init (
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateRoleToGroupOutputResponseBody: Swift.Equatable {
    let associatedAt: Swift.String?
}

extension AssociateRoleToGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

extension AssociateServiceRoleToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateServiceRoleToAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct AssociateServiceRoleToAccountInput: Swift.Equatable {
    /// The ARN of the service role you wish to associate with your account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateServiceRoleToAccountInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateServiceRoleToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateServiceRoleToAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceRoleToAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateServiceRoleToAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceRoleToAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateServiceRoleToAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateServiceRoleToAccountOutputResponse: Swift.Equatable {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?

    public init (
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateServiceRoleToAccountOutputResponseBody: Swift.Equatable {
    let associatedAt: Swift.String?
}

extension AssociateServiceRoleToAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorDetails = output.errorDetails
            self.message = output.message
        } else {
            self.errorDetails = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// General error information.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Details about the error.
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// A message containing information about the error.
    public var message: Swift.String?

    public init (
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorDetails = errorDetails
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassClientTypes.BulkDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
        case createdAt = "CreatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulkDeploymentArn = self.bulkDeploymentArn {
            try encodeContainer.encode(bulkDeploymentArn, forKey: .bulkDeploymentArn)
        }
        if let bulkDeploymentId = self.bulkDeploymentId {
            try encodeContainer.encode(bulkDeploymentId, forKey: .bulkDeploymentId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a bulk deployment. You cannot start a new bulk deployment while another one is still running or in a non-terminal state.
    public struct BulkDeployment: Swift.Equatable {
        /// The ARN of the bulk deployment.
        public var bulkDeploymentArn: Swift.String?
        /// The ID of the bulk deployment.
        public var bulkDeploymentId: Swift.String?
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?

        public init (
            bulkDeploymentArn: Swift.String? = nil,
            bulkDeploymentId: Swift.String? = nil,
            createdAt: Swift.String? = nil
        )
        {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
            self.createdAt = createdAt
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidInputRecords = "InvalidInputRecords"
        case recordsProcessed = "RecordsProcessed"
        case retryAttempts = "RetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invalidInputRecords = self.invalidInputRecords {
            try encodeContainer.encode(invalidInputRecords, forKey: .invalidInputRecords)
        }
        if let recordsProcessed = self.recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
        if let retryAttempts = self.retryAttempts {
            try encodeContainer.encode(retryAttempts, forKey: .retryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidInputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invalidInputRecords)
        invalidInputRecords = invalidInputRecordsDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
        let retryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAttempts)
        retryAttempts = retryAttemptsDecoded
    }
}

extension GreengrassClientTypes {
    /// Relevant metrics on input records processed during bulk deployment.
    public struct BulkDeploymentMetrics: Swift.Equatable {
        /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
        public var invalidInputRecords: Swift.Int?
        /// The total number of group records from the input file that have been processed so far, or attempted.
        public var recordsProcessed: Swift.Int?
        /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
        public var retryAttempts: Swift.Int?

        public init (
            invalidInputRecords: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil,
            retryAttempts: Swift.Int? = nil
        )
        {
            self.invalidInputRecords = invalidInputRecords
            self.recordsProcessed = recordsProcessed
            self.retryAttempts = retryAttempts
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = self.deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetails)
            for errordetail0 in errorDetails {
                try errorDetailsContainer.encode(errordetail0)
            }
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about an individual group deployment in a bulk deployment operation.
    public struct BulkDeploymentResult: Swift.Equatable {
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the group deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the group deployment.
        public var deploymentId: Swift.String?
        /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public var deploymentStatus: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// Details about the error.
        public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
        /// The error message for a failed deployment
        public var errorMessage: Swift.String?
        /// The ARN of the Greengrass group.
        public var groupArn: Swift.String?

        public init (
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
            errorMessage: Swift.String? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {
    /// The current status of the bulk deployment.
    public enum BulkDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkDeploymentStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .initializing: return "Initializing"
            case .running: return "Running"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BulkDeploymentStatus(rawValue: rawValue) ?? BulkDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    public enum ConfigurationSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insync
        case outofsync
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSyncStatus] {
            return [
                .insync,
                .outofsync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insync: return "InSync"
            case .outofsync: return "OutOfSync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSyncStatus(rawValue: rawValue) ?? ConfigurationSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.ConnectivityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostAddress = "HostAddress"
        case id = "Id"
        case metadata = "Metadata"
        case portNumber = "PortNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostAddress = self.hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let portNumber = self.portNumber {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let portNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .portNumber)
        portNumber = portNumberDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a Greengrass core's connectivity.
    public struct ConnectivityInfo: Swift.Equatable {
        /// The endpoint for the Greengrass core. Can be an IP address or DNS.
        public var hostAddress: Swift.String?
        /// The ID of the connectivity information.
        public var id: Swift.String?
        /// Metadata for this endpoint.
        public var metadata: Swift.String?
        /// The port of the Greengrass core. Usually 8883.
        public var portNumber: Swift.Int?

        public init (
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int? = nil
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }

}

extension GreengrassClientTypes.Connector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn = "ConnectorArn"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorArn = self.connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, __mapOf__string0) in parameters {
                try parametersContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in parametersContainer {
                if let __string0 = __string0 {
                    parametersDecoded0?[key0] = __string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a connector. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public struct Connector: Swift.Equatable {
        /// The ARN of the connector.
        /// This member is required.
        public var connectorArn: Swift.String?
        /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
        /// This member is required.
        public var id: Swift.String?
        /// The parameters or configuration that the connector uses.
        public var parameters: [Swift.String:Swift.String]?

        public init (
            connectorArn: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.connectorArn = connectorArn
            self.id = id
            self.parameters = parameters
        }
    }

}

extension GreengrassClientTypes.ConnectorDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for connector0 in connectors {
                try connectorsContainer.encode(connector0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[GreengrassClientTypes.Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [GreengrassClientTypes.Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about the connector definition version, which is a container for connectors.
    public struct ConnectorDefinitionVersion: Swift.Equatable {
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public var connectors: [GreengrassClientTypes.Connector]?

        public init (
            connectors: [GreengrassClientTypes.Connector]? = nil
        )
        {
            self.connectors = connectors
        }
    }

}

extension GreengrassClientTypes.Core: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let syncShadow = self.syncShadow {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a core.
    public struct Core: Swift.Equatable {
        /// The ARN of the certificate associated with the core.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the core's local shadow is automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The ARN of the thing which is the core.
        /// This member is required.
        public var thingArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.CoreDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for core0 in cores {
                try coresContainer.encode(core0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Core?].self, forKey: .cores)
        var coresDecoded0:[GreengrassClientTypes.Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [GreengrassClientTypes.Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a core definition version.
    public struct CoreDefinitionVersion: Swift.Equatable {
        /// A list of cores in the core definition version.
        public var cores: [GreengrassClientTypes.Core]?

        public init (
            cores: [GreengrassClientTypes.Core]? = nil
        )
        {
            self.cores = cores
        }
    }

}

extension CreateConnectorDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConnectorDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

public struct CreateConnectorDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the connector definition.
    public var initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The name of the connector definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConnectorDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConnectorDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConnectorDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectorDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectorDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectorDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateConnectorDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateConnectorDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateConnectorDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateConnectorDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for connector0 in connectors {
                try connectorsContainer.encode(connector0)
            }
        }
    }
}

extension CreateConnectorDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateConnectorDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public var connectors: [GreengrassClientTypes.Connector]?

    public init (
        amznClientToken: Swift.String? = nil,
        connectorDefinitionId: Swift.String? = nil,
        connectors: [GreengrassClientTypes.Connector]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionId = connectorDefinitionId
        self.connectors = connectors
    }
}

struct CreateConnectorDefinitionVersionInputBody: Swift.Equatable {
    let connectors: [GreengrassClientTypes.Connector]?
}

extension CreateConnectorDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[GreengrassClientTypes.Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [GreengrassClientTypes.Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension CreateConnectorDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectorDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectorDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectorDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectorDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateConnectorDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateConnectorDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateConnectorDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateCoreDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCoreDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/cores"
    }
}

/// Information needed to create a core definition.
public struct CreateCoreDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the core definition.
    public var initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    /// The name of the core definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateCoreDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCoreDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.CoreDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCoreDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCoreDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCoreDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateCoreDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateCoreDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateCoreDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateCoreDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for core0 in cores {
                try coresContainer.encode(core0)
            }
        }
    }
}

extension CreateCoreDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateCoreDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// A list of cores in the core definition version.
    public var cores: [GreengrassClientTypes.Core]?

    public init (
        amznClientToken: Swift.String? = nil,
        coreDefinitionId: Swift.String? = nil,
        cores: [GreengrassClientTypes.Core]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.coreDefinitionId = coreDefinitionId
        self.cores = cores
    }
}

struct CreateCoreDefinitionVersionInputBody: Swift.Equatable {
    let cores: [GreengrassClientTypes.Core]?
}

extension CreateCoreDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Core?].self, forKey: .cores)
        var coresDecoded0:[GreengrassClientTypes.Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [GreengrassClientTypes.Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension CreateCoreDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCoreDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCoreDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCoreDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCoreDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateCoreDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateCoreDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateCoreDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupVersionId = self.groupVersionId {
            try encodeContainer.encode(groupVersionId, forKey: .groupVersionId)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    public var deploymentId: Swift.String?
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    /// This member is required.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version to be deployed.
    public var groupVersionId: Swift.String?

    public init (
        amznClientToken: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let deploymentType: GreengrassClientTypes.DeploymentType?
    let groupVersionId: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupVersionId)
        groupVersionId = groupVersionIdDecoded
    }
}

extension CreateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Swift.Equatable {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init (
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputResponseBody: Swift.Equatable {
    let deploymentArn: Swift.String?
    let deploymentId: Swift.String?
}

extension CreateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension CreateDeviceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeviceDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/devices"
    }
}

public struct CreateDeviceDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the device definition.
    public var initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The name of the device definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeviceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeviceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeviceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeviceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateDeviceDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateDeviceDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateDeviceDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDeviceDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for device0 in devices {
                try devicesContainer.encode(device0)
            }
        }
    }
}

extension CreateDeviceDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateDeviceDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// A list of devices in the definition version.
    public var devices: [GreengrassClientTypes.Device]?

    public init (
        amznClientToken: Swift.String? = nil,
        deviceDefinitionId: Swift.String? = nil,
        devices: [GreengrassClientTypes.Device]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deviceDefinitionId = deviceDefinitionId
        self.devices = devices
    }
}

struct CreateDeviceDefinitionVersionInputBody: Swift.Equatable {
    let devices: [GreengrassClientTypes.Device]?
}

extension CreateDeviceDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension CreateDeviceDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDeviceDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDeviceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateDeviceDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateDeviceDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateDeviceDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateFunctionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFunctionDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/functions"
    }
}

public struct CreateFunctionDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the function definition.
    public var initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The name of the function definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateFunctionDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFunctionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFunctionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFunctionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFunctionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateFunctionDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateFunctionDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateFunctionDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateFunctionDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = self.defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for function0 in functions {
                try functionsContainer.encode(function0)
            }
        }
    }
}

extension CreateFunctionDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

/// Information needed to create a function definition version.
public struct CreateFunctionDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// A list of Lambda functions in this function definition version.
    public var functions: [GreengrassClientTypes.Function]?

    public init (
        amznClientToken: Swift.String? = nil,
        defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
        functionDefinitionId: Swift.String? = nil,
        functions: [GreengrassClientTypes.Function]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.defaultConfig = defaultConfig
        self.functionDefinitionId = functionDefinitionId
        self.functions = functions
    }
}

struct CreateFunctionDefinitionVersionInputBody: Swift.Equatable {
    let defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    let functions: [GreengrassClientTypes.Function]?
}

extension CreateFunctionDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Function?].self, forKey: .functions)
        var functionsDecoded0:[GreengrassClientTypes.Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [GreengrassClientTypes.Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension CreateFunctionDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFunctionDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFunctionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateFunctionDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateFunctionDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateFunctionDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateGroupCertificateAuthorityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct CreateGroupCertificateAuthorityInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        amznClientToken: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.groupId = groupId
    }
}

struct CreateGroupCertificateAuthorityInputBody: Swift.Equatable {
}

extension CreateGroupCertificateAuthorityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateGroupCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
        } else {
            self.groupCertificateAuthorityArn = nil
        }
    }
}

public struct CreateGroupCertificateAuthorityOutputResponse: Swift.Equatable {
    /// The ARN of the group certificate authority.
    public var groupCertificateAuthorityArn: Swift.String?

    public init (
        groupCertificateAuthorityArn: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
    }
}

struct CreateGroupCertificateAuthorityOutputResponseBody: Swift.Equatable {
    let groupCertificateAuthorityArn: Swift.String?
}

extension CreateGroupCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/groups"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the group.
    public var initialVersion: GreengrassClientTypes.GroupVersion?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.GroupVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.GroupVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateGroupVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = self.connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = self.coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = self.deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = self.functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = self.loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = self.resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = self.subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }
}

extension CreateGroupVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

public struct CreateGroupVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the connector definition version for this group.
    public var connectorDefinitionVersionArn: Swift.String?
    /// The ARN of the core definition version for this group.
    public var coreDefinitionVersionArn: Swift.String?
    /// The ARN of the device definition version for this group.
    public var deviceDefinitionVersionArn: Swift.String?
    /// The ARN of the function definition version for this group.
    public var functionDefinitionVersionArn: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the logger definition version for this group.
    public var loggerDefinitionVersionArn: Swift.String?
    /// The ARN of the resource definition version for this group.
    public var resourceDefinitionVersionArn: Swift.String?
    /// The ARN of the subscription definition version for this group.
    public var subscriptionDefinitionVersionArn: Swift.String?

    public init (
        amznClientToken: Swift.String? = nil,
        connectorDefinitionVersionArn: Swift.String? = nil,
        coreDefinitionVersionArn: Swift.String? = nil,
        deviceDefinitionVersionArn: Swift.String? = nil,
        functionDefinitionVersionArn: Swift.String? = nil,
        groupId: Swift.String? = nil,
        loggerDefinitionVersionArn: Swift.String? = nil,
        resourceDefinitionVersionArn: Swift.String? = nil,
        subscriptionDefinitionVersionArn: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.groupId = groupId
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

struct CreateGroupVersionInputBody: Swift.Equatable {
    let connectorDefinitionVersionArn: Swift.String?
    let coreDefinitionVersionArn: Swift.String?
    let deviceDefinitionVersionArn: Swift.String?
    let functionDefinitionVersionArn: Swift.String?
    let loggerDefinitionVersionArn: Swift.String?
    let resourceDefinitionVersionArn: Swift.String?
    let subscriptionDefinitionVersionArn: Swift.String?
}

extension CreateGroupVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension CreateGroupVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateGroupVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateGroupVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateGroupVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateLoggerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLoggerDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

public struct CreateLoggerDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the logger definition.
    public var initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The name of the logger definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateLoggerDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLoggerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLoggerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoggerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoggerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLoggerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateLoggerDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateLoggerDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateLoggerDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateLoggerDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for logger0 in loggers {
                try loggersContainer.encode(logger0)
            }
        }
    }
}

extension CreateLoggerDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateLoggerDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// A list of loggers.
    public var loggers: [GreengrassClientTypes.Logger]?

    public init (
        amznClientToken: Swift.String? = nil,
        loggerDefinitionId: Swift.String? = nil,
        loggers: [GreengrassClientTypes.Logger]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.loggerDefinitionId = loggerDefinitionId
        self.loggers = loggers
    }
}

struct CreateLoggerDefinitionVersionInputBody: Swift.Equatable {
    let loggers: [GreengrassClientTypes.Logger]?
}

extension CreateLoggerDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Logger?].self, forKey: .loggers)
        var loggersDecoded0:[GreengrassClientTypes.Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [GreengrassClientTypes.Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension CreateLoggerDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLoggerDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoggerDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoggerDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLoggerDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateLoggerDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateLoggerDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateLoggerDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateResourceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateResourceDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/resources"
    }
}

public struct CreateResourceDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the resource definition.
    public var initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The name of the resource definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateResourceDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateResourceDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateResourceDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateResourceDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateResourceDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }
}

extension CreateResourceDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateResourceDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// A list of resources.
    public var resources: [GreengrassClientTypes.Resource]?

    public init (
        amznClientToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil,
        resources: [GreengrassClientTypes.Resource]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.resourceDefinitionId = resourceDefinitionId
        self.resources = resources
    }
}

struct CreateResourceDefinitionVersionInputBody: Swift.Equatable {
    let resources: [GreengrassClientTypes.Resource]?
}

extension CreateResourceDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[GreengrassClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [GreengrassClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension CreateResourceDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateResourceDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateResourceDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateResourceDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateSoftwareUpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3UrlSignerRole = self.s3UrlSignerRole {
            try encodeContainer.encode(s3UrlSignerRole, forKey: .s3UrlSignerRole)
        }
        if let softwareToUpdate = self.softwareToUpdate {
            try encodeContainer.encode(softwareToUpdate.rawValue, forKey: .softwareToUpdate)
        }
        if let updateAgentLogLevel = self.updateAgentLogLevel {
            try encodeContainer.encode(updateAgentLogLevel.rawValue, forKey: .updateAgentLogLevel)
        }
        if let updateTargets = updateTargets {
            var updateTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateTargets)
            for __string0 in updateTargets {
                try updateTargetsContainer.encode(__string0)
            }
        }
        if let updateTargetsArchitecture = self.updateTargetsArchitecture {
            try encodeContainer.encode(updateTargetsArchitecture.rawValue, forKey: .updateTargetsArchitecture)
        }
        if let updateTargetsOperatingSystem = self.updateTargetsOperatingSystem {
            try encodeContainer.encode(updateTargetsOperatingSystem.rawValue, forKey: .updateTargetsOperatingSystem)
        }
    }
}

extension CreateSoftwareUpdateJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSoftwareUpdateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/updates"
    }
}

public struct CreateSoftwareUpdateJobInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    /// This member is required.
    public var s3UrlSignerRole: Swift.String?
    /// The piece of software on the Greengrass core that will be updated.
    /// This member is required.
    public var softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public var updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    /// This member is required.
    public var updateTargets: [Swift.String]?
    /// The architecture of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    /// The operating system of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?

    public init (
        amznClientToken: Swift.String? = nil,
        s3UrlSignerRole: Swift.String? = nil,
        softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate? = nil,
        updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel? = nil,
        updateTargets: [Swift.String]? = nil,
        updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture? = nil,
        updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.s3UrlSignerRole = s3UrlSignerRole
        self.softwareToUpdate = softwareToUpdate
        self.updateAgentLogLevel = updateAgentLogLevel
        self.updateTargets = updateTargets
        self.updateTargetsArchitecture = updateTargetsArchitecture
        self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
    }
}

struct CreateSoftwareUpdateJobInputBody: Swift.Equatable {
    let s3UrlSignerRole: Swift.String?
    let softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    let updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    let updateTargets: [Swift.String]?
    let updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    let updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?
}

extension CreateSoftwareUpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlSignerRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3UrlSignerRole)
        s3UrlSignerRole = s3UrlSignerRoleDecoded
        let softwareToUpdateDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SoftwareToUpdate.self, forKey: .softwareToUpdate)
        softwareToUpdate = softwareToUpdateDecoded
        let updateAgentLogLevelDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateAgentLogLevel.self, forKey: .updateAgentLogLevel)
        updateAgentLogLevel = updateAgentLogLevelDecoded
        let updateTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .updateTargets)
        var updateTargetsDecoded0:[Swift.String]? = nil
        if let updateTargetsContainer = updateTargetsContainer {
            updateTargetsDecoded0 = [Swift.String]()
            for string0 in updateTargetsContainer {
                if let string0 = string0 {
                    updateTargetsDecoded0?.append(string0)
                }
            }
        }
        updateTargets = updateTargetsDecoded0
        let updateTargetsArchitectureDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateTargetsArchitecture.self, forKey: .updateTargetsArchitecture)
        updateTargetsArchitecture = updateTargetsArchitectureDecoded
        let updateTargetsOperatingSystemDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateTargetsOperatingSystem.self, forKey: .updateTargetsOperatingSystem)
        updateTargetsOperatingSystem = updateTargetsOperatingSystemDecoded
    }
}

extension CreateSoftwareUpdateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSoftwareUpdateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSoftwareUpdateJobOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSoftwareUpdateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSoftwareUpdateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
            self.platformSoftwareVersion = output.platformSoftwareVersion
        } else {
            self.iotJobArn = nil
            self.iotJobId = nil
            self.platformSoftwareVersion = nil
        }
    }
}

public struct CreateSoftwareUpdateJobOutputResponse: Swift.Equatable {
    /// The IoT Job ARN corresponding to this update.
    public var iotJobArn: Swift.String?
    /// The IoT Job Id corresponding to this update.
    public var iotJobId: Swift.String?
    /// The software version installed on the device or devices after the update.
    public var platformSoftwareVersion: Swift.String?

    public init (
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil,
        platformSoftwareVersion: Swift.String? = nil
    )
    {
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.platformSoftwareVersion = platformSoftwareVersion
    }
}

struct CreateSoftwareUpdateJobOutputResponseBody: Swift.Equatable {
    let iotJobArn: Swift.String?
    let iotJobId: Swift.String?
    let platformSoftwareVersion: Swift.String?
}

extension CreateSoftwareUpdateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotJobArn = "IotJobArn"
        case iotJobId = "IotJobId"
        case platformSoftwareVersion = "PlatformSoftwareVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let platformSoftwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformSoftwareVersion)
        platformSoftwareVersion = platformSoftwareVersionDecoded
    }
}

extension CreateSubscriptionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSubscriptionDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

public struct CreateSubscriptionDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the subscription definition.
    public var initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The name of the subscription definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateSubscriptionDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSubscriptionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SubscriptionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubscriptionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSubscriptionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateSubscriptionDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateSubscriptionDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateSubscriptionDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSubscriptionDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
    }
}

extension CreateSubscriptionDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateSubscriptionDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [GreengrassClientTypes.Subscription]?

    public init (
        amznClientToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptions: [GreengrassClientTypes.Subscription]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptions = subscriptions
    }
}

struct CreateSubscriptionDefinitionVersionInputBody: Swift.Equatable {
    let subscriptions: [GreengrassClientTypes.Subscription]?
}

extension CreateSubscriptionDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[GreengrassClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [GreengrassClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension CreateSubscriptionDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubscriptionDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSubscriptionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateSubscriptionDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateSubscriptionDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateSubscriptionDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GreengrassClientTypes.DefinitionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = self.latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = self.latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a definition.
    public struct DefinitionInformation: Swift.Equatable {
        /// The ARN of the definition.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the definition.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the definition.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the definition.
        public var latestVersionArn: Swift.String?
        /// The name of the definition.
        public var name: Swift.String?
        /// Tag(s) attached to the resource arn.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }
    }

}

extension DeleteConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init (
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct DeleteConnectorDefinitionInputBody: Swift.Equatable {
}

extension DeleteConnectorDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectorDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectorDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectorDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectorDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectorDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init (
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct DeleteCoreDefinitionInputBody: Swift.Equatable {
}

extension DeleteCoreDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCoreDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCoreDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init (
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct DeleteDeviceDefinitionInputBody: Swift.Equatable {
}

extension DeleteDeviceDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDeviceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init (
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct DeleteFunctionDefinitionInputBody: Swift.Equatable {
}

extension DeleteFunctionDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFunctionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
}

extension DeleteGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init (
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct DeleteLoggerDefinitionInputBody: Swift.Equatable {
}

extension DeleteLoggerDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLoggerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLoggerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoggerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoggerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoggerDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteResourceDefinitionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init (
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct DeleteResourceDefinitionInputBody: Swift.Equatable {
}

extension DeleteResourceDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionDefinitionInput: Swift.Equatable {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init (
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct DeleteSubscriptionDefinitionInputBody: Swift.Equatable {
}

extension DeleteSubscriptionDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriptionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSubscriptionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriptionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSubscriptionDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = self.deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a deployment.
    public struct Deployment: Swift.Equatable {
        /// The time, in milliseconds since the epoch, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// The ARN of the group for this deployment.
        public var groupArn: Swift.String?

        public init (
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forceresetdeployment
        case newdeployment
        case redeployment
        case resetdeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .forceresetdeployment,
                .newdeployment,
                .redeployment,
                .resetdeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forceresetdeployment: return "ForceResetDeployment"
            case .newdeployment: return "NewDeployment"
            case .redeployment: return "Redeployment"
            case .resetdeployment: return "ResetDeployment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let syncShadow = self.syncShadow {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a device.
    public struct Device: Swift.Equatable {
        /// The ARN of the certificate associated with the device.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the device's local shadow will be automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The thing ARN of the device.
        /// This member is required.
        public var thingArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.DeviceDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for device0 in devices {
                try devicesContainer.encode(device0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a device definition version.
    public struct DeviceDefinitionVersion: Swift.Equatable {
        /// A list of devices in the definition version.
        public var devices: [GreengrassClientTypes.Device]?

        public init (
            devices: [GreengrassClientTypes.Device]? = nil
        )
        {
            self.devices = devices
        }
    }

}

extension DisassociateRoleFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct DisassociateRoleFromGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DisassociateRoleFromGroupInputBody: Swift.Equatable {
}

extension DisassociateRoleFromGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRoleFromGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRoleFromGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateRoleFromGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRoleFromGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateRoleFromGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateRoleFromGroupOutputResponse: Swift.Equatable {
    /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
    public var disassociatedAt: Swift.String?

    public init (
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateRoleFromGroupOutputResponseBody: Swift.Equatable {
    let disassociatedAt: Swift.String?
}

extension DisassociateRoleFromGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

extension DisassociateServiceRoleFromAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct DisassociateServiceRoleFromAccountInput: Swift.Equatable {

    public init () { }
}

struct DisassociateServiceRoleFromAccountInputBody: Swift.Equatable {
}

extension DisassociateServiceRoleFromAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateServiceRoleFromAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceRoleFromAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateServiceRoleFromAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceRoleFromAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateServiceRoleFromAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateServiceRoleFromAccountOutputResponse: Swift.Equatable {
    /// The time when the service role was disassociated from the account.
    public var disassociatedAt: Swift.String?

    public init (
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateServiceRoleFromAccountOutputResponseBody: Swift.Equatable {
    let disassociatedAt: Swift.String?
}

extension DisassociateServiceRoleFromAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

extension GreengrassClientTypes {
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .binary,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedErrorCode = "DetailedErrorCode"
        case detailedErrorMessage = "DetailedErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedErrorCode = self.detailedErrorCode {
            try encodeContainer.encode(detailedErrorCode, forKey: .detailedErrorCode)
        }
        if let detailedErrorMessage = self.detailedErrorMessage {
            try encodeContainer.encode(detailedErrorMessage, forKey: .detailedErrorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedErrorCode)
        detailedErrorCode = detailedErrorCodeDecoded
        let detailedErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedErrorMessage)
        detailedErrorMessage = detailedErrorMessageDecoded
    }
}

extension GreengrassClientTypes {
    /// Details about the error.
    public struct ErrorDetail: Swift.Equatable {
        /// A detailed error code.
        public var detailedErrorCode: Swift.String?
        /// A detailed error message.
        public var detailedErrorMessage: Swift.String?

        public init (
            detailedErrorCode: Swift.String? = nil,
            detailedErrorMessage: Swift.String? = nil
        )
        {
            self.detailedErrorCode = detailedErrorCode
            self.detailedErrorMessage = detailedErrorMessage
        }
    }

}

extension GreengrassClientTypes.Function: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case functionConfiguration = "FunctionConfiguration"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionConfiguration = self.functionConfiguration {
            try encodeContainer.encode(functionConfiguration, forKey: .functionConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a Lambda function.
    public struct Function: Swift.Equatable {
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// The configuration of the Lambda function.
        public var functionConfiguration: GreengrassClientTypes.FunctionConfiguration?
        /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?

        public init (
            functionArn: Swift.String? = nil,
            functionConfiguration: GreengrassClientTypes.FunctionConfiguration? = nil,
            id: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionConfiguration = functionConfiguration
            self.id = id
        }
    }

}

extension GreengrassClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingType = "EncodingType"
        case environment = "Environment"
        case execArgs = "ExecArgs"
        case executable = "Executable"
        case functionRuntimeOverride = "FunctionRuntimeOverride"
        case memorySize = "MemorySize"
        case pinned = "Pinned"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingType = self.encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let execArgs = self.execArgs {
            try encodeContainer.encode(execArgs, forKey: .execArgs)
        }
        if let executable = self.executable {
            try encodeContainer.encode(executable, forKey: .executable)
        }
        if let functionRuntimeOverride = self.functionRuntimeOverride {
            try encodeContainer.encode(functionRuntimeOverride, forKey: .functionRuntimeOverride)
        }
        if let memorySize = self.memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let pinned = self.pinned {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionConfigurationEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let execArgsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .execArgs)
        execArgs = execArgsDecoded
        let executableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executable)
        executable = executableDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let pinnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let functionRuntimeOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionRuntimeOverride)
        functionRuntimeOverride = functionRuntimeOverrideDecoded
    }
}

extension GreengrassClientTypes {
    /// The configuration of the Lambda function.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The expected encoding type of the input payload for the function. The default is ''json''.
        public var encodingType: GreengrassClientTypes.EncodingType?
        /// The environment configuration of the function.
        public var environment: GreengrassClientTypes.FunctionConfigurationEnvironment?
        /// The execution arguments.
        public var execArgs: Swift.String?
        /// The name of the function executable.
        public var executable: Swift.String?
        /// The Lambda runtime supported by Greengrass which is to be used instead of the one specified in the Lambda function.
        public var functionRuntimeOverride: Swift.String?
        /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
        public var memorySize: Swift.Int?
        /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
        public var pinned: Swift.Bool?
        /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
        public var timeout: Swift.Int?

        public init (
            encodingType: GreengrassClientTypes.EncodingType? = nil,
            environment: GreengrassClientTypes.FunctionConfigurationEnvironment? = nil,
            execArgs: Swift.String? = nil,
            executable: Swift.String? = nil,
            functionRuntimeOverride: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            pinned: Swift.Bool? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.encodingType = encodingType
            self.environment = environment
            self.execArgs = execArgs
            self.executable = executable
            self.functionRuntimeOverride = functionRuntimeOverride
            self.memorySize = memorySize
            self.pinned = pinned
            self.timeout = timeout
        }
    }

}

extension GreengrassClientTypes.FunctionConfigurationEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessSysfs = "AccessSysfs"
        case execution = "Execution"
        case resourceAccessPolicies = "ResourceAccessPolicies"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessSysfs = self.accessSysfs {
            try encodeContainer.encode(accessSysfs, forKey: .accessSysfs)
        }
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let resourceAccessPolicies = resourceAccessPolicies {
            var resourceAccessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAccessPolicies)
            for resourceaccesspolicy0 in resourceAccessPolicies {
                try resourceAccessPoliciesContainer.encode(resourceaccesspolicy0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, __mapOf__string0) in variables {
                try variablesContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessSysfsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessSysfs)
        accessSysfs = accessSysfsDecoded
        let executionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
        let resourceAccessPoliciesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ResourceAccessPolicy?].self, forKey: .resourceAccessPolicies)
        var resourceAccessPoliciesDecoded0:[GreengrassClientTypes.ResourceAccessPolicy]? = nil
        if let resourceAccessPoliciesContainer = resourceAccessPoliciesContainer {
            resourceAccessPoliciesDecoded0 = [GreengrassClientTypes.ResourceAccessPolicy]()
            for structure0 in resourceAccessPoliciesContainer {
                if let structure0 = structure0 {
                    resourceAccessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourceAccessPolicies = resourceAccessPoliciesDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in variablesContainer {
                if let __string0 = __string0 {
                    variablesDecoded0?[key0] = __string0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension GreengrassClientTypes {
    /// The environment configuration of the function.
    public struct FunctionConfigurationEnvironment: Swift.Equatable {
        /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
        public var accessSysfs: Swift.Bool?
        /// Configuration related to executing the Lambda function
        public var execution: GreengrassClientTypes.FunctionExecutionConfig?
        /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
        public var resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]?
        /// Environment variables for the Lambda function's configuration.
        public var variables: [Swift.String:Swift.String]?

        public init (
            accessSysfs: Swift.Bool? = nil,
            execution: GreengrassClientTypes.FunctionExecutionConfig? = nil,
            resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessSysfs = accessSysfs
            self.execution = execution
            self.resourceAccessPolicies = resourceAccessPolicies
            self.variables = variables
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution = "Execution"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension GreengrassClientTypes {
    /// The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.
    public struct FunctionDefaultConfig: Swift.Equatable {
        /// Configuration information that specifies how a Lambda function runs.
        public var execution: GreengrassClientTypes.FunctionDefaultExecutionConfig?

        public init (
            execution: GreengrassClientTypes.FunctionDefaultExecutionConfig? = nil
        )
        {
            self.execution = execution
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultExecutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = self.isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = self.runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionDefaultExecutionConfig: Swift.Equatable {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init (
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes.FunctionDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = self.defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for function0 in functions {
                try functionsContainer.encode(function0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Function?].self, forKey: .functions)
        var functionsDecoded0:[GreengrassClientTypes.Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [GreengrassClientTypes.Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a function definition version.
    public struct FunctionDefinitionVersion: Swift.Equatable {
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
        /// A list of Lambda functions in this function definition version.
        public var functions: [GreengrassClientTypes.Function]?

        public init (
            defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
            functions: [GreengrassClientTypes.Function]? = nil
        )
        {
            self.defaultConfig = defaultConfig
            self.functions = functions
        }
    }

}

extension GreengrassClientTypes.FunctionExecutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = self.isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = self.runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionExecutionConfig: Swift.Equatable {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init (
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes {
    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public enum FunctionIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrasscontainer
        case nocontainer
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionIsolationMode] {
            return [
                .greengrasscontainer,
                .nocontainer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrasscontainer: return "GreengrassContainer"
            case .nocontainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionIsolationMode(rawValue: rawValue) ?? FunctionIsolationMode.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.FunctionRunAsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
    }
}

extension GreengrassClientTypes {
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public struct FunctionRunAsConfig: Swift.Equatable {
        /// The group ID whose permissions are used to run a Lambda function.
        public var gid: Swift.Int?
        /// The user ID whose permissions are used to run a Lambda function.
        public var uid: Swift.Int?

        public init (
            gid: Swift.Int? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.uid = uid
        }
    }

}

extension GetAssociatedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct GetAssociatedRoleInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetAssociatedRoleInputBody: Swift.Equatable {
}

extension GetAssociatedRoleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssociatedRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssociatedRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssociatedRoleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssociatedRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssociatedRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetAssociatedRoleOutputResponse: Swift.Equatable {
    /// The time when the role was associated with the group.
    public var associatedAt: Swift.String?
    /// The ARN of the role that is associated with the group.
    public var roleArn: Swift.String?

    public init (
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetAssociatedRoleOutputResponseBody: Swift.Equatable {
    let associatedAt: Swift.String?
    let roleArn: Swift.String?
}

extension GetAssociatedRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetBulkDeploymentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/status"
    }
}

public struct GetBulkDeploymentStatusInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init (
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct GetBulkDeploymentStatusInputBody: Swift.Equatable {
}

extension GetBulkDeploymentStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBulkDeploymentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBulkDeploymentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBulkDeploymentStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBulkDeploymentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBulkDeploymentStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeploymentMetrics = output.bulkDeploymentMetrics
            self.bulkDeploymentStatus = output.bulkDeploymentStatus
            self.createdAt = output.createdAt
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.tags = output.tags
        } else {
            self.bulkDeploymentMetrics = nil
            self.bulkDeploymentStatus = nil
            self.createdAt = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.tags = nil
        }
    }
}

public struct GetBulkDeploymentStatusOutputResponse: Swift.Equatable {
    /// Relevant metrics on input records processed during bulk deployment.
    public var bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    /// The status of the bulk deployment.
    public var bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    /// The time, in ISO format, when the deployment was created.
    public var createdAt: Swift.String?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics? = nil,
        bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus? = nil,
        createdAt: Swift.String? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.bulkDeploymentMetrics = bulkDeploymentMetrics
        self.bulkDeploymentStatus = bulkDeploymentStatus
        self.createdAt = createdAt
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.tags = tags
    }
}

struct GetBulkDeploymentStatusOutputResponseBody: Swift.Equatable {
    let bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    let bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    let createdAt: Swift.String?
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let errorMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetBulkDeploymentStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentMetrics = "BulkDeploymentMetrics"
        case bulkDeploymentStatus = "BulkDeploymentStatus"
        case createdAt = "CreatedAt"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentMetricsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.BulkDeploymentMetrics.self, forKey: .bulkDeploymentMetrics)
        bulkDeploymentMetrics = bulkDeploymentMetricsDecoded
        let bulkDeploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.BulkDeploymentStatus.self, forKey: .bulkDeploymentStatus)
        bulkDeploymentStatus = bulkDeploymentStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

public struct GetConnectivityInfoInput: Swift.Equatable {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetConnectivityInfoInputBody: Swift.Equatable {
}

extension GetConnectivityInfoInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectivityInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectivityInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectivityInfoOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectivityInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectivityInfoOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectivityInfo = output.connectivityInfo
            self.message = output.message
        } else {
            self.connectivityInfo = nil
            self.message = nil
        }
    }
}

public struct GetConnectivityInfoOutputResponse: Swift.Equatable {
    /// Connectivity info list.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// A message about the connectivity info request.
    public var message: Swift.String?

    public init (
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

struct GetConnectivityInfoOutputResponseBody: Swift.Equatable {
    let connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    let message: Swift.String?
}

extension GetConnectivityInfoOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init (
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct GetConnectorDefinitionInputBody: Swift.Equatable {
}

extension GetConnectorDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectorDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectorDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectorDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectorDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectorDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetConnectorDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetConnectorDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetConnectorDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetConnectorDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetConnectorDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        guard let connectorDefinitionVersionId = connectorDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions/\(connectorDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionVersionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var connectorDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        connectorDefinitionId: Swift.String? = nil,
        connectorDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.connectorDefinitionVersionId = connectorDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetConnectorDefinitionVersionInputBody: Swift.Equatable {
}

extension GetConnectorDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectorDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectorDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConnectorDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectorDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConnectorDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetConnectorDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the connector definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the connector definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the connector definition version.
    public var definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The ID of the connector definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the connector definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetConnectorDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetConnectorDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConnectorDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init (
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct GetCoreDefinitionInputBody: Swift.Equatable {
}

extension GetCoreDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetCoreDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetCoreDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetCoreDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        guard let coreDefinitionVersionId = coreDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions/\(coreDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionVersionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var coreDefinitionVersionId: Swift.String?

    public init (
        coreDefinitionId: Swift.String? = nil,
        coreDefinitionVersionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.coreDefinitionVersionId = coreDefinitionVersionId
    }
}

struct GetCoreDefinitionVersionInputBody: Swift.Equatable {
}

extension GetCoreDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCoreDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCoreDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetCoreDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the core definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the core definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the core definition version.
    public var definition: GreengrassClientTypes.CoreDefinitionVersion?
    /// The ID of the core definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the core definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetCoreDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.CoreDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetCoreDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.CoreDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetDeploymentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())/status"
    }
}

public struct GetDeploymentStatusInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.groupId = groupId
    }
}

struct GetDeploymentStatusInputBody: Swift.Equatable {
}

extension GetDeploymentStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeploymentStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeploymentStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentStatus = output.deploymentStatus
            self.deploymentType = output.deploymentType
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.updatedAt = output.updatedAt
        } else {
            self.deploymentStatus = nil
            self.deploymentType = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDeploymentStatusOutputResponse: Swift.Equatable {
    /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public var deploymentStatus: Swift.String?
    /// The type of the deployment.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment status was updated.
    public var updatedAt: Swift.String?

    public init (
        deploymentStatus: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.updatedAt = updatedAt
    }
}

struct GetDeploymentStatusOutputResponseBody: Swift.Equatable {
    let deploymentStatus: Swift.String?
    let deploymentType: GreengrassClientTypes.DeploymentType?
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let errorMessage: Swift.String?
    let updatedAt: Swift.String?
}

extension GetDeploymentStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init (
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct GetDeviceDefinitionInputBody: Swift.Equatable {
}

extension GetDeviceDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetDeviceDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetDeviceDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetDeviceDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDeviceDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetDeviceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        guard let deviceDefinitionVersionId = deviceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions/\(deviceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionVersionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var deviceDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deviceDefinitionId: Swift.String? = nil,
        deviceDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.deviceDefinitionVersionId = deviceDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetDeviceDefinitionVersionInputBody: Swift.Equatable {
}

extension GetDeviceDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDeviceDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDeviceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetDeviceDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the device definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the device definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the device definition version.
    public var definition: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The ID of the device definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the device definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetDeviceDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.DeviceDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetDeviceDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeviceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init (
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct GetFunctionDefinitionInputBody: Swift.Equatable {
}

extension GetFunctionDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFunctionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFunctionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetFunctionDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetFunctionDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFunctionDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        guard let functionDefinitionVersionId = functionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions/\(functionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionVersionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var functionDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        functionDefinitionId: Swift.String? = nil,
        functionDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.functionDefinitionVersionId = functionDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetFunctionDefinitionVersionInputBody: Swift.Equatable {
}

extension GetFunctionDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFunctionDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFunctionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetFunctionDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the function definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the function definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information on the definition.
    public var definition: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The ID of the function definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the function definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetFunctionDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.FunctionDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetFunctionDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetGroupCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let certificateAuthorityId = certificateAuthorityId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/\(certificateAuthorityId.urlPercentEncoding())"
    }
}

public struct GetGroupCertificateAuthorityInput: Swift.Equatable {
    /// The ID of the certificate authority.
    /// This member is required.
    public var certificateAuthorityId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        certificateAuthorityId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityId = certificateAuthorityId
        self.groupId = groupId
    }
}

struct GetGroupCertificateAuthorityInputBody: Swift.Equatable {
}

extension GetGroupCertificateAuthorityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = output.groupCertificateAuthorityId
            self.pemEncodedCertificate = output.pemEncodedCertificate
        } else {
            self.groupCertificateAuthorityArn = nil
            self.groupCertificateAuthorityId = nil
            self.pemEncodedCertificate = nil
        }
    }
}

public struct GetGroupCertificateAuthorityOutputResponse: Swift.Equatable {
    /// The ARN of the certificate authority for the group.
    public var groupCertificateAuthorityArn: Swift.String?
    /// The ID of the certificate authority for the group.
    public var groupCertificateAuthorityId: Swift.String?
    /// The PEM encoded certificate for the group.
    public var pemEncodedCertificate: Swift.String?

    public init (
        groupCertificateAuthorityArn: Swift.String? = nil,
        groupCertificateAuthorityId: Swift.String? = nil,
        pemEncodedCertificate: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
        self.pemEncodedCertificate = pemEncodedCertificate
    }
}

struct GetGroupCertificateAuthorityOutputResponseBody: Swift.Equatable {
    let groupCertificateAuthorityArn: Swift.String?
    let groupCertificateAuthorityId: Swift.String?
    let pemEncodedCertificate: Swift.String?
}

extension GetGroupCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
        case pemEncodedCertificate = "PemEncodedCertificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
    }
}

extension GetGroupCertificateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

public struct GetGroupCertificateConfigurationInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationInputBody: Swift.Equatable {
}

extension GetGroupCertificateConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupCertificateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupCertificateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupCertificateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupCertificateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupCertificateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct GetGroupCertificateConfigurationOutputResponse: Swift.Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init (
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationOutputResponseBody: Swift.Equatable {
    let certificateAuthorityExpiryInMilliseconds: Swift.String?
    let certificateExpiryInMilliseconds: Swift.String?
    let groupId: Swift.String?
}

extension GetGroupCertificateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupInputBody: Swift.Equatable {
}

extension GetGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetGroupOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetGroupVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let groupVersionId = groupVersionId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions/\(groupVersionId.urlPercentEncoding())"
    }
}

public struct GetGroupVersionInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    /// This member is required.
    public var groupVersionId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct GetGroupVersionInputBody: Swift.Equatable {
}

extension GetGroupVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGroupVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGroupVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetGroupVersionOutputResponse: Swift.Equatable {
    /// The ARN of the group version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the group version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the group version definition.
    public var definition: GreengrassClientTypes.GroupVersion?
    /// The ID of the group that the version is associated with.
    public var id: Swift.String?
    /// The ID of the group version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.GroupVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetGroupVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.GroupVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetGroupVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init (
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct GetLoggerDefinitionInputBody: Swift.Equatable {
}

extension GetLoggerDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLoggerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLoggerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetLoggerDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetLoggerDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetLoggerDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetLoggerDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetLoggerDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        guard let loggerDefinitionVersionId = loggerDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions/\(loggerDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionVersionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var loggerDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        loggerDefinitionId: Swift.String? = nil,
        loggerDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.loggerDefinitionVersionId = loggerDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetLoggerDefinitionVersionInputBody: Swift.Equatable {
}

extension GetLoggerDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggerDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggerDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLoggerDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggerDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLoggerDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetLoggerDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the logger definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the logger definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the logger definition version.
    public var definition: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The ID of the logger definition version.
    public var id: Swift.String?
    /// The version of the logger definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetLoggerDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.LoggerDefinitionVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetLoggerDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init (
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct GetResourceDefinitionInputBody: Swift.Equatable {
}

extension GetResourceDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetResourceDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetResourceDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetResourceDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetResourceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        guard let resourceDefinitionVersionId = resourceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions/\(resourceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionVersionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var resourceDefinitionVersionId: Swift.String?

    public init (
        resourceDefinitionId: Swift.String? = nil,
        resourceDefinitionVersionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
        self.resourceDefinitionVersionId = resourceDefinitionVersionId
    }
}

struct GetResourceDefinitionVersionInputBody: Swift.Equatable {
}

extension GetResourceDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetResourceDefinitionVersionOutputResponse: Swift.Equatable {
    /// Arn of the resource definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the resource definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the definition.
    public var definition: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The ID of the resource definition version.
    public var id: Swift.String?
    /// The version of the resource definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetResourceDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.ResourceDefinitionVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetResourceDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetServiceRoleForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct GetServiceRoleForAccountInput: Swift.Equatable {

    public init () { }
}

struct GetServiceRoleForAccountInputBody: Swift.Equatable {
}

extension GetServiceRoleForAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceRoleForAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceRoleForAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceRoleForAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceRoleForAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServiceRoleForAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetServiceRoleForAccountOutputResponse: Swift.Equatable {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?
    /// The ARN of the role which is associated with the account.
    public var roleArn: Swift.String?

    public init (
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetServiceRoleForAccountOutputResponseBody: Swift.Equatable {
    let associatedAt: Swift.String?
    let roleArn: Swift.String?
}

extension GetServiceRoleForAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionInput: Swift.Equatable {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init (
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct GetSubscriptionDefinitionInputBody: Swift.Equatable {
}

extension GetSubscriptionDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSubscriptionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSubscriptionDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetSubscriptionDefinitionOutputResponse: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetSubscriptionDefinitionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSubscriptionDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSubscriptionDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetSubscriptionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        guard let subscriptionDefinitionVersionId = subscriptionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions/\(subscriptionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionVersionInput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var subscriptionDefinitionVersionId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptionDefinitionVersionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
    }
}

struct GetSubscriptionDefinitionVersionInputBody: Swift.Equatable {
}

extension GetSubscriptionDefinitionVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionDefinitionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionDefinitionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSubscriptionDefinitionVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionDefinitionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSubscriptionDefinitionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetSubscriptionDefinitionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the subscription definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the subscription definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the subscription definition version.
    public var definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The ID of the subscription definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the subscription definition version.
    public var version: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetSubscriptionDefinitionVersionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetSubscriptionDefinitionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SubscriptionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetThingRuntimeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

public struct GetThingRuntimeConfigurationInput: Swift.Equatable {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetThingRuntimeConfigurationInputBody: Swift.Equatable {
}

extension GetThingRuntimeConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThingRuntimeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThingRuntimeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetThingRuntimeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThingRuntimeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetThingRuntimeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.runtimeConfiguration = output.runtimeConfiguration
        } else {
            self.runtimeConfiguration = nil
        }
    }
}

public struct GetThingRuntimeConfigurationOutputResponse: Swift.Equatable {
    /// Runtime configuration for a thing.
    public var runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?

    public init (
        runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration? = nil
    )
    {
        self.runtimeConfiguration = runtimeConfiguration
    }
}

struct GetThingRuntimeConfigurationOutputResponseBody: Swift.Equatable {
    let runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?
}

extension GetThingRuntimeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeConfiguration = "RuntimeConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.RuntimeConfiguration.self, forKey: .runtimeConfiguration)
        runtimeConfiguration = runtimeConfigurationDecoded
    }
}

extension GreengrassClientTypes.GroupCertificateAuthorityProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupCertificateAuthorityArn = self.groupCertificateAuthorityArn {
            try encodeContainer.encode(groupCertificateAuthorityArn, forKey: .groupCertificateAuthorityArn)
        }
        if let groupCertificateAuthorityId = self.groupCertificateAuthorityId {
            try encodeContainer.encode(groupCertificateAuthorityId, forKey: .groupCertificateAuthorityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a certificate authority for a group.
    public struct GroupCertificateAuthorityProperties: Swift.Equatable {
        /// The ARN of the certificate authority for the group.
        public var groupCertificateAuthorityArn: Swift.String?
        /// The ID of the certificate authority for the group.
        public var groupCertificateAuthorityId: Swift.String?

        public init (
            groupCertificateAuthorityArn: Swift.String? = nil,
            groupCertificateAuthorityId: Swift.String? = nil
        )
        {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
        }
    }

}

extension GreengrassClientTypes.GroupInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = self.latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = self.latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a group.
    public struct GroupInformation: Swift.Equatable {
        /// The ARN of the group.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the group.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the group.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the group.
        public var latestVersionArn: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }
    }

}

extension GreengrassClientTypes.GroupOwnerSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAddGroupOwner = "AutoAddGroupOwner"
        case groupOwner = "GroupOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAddGroupOwner = self.autoAddGroupOwner {
            try encodeContainer.encode(autoAddGroupOwner, forKey: .autoAddGroupOwner)
        }
        if let groupOwner = self.groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAddGroupOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAddGroupOwner)
        autoAddGroupOwner = autoAddGroupOwnerDecoded
        let groupOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
    }
}

extension GreengrassClientTypes {
    /// Group owner related settings for local resources.
    public struct GroupOwnerSetting: Swift.Equatable {
        /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
        public var autoAddGroupOwner: Swift.Bool?
        /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
        public var groupOwner: Swift.String?

        public init (
            autoAddGroupOwner: Swift.Bool? = nil,
            groupOwner: Swift.String? = nil
        )
        {
            self.autoAddGroupOwner = autoAddGroupOwner
            self.groupOwner = groupOwner
        }
    }

}

extension GreengrassClientTypes.GroupVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = self.connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = self.coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = self.deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = self.functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = self.loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = self.resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = self.subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a group version.
    public struct GroupVersion: Swift.Equatable {
        /// The ARN of the connector definition version for this group.
        public var connectorDefinitionVersionArn: Swift.String?
        /// The ARN of the core definition version for this group.
        public var coreDefinitionVersionArn: Swift.String?
        /// The ARN of the device definition version for this group.
        public var deviceDefinitionVersionArn: Swift.String?
        /// The ARN of the function definition version for this group.
        public var functionDefinitionVersionArn: Swift.String?
        /// The ARN of the logger definition version for this group.
        public var loggerDefinitionVersionArn: Swift.String?
        /// The ARN of the resource definition version for this group.
        public var resourceDefinitionVersionArn: Swift.String?
        /// The ARN of the subscription definition version for this group.
        public var subscriptionDefinitionVersionArn: Swift.String?

        public init (
            connectorDefinitionVersionArn: Swift.String? = nil,
            coreDefinitionVersionArn: Swift.String? = nil,
            deviceDefinitionVersionArn: Swift.String? = nil,
            functionDefinitionVersionArn: Swift.String? = nil,
            loggerDefinitionVersionArn: Swift.String? = nil,
            resourceDefinitionVersionArn: Swift.String? = nil,
            subscriptionDefinitionVersionArn: Swift.String? = nil
        )
        {
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorDetails = output.errorDetails
            self.message = output.message
        } else {
            self.errorDetails = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// General error information.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Details about the error.
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// A message containing information about the error.
    public var message: Swift.String?

    public init (
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorDetails = errorDetails
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBulkDeploymentDetailedReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkDeploymentDetailedReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/detailed-reports"
    }
}

public struct ListBulkDeploymentDetailedReportsInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        bulkDeploymentId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsInputBody: Swift.Equatable {
}

extension ListBulkDeploymentDetailedReportsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkDeploymentDetailedReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBulkDeploymentDetailedReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBulkDeploymentDetailedReportsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBulkDeploymentDetailedReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBulkDeploymentDetailedReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentDetailedReportsOutputResponse: Swift.Equatable {
    /// A list of the individual group deployments in the bulk deployment operation.
    public var deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deployments: [GreengrassClientTypes.BulkDeploymentResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsOutputResponseBody: Swift.Equatable {
    let deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    let nextToken: Swift.String?
}

extension ListBulkDeploymentDetailedReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.BulkDeploymentResult?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassClientTypes.BulkDeploymentResult]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassClientTypes.BulkDeploymentResult]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBulkDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

public struct ListBulkDeploymentsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsInputBody: Swift.Equatable {
}

extension ListBulkDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBulkDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBulkDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBulkDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBulkDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeployments = output.bulkDeployments
            self.nextToken = output.nextToken
        } else {
            self.bulkDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentsOutputResponse: Swift.Equatable {
    /// A list of bulk deployments.
    public var bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        bulkDeployments: [GreengrassClientTypes.BulkDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeployments = bulkDeployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsOutputResponseBody: Swift.Equatable {
    let bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    let nextToken: Swift.String?
}

extension ListBulkDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeployments = "BulkDeployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.BulkDeployment?].self, forKey: .bulkDeployments)
        var bulkDeploymentsDecoded0:[GreengrassClientTypes.BulkDeployment]? = nil
        if let bulkDeploymentsContainer = bulkDeploymentsContainer {
            bulkDeploymentsDecoded0 = [GreengrassClientTypes.BulkDeployment]()
            for structure0 in bulkDeploymentsContainer {
                if let structure0 = structure0 {
                    bulkDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        bulkDeployments = bulkDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConnectorDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListConnectorDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        connectorDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListConnectorDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectorDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectorDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectorDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListConnectorDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListConnectorDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListConnectorDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListConnectorDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConnectorDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

public struct ListConnectorDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsInputBody: Swift.Equatable {
}

extension ListConnectorDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectorDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectorDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectorDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectorDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectorDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListConnectorDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListCoreDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        coreDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListCoreDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCoreDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCoreDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListCoreDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListCoreDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListCoreDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListCoreDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/cores"
    }
}

public struct ListCoreDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsInputBody: Swift.Equatable {
}

extension ListCoreDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCoreDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCoreDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListCoreDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Swift.Equatable {
    /// A list of deployments for the requested groups.
    public var deployments: [GreengrassClientTypes.Deployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deployments: [GreengrassClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Swift.Equatable {
    let deployments: [GreengrassClientTypes.Deployment]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListDeviceDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deviceDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListDeviceDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListDeviceDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListDeviceDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListDeviceDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListDeviceDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/devices"
    }
}

public struct ListDeviceDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsInputBody: Swift.Equatable {
}

extension ListDeviceDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListDeviceDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFunctionDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListFunctionDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        functionDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListFunctionDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFunctionDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFunctionDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListFunctionDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListFunctionDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListFunctionDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListFunctionDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/functions"
    }
}

public struct ListFunctionDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsInputBody: Swift.Equatable {
}

extension ListFunctionDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFunctionDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFunctionDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListFunctionDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupCertificateAuthoritiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct ListGroupCertificateAuthoritiesInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct ListGroupCertificateAuthoritiesInputBody: Swift.Equatable {
}

extension ListGroupCertificateAuthoritiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupCertificateAuthoritiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupCertificateAuthoritiesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupCertificateAuthoritiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorities = output.groupCertificateAuthorities
        } else {
            self.groupCertificateAuthorities = nil
        }
    }
}

public struct ListGroupCertificateAuthoritiesOutputResponse: Swift.Equatable {
    /// A list of certificate authorities associated with the group.
    public var groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?

    public init (
        groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
    )
    {
        self.groupCertificateAuthorities = groupCertificateAuthorities
    }
}

struct ListGroupCertificateAuthoritiesOutputResponseBody: Swift.Equatable {
    let groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?
}

extension ListGroupCertificateAuthoritiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorities = "GroupCertificateAuthorities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.GroupCertificateAuthorityProperties?].self, forKey: .groupCertificateAuthorities)
        var groupCertificateAuthoritiesDecoded0:[GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
        if let groupCertificateAuthoritiesContainer = groupCertificateAuthoritiesContainer {
            groupCertificateAuthoritiesDecoded0 = [GreengrassClientTypes.GroupCertificateAuthorityProperties]()
            for structure0 in groupCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    groupCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        groupCertificateAuthorities = groupCertificateAuthoritiesDecoded0
    }
}

extension ListGroupVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

public struct ListGroupVersionsInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupVersionsInputBody: Swift.Equatable {
}

extension ListGroupVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListGroupVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListGroupVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListGroupVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/groups"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
}

extension ListGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// Information about a group.
    public var groups: [GreengrassClientTypes.GroupInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        groups: [GreengrassClientTypes.GroupInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groups: [GreengrassClientTypes.GroupInformation]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.GroupInformation?].self, forKey: .groups)
        var groupsDecoded0:[GreengrassClientTypes.GroupInformation]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GreengrassClientTypes.GroupInformation]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLoggerDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLoggerDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListLoggerDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        loggerDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListLoggerDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLoggerDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggerDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLoggerDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggerDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLoggerDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListLoggerDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListLoggerDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListLoggerDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListLoggerDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLoggerDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

public struct ListLoggerDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsInputBody: Swift.Equatable {
}

extension ListLoggerDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLoggerDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggerDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLoggerDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggerDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLoggerDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLoggerDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListLoggerDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListResourceDefinitionVersionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct ListResourceDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListResourceDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListResourceDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListResourceDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListResourceDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListResourceDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/resources"
    }
}

public struct ListResourceDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsInputBody: Swift.Equatable {
}

extension ListResourceDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListResourceDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscriptionDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListSubscriptionDefinitionVersionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct ListSubscriptionDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListSubscriptionDefinitionVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionDefinitionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscriptionDefinitionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSubscriptionDefinitionVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionDefinitionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSubscriptionDefinitionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSubscriptionDefinitionVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSubscriptionDefinitionVersionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListSubscriptionDefinitionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension ListSubscriptionDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

public struct ListSubscriptionDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsInputBody: Swift.Equatable {
}

extension ListSubscriptionDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscriptionDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSubscriptionDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscriptionDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSubscriptionDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionDefinitionsOutputResponse: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsOutputResponseBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListSubscriptionDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassClientTypes.LocalDeviceResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwnerSetting = self.groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local device resource.
    public struct LocalDeviceResourceData: Swift.Equatable {
        /// Group/owner related settings for local resources.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
        public var sourcePath: Swift.String?

        public init (
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.LocalVolumeResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let groupOwnerSetting = self.groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local volume resource.
    public struct LocalVolumeResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
        public var sourcePath: Swift.String?

        public init (
            destinationPath: Swift.String? = nil,
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.Logger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
        case id = "Id"
        case level = "Level"
        case space = "Space"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = self.component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let space = self.space {
            try encodeContainer.encode(space, forKey: .space)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerComponent.self, forKey: .component)
        component = componentDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let levelDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerLevel.self, forKey: .level)
        level = levelDecoded
        let spaceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .space)
        space = spaceDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a logger
    public struct Logger: Swift.Equatable {
        /// The component that will be subject to logging.
        /// This member is required.
        public var component: GreengrassClientTypes.LoggerComponent?
        /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The level of the logs.
        /// This member is required.
        public var level: GreengrassClientTypes.LoggerLevel?
        /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
        public var space: Swift.Int?
        /// The type of log output which will be used.
        /// This member is required.
        public var type: GreengrassClientTypes.LoggerType?

        public init (
            component: GreengrassClientTypes.LoggerComponent? = nil,
            id: Swift.String? = nil,
            level: GreengrassClientTypes.LoggerLevel? = nil,
            space: Swift.Int? = nil,
            type: GreengrassClientTypes.LoggerType? = nil
        )
        {
            self.component = component
            self.id = id
            self.level = level
            self.space = space
            self.type = type
        }
    }

}

extension GreengrassClientTypes {
    public enum LoggerComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrasssystem
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerComponent] {
            return [
                .greengrasssystem,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrasssystem: return "GreengrassSystem"
            case .lambda: return "Lambda"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerComponent(rawValue: rawValue) ?? LoggerComponent.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.LoggerDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for logger0 in loggers {
                try loggersContainer.encode(logger0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Logger?].self, forKey: .loggers)
        var loggersDecoded0:[GreengrassClientTypes.Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [GreengrassClientTypes.Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a logger definition version.
    public struct LoggerDefinitionVersion: Swift.Equatable {
        /// A list of loggers.
        public var loggers: [GreengrassClientTypes.Logger]?

        public init (
            loggers: [GreengrassClientTypes.Logger]? = nil
        )
        {
            self.loggers = loggers
        }
    }

}

extension GreengrassClientTypes {
    public enum LoggerLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerLevel(rawValue: rawValue) ?? LoggerLevel.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    public enum LoggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awscloudwatch
        case filesystem
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerType] {
            return [
                .awscloudwatch,
                .filesystem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awscloudwatch: return "AWSCloudWatch"
            case .filesystem: return "FileSystem"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerType(rawValue: rawValue) ?? LoggerType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    /// The type of permission a function has to access a resource.
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .ro,
                .rw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension ResetDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
    }
}

extension ResetDeploymentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension ResetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/$reset"
    }
}

/// Information needed to reset deployments.
public struct ResetDeploymentsInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// If true, performs a best-effort only core reset.
    public var force: Swift.Bool?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        amznClientToken: Swift.String? = nil,
        force: Swift.Bool? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.force = force
        self.groupId = groupId
    }
}

struct ResetDeploymentsInputBody: Swift.Equatable {
    let force: Swift.Bool?
}

extension ResetDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension ResetDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct ResetDeploymentsOutputResponse: Swift.Equatable {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init (
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct ResetDeploymentsOutputResponseBody: Swift.Equatable {
    let deploymentArn: Swift.String?
    let deploymentId: Swift.String?
}

extension ResetDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension GreengrassClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case resourceDataContainer = "ResourceDataContainer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceDataContainer = self.resourceDataContainer {
            try encodeContainer.encode(resourceDataContainer, forKey: .resourceDataContainer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceDataContainerDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDataContainer.self, forKey: .resourceDataContainer)
        resourceDataContainer = resourceDataContainerDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a resource.
    public struct Resource: Swift.Equatable {
        /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var id: Swift.String?
        /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var name: Swift.String?
        /// A container of data for all resource types.
        /// This member is required.
        public var resourceDataContainer: GreengrassClientTypes.ResourceDataContainer?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceDataContainer: GreengrassClientTypes.ResourceDataContainer? = nil
        )
        {
            self.id = id
            self.name = name
            self.resourceDataContainer = resourceDataContainer
        }
    }

}

extension GreengrassClientTypes.ResourceAccessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission = "Permission"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GreengrassClientTypes {
    /// A policy used by the function to access a resource.
    public struct ResourceAccessPolicy: Swift.Equatable {
        /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
        public var permission: GreengrassClientTypes.Permission?
        /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
        /// This member is required.
        public var resourceId: Swift.String?

        public init (
            permission: GreengrassClientTypes.Permission? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.permission = permission
            self.resourceId = resourceId
        }
    }

}

extension GreengrassClientTypes.ResourceDataContainer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localDeviceResourceData = "LocalDeviceResourceData"
        case localVolumeResourceData = "LocalVolumeResourceData"
        case s3MachineLearningModelResourceData = "S3MachineLearningModelResourceData"
        case sageMakerMachineLearningModelResourceData = "SageMakerMachineLearningModelResourceData"
        case secretsManagerSecretResourceData = "SecretsManagerSecretResourceData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localDeviceResourceData = self.localDeviceResourceData {
            try encodeContainer.encode(localDeviceResourceData, forKey: .localDeviceResourceData)
        }
        if let localVolumeResourceData = self.localVolumeResourceData {
            try encodeContainer.encode(localVolumeResourceData, forKey: .localVolumeResourceData)
        }
        if let s3MachineLearningModelResourceData = self.s3MachineLearningModelResourceData {
            try encodeContainer.encode(s3MachineLearningModelResourceData, forKey: .s3MachineLearningModelResourceData)
        }
        if let sageMakerMachineLearningModelResourceData = self.sageMakerMachineLearningModelResourceData {
            try encodeContainer.encode(sageMakerMachineLearningModelResourceData, forKey: .sageMakerMachineLearningModelResourceData)
        }
        if let secretsManagerSecretResourceData = self.secretsManagerSecretResourceData {
            try encodeContainer.encode(secretsManagerSecretResourceData, forKey: .secretsManagerSecretResourceData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDeviceResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LocalDeviceResourceData.self, forKey: .localDeviceResourceData)
        localDeviceResourceData = localDeviceResourceDataDecoded
        let localVolumeResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LocalVolumeResourceData.self, forKey: .localVolumeResourceData)
        localVolumeResourceData = localVolumeResourceDataDecoded
        let s3MachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.S3MachineLearningModelResourceData.self, forKey: .s3MachineLearningModelResourceData)
        s3MachineLearningModelResourceData = s3MachineLearningModelResourceDataDecoded
        let sageMakerMachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SageMakerMachineLearningModelResourceData.self, forKey: .sageMakerMachineLearningModelResourceData)
        sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceDataDecoded
        let secretsManagerSecretResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SecretsManagerSecretResourceData.self, forKey: .secretsManagerSecretResourceData)
        secretsManagerSecretResourceData = secretsManagerSecretResourceDataDecoded
    }
}

extension GreengrassClientTypes {
    /// A container for resource data. The container takes only one of the following supported resource data types: ''LocalDeviceResourceData'', ''LocalVolumeResourceData'', ''SageMakerMachineLearningModelResourceData'', ''S3MachineLearningModelResourceData'', ''SecretsManagerSecretResourceData''.
    public struct ResourceDataContainer: Swift.Equatable {
        /// Attributes that define the local device resource.
        public var localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData?
        /// Attributes that define the local volume resource.
        public var localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData?
        /// Attributes that define an Amazon S3 machine learning resource.
        public var s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData?
        /// Attributes that define an Amazon SageMaker machine learning resource.
        public var sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?
        /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
        public var secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData?

        public init (
            localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData? = nil,
            localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData? = nil,
            s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData? = nil,
            sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData? = nil,
            secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData? = nil
        )
        {
            self.localDeviceResourceData = localDeviceResourceData
            self.localVolumeResourceData = localVolumeResourceData
            self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
            self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
            self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
        }
    }

}

extension GreengrassClientTypes.ResourceDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[GreengrassClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [GreengrassClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a resource definition version.
    public struct ResourceDefinitionVersion: Swift.Equatable {
        /// A list of resources.
        public var resources: [GreengrassClientTypes.Resource]?

        public init (
            resources: [GreengrassClientTypes.Resource]? = nil
        )
        {
            self.resources = resources
        }
    }

}

extension GreengrassClientTypes.ResourceDownloadOwnerSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupOwner = "GroupOwner"
        case groupPermission = "GroupPermission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwner = self.groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
        if let groupPermission = self.groupPermission {
            try encodeContainer.encode(groupPermission.rawValue, forKey: .groupPermission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
        let groupPermissionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Permission.self, forKey: .groupPermission)
        groupPermission = groupPermissionDecoded
    }
}

extension GreengrassClientTypes {
    /// The owner setting for downloaded machine learning resources.
    public struct ResourceDownloadOwnerSetting: Swift.Equatable {
        /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
        /// This member is required.
        public var groupOwner: Swift.String?
        /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
        /// This member is required.
        public var groupPermission: GreengrassClientTypes.Permission?

        public init (
            groupOwner: Swift.String? = nil,
            groupPermission: GreengrassClientTypes.Permission? = nil
        )
        {
            self.groupOwner = groupOwner
            self.groupPermission = groupPermission
        }
    }

}

extension GreengrassClientTypes.RuntimeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = self.telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.TelemetryConfiguration.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension GreengrassClientTypes {
    /// Runtime configuration for a thing.
    public struct RuntimeConfiguration: Swift.Equatable {
        /// Configuration for telemetry service.
        public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration?

        public init (
            telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration? = nil
        )
        {
            self.telemetryConfiguration = telemetryConfiguration
        }
    }

}

extension GreengrassClientTypes.S3MachineLearningModelResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = self.ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon S3 machine learning resource.
    public struct S3MachineLearningModelResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
        public var s3Uri: Swift.String?

        public init (
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.s3Uri = s3Uri
        }
    }

}

extension GreengrassClientTypes.SageMakerMachineLearningModelResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case sageMakerJobArn = "SageMakerJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = self.ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let sageMakerJobArn = self.sageMakerJobArn {
            try encodeContainer.encode(sageMakerJobArn, forKey: .sageMakerJobArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let sageMakerJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sageMakerJobArn)
        sageMakerJobArn = sageMakerJobArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon SageMaker machine learning resource.
    public struct SageMakerMachineLearningModelResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The ARN of the Amazon SageMaker training job that represents the source model.
        public var sageMakerJobArn: Swift.String?

        public init (
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            sageMakerJobArn: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.sageMakerJobArn = sageMakerJobArn
        }
    }

}

extension GreengrassClientTypes.SecretsManagerSecretResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case additionalStagingLabelsToDownload = "AdditionalStagingLabelsToDownload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let additionalStagingLabelsToDownload = additionalStagingLabelsToDownload {
            var additionalStagingLabelsToDownloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalStagingLabelsToDownload)
            for __string0 in additionalStagingLabelsToDownload {
                try additionalStagingLabelsToDownloadContainer.encode(__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let additionalStagingLabelsToDownloadContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalStagingLabelsToDownload)
        var additionalStagingLabelsToDownloadDecoded0:[Swift.String]? = nil
        if let additionalStagingLabelsToDownloadContainer = additionalStagingLabelsToDownloadContainer {
            additionalStagingLabelsToDownloadDecoded0 = [Swift.String]()
            for string0 in additionalStagingLabelsToDownloadContainer {
                if let string0 = string0 {
                    additionalStagingLabelsToDownloadDecoded0?.append(string0)
                }
            }
        }
        additionalStagingLabelsToDownload = additionalStagingLabelsToDownloadDecoded0
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager. AWS IoT Greengrass stores a local, encrypted copy of the secret on the Greengrass core, where it can be securely accessed by connectors and Lambda functions.
    public struct SecretsManagerSecretResourceData: Swift.Equatable {
        /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
        public var additionalStagingLabelsToDownload: [Swift.String]?
        /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
        public var arn: Swift.String?

        public init (
            additionalStagingLabelsToDownload: [Swift.String]? = nil,
            arn: Swift.String? = nil
        )
        {
            self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
            self.arn = arn
        }
    }

}

extension GreengrassClientTypes {
    /// The piece of software on the Greengrass core that will be updated.
    public enum SoftwareToUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case core
        case otaAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareToUpdate] {
            return [
                .core,
                .otaAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .core: return "core"
            case .otaAgent: return "ota_agent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareToUpdate(rawValue: rawValue) ?? SoftwareToUpdate.sdkUnknown(rawValue)
        }
    }
}

extension StartBulkDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputFileUri = self.inputFileUri {
            try encodeContainer.encode(inputFileUri, forKey: .inputFileUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartBulkDeploymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension StartBulkDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

public struct StartBulkDeploymentInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    /// This member is required.
    public var inputFileUri: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        amznClientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputFileUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.executionRoleArn = executionRoleArn
        self.inputFileUri = inputFileUri
        self.tags = tags
    }
}

struct StartBulkDeploymentInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let inputFileUri: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartBulkDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let inputFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileUri)
        inputFileUri = inputFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBulkDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartBulkDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBulkDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartBulkDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeploymentArn = output.bulkDeploymentArn
            self.bulkDeploymentId = output.bulkDeploymentId
        } else {
            self.bulkDeploymentArn = nil
            self.bulkDeploymentId = nil
        }
    }
}

public struct StartBulkDeploymentOutputResponse: Swift.Equatable {
    /// The ARN of the bulk deployment.
    public var bulkDeploymentArn: Swift.String?
    /// The ID of the bulk deployment.
    public var bulkDeploymentId: Swift.String?

    public init (
        bulkDeploymentArn: Swift.String? = nil,
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StartBulkDeploymentOutputResponseBody: Swift.Equatable {
    let bulkDeploymentArn: Swift.String?
    let bulkDeploymentId: Swift.String?
}

extension StartBulkDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
    }
}

extension StopBulkDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/$stop"
    }
}

public struct StopBulkDeploymentInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init (
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StopBulkDeploymentInputBody: Swift.Equatable {
}

extension StopBulkDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopBulkDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBulkDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopBulkDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBulkDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopBulkDeploymentOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case source = "Source"
        case subject = "Subject"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription.
    public struct Subscription: Swift.Equatable {
        /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var source: Swift.String?
        /// The MQTT topic used to route the message.
        /// This member is required.
        public var subject: Swift.String?
        /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var target: Swift.String?

        public init (
            id: Swift.String? = nil,
            source: Swift.String? = nil,
            subject: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.id = id
            self.source = source
            self.subject = subject
            self.target = target
        }
    }

}

extension GreengrassClientTypes.SubscriptionDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[GreengrassClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [GreengrassClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription definition version.
    public struct SubscriptionDefinitionVersion: Swift.Equatable {
        /// A list of subscriptions.
        public var subscriptions: [GreengrassClientTypes.Subscription]?

        public init (
            subscriptions: [GreengrassClientTypes.Subscription]? = nil
        )
        {
            self.subscriptions = subscriptions
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// A map of the key-value pairs for the resource tag.
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes {
    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Telemetry(rawValue: rawValue) ?? Telemetry.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.TelemetryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSyncStatus = "ConfigurationSyncStatus"
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSyncStatus = self.configurationSyncStatus {
            try encodeContainer.encode(configurationSyncStatus.rawValue, forKey: .configurationSyncStatus)
        }
        if let telemetry = self.telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSyncStatusDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConfigurationSyncStatus.self, forKey: .configurationSyncStatus)
        configurationSyncStatus = configurationSyncStatusDecoded
        let telemetryDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfiguration: Swift.Equatable {
        /// Synchronization status of the device reported configuration with the desired configuration.
        public var configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus?
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init (
            configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus? = nil,
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.configurationSyncStatus = configurationSyncStatus
            self.telemetry = telemetry
        }
    }

}

extension GreengrassClientTypes.TelemetryConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetry = self.telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfigurationUpdate: Swift.Equatable {
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init (
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.telemetry = telemetry
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes {
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public enum UpdateAgentLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case `none`
        case trace
        case verbose
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAgentLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .none,
                .trace,
                .verbose,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .none: return "NONE"
            case .trace: return "TRACE"
            case .verbose: return "VERBOSE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateAgentLogLevel(rawValue: rawValue) ?? UpdateAgentLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension UpdateConnectivityInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = connectivityInfo {
            var connectivityInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectivityInfo)
            for connectivityinfo0 in connectivityInfo {
                try connectivityInfoContainer.encode(connectivityinfo0)
            }
        }
    }
}

extension UpdateConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

/// Connectivity information.
public struct UpdateConnectivityInfoInput: Swift.Equatable {
    /// A list of connectivity info.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

struct UpdateConnectivityInfoInputBody: Swift.Equatable {
    let connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
}

extension UpdateConnectivityInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
    }
}

extension UpdateConnectivityInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectivityInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectivityInfoOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectivityInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConnectivityInfoOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.version = output.version
        } else {
            self.message = nil
            self.version = nil
        }
    }
}

public struct UpdateConnectivityInfoOutputResponse: Swift.Equatable {
    /// A message about the connectivity info update request.
    public var message: Swift.String?
    /// The new version of the connectivity info.
    public var version: Swift.String?

    public init (
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

struct UpdateConnectivityInfoOutputResponseBody: Swift.Equatable {
    let message: Swift.String?
    let version: Swift.String?
}

extension UpdateConnectivityInfoOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension UpdateConnectorDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        connectorDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.name = name
    }
}

struct UpdateConnectorDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateConnectorDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateConnectorDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectorDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectorDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectorDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectorDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCoreDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        coreDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.name = name
    }
}

struct UpdateCoreDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateCoreDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateCoreDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCoreDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCoreDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCoreDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCoreDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDeviceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        deviceDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.name = name
    }
}

struct UpdateDeviceDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateDeviceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDeviceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDeviceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeviceDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFunctionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        functionDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.name = name
    }
}

struct UpdateFunctionDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFunctionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFunctionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFunctionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFunctionDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGroupCertificateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateExpiryInMilliseconds = self.certificateExpiryInMilliseconds {
            try encodeContainer.encode(certificateExpiryInMilliseconds, forKey: .certificateExpiryInMilliseconds)
        }
    }
}

extension UpdateGroupCertificateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

public struct UpdateGroupCertificateConfigurationInput: Swift.Equatable {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationInputBody: Swift.Equatable {
    let certificateExpiryInMilliseconds: Swift.String?
}

extension UpdateGroupCertificateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
    }
}

extension UpdateGroupCertificateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupCertificateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGroupCertificateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupCertificateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGroupCertificateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct UpdateGroupCertificateConfigurationOutputResponse: Swift.Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init (
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationOutputResponseBody: Swift.Equatable {
    let certificateAuthorityExpiryInMilliseconds: Swift.String?
    let certificateExpiryInMilliseconds: Swift.String?
    let groupId: Swift.String?
}

extension UpdateGroupCertificateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.name = name
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLoggerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init (
        loggerDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.name = name
    }
}

struct UpdateLoggerDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateLoggerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateLoggerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLoggerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLoggerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoggerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLoggerDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateResourceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateResourceDefinitionInput: Swift.Equatable {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init (
        name: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct UpdateResourceDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateResourceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateResourceDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSubscriptionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionDefinitionInput: Swift.Equatable {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init (
        name: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct UpdateSubscriptionDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateSubscriptionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubscriptionDefinitionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSubscriptionDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes {
    /// The architecture of the cores which are the targets of an update.
    public enum UpdateTargetsArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aarch64
        case armv6l
        case armv7l
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsArchitecture] {
            return [
                .aarch64,
                .armv6l,
                .armv7l,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aarch64: return "aarch64"
            case .armv6l: return "armv6l"
            case .armv7l: return "armv7l"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateTargetsArchitecture(rawValue: rawValue) ?? UpdateTargetsArchitecture.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    /// The operating system of the cores which are the targets of an update.
    public enum UpdateTargetsOperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux
        case openwrt
        case raspbian
        case ubuntu
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsOperatingSystem] {
            return [
                .amazonLinux,
                .openwrt,
                .raspbian,
                .ubuntu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux: return "amazon_linux"
            case .openwrt: return "openwrt"
            case .raspbian: return "raspbian"
            case .ubuntu: return "ubuntu"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateTargetsOperatingSystem(rawValue: rawValue) ?? UpdateTargetsOperatingSystem.sdkUnknown(rawValue)
        }
    }
}

extension UpdateThingRuntimeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = self.telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }
}

extension UpdateThingRuntimeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

public struct UpdateThingRuntimeConfigurationInput: Swift.Equatable {
    /// Configuration for telemetry service.
    public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
        self.thingName = thingName
    }
}

struct UpdateThingRuntimeConfigurationInputBody: Swift.Equatable {
    let telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
}

extension UpdateThingRuntimeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.TelemetryConfigurationUpdate.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension UpdateThingRuntimeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingRuntimeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThingRuntimeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingRuntimeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThingRuntimeConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension GreengrassClientTypes.VersionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a version.
    public struct VersionInformation: Swift.Equatable {
        /// The ARN of the version.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the parent definition that the version is associated with.
        public var id: Swift.String?
        /// The ID of the version.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }
    }

}
