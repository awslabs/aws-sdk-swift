// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case crossRegionCopy = "CrossRegionCopy"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossRegionCopy = crossRegionCopy {
            var crossRegionCopyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopy)
            for crossregioncopyactionlist0 in crossRegionCopy {
                try crossRegionCopyContainer.encode(crossregioncopyactionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let crossRegionCopyContainer = try containerValues.decodeIfPresent([CrossRegionCopyAction?].self, forKey: .crossRegionCopy)
        var crossRegionCopyDecoded0:[CrossRegionCopyAction]? = nil
        if let crossRegionCopyContainer = crossRegionCopyContainer {
            crossRegionCopyDecoded0 = [CrossRegionCopyAction]()
            for structure0 in crossRegionCopyContainer {
                if let structure0 = structure0 {
                    crossRegionCopyDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopy = crossRegionCopyDecoded0
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(crossRegionCopy: \(String(describing: crossRegionCopy)), name: \(String(describing: name)))"}
}

/// <p>Specifies an action for an event-based policy.</p>
public struct Action: Equatable {
    /// <p>The rule for copying shared snapshots across Regions.</p>
    public let crossRegionCopy: [CrossRegionCopyAction]?
    /// <p>A descriptive name for the action.</p>
    public let name: String?

    public init (
        crossRegionCopy: [CrossRegionCopyAction]? = nil,
        name: String? = nil
    )
    {
        self.crossRegionCopy = crossRegionCopy
        self.name = name
    }
}

public struct CreateLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLifecyclePolicyOutputError>
}

extension CreateLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLifecyclePolicyInput(description: \(String(describing: description)), executionRoleArn: \(String(describing: executionRoleArn)), policyDetails: \(String(describing: policyDetails)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

extension CreateLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<CreateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLifecyclePolicyOutputError>
}

public struct CreateLifecyclePolicyInput: Equatable {
    /// <p>A description of the lifecycle policy. The characters ^[0-9A-Za-z _-]+$ are
    /// 			supported.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
    /// 			the lifecycle policy.</p>
    public let executionRoleArn: String?
    /// <p>The configuration details of the lifecycle policy.</p>
    public let policyDetails: PolicyDetails?
    /// <p>The desired activation state of the lifecycle policy after creation.</p>
    public let state: SettablePolicyStateValues?
    /// <p>The tags to apply to the lifecycle policy during creation.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        executionRoleArn: String? = nil,
        policyDetails: PolicyDetails? = nil,
        state: SettablePolicyStateValues? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.policyDetails = policyDetails
        self.state = state
        self.tags = tags
    }
}

struct CreateLifecyclePolicyInputBody: Equatable {
    public let executionRoleArn: String?
    public let description: String?
    public let state: SettablePolicyStateValues?
    public let policyDetails: PolicyDetails?
    public let tags: [String:String]?
}

extension CreateLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLifecyclePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLifecyclePolicyOutputResponse(policyId: \(String(describing: policyId)))"}
}

extension CreateLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyId = output.policyId
        } else {
            self.policyId = nil
        }
    }
}

public struct CreateLifecyclePolicyOutputResponse: Equatable {
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?

    public init (
        policyId: String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct CreateLifecyclePolicyOutputResponseBody: Equatable {
    public let policyId: String?
}

extension CreateLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyId = "PolicyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension CreateRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
        case location = "Location"
        case times = "Times"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
        if let location = location {
            try encodeContainer.encode(location.rawValue, forKey: .location)
        }
        if let times = times {
            var timesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .times)
            for timeslist0 in times {
                try timesContainer.encode(timeslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(LocationValues.self, forKey: .location)
        location = locationDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(IntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let timesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .times)
        var timesDecoded0:[String]? = nil
        if let timesContainer = timesContainer {
            timesDecoded0 = [String]()
            for string0 in timesContainer {
                if let string0 = string0 {
                    timesDecoded0?.append(string0)
                }
            }
        }
        times = timesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
    }
}

extension CreateRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRule(cronExpression: \(String(describing: cronExpression)), interval: \(String(describing: interval)), intervalUnit: \(String(describing: intervalUnit)), location: \(String(describing: location)), times: \(String(describing: times)))"}
}

/// <p>Specifies when to create snapshots of EBS volumes.</p>
/// 		       <p>You must specify either a Cron expression or an interval, interval unit, and start
/// 			time. You cannot specify both.</p>
public struct CreateRule: Equatable {
    /// <p>The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1
    /// 			year. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron
    /// 				expressions</a> in the <i>Amazon CloudWatch User Guide</i>.</p>
    public let cronExpression: String?
    /// <p>The interval between snapshots. The supported values are 1, 2, 3, 4, 6, 8, 12, and
    /// 			24.</p>
    public let interval: Int
    /// <p>The interval unit.</p>
    public let intervalUnit: IntervalUnitValues?
    /// <p>Specifies the destination for snapshots created by the policy. To create snapshots in the same
    /// 			Region as the source resource, specify <code>CLOUD</code>. To create snapshots on the same
    /// 			Outpost as the source resource, specify <code>OUTPOST_LOCAL</code>. If you omit this
    /// 			parameter, <code>CLOUD</code> is used by default.</p>
    /// 		       <p>If the policy targets resources in an AWS Region, then you must create snapshots in the same
    /// 			Region as the source resource. </p>
    /// 		       <p>If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost
    /// 			as the source resource, or in the Region of that Outpost.</p>
    public let location: LocationValues?
    /// <p>The time, in UTC, to start the operation. The supported format is hh:mm.</p>
    /// 		       <p>The operation occurs within a one-hour window following the specified time. If you do
    /// 			not specify a time, Amazon DLM selects a time within the next 24 hours.</p>
    public let times: [String]?

    public init (
        cronExpression: String? = nil,
        interval: Int = 0,
        intervalUnit: IntervalUnitValues? = nil,
        location: LocationValues? = nil,
        times: [String]? = nil
    )
    {
        self.cronExpression = cronExpression
        self.interval = interval
        self.intervalUnit = intervalUnit
        self.location = location
        self.times = times
    }
}

extension CrossRegionCopyAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case retainRule = "RetainRule"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
    }
}

extension CrossRegionCopyAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrossRegionCopyAction(encryptionConfiguration: \(String(describing: encryptionConfiguration)), retainRule: \(String(describing: retainRule)), target: \(String(describing: target)))"}
}

/// <p>Specifies a rule for copying shared snapshots across Regions.</p>
public struct CrossRegionCopyAction: Equatable {
    /// <p>The encryption settings for the copied snapshot.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>Specifies the retention rule for cross-Region snapshot copies.</p>
    public let retainRule: CrossRegionCopyRetainRule?
    /// <p>The target Region.</p>
    public let target: String?

    public init (
        encryptionConfiguration: EncryptionConfiguration? = nil,
        retainRule: CrossRegionCopyRetainRule? = nil,
        target: String? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.retainRule = retainRule
        self.target = target
    }
}

extension CrossRegionCopyRetainRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension CrossRegionCopyRetainRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrossRegionCopyRetainRule(interval: \(String(describing: interval)), intervalUnit: \(String(describing: intervalUnit)))"}
}

/// <p>Specifies the retention rule for cross-Region snapshot copies.</p>
public struct CrossRegionCopyRetainRule: Equatable {
    /// <p>The amount of time to retain each snapshot. The maximum is 100 years. This is
    /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.</p>
    public let interval: Int
    /// <p>The unit of time for time-based retention.</p>
    public let intervalUnit: RetentionIntervalUnitValues?

    public init (
        interval: Int = 0,
        intervalUnit: RetentionIntervalUnitValues? = nil
    )
    {
        self.interval = interval
        self.intervalUnit = intervalUnit
    }
}

extension CrossRegionCopyRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cmkArn = "CmkArn"
        case copyTags = "CopyTags"
        case encrypted = "Encrypted"
        case retainRule = "RetainRule"
        case target = "Target"
        case targetRegion = "TargetRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetRegion = targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(CrossRegionCopyRetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
    }
}

extension CrossRegionCopyRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CrossRegionCopyRule(cmkArn: \(String(describing: cmkArn)), copyTags: \(String(describing: copyTags)), encrypted: \(String(describing: encrypted)), retainRule: \(String(describing: retainRule)), target: \(String(describing: target)), targetRegion: \(String(describing: targetRegion)))"}
}

/// <p>Specifies a rule for cross-Region snapshot copies.</p>
public struct CrossRegionCopyRule: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS KMS customer master key (CMK) to use for EBS
    /// 			encryption. If this parameter is not specified, your AWS managed CMK for EBS is
    /// 			used.</p>
    public let cmkArn: String?
    /// <p>Copy all user-defined tags from the source snapshot to the copied snapshot.</p>
    public let copyTags: Bool?
    /// <p>To encrypt a copy of an unencrypted snapshot if encryption by default is not enabled,
    /// 			enable encryption using this parameter. Copies of encrypted snapshots are encrypted,
    /// 			even if this parameter is false or if encryption by default is not enabled.</p>
    public let encrypted: Bool?
    /// <p>The retention rule.</p>
    public let retainRule: CrossRegionCopyRetainRule?
    /// <p>The Amazon Resource Name (ARN) of the target AWS Outpost for the snapshot copies.</p>
    /// 		       <p>If you specify an ARN, you must omit <b>TargetRegion</b>. You cannot
    /// 			specify a target Region and a target Outpost in the same rule.</p>
    public let target: String?
    /// <p>The target Region for the snapshot copies.</p>
    /// 		       <p>If you specify a target Region, you must omit <b>Target</b>. You cannot
    /// 			specify a target Region and a target Outpost in the same rule.</p>
    public let targetRegion: String?

    public init (
        cmkArn: String? = nil,
        copyTags: Bool? = nil,
        encrypted: Bool? = nil,
        retainRule: CrossRegionCopyRetainRule? = nil,
        target: String? = nil,
        targetRegion: String? = nil
    )
    {
        self.cmkArn = cmkArn
        self.copyTags = copyTags
        self.encrypted = encrypted
        self.retainRule = retainRule
        self.target = target
        self.targetRegion = targetRegion
    }
}

extension DeleteLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyInput(policyId: \(String(describing: policyId)))"}
}

extension DeleteLifecyclePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInput: Equatable {
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?

    public init (
        policyId: String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct DeleteLifecyclePolicyInputBody: Equatable {
}

extension DeleteLifecyclePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLifecyclePolicyOutputResponse()"}
}

extension DeleteLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteLifecyclePolicyOutputResponseBody: Equatable {
}

extension DeleteLifecyclePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cmkArn = "CmkArn"
        case encrypted = "Encrypted"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkArn = cmkArn {
            try encodeContainer.encode(cmkArn, forKey: .cmkArn)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let cmkArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cmkArn)
        cmkArn = cmkArnDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(cmkArn: \(String(describing: cmkArn)), encrypted: \(String(describing: encrypted)))"}
}

/// <p>Specifies the encryption settings for shared snapshots that are copied across Regions.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS KMS customer master key (CMK) to use for EBS
    /// 			encryption. If this parameter is not specified, your AWS managed CMK for EBS is used.</p>
    public let cmkArn: String?
    /// <p>To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable
    /// 			encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this
    /// 			parameter is false or when encryption by default is not enabled.</p>
    public let encrypted: Bool?

    public init (
        cmkArn: String? = nil,
        encrypted: Bool? = nil
    )
    {
        self.cmkArn = cmkArn
        self.encrypted = encrypted
    }
}

extension EventParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case descriptionRegex = "DescriptionRegex"
        case eventType = "EventType"
        case snapshotOwner = "SnapshotOwner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let descriptionRegex = descriptionRegex {
            try encodeContainer.encode(descriptionRegex, forKey: .descriptionRegex)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let snapshotOwner = snapshotOwner {
            var snapshotOwnerContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snapshotOwner)
            for snapshotownerlist0 in snapshotOwner {
                try snapshotOwnerContainer.encode(snapshotownerlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventTypeValues.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let snapshotOwnerContainer = try containerValues.decodeIfPresent([String?].self, forKey: .snapshotOwner)
        var snapshotOwnerDecoded0:[String]? = nil
        if let snapshotOwnerContainer = snapshotOwnerContainer {
            snapshotOwnerDecoded0 = [String]()
            for string0 in snapshotOwnerContainer {
                if let string0 = string0 {
                    snapshotOwnerDecoded0?.append(string0)
                }
            }
        }
        snapshotOwner = snapshotOwnerDecoded0
        let descriptionRegexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .descriptionRegex)
        descriptionRegex = descriptionRegexDecoded
    }
}

extension EventParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventParameters(descriptionRegex: \(String(describing: descriptionRegex)), eventType: \(String(describing: eventType)), snapshotOwner: \(String(describing: snapshotOwner)))"}
}

/// <p>Specifies an event that triggers an event-based policy.</p>
public struct EventParameters: Equatable {
    /// <p>The snapshot description that can trigger the policy. The description pattern is specified using
    /// 			a regular expression. The policy runs only if a snapshot with a description that matches the
    /// 			specified pattern is shared with your account.</p>
    /// 		       <p>For example, specifying <code>^.*Created for policy: policy-1234567890abcdef0.*$</code>
    /// 			configures the policy to run only if snapshots created by policy <code>policy-1234567890abcdef0</code>
    /// 			are shared with your account.</p>
    public let descriptionRegex: String?
    /// <p>The type of event. Currently, only snapshot sharing events are supported.</p>
    public let eventType: EventTypeValues?
    /// <p>The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The
    /// 			policy only runs if one of the specified AWS accounts shares a snapshot with your account.</p>
    public let snapshotOwner: [String]?

    public init (
        descriptionRegex: String? = nil,
        eventType: EventTypeValues? = nil,
        snapshotOwner: [String]? = nil
    )
    {
        self.descriptionRegex = descriptionRegex
        self.eventType = eventType
        self.snapshotOwner = snapshotOwner
    }
}

extension EventSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EventSourceValues.self, forKey: .type)
        type = typeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(EventParameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension EventSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSource(parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

/// <p>Specifies an event that triggers an event-based policy.</p>
public struct EventSource: Equatable {
    /// <p>Information about the event.</p>
    public let parameters: EventParameters?
    /// <p>The source of the event. Currently only managed AWS CloudWatch Events rules are supported.</p>
    public let type: EventSourceValues?

    public init (
        parameters: EventParameters? = nil,
        type: EventSourceValues? = nil
    )
    {
        self.parameters = parameters
        self.type = type
    }
}

public enum EventSourceValues {
    case managedCwe
    case sdkUnknown(String)
}

extension EventSourceValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventSourceValues] {
        return [
            .managedCwe,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .managedCwe: return "MANAGED_CWE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventSourceValues(rawValue: rawValue) ?? EventSourceValues.sdkUnknown(rawValue)
    }
}

public enum EventTypeValues {
    case shareSnapshot
    case sdkUnknown(String)
}

extension EventTypeValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventTypeValues] {
        return [
            .shareSnapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .shareSnapshot: return "shareSnapshot"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventTypeValues(rawValue: rawValue) ?? EventTypeValues.sdkUnknown(rawValue)
    }
}

extension FastRestoreRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension FastRestoreRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FastRestoreRule(availabilityZones: \(String(describing: availabilityZones)), count: \(String(describing: count)), interval: \(String(describing: interval)), intervalUnit: \(String(describing: intervalUnit)))"}
}

/// <p>Specifies a rule for enabling fast snapshot restore. You can enable fast snapshot
/// 			restore based on either a count or a time interval.</p>
public struct FastRestoreRule: Equatable {
    /// <p>The Availability Zones in which to enable fast snapshot restore.</p>
    public let availabilityZones: [String]?
    /// <p>The number of snapshots to be enabled with fast snapshot restore.</p>
    public let count: Int
    /// <p>The amount of time to enable fast snapshot restore. The maximum is 100 years. This is
    /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.</p>
    public let interval: Int
    /// <p>The unit of time for enabling fast snapshot restore.</p>
    public let intervalUnit: RetentionIntervalUnitValues?

    public init (
        availabilityZones: [String]? = nil,
        count: Int = 0,
        interval: Int = 0,
        intervalUnit: RetentionIntervalUnitValues? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.count = count
        self.interval = interval
        self.intervalUnit = intervalUnit
    }
}

extension GetLifecyclePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePoliciesInput(policyIds: \(String(describing: policyIds)), resourceTypes: \(String(describing: resourceTypes)), state: \(String(describing: state)), tagsToAdd: \(String(describing: tagsToAdd)), targetTags: \(String(describing: targetTags)))"}
}

extension GetLifecyclePoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLifecyclePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetLifecyclePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePoliciesInput>
    public typealias MOutput = OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLifecyclePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceTypes = input.operationInput.resourceTypes {
            resourceTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "resourceTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let tagsToAdd = input.operationInput.tagsToAdd {
            tagsToAdd.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagsToAdd".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let state = input.operationInput.state {
            let stateQueryItem = URLQueryItem(name: "state".urlPercentEncoding(), value: String(state.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stateQueryItem)
        }
        if let policyIds = input.operationInput.policyIds {
            policyIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "policyIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let targetTags = input.operationInput.targetTags {
            targetTags.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "targetTags".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePoliciesInput>
    public typealias MOutput = OperationOutput<GetLifecyclePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePoliciesOutputError>
}

public struct GetLifecyclePoliciesInput: Equatable {
    /// <p>The identifiers of the data lifecycle policies.</p>
    public let policyIds: [String]?
    /// <p>The resource type.</p>
    public let resourceTypes: [ResourceTypeValues]?
    /// <p>The activation state.</p>
    public let state: GettablePolicyStateValues?
    /// <p>The tags to add to objects created by the policy.</p>
    /// 		       <p>Tags are strings in the format <code>key=value</code>.</p>
    /// 		       <p>These user-defined tags are added in addition to the AWS-added lifecycle tags.</p>
    public let tagsToAdd: [String]?
    /// <p>The target tag for a policy.</p>
    /// 		       <p>Tags are strings in the format <code>key=value</code>.</p>
    public let targetTags: [String]?

    public init (
        policyIds: [String]? = nil,
        resourceTypes: [ResourceTypeValues]? = nil,
        state: GettablePolicyStateValues? = nil,
        tagsToAdd: [String]? = nil,
        targetTags: [String]? = nil
    )
    {
        self.policyIds = policyIds
        self.resourceTypes = resourceTypes
        self.state = state
        self.tagsToAdd = tagsToAdd
        self.targetTags = targetTags
    }
}

struct GetLifecyclePoliciesInputBody: Equatable {
}

extension GetLifecyclePoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLifecyclePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePoliciesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePoliciesOutputResponse(policies: \(String(describing: policies)))"}
}

extension GetLifecyclePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLifecyclePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policies = output.policies
        } else {
            self.policies = nil
        }
    }
}

public struct GetLifecyclePoliciesOutputResponse: Equatable {
    /// <p>Summary information about the lifecycle policies.</p>
    public let policies: [LifecyclePolicySummary]?

    public init (
        policies: [LifecyclePolicySummary]? = nil
    )
    {
        self.policies = policies
    }
}

struct GetLifecyclePoliciesOutputResponseBody: Equatable {
    public let policies: [LifecyclePolicySummary]?
}

extension GetLifecyclePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policies = "Policies"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([LifecyclePolicySummary?].self, forKey: .policies)
        var policiesDecoded0:[LifecyclePolicySummary]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [LifecyclePolicySummary]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension GetLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyInput(policyId: \(String(describing: policyId)))"}
}

extension GetLifecyclePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInput: Equatable {
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?

    public init (
        policyId: String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetLifecyclePolicyInputBody: Equatable {
}

extension GetLifecyclePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLifecyclePolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Equatable {
    /// <p>Detailed information about the lifecycle policy.</p>
    public let policy: LifecyclePolicy?

    public init (
        policy: LifecyclePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetLifecyclePolicyOutputResponseBody: Equatable {
    public let policy: LifecyclePolicy?
}

extension GetLifecyclePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(LifecyclePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public enum GettablePolicyStateValues {
    case disabled
    case enabled
    case error
    case sdkUnknown(String)
}

extension GettablePolicyStateValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GettablePolicyStateValues] {
        return [
            .disabled,
            .enabled,
            .error,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case .error: return "ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GettablePolicyStateValues(rawValue: rawValue) ?? GettablePolicyStateValues.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service failed in an unexpected way.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

public enum IntervalUnitValues {
    case hours
    case sdkUnknown(String)
}

extension IntervalUnitValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntervalUnitValues] {
        return [
            .hours,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hours: return "HOURS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntervalUnitValues(rawValue: rawValue) ?? IntervalUnitValues.sdkUnknown(rawValue)
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(code: \(String(describing: code)), message: \(String(describing: message)), mutuallyExclusiveParameters: \(String(describing: mutuallyExclusiveParameters)), requiredParameters: \(String(describing: requiredParameters)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.mutuallyExclusiveParameters = output.mutuallyExclusiveParameters
            self.requiredParameters = output.requiredParameters
        } else {
            self.code = nil
            self.message = nil
            self.mutuallyExclusiveParameters = nil
            self.requiredParameters = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Bad request. The request is missing required parameters or has invalid
/// 			parameters.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>The request included parameters that cannot be provided together.</p>
    public var mutuallyExclusiveParameters: [String]?
    /// <p>The request omitted one or more required parameters.</p>
    public var requiredParameters: [String]?

    public init (
        code: String? = nil,
        message: String? = nil,
        mutuallyExclusiveParameters: [String]? = nil,
        requiredParameters: [String]? = nil
    )
    {
        self.code = code
        self.message = message
        self.mutuallyExclusiveParameters = mutuallyExclusiveParameters
        self.requiredParameters = requiredParameters
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let requiredParameters: [String]?
    public let mutuallyExclusiveParameters: [String]?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
        case mutuallyExclusiveParameters = "MutuallyExclusiveParameters"
        case requiredParameters = "RequiredParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let requiredParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .requiredParameters)
        var requiredParametersDecoded0:[String]? = nil
        if let requiredParametersContainer = requiredParametersContainer {
            requiredParametersDecoded0 = [String]()
            for string0 in requiredParametersContainer {
                if let string0 = string0 {
                    requiredParametersDecoded0?.append(string0)
                }
            }
        }
        requiredParameters = requiredParametersDecoded0
        let mutuallyExclusiveParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .mutuallyExclusiveParameters)
        var mutuallyExclusiveParametersDecoded0:[String]? = nil
        if let mutuallyExclusiveParametersContainer = mutuallyExclusiveParametersContainer {
            mutuallyExclusiveParametersDecoded0 = [String]()
            for string0 in mutuallyExclusiveParametersContainer {
                if let string0 = string0 {
                    mutuallyExclusiveParametersDecoded0?.append(string0)
                }
            }
        }
        mutuallyExclusiveParameters = mutuallyExclusiveParametersDecoded0
    }
}

extension LifecyclePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyArn = "PolicyArn"
        case policyDetails = "PolicyDetails"
        case policyId = "PolicyId"
        case state = "State"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension LifecyclePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicy(dateCreated: \(String(describing: dateCreated)), dateModified: \(String(describing: dateModified)), description: \(String(describing: description)), executionRoleArn: \(String(describing: executionRoleArn)), policyArn: \(String(describing: policyArn)), policyDetails: \(String(describing: policyDetails)), policyId: \(String(describing: policyId)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)))"}
}

/// <p>Detailed information about a lifecycle policy.</p>
public struct LifecyclePolicy: Equatable {
    /// <p>The local date and time when the lifecycle policy was created.</p>
    public let dateCreated: Date?
    /// <p>The local date and time when the lifecycle policy was last modified.</p>
    public let dateModified: Date?
    /// <p>The description of the lifecycle policy.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
    /// 			the lifecycle policy.</p>
    public let executionRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    public let policyArn: String?
    /// <p>The configuration of the lifecycle policy</p>
    public let policyDetails: PolicyDetails?
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?
    /// <p>The activation state of the lifecycle policy.</p>
    public let state: GettablePolicyStateValues?
    /// <p>The description of the status.</p>
    public let statusMessage: String?
    /// <p>The tags.</p>
    public let tags: [String:String]?

    public init (
        dateCreated: Date? = nil,
        dateModified: Date? = nil,
        description: String? = nil,
        executionRoleArn: String? = nil,
        policyArn: String? = nil,
        policyDetails: PolicyDetails? = nil,
        policyId: String? = nil,
        state: GettablePolicyStateValues? = nil,
        statusMessage: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.policyArn = policyArn
        self.policyDetails = policyDetails
        self.policyId = policyId
        self.state = state
        self.statusMessage = statusMessage
        self.tags = tags
    }
}

extension LifecyclePolicySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let policyTypeDecoded = try containerValues.decodeIfPresent(PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension LifecyclePolicySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecyclePolicySummary(description: \(String(describing: description)), policyId: \(String(describing: policyId)), policyType: \(String(describing: policyType)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a lifecycle policy.</p>
public struct LifecyclePolicySummary: Equatable {
    /// <p>The description of the lifecycle policy.</p>
    public let description: String?
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?
    /// <p>The type of policy. <code>EBS_SNAPSHOT_MANAGEMENT</code> indicates that the policy
    /// 			manages the lifecycle of Amazon EBS snapshots. <code>IMAGE_MANAGEMENT</code>
    /// 			indicates that the policy manages the lifecycle of EBS-backed AMIs.</p>
    public let policyType: PolicyTypeValues?
    /// <p>The activation state of the lifecycle policy.</p>
    public let state: GettablePolicyStateValues?
    /// <p>The tags.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        policyId: String? = nil,
        policyType: PolicyTypeValues? = nil,
        state: GettablePolicyStateValues? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.policyId = policyId
        self.policyType = policyType
        self.state = state
        self.tags = tags
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because a limit was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>Value is the type of resource for which a limit was exceeded.</p>
    public var resourceType: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let resourceType: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LocationValues {
    case cloud
    case outpostLocal
    case sdkUnknown(String)
}

extension LocationValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocationValues] {
        return [
            .cloud,
            .outpostLocal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloud: return "CLOUD"
        case .outpostLocal: return "OUTPOST_LOCAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocationValues(rawValue: rawValue) ?? LocationValues.sdkUnknown(rawValue)
    }
}

extension Parameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeBootVolume = "ExcludeBootVolume"
        case noReboot = "NoReboot"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeBootVolume = excludeBootVolume {
            try encodeContainer.encode(excludeBootVolume, forKey: .excludeBootVolume)
        }
        if let noReboot = noReboot {
            try encodeContainer.encode(noReboot, forKey: .noReboot)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludeBootVolumeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .excludeBootVolume)
        excludeBootVolume = excludeBootVolumeDecoded
        let noRebootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .noReboot)
        noReboot = noRebootDecoded
    }
}

extension Parameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameters(excludeBootVolume: \(String(describing: excludeBootVolume)), noReboot: \(String(describing: noReboot)))"}
}

/// <p>Specifies optional parameters to add to a policy. The set of valid parameters depends
/// 			on the combination of policy type and resource type.</p>
public struct Parameters: Equatable {
    /// <p>[EBS Snapshot Management  Instance policies only] Indicates whether to exclude the
    /// 			root volume from snapshots created using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSnapshots.html">CreateSnapshots</a>.
    /// 			The default is false.</p>
    public let excludeBootVolume: Bool?
    /// <p>Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle
    /// 			policy runs. <code>true</code> indicates that targeted instances are not rebooted when the policy
    /// 			runs. <code>false</code> indicates that target instances are rebooted when the policy runs. The
    /// 			default is <code>true</code> (instances are not rebooted).</p>
    public let noReboot: Bool?

    public init (
        excludeBootVolume: Bool? = nil,
        noReboot: Bool? = nil
    )
    {
        self.excludeBootVolume = excludeBootVolume
        self.noReboot = noReboot
    }
}

extension PolicyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case eventSource = "EventSource"
        case parameters = "Parameters"
        case policyType = "PolicyType"
        case resourceLocations = "ResourceLocations"
        case resourceTypes = "ResourceTypes"
        case schedules = "Schedules"
        case targetTags = "TargetTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let resourceLocations = resourceLocations {
            var resourceLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceLocations)
            for resourcelocationlist0 in resourceLocations {
                try resourceLocationsContainer.encode(resourcelocationlist0.rawValue)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypevalueslist0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypevalueslist0.rawValue)
            }
        }
        if let schedules = schedules {
            var schedulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schedules)
            for schedulelist0 in schedules {
                try schedulesContainer.encode(schedulelist0)
            }
        }
        if let targetTags = targetTags {
            var targetTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTags)
            for targettaglist0 in targetTags {
                try targetTagsContainer.encode(targettaglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTypeDecoded = try containerValues.decodeIfPresent(PolicyTypeValues.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([ResourceTypeValues?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ResourceTypeValues]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ResourceTypeValues]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let resourceLocationsContainer = try containerValues.decodeIfPresent([ResourceLocationValues?].self, forKey: .resourceLocations)
        var resourceLocationsDecoded0:[ResourceLocationValues]? = nil
        if let resourceLocationsContainer = resourceLocationsContainer {
            resourceLocationsDecoded0 = [ResourceLocationValues]()
            for string0 in resourceLocationsContainer {
                if let string0 = string0 {
                    resourceLocationsDecoded0?.append(string0)
                }
            }
        }
        resourceLocations = resourceLocationsDecoded0
        let targetTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .targetTags)
        var targetTagsDecoded0:[Tag]? = nil
        if let targetTagsContainer = targetTagsContainer {
            targetTagsDecoded0 = [Tag]()
            for structure0 in targetTagsContainer {
                if let structure0 = structure0 {
                    targetTagsDecoded0?.append(structure0)
                }
            }
        }
        targetTags = targetTagsDecoded0
        let schedulesContainer = try containerValues.decodeIfPresent([Schedule?].self, forKey: .schedules)
        var schedulesDecoded0:[Schedule]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [Schedule]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
        let parametersDecoded = try containerValues.decodeIfPresent(Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(EventSource.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension PolicyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyDetails(actions: \(String(describing: actions)), eventSource: \(String(describing: eventSource)), parameters: \(String(describing: parameters)), policyType: \(String(describing: policyType)), resourceLocations: \(String(describing: resourceLocations)), resourceTypes: \(String(describing: resourceTypes)), schedules: \(String(describing: schedules)), targetTags: \(String(describing: targetTags)))"}
}

/// <p>Specifies the configuration of a lifecycle policy.</p>
public struct PolicyDetails: Equatable {
    /// <p>The actions to be performed when the event-based policy is triggered. You can specify
    /// 		only one action per policy.</p>
    /// 		       <p>This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter.</p>
    public let actions: [Action]?
    /// <p>The event that triggers the event-based policy. </p>
    /// 		       <p>This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter.</p>
    public let eventSource: EventSource?
    /// <p>A set of optional parameters for snapshot and AMI lifecycle policies. </p>
    /// 		       <p>This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.</p>
    public let parameters: Parameters?
    /// <p>The valid target resource types and actions a policy can manage. Specify <code>EBS_SNAPSHOT_MANAGEMENT</code>
    /// 			to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify <code>IMAGE_MANAGEMENT</code>
    /// 			to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify <code>EVENT_BASED_POLICY </code>
    /// 			to create an event-based policy that performs specific actions when a defined event occurs in your AWS account.</p>
    /// 		       <p>The default is <code>EBS_SNAPSHOT_MANAGEMENT</code>.</p>
    public let policyType: PolicyTypeValues?
    /// <p>The location of the resources to backup. If the source resources are located in an AWS Region, specify
    /// 			<code>CLOUD</code>. If the source resources are located on an AWS Outpost
    /// 			in your account, specify <code>OUTPOST</code>. </p>
    /// 			      <p>If you specify <code>OUTPOST</code>, Amazon Data Lifecycle Manager backs up all resources
    /// 				of the specified type with matching target tags across all of the Outposts in your account.</p>
    public let resourceLocations: [ResourceLocationValues]?
    /// <p>The target resource type for snapshot and AMI lifecycle policies. Use <code>VOLUME </code>to
    /// 			create snapshots of individual volumes or use <code>INSTANCE</code> to create multi-volume
    /// 			snapshots from the volumes for an instance.</p>
    /// 		       <p>This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.</p>
    public let resourceTypes: [ResourceTypeValues]?
    /// <p>The schedules of policy-defined actions for snapshot and AMI lifecycle policies. A policy
    /// 			can have up to four schedulesone mandatory schedule and up to three optional schedules.</p>
    /// 		       <p>This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.</p>
    public let schedules: [Schedule]?
    /// <p>The single tag that identifies targeted resources for this policy.</p>
    /// 		       <p>This parameter is required for snapshot and AMI policies only. If you are creating an event-based policy, omit this parameter.</p>
    public let targetTags: [Tag]?

    public init (
        actions: [Action]? = nil,
        eventSource: EventSource? = nil,
        parameters: Parameters? = nil,
        policyType: PolicyTypeValues? = nil,
        resourceLocations: [ResourceLocationValues]? = nil,
        resourceTypes: [ResourceTypeValues]? = nil,
        schedules: [Schedule]? = nil,
        targetTags: [Tag]? = nil
    )
    {
        self.actions = actions
        self.eventSource = eventSource
        self.parameters = parameters
        self.policyType = policyType
        self.resourceLocations = resourceLocations
        self.resourceTypes = resourceTypes
        self.schedules = schedules
        self.targetTags = targetTags
    }
}

public enum PolicyTypeValues {
    case ebsSnapshotManagement
    case eventBasedPolicy
    case imageManagement
    case sdkUnknown(String)
}

extension PolicyTypeValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyTypeValues] {
        return [
            .ebsSnapshotManagement,
            .eventBasedPolicy,
            .imageManagement,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ebsSnapshotManagement: return "EBS_SNAPSHOT_MANAGEMENT"
        case .eventBasedPolicy: return "EVENT_BASED_POLICY"
        case .imageManagement: return "IMAGE_MANAGEMENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyTypeValues(rawValue: rawValue) ?? PolicyTypeValues.sdkUnknown(rawValue)
    }
}

public enum ResourceLocationValues {
    case cloud
    case outpost
    case sdkUnknown(String)
}

extension ResourceLocationValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceLocationValues] {
        return [
            .cloud,
            .outpost,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloud: return "CLOUD"
        case .outpost: return "OUTPOST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceLocationValues(rawValue: rawValue) ?? ResourceLocationValues.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)), resourceIds: \(String(describing: resourceIds)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.resourceIds = output.resourceIds
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceIds = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A requested resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>Value is a list of resource IDs that were not found.</p>
    public var resourceIds: [String]?
    /// <p>Value is the type of resource that was not found.</p>
    public var resourceType: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        resourceIds: [String]? = nil,
        resourceType: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceIds = resourceIds
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let resourceType: String?
    public let resourceIds: [String]?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

public enum ResourceTypeValues {
    case instance
    case volume
    case sdkUnknown(String)
}

extension ResourceTypeValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceTypeValues] {
        return [
            .instance,
            .volume,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instance: return "INSTANCE"
        case .volume: return "VOLUME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceTypeValues(rawValue: rawValue) ?? ResourceTypeValues.sdkUnknown(rawValue)
    }
}

extension RetainRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case interval = "Interval"
        case intervalUnit = "IntervalUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let intervalUnit = intervalUnit {
            try encodeContainer.encode(intervalUnit.rawValue, forKey: .intervalUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let intervalDecoded = try containerValues.decode(Int.self, forKey: .interval)
        interval = intervalDecoded
        let intervalUnitDecoded = try containerValues.decodeIfPresent(RetentionIntervalUnitValues.self, forKey: .intervalUnit)
        intervalUnit = intervalUnitDecoded
    }
}

extension RetainRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetainRule(count: \(String(describing: count)), interval: \(String(describing: interval)), intervalUnit: \(String(describing: intervalUnit)))"}
}

/// <p>Specifies the retention rule for a lifecycle policy. You can retain snapshots based on
/// 			either a count or a time interval.</p>
public struct RetainRule: Equatable {
    /// <p>The number of snapshots to retain for each volume, up to a maximum of 1000.</p>
    public let count: Int
    /// <p>The amount of time to retain each snapshot. The maximum is 100 years. This is
    /// 			equivalent to 1200 months, 5200 weeks, or 36500 days.</p>
    public let interval: Int
    /// <p>The unit of time for time-based retention.</p>
    public let intervalUnit: RetentionIntervalUnitValues?

    public init (
        count: Int = 0,
        interval: Int = 0,
        intervalUnit: RetentionIntervalUnitValues? = nil
    )
    {
        self.count = count
        self.interval = interval
        self.intervalUnit = intervalUnit
    }
}

public enum RetentionIntervalUnitValues {
    case days
    case months
    case weeks
    case years
    case sdkUnknown(String)
}

extension RetentionIntervalUnitValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RetentionIntervalUnitValues] {
        return [
            .days,
            .months,
            .weeks,
            .years,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .days: return "DAYS"
        case .months: return "MONTHS"
        case .weeks: return "WEEKS"
        case .years: return "YEARS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RetentionIntervalUnitValues(rawValue: rawValue) ?? RetentionIntervalUnitValues.sdkUnknown(rawValue)
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case copyTags = "CopyTags"
        case createRule = "CreateRule"
        case crossRegionCopyRules = "CrossRegionCopyRules"
        case fastRestoreRule = "FastRestoreRule"
        case name = "Name"
        case retainRule = "RetainRule"
        case shareRules = "ShareRules"
        case tagsToAdd = "TagsToAdd"
        case variableTags = "VariableTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if copyTags != false {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let createRule = createRule {
            try encodeContainer.encode(createRule, forKey: .createRule)
        }
        if let crossRegionCopyRules = crossRegionCopyRules {
            var crossRegionCopyRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossRegionCopyRules)
            for crossregioncopyrules0 in crossRegionCopyRules {
                try crossRegionCopyRulesContainer.encode(crossregioncopyrules0)
            }
        }
        if let fastRestoreRule = fastRestoreRule {
            try encodeContainer.encode(fastRestoreRule, forKey: .fastRestoreRule)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retainRule = retainRule {
            try encodeContainer.encode(retainRule, forKey: .retainRule)
        }
        if let shareRules = shareRules {
            var shareRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareRules)
            for sharerules0 in shareRules {
                try shareRulesContainer.encode(sharerules0)
            }
        }
        if let tagsToAdd = tagsToAdd {
            var tagsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsToAdd)
            for tagstoaddlist0 in tagsToAdd {
                try tagsToAddContainer.encode(tagstoaddlist0)
            }
        }
        if let variableTags = variableTags {
            var variableTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableTags)
            for variabletagslist0 in variableTags {
                try variableTagsContainer.encode(variabletagslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let copyTagsDecoded = try containerValues.decode(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let tagsToAddContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsToAdd)
        var tagsToAddDecoded0:[Tag]? = nil
        if let tagsToAddContainer = tagsToAddContainer {
            tagsToAddDecoded0 = [Tag]()
            for structure0 in tagsToAddContainer {
                if let structure0 = structure0 {
                    tagsToAddDecoded0?.append(structure0)
                }
            }
        }
        tagsToAdd = tagsToAddDecoded0
        let variableTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .variableTags)
        var variableTagsDecoded0:[Tag]? = nil
        if let variableTagsContainer = variableTagsContainer {
            variableTagsDecoded0 = [Tag]()
            for structure0 in variableTagsContainer {
                if let structure0 = structure0 {
                    variableTagsDecoded0?.append(structure0)
                }
            }
        }
        variableTags = variableTagsDecoded0
        let createRuleDecoded = try containerValues.decodeIfPresent(CreateRule.self, forKey: .createRule)
        createRule = createRuleDecoded
        let retainRuleDecoded = try containerValues.decodeIfPresent(RetainRule.self, forKey: .retainRule)
        retainRule = retainRuleDecoded
        let fastRestoreRuleDecoded = try containerValues.decodeIfPresent(FastRestoreRule.self, forKey: .fastRestoreRule)
        fastRestoreRule = fastRestoreRuleDecoded
        let crossRegionCopyRulesContainer = try containerValues.decodeIfPresent([CrossRegionCopyRule?].self, forKey: .crossRegionCopyRules)
        var crossRegionCopyRulesDecoded0:[CrossRegionCopyRule]? = nil
        if let crossRegionCopyRulesContainer = crossRegionCopyRulesContainer {
            crossRegionCopyRulesDecoded0 = [CrossRegionCopyRule]()
            for structure0 in crossRegionCopyRulesContainer {
                if let structure0 = structure0 {
                    crossRegionCopyRulesDecoded0?.append(structure0)
                }
            }
        }
        crossRegionCopyRules = crossRegionCopyRulesDecoded0
        let shareRulesContainer = try containerValues.decodeIfPresent([ShareRule?].self, forKey: .shareRules)
        var shareRulesDecoded0:[ShareRule]? = nil
        if let shareRulesContainer = shareRulesContainer {
            shareRulesDecoded0 = [ShareRule]()
            for structure0 in shareRulesContainer {
                if let structure0 = structure0 {
                    shareRulesDecoded0?.append(structure0)
                }
            }
        }
        shareRules = shareRulesDecoded0
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(copyTags: \(String(describing: copyTags)), createRule: \(String(describing: createRule)), crossRegionCopyRules: \(String(describing: crossRegionCopyRules)), fastRestoreRule: \(String(describing: fastRestoreRule)), name: \(String(describing: name)), retainRule: \(String(describing: retainRule)), shareRules: \(String(describing: shareRules)), tagsToAdd: \(String(describing: tagsToAdd)), variableTags: \(String(describing: variableTags)))"}
}

/// <p>Specifies a backup schedule for a snapshot or AMI lifecycle policy.</p>
public struct Schedule: Equatable {
    /// <p>Copy all user-defined tags on a source volume to snapshots of the volume created by
    /// 			this policy.</p>
    public let copyTags: Bool
    /// <p>The creation rule.</p>
    public let createRule: CreateRule?
    /// <p>The rule for cross-Region snapshot copies.</p>
    /// 		       <p>You can only specify cross-Region copy rules for policies that create snapshots in a Region.
    /// 			If the policy creates snapshots on an Outpost, then you cannot copy the snapshots to a Region or
    /// 			to an Outpost. If the policy creates snapshots in a Region, then snapshots can be copied to up to three
    /// 			Regions or Outposts.</p>
    public let crossRegionCopyRules: [CrossRegionCopyRule]?
    /// <p>The rule for enabling fast snapshot restore.</p>
    public let fastRestoreRule: FastRestoreRule?
    /// <p>The name of the schedule.</p>
    public let name: String?
    /// <p>The retention rule.</p>
    public let retainRule: RetainRule?
    /// <p>The rule for sharing snapshots with other AWS accounts.</p>
    public let shareRules: [ShareRule]?
    /// <p>The tags to apply to policy-created resources. These user-defined tags are in addition
    /// 			to the AWS-added lifecycle tags.</p>
    public let tagsToAdd: [Tag]?
    /// <p>A collection of key/value pairs with values determined dynamically when the policy is
    /// 			executed. Keys may be any valid Amazon EC2 tag key. Values must be in one of the two
    /// 			following formats: <code>$(instance-id)</code> or <code>$(timestamp)</code>. Variable
    /// 			tags are only valid for EBS Snapshot Management  Instance policies.</p>
    public let variableTags: [Tag]?

    public init (
        copyTags: Bool = false,
        createRule: CreateRule? = nil,
        crossRegionCopyRules: [CrossRegionCopyRule]? = nil,
        fastRestoreRule: FastRestoreRule? = nil,
        name: String? = nil,
        retainRule: RetainRule? = nil,
        shareRules: [ShareRule]? = nil,
        tagsToAdd: [Tag]? = nil,
        variableTags: [Tag]? = nil
    )
    {
        self.copyTags = copyTags
        self.createRule = createRule
        self.crossRegionCopyRules = crossRegionCopyRules
        self.fastRestoreRule = fastRestoreRule
        self.name = name
        self.retainRule = retainRule
        self.shareRules = shareRules
        self.tagsToAdd = tagsToAdd
        self.variableTags = variableTags
    }
}

public enum SettablePolicyStateValues {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension SettablePolicyStateValues : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SettablePolicyStateValues] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SettablePolicyStateValues(rawValue: rawValue) ?? SettablePolicyStateValues.sdkUnknown(rawValue)
    }
}

extension ShareRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetAccounts = "TargetAccounts"
        case unshareInterval = "UnshareInterval"
        case unshareIntervalUnit = "UnshareIntervalUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAccounts = targetAccounts {
            var targetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccounts)
            for sharetargetaccountlist0 in targetAccounts {
                try targetAccountsContainer.encode(sharetargetaccountlist0)
            }
        }
        if unshareInterval != 0 {
            try encodeContainer.encode(unshareInterval, forKey: .unshareInterval)
        }
        if let unshareIntervalUnit = unshareIntervalUnit {
            try encodeContainer.encode(unshareIntervalUnit.rawValue, forKey: .unshareIntervalUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetAccounts)
        var targetAccountsDecoded0:[String]? = nil
        if let targetAccountsContainer = targetAccountsContainer {
            targetAccountsDecoded0 = [String]()
            for string0 in targetAccountsContainer {
                if let string0 = string0 {
                    targetAccountsDecoded0?.append(string0)
                }
            }
        }
        targetAccounts = targetAccountsDecoded0
        let unshareIntervalDecoded = try containerValues.decode(Int.self, forKey: .unshareInterval)
        unshareInterval = unshareIntervalDecoded
        let unshareIntervalUnitDecoded = try containerValues.decodeIfPresent(RetentionIntervalUnitValues.self, forKey: .unshareIntervalUnit)
        unshareIntervalUnit = unshareIntervalUnitDecoded
    }
}

extension ShareRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareRule(targetAccounts: \(String(describing: targetAccounts)), unshareInterval: \(String(describing: unshareInterval)), unshareIntervalUnit: \(String(describing: unshareIntervalUnit)))"}
}

/// <p>Specifies a rule for sharing snapshots across AWS accounts.</p>
public struct ShareRule: Equatable {
    /// <p>The IDs of the AWS accounts with which to share the snapshots.</p>
    public let targetAccounts: [String]?
    /// <p>The period after which snapshots that are shared with other AWS accounts are automatically unshared.</p>
    public let unshareInterval: Int
    /// <p>The unit of time for the automatic unsharing interval.</p>
    public let unshareIntervalUnit: RetentionIntervalUnitValues?

    public init (
        targetAccounts: [String]? = nil,
        unshareInterval: Int = 0,
        unshareIntervalUnit: RetentionIntervalUnitValues? = nil
    )
    {
        self.targetAccounts = targetAccounts
        self.unshareInterval = unshareInterval
        self.unshareIntervalUnit = unshareIntervalUnit
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Specifies a tag for a resource.</p>
public struct Tag: Equatable {
    /// <p>The tag key.</p>
    public let key: String?
    /// <p>The tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLifecyclePolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLifecyclePolicyOutputError>
}

extension UpdateLifecyclePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLifecyclePolicyInput(description: \(String(describing: description)), executionRoleArn: \(String(describing: executionRoleArn)), policyDetails: \(String(describing: policyDetails)), policyId: \(String(describing: policyId)), state: \(String(describing: state)))"}
}

extension UpdateLifecyclePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct UpdateLifecyclePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLifecyclePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLifecyclePolicyInput>
    public typealias MOutput = OperationOutput<UpdateLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLifecyclePolicyOutputError>
}

public struct UpdateLifecyclePolicyInput: Equatable {
    /// <p>A description of the lifecycle policy.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role used to run the operations specified by
    /// 			the lifecycle policy.</p>
    public let executionRoleArn: String?
    /// <p>The configuration of the lifecycle policy. You cannot update the policy type or the
    /// 			resource type.</p>
    public let policyDetails: PolicyDetails?
    /// <p>The identifier of the lifecycle policy.</p>
    public let policyId: String?
    /// <p>The desired activation state of the lifecycle policy after creation.</p>
    public let state: SettablePolicyStateValues?

    public init (
        description: String? = nil,
        executionRoleArn: String? = nil,
        policyDetails: PolicyDetails? = nil,
        policyId: String? = nil,
        state: SettablePolicyStateValues? = nil
    )
    {
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.policyDetails = policyDetails
        self.policyId = policyId
        self.state = state
    }
}

struct UpdateLifecyclePolicyInputBody: Equatable {
    public let executionRoleArn: String?
    public let state: SettablePolicyStateValues?
    public let description: String?
    public let policyDetails: PolicyDetails?
}

extension UpdateLifecyclePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case executionRoleArn = "ExecutionRoleArn"
        case policyDetails = "PolicyDetails"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SettablePolicyStateValues.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
    }
}

extension UpdateLifecyclePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLifecyclePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLifecyclePolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLifecyclePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLifecyclePolicyOutputResponse()"}
}

extension UpdateLifecyclePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLifecyclePolicyOutputResponse: Equatable {

    public init() {}
}

struct UpdateLifecyclePolicyOutputResponseBody: Equatable {
}

extension UpdateLifecyclePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
