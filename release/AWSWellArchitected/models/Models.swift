// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.Answer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswers = "ChoiceAnswers"
        case choices = "Choices"
        case helpfulResourceDisplayText = "HelpfulResourceDisplayText"
        case helpfulResourceUrl = "HelpfulResourceUrl"
        case improvementPlanUrl = "ImprovementPlanUrl"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case pillarId = "PillarId"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswers = choiceAnswers {
            var choiceAnswersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswers)
            for choiceanswers0 in choiceAnswers {
                try choiceAnswersContainer.encode(choiceanswers0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if let helpfulResourceDisplayText = helpfulResourceDisplayText {
            try encodeContainer.encode(helpfulResourceDisplayText, forKey: .helpfulResourceDisplayText)
        }
        if let helpfulResourceUrl = helpfulResourceUrl {
            try encodeContainer.encode(helpfulResourceUrl, forKey: .helpfulResourceUrl)
        }
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDescription = questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let helpfulResourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceUrl)
        helpfulResourceUrl = helpfulResourceUrlDecoded
        let helpfulResourceDisplayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceDisplayText)
        helpfulResourceDisplayText = helpfulResourceDisplayTextDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswersContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswer?].self, forKey: .choiceAnswers)
        var choiceAnswersDecoded0:[WellArchitectedClientTypes.ChoiceAnswer]? = nil
        if let choiceAnswersContainer = choiceAnswersContainer {
            choiceAnswersDecoded0 = [WellArchitectedClientTypes.ChoiceAnswer]()
            for structure0 in choiceAnswersContainer {
                if let structure0 = structure0 {
                    choiceAnswersDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswers = choiceAnswersDecoded0
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An answer of the question.
    public struct Answer: Swift.Equatable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL for a question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init (
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool = false,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

extension WellArchitectedClientTypes {
    public enum AnswerReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [AnswerReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnswerReason(rawValue: rawValue) ?? AnswerReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.AnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswerSummaries = "ChoiceAnswerSummaries"
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswerSummaries = choiceAnswerSummaries {
            var choiceAnswerSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswerSummaries)
            for choiceanswersummaries0 in choiceAnswerSummaries {
                try choiceAnswerSummariesContainer.encode(choiceanswersummaries0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswerSummary?].self, forKey: .choiceAnswerSummaries)
        var choiceAnswerSummariesDecoded0:[WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil
        if let choiceAnswerSummariesContainer = choiceAnswerSummariesContainer {
            choiceAnswerSummariesDecoded0 = [WellArchitectedClientTypes.ChoiceAnswerSummary]()
            for structure0 in choiceAnswerSummariesContainer {
                if let structure0 = structure0 {
                    choiceAnswerSummariesDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswerSummaries = choiceAnswerSummariesDecoded0
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An answer summary of a lens review in a workload.
    public struct AnswerSummary: Swift.Equatable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init (
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool = false,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

extension AssociateLensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

extension AssociateLensesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/associateLenses"
    }
}

/// Input to associate lens reviews.
public struct AssociateLensesInput: Swift.Equatable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct AssociateLensesInputBody: Swift.Equatable {
    let lensAliases: [Swift.String]?
}

extension AssociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension AssociateLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateLensesOutputResponse: Swift.Equatable {

}

extension WellArchitectedClientTypes.Choice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case description = "Description"
        case helpfulResource = "HelpfulResource"
        case improvementPlan = "ImprovementPlan"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let helpfulResource = helpfulResource {
            try encodeContainer.encode(helpfulResource, forKey: .helpfulResource)
        }
        if let improvementPlan = improvementPlan {
            try encodeContainer.encode(improvementPlan, forKey: .improvementPlan)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let helpfulResourceDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .helpfulResource)
        helpfulResource = helpfulResourceDecoded
        let improvementPlanDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .improvementPlan)
        improvementPlan = improvementPlanDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A choice available to answer question.
    public struct Choice: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The description of a choice.
        public var description: Swift.String?
        /// The choice level helpful resource.
        public var helpfulResource: WellArchitectedClientTypes.ChoiceContent?
        /// The choice level improvement plan.
        public var improvementPlan: WellArchitectedClientTypes.ChoiceContent?
        /// The title of a choice.
        public var title: Swift.String?

        public init (
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            helpfulResource: WellArchitectedClientTypes.ChoiceContent? = nil,
            improvementPlan: WellArchitectedClientTypes.ChoiceContent? = nil,
            title: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.description = description
            self.helpfulResource = helpfulResource
            self.improvementPlan = improvementPlan
            self.title = title
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A choice that has been answered on a question in your workload.
    public struct ChoiceAnswer: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            choiceId: Swift.String? = nil,
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A choice summary that has been answered on a question in your workload.
    public struct ChoiceAnswerSummary: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            choiceId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayText = "DisplayText"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayText = displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The choice content.
    public struct ChoiceContent: Swift.Equatable {
        /// The display text for the choice content.
        public var displayText: Swift.String?
        /// The URL for the choice content.
        public var url: Swift.String?

        public init (
            displayText: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.displayText = displayText
            self.url = url
        }
    }

}

extension WellArchitectedClientTypes.ChoiceImprovementPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case displayText = "DisplayText"
        case improvementPlanUrl = "ImprovementPlanUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let displayText = displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The choice level improvement plan.
    public struct ChoiceImprovementPlan: Swift.Equatable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The display text for the improvement plan.
        public var displayText: Swift.String?
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?

        public init (
            choiceId: Swift.String? = nil,
            displayText: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.displayText = displayText
            self.improvementPlanUrl = improvementPlanUrl
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ChoiceReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceReason(rawValue: rawValue) ?? ChoiceReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ChoiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notApplicable
        case selected
        case unselected
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceStatus] {
            return [
                .notApplicable,
                .selected,
                .unselected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notApplicable: return "NOT_APPLICABLE"
            case .selected: return "SELECTED"
            case .unselected: return "UNSELECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceStatus(rawValue: rawValue) ?? ChoiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ChoiceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A list of choices to be updated.
    public struct ChoiceUpdate: Swift.Equatable {
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        /// This member is required.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init (
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateLensShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateLensShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

public struct CreateLensShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.sharedWith = sharedWith
    }
}

struct CreateLensShareInputBody: Swift.Equatable {
    let sharedWith: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateLensShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLensShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLensShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLensShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLensShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
        } else {
            self.shareId = nil
        }
    }
}

public struct CreateLensShareOutputResponse: Swift.Equatable {
    /// The ID associated with the workload share.
    public var shareId: Swift.String?

    public init (
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct CreateLensShareOutputResponseBody: Swift.Equatable {
    let shareId: Swift.String?
}

extension CreateLensShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

extension CreateLensVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if isMajorVersion != false {
            try encodeContainer.encode(isMajorVersion, forKey: .isMajorVersion)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
    }
}

extension CreateLensVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versions"
    }
}

public struct CreateLensVersionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Set to true if this new major lens version.
    public var isMajorVersion: Swift.Bool
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The version of the lens being created.
    /// This member is required.
    public var lensVersion: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        isMajorVersion: Swift.Bool = false,
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.isMajorVersion = isMajorVersion
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionInputBody: Swift.Equatable {
    let lensVersion: Swift.String?
    let isMajorVersion: Swift.Bool
    let clientRequestToken: Swift.String?
}

extension CreateLensVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let isMajorVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMajorVersion)
        isMajorVersion = isMajorVersionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLensVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLensVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLensVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLensVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.lensVersion = output.lensVersion
        } else {
            self.lensArn = nil
            self.lensVersion = nil
        }
    }
}

public struct CreateLensVersionOutputResponse: Swift.Equatable {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The version of the lens.
    public var lensVersion: Swift.String?

    public init (
        lensArn: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensArn = lensArn
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionOutputResponseBody: Swift.Equatable {
    let lensArn: Swift.String?
    let lensVersion: Swift.String?
}

extension CreateLensVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
    }
}

extension CreateMilestoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

extension CreateMilestoneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones"
    }
}

/// Input for milestone creation.
public struct CreateMilestoneInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct CreateMilestoneInputBody: Swift.Equatable {
    let milestoneName: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateMilestoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMilestoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMilestoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMilestoneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMilestoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a create milestone call.
public struct CreateMilestoneOutputResponse: Swift.Equatable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct CreateMilestoneOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
}

extension CreateMilestoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
    }
}

extension CreateWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension CreateWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workloads"
    }
}

/// Input for workload creation.
public struct CreateWorkloadInput: Swift.Equatable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description for the workload.
    /// This member is required.
    public var description: Swift.String?
    /// The environment for the workload.
    /// This member is required.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    /// This member is required.
    public var reviewOwner: Swift.String?
    /// The tags to be associated with the workload.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    /// This member is required.
    public var workloadName: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        lenses: [Swift.String]? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.environment = environment
        self.industry = industry
        self.industryType = industryType
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.tags = tags
        self.workloadName = workloadName
    }
}

struct CreateWorkloadInputBody: Swift.Equatable {
    let workloadName: Swift.String?
    let description: Swift.String?
    let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    let accountIds: [Swift.String]?
    let awsRegions: [Swift.String]?
    let nonAwsRegions: [Swift.String]?
    let pillarPriorities: [Swift.String]?
    let architecturalDesign: Swift.String?
    let reviewOwner: Swift.String?
    let industryType: Swift.String?
    let industry: Swift.String?
    let lenses: [Swift.String]?
    let notes: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workloadArn = output.workloadArn
            self.workloadId = output.workloadId
        } else {
            self.workloadArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a create workload call.
public struct CreateWorkloadOutputResponse: Swift.Equatable {
    /// The ARN for the workload.
    public var workloadArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        workloadArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
        self.workloadId = workloadId
    }
}

struct CreateWorkloadOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadArn: Swift.String?
}

extension CreateWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
    }
}

extension CreateWorkloadShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateWorkloadShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Permission granted on a workload share.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        sharedWith: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.permissionType = permissionType
        self.sharedWith = sharedWith
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareInputBody: Swift.Equatable {
    let sharedWith: Swift.String?
    let permissionType: WellArchitectedClientTypes.PermissionType?
    let clientRequestToken: Swift.String?
}

extension CreateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
            self.workloadId = output.workloadId
        } else {
            self.shareId = nil
            self.workloadId = nil
        }
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareOutputResponse: Swift.Equatable {
    /// The ID associated with the workload share.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let shareId: Swift.String?
}

extension CreateWorkloadShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

extension DeleteLensInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientRequestToken = clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            items.append(clientRequestTokenQueryItem)
        }
        if let lensStatus = lensStatus {
            let lensStatusQueryItem = ClientRuntime.URLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            items.append(lensStatusQueryItem)
        }
        return items
    }
}

extension DeleteLensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

public struct DeleteLensInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The status of the lens to be deleted.
    /// This member is required.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.lensStatus = lensStatus
    }
}

struct DeleteLensInputBody: Swift.Equatable {
}

extension DeleteLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLensOutputResponse: Swift.Equatable {

}

extension DeleteLensShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientRequestToken = clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            items.append(clientRequestTokenQueryItem)
        }
        return items
    }
}

extension DeleteLensShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        guard let shareId = shareId else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteLensShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.shareId = shareId
    }
}

struct DeleteLensShareInputBody: Swift.Equatable {
}

extension DeleteLensShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLensShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLensShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLensShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLensShareOutputResponse: Swift.Equatable {

}

extension DeleteWorkloadInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientRequestToken = clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            items.append(clientRequestTokenQueryItem)
        }
        return items
    }
}

extension DeleteWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input for workload deletion.
public struct DeleteWorkloadInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadInputBody: Swift.Equatable {
}

extension DeleteWorkloadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadOutputResponse: Swift.Equatable {

}

extension DeleteWorkloadShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientRequestToken = clientRequestToken {
            let clientRequestTokenQueryItem = ClientRuntime.URLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
            items.append(clientRequestTokenQueryItem)
        }
        return items
    }
}

extension DeleteWorkloadShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let shareId = shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

/// Input for Delete Workload Share
public struct DeleteWorkloadShareInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadShareInputBody: Swift.Equatable {
}

extension DeleteWorkloadShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkloadShareOutputResponse: Swift.Equatable {

}

extension WellArchitectedClientTypes {
    public enum DifferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case new
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferenceStatus] {
            return [
                .deleted,
                .new,
                .updated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .new: return "NEW"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DifferenceStatus(rawValue: rawValue) ?? DifferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateLensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensaliases0 in lensAliases {
                try lensAliasesContainer.encode(lensaliases0)
            }
        }
    }
}

extension DisassociateLensesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/disassociateLenses"
    }
}

/// Input to disassociate lens reviews.
public struct DisassociateLensesInput: Swift.Equatable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct DisassociateLensesInputBody: Swift.Equatable {
    let lensAliases: [Swift.String]?
}

extension DisassociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension DisassociateLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateLensesOutputResponse: Swift.Equatable {

}

extension ExportLensInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let lensVersion = lensVersion {
            let lensVersionQueryItem = ClientRuntime.URLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension ExportLensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/export"
    }
}

public struct ExportLensInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be exported.
    public var lensVersion: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct ExportLensInputBody: Swift.Equatable {
}

extension ExportLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensJSON = output.lensJSON
        } else {
            self.lensJSON = nil
        }
    }
}

public struct ExportLensOutputResponse: Swift.Equatable {
    /// The JSON for the lens.
    public var lensJSON: Swift.String?

    public init (
        lensJSON: Swift.String? = nil
    )
    {
        self.lensJSON = lensJSON
    }
}

struct ExportLensOutputResponseBody: Swift.Equatable {
    let lensJSON: Swift.String?
}

extension ExportLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensJSON = "LensJSON"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensJSON)
        lensJSON = lensJSONDecoded
    }
}

extension GetAnswerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetAnswerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        guard let questionId = questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

/// Input to get answer.
public struct GetAnswerInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct GetAnswerInputBody: Swift.Equatable {
}

extension GetAnswerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnswerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnswerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnswerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnswerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnswerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get answer call.
public struct GetAnswerOutputResponse: Swift.Equatable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetAnswerOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answer: WellArchitectedClientTypes.Answer?
}

extension GetAnswerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

extension GetLensInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let lensVersion = lensVersion {
            let lensVersionQueryItem = ClientRuntime.URLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension GetLensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

public struct GetLensInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be retrieved.
    public var lensVersion: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct GetLensInputBody: Swift.Equatable {
}

extension GetLensInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lens = output.lens
        } else {
            self.lens = nil
        }
    }
}

public struct GetLensOutputResponse: Swift.Equatable {
    /// A lens return object.
    public var lens: WellArchitectedClientTypes.Lens?

    public init (
        lens: WellArchitectedClientTypes.Lens? = nil
    )
    {
        self.lens = lens
    }
}

struct GetLensOutputResponseBody: Swift.Equatable {
    let lens: WellArchitectedClientTypes.Lens?
}

extension GetLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lens = "Lens"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Lens.self, forKey: .lens)
        lens = lensDecoded
    }
}

extension GetLensReviewInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensReviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

/// Input to get lens review.
public struct GetLensReviewInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewInputBody: Swift.Equatable {
}

extension GetLensReviewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review call.
public struct GetLensReviewOutputResponse: Swift.Equatable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensReview: WellArchitectedClientTypes.LensReview?
}

extension GetLensReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

extension GetLensReviewReportInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensReviewReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/report"
    }
}

/// Input to get lens review report.
public struct GetLensReviewReportInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportInputBody: Swift.Equatable {
}

extension GetLensReviewReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensReviewReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensReviewReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensReviewReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensReviewReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewReport = output.lensReviewReport
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReviewReport = nil
            self.milestoneNumber = 0
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review report call.
public struct GetLensReviewReportOutputResponse: Swift.Equatable {
    /// A report of a lens review.
    public var lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReviewReport: WellArchitectedClientTypes.LensReviewReport? = nil,
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewReport = lensReviewReport
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
}

extension GetLensReviewReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewReport = "LensReviewReport"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewReportDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReviewReport.self, forKey: .lensReviewReport)
        lensReviewReport = lensReviewReportDecoded
    }
}

extension GetLensVersionDifferenceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let baseLensVersion = baseLensVersion {
            let baseLensVersionQueryItem = ClientRuntime.URLQueryItem(name: "BaseLensVersion".urlPercentEncoding(), value: Swift.String(baseLensVersion).urlPercentEncoding())
            items.append(baseLensVersionQueryItem)
        }
        if let targetLensVersion = targetLensVersion {
            let targetLensVersionQueryItem = ClientRuntime.URLQueryItem(name: "TargetLensVersion".urlPercentEncoding(), value: Swift.String(targetLensVersion).urlPercentEncoding())
            items.append(targetLensVersionQueryItem)
        }
        return items
    }
}

extension GetLensVersionDifferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versionDifference"
    }
}

public struct GetLensVersionDifferenceInput: Swift.Equatable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to target a difference for.
    public var targetLensVersion: Swift.String?

    public init (
        baseLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.lensAlias = lensAlias
        self.targetLensVersion = targetLensVersion
    }
}

struct GetLensVersionDifferenceInputBody: Swift.Equatable {
}

extension GetLensVersionDifferenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLensVersionDifferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLensVersionDifferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLensVersionDifferenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLensVersionDifferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLensVersionDifferenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.baseLensVersion = output.baseLensVersion
            self.latestLensVersion = output.latestLensVersion
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.targetLensVersion = output.targetLensVersion
            self.versionDifferences = output.versionDifferences
        } else {
            self.baseLensVersion = nil
            self.latestLensVersion = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.targetLensVersion = nil
            self.versionDifferences = nil
        }
    }
}

public struct GetLensVersionDifferenceOutputResponse: Swift.Equatable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The latest version of the lens.
    public var latestLensVersion: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The target lens version for the lens.
    public var targetLensVersion: Swift.String?
    /// The differences between the base and latest versions of the lens.
    public var versionDifferences: WellArchitectedClientTypes.VersionDifferences?

    public init (
        baseLensVersion: Swift.String? = nil,
        latestLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil,
        versionDifferences: WellArchitectedClientTypes.VersionDifferences? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.targetLensVersion = targetLensVersion
        self.versionDifferences = versionDifferences
    }
}

struct GetLensVersionDifferenceOutputResponseBody: Swift.Equatable {
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let baseLensVersion: Swift.String?
    let targetLensVersion: Swift.String?
    let latestLensVersion: Swift.String?
    let versionDifferences: WellArchitectedClientTypes.VersionDifferences?
}

extension GetLensVersionDifferenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseLensVersion = "BaseLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case targetLensVersion = "TargetLensVersion"
        case versionDifferences = "VersionDifferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let baseLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseLensVersion)
        baseLensVersion = baseLensVersionDecoded
        let targetLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLensVersion)
        targetLensVersion = targetLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
        let versionDifferencesDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.VersionDifferences.self, forKey: .versionDifferences)
        versionDifferences = versionDifferencesDecoded
    }
}

extension GetMilestoneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones/\(milestoneNumber)"
    }
}

/// Input to get a milestone.
public struct GetMilestoneInput: Swift.Equatable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    /// This member is required.
    public var milestoneNumber: Swift.Int
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        milestoneNumber: Swift.Int = 0,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetMilestoneInputBody: Swift.Equatable {
}

extension GetMilestoneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMilestoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMilestoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMilestoneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMilestoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMilestoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestone = output.milestone
            self.workloadId = output.workloadId
        } else {
            self.milestone = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get milestone call.
public struct GetMilestoneOutputResponse: Swift.Equatable {
    /// A milestone return object.
    public var milestone: WellArchitectedClientTypes.Milestone?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestone: WellArchitectedClientTypes.Milestone? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestone = milestone
        self.workloadId = workloadId
    }
}

struct GetMilestoneOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestone: WellArchitectedClientTypes.Milestone?
}

extension GetMilestoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestone = "Milestone"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Milestone.self, forKey: .milestone)
        milestone = milestoneDecoded
    }
}

extension GetWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input to get a workload.
public struct GetWorkloadInput: Swift.Equatable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        workloadId: Swift.String? = nil
    )
    {
        self.workloadId = workloadId
    }
}

struct GetWorkloadInputBody: Swift.Equatable {
}

extension GetWorkloadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of a get workload call.
public struct GetWorkloadOutputResponse: Swift.Equatable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init (
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct GetWorkloadOutputResponseBody: Swift.Equatable {
    let workload: WellArchitectedClientTypes.Workload?
}

extension GetWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension ImportLensInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jSONString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let jSONString = jSONString {
            try encodeContainer.encode(jSONString, forKey: .jSONString)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ImportLensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/importLens"
    }
}

public struct ImportLensInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The JSON representation of a lens.
    /// This member is required.
    public var jSONString: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// Tags to associate to a lens.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        jSONString: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.jSONString = jSONString
        self.lensAlias = lensAlias
        self.tags = tags
    }
}

struct ImportLensInputBody: Swift.Equatable {
    let lensAlias: Swift.String?
    let jSONString: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ImportLensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jSONString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let jSONStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jSONString)
        jSONString = jSONStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportLensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportLensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportLensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportLensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportLensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.status = output.status
        } else {
            self.lensArn = nil
            self.status = nil
        }
    }
}

public struct ImportLensOutputResponse: Swift.Equatable {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The status of the imported lens.
    public var status: WellArchitectedClientTypes.ImportLensStatus?

    public init (
        lensArn: Swift.String? = nil,
        status: WellArchitectedClientTypes.ImportLensStatus? = nil
    )
    {
        self.lensArn = lensArn
        self.status = status
    }
}

struct ImportLensOutputResponseBody: Swift.Equatable {
    let lensArn: Swift.String?
    let status: WellArchitectedClientTypes.ImportLensStatus?
}

extension ImportLensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ImportLensStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes {
    public enum ImportLensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportLensStatus] {
            return [
                .complete,
                .error,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportLensStatus(rawValue: rawValue) ?? ImportLensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ImprovementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementPlanUrl = "ImprovementPlanUrl"
        case improvementPlans = "ImprovementPlans"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementPlanUrl = improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let improvementPlans = improvementPlans {
            var improvementPlansContainer = encodeContainer.nestedUnkeyedContainer(forKey: .improvementPlans)
            for choiceimprovementplans0 in improvementPlans {
                try improvementPlansContainer.encode(choiceimprovementplans0)
            }
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let improvementPlansContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceImprovementPlan?].self, forKey: .improvementPlans)
        var improvementPlansDecoded0:[WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil
        if let improvementPlansContainer = improvementPlansContainer {
            improvementPlansDecoded0 = [WellArchitectedClientTypes.ChoiceImprovementPlan]()
            for structure0 in improvementPlansContainer {
                if let structure0 = structure0 {
                    improvementPlansDecoded0?.append(structure0)
                }
            }
        }
        improvementPlans = improvementPlansDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// An improvement summary of a lens review in a workload.
    public struct ImprovementSummary: Swift.Equatable {
        /// The improvement plan URL for a question. This value is only available if the question has been answered.
        public var improvementPlanUrl: Swift.String?
        /// The improvement plan details.
        public var improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init (
            improvementPlanUrl: Swift.String? = nil,
            improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.improvementPlanUrl = improvementPlanUrl
            self.improvementPlans = improvementPlans
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.risk = risk
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a problem with the Well-Architected Tool API service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.Lens: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
        case name = "Name"
        case owner = "Owner"
        case shareInvitationId = "ShareInvitationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens return object.
    public struct Lens: Swift.Equatable {
        /// The description of the lens.
        public var description: Swift.String?
        /// The ARN of a lens.
        public var lensArn: Swift.String?
        /// The version of a lens.
        public var lensVersion: Swift.String?
        /// The full name of the lens.
        public var name: Swift.String?
        /// The Amazon Web Services account ID that owns the lens.
        public var owner: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?

        public init (
            description: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil
        )
        {
            self.description = description
            self.lensArn = lensArn
            self.lensVersion = lensVersion
            self.name = name
            self.owner = owner
            self.shareInvitationId = shareInvitationId
        }
    }

}

extension WellArchitectedClientTypes.LensReview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case nextToken = "NextToken"
        case notes = "Notes"
        case pillarReviewSummaries = "PillarReviewSummaries"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarReviewSummaries = pillarReviewSummaries {
            var pillarReviewSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarReviewSummaries)
            for pillarreviewsummaries0 in pillarReviewSummaries {
                try pillarReviewSummariesContainer.encode(pillarreviewsummaries0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let pillarReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarReviewSummary?].self, forKey: .pillarReviewSummaries)
        var pillarReviewSummariesDecoded0:[WellArchitectedClientTypes.PillarReviewSummary]? = nil
        if let pillarReviewSummariesContainer = pillarReviewSummariesContainer {
            pillarReviewSummariesDecoded0 = [WellArchitectedClientTypes.PillarReviewSummary]()
            for structure0 in pillarReviewSummariesContainer {
                if let structure0 = structure0 {
                    pillarReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        pillarReviewSummaries = pillarReviewSummariesDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens review of a question.
    public struct LensReview: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// List of pillar review summaries of lens review in a workload.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensReviewReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base64String = "Base64String"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base64String = base64String {
            try encodeContainer.encode(base64String, forKey: .base64String)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let base64StringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .base64String)
        base64String = base64StringDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A report of a lens review.
    public struct LensReviewReport: Swift.Equatable {
        /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file.
        public var base64String: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?

        public init (
            base64String: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil
        )
        {
            self.base64String = base64String
            self.lensAlias = lensAlias
            self.lensArn = lensArn
        }
    }

}

extension WellArchitectedClientTypes.LensReviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A lens review summary of a workload.
    public struct LensReviewSummary: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens share summary return object.
    public struct LensShareSummary: Swift.Equatable {
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?

        public init (
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case deleted
        case deprecated
        case notCurrent
        case unshared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatus] {
            return [
                .current,
                .deleted,
                .deprecated,
                .notCurrent,
                .unshared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .notCurrent: return "NOT_CURRENT"
            case .unshared: return "UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatus(rawValue: rawValue) ?? LensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum LensStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatusType] {
            return [
                .all,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatusType(rawValue: rawValue) ?? LensStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensType = "LensType"
        case lensVersion = "LensVersion"
        case owner = "Owner"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensType = lensType {
            try encodeContainer.encode(lensType.rawValue, forKey: .lensType)
        }
        if let lensVersion = lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensType.self, forKey: .lensType)
        lensType = lensTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens summary of a lens.
    public struct LensSummary: Swift.Equatable {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// The description of the lens.
        public var description: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN of the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The type of the lens.
        public var lensType: WellArchitectedClientTypes.LensType?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensType: WellArchitectedClientTypes.LensType? = nil,
            lensVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.lensVersion = lensVersion
            self.owner = owner
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOfficial
        case customSelf
        case customShared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensType] {
            return [
                .awsOfficial,
                .customSelf,
                .customShared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOfficial: return "AWS_OFFICIAL"
            case .customSelf: return "CUSTOM_SELF"
            case .customShared: return "CUSTOM_SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensType(rawValue: rawValue) ?? LensType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensUpgradeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLensVersion = "CurrentLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLensVersion = currentLensVersion {
            try encodeContainer.encode(currentLensVersion, forKey: .currentLensVersion)
        }
        if let latestLensVersion = latestLensVersion {
            try encodeContainer.encode(latestLensVersion, forKey: .latestLensVersion)
        }
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let currentLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLensVersion)
        currentLensVersion = currentLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Lens upgrade summary return object.
    public struct LensUpgradeSummary: Swift.Equatable {
        /// The current version of the lens.
        public var currentLensVersion: Swift.String?
        /// The latest version of the lens.
        public var latestLensVersion: Swift.String?
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            currentLensVersion: Swift.String? = nil,
            latestLensVersion: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentLensVersion = currentLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension ListAnswersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let pillarId = pillarId {
            let pillarIdQueryItem = ClientRuntime.URLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListAnswersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
    }
}

/// Input to list answers.
public struct ListAnswersInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListAnswersInputBody: Swift.Equatable {
}

extension ListAnswersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnswersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnswersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnswersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnswersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnswersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answerSummaries = output.answerSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.answerSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list answers call.
public struct ListAnswersOutputResponse: Swift.Equatable {
    /// List of answer summaries of lens review in a workload.
    public var answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answerSummaries: [WellArchitectedClientTypes.AnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListAnswersOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    let nextToken: Swift.String?
}

extension ListAnswersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerSummaries = "AnswerSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.AnswerSummary?].self, forKey: .answerSummaries)
        var answerSummariesDecoded0:[WellArchitectedClientTypes.AnswerSummary]? = nil
        if let answerSummariesContainer = answerSummariesContainer {
            answerSummariesDecoded0 = [WellArchitectedClientTypes.AnswerSummary]()
            for structure0 in answerSummariesContainer {
                if let structure0 = structure0 {
                    answerSummariesDecoded0?.append(structure0)
                }
            }
        }
        answerSummaries = answerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewImprovementsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let pillarId = pillarId {
            let pillarIdQueryItem = ClientRuntime.URLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensReviewImprovementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/improvements"
    }
}

/// Input to list lens review improvements.
public struct ListLensReviewImprovementsInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsInputBody: Swift.Equatable {
}

extension ListLensReviewImprovementsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewImprovementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewImprovementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewImprovementsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewImprovementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensReviewImprovementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.improvementSummaries = output.improvementSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.improvementSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens review improvements call.
public struct ListLensReviewImprovementsOutputResponse: Swift.Equatable {
    /// List of improvement summaries of lens review in a workload.
    public var improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.improvementSummaries = improvementSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    let nextToken: Swift.String?
}

extension ListLensReviewImprovementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementSummaries = "ImprovementSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let improvementSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ImprovementSummary?].self, forKey: .improvementSummaries)
        var improvementSummariesDecoded0:[WellArchitectedClientTypes.ImprovementSummary]? = nil
        if let improvementSummariesContainer = improvementSummariesContainer {
            improvementSummariesDecoded0 = [WellArchitectedClientTypes.ImprovementSummary]()
            for structure0 in improvementSummariesContainer {
                if let structure0 = structure0 {
                    improvementSummariesDecoded0?.append(structure0)
                }
            }
        }
        improvementSummaries = improvementSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensReviewsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if milestoneNumber != 0 {
            let milestoneNumberQueryItem = ClientRuntime.URLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensReviewsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews"
    }
}

/// Input to list lens reviews.
public struct ListLensReviewsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsInputBody: Swift.Equatable {
}

extension ListLensReviewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensReviewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensReviewsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensReviewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensReviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewSummaries = output.lensReviewSummaries
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.lensReviewSummaries = nil
            self.milestoneNumber = 0
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens reviews call.
public struct ListLensReviewsOutputResponse: Swift.Equatable {
    /// List of lens summaries of lens reviews of a workload.
    public var lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]? = nil,
        milestoneNumber: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewSummaries = lensReviewSummaries
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int
    let lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    let nextToken: Swift.String?
}

extension ListLensReviewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewSummaries = "LensReviewSummaries"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensReviewSummary?].self, forKey: .lensReviewSummaries)
        var lensReviewSummariesDecoded0:[WellArchitectedClientTypes.LensReviewSummary]? = nil
        if let lensReviewSummariesContainer = lensReviewSummariesContainer {
            lensReviewSummariesDecoded0 = [WellArchitectedClientTypes.LensReviewSummary]()
            for structure0 in lensReviewSummariesContainer {
                if let structure0 = structure0 {
                    lensReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensReviewSummaries = lensReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensSharesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let sharedWithPrefix = sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.URLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLensSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

public struct ListLensSharesInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the lens is shared.
    public var sharedWithPrefix: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
    }
}

struct ListLensSharesInputBody: Swift.Equatable {
}

extension ListLensSharesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensSharesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensShareSummaries = output.lensShareSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensShareSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLensSharesOutputResponse: Swift.Equatable {
    /// A list of lens share summaries.
    public var lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensShareSummaries = lensShareSummaries
        self.nextToken = nextToken
    }
}

struct ListLensSharesOutputResponseBody: Swift.Equatable {
    let lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    let nextToken: Swift.String?
}

extension ListLensSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensShareSummaries = "LensShareSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensShareSummary?].self, forKey: .lensShareSummaries)
        var lensShareSummariesDecoded0:[WellArchitectedClientTypes.LensShareSummary]? = nil
        if let lensShareSummariesContainer = lensShareSummariesContainer {
            lensShareSummariesDecoded0 = [WellArchitectedClientTypes.LensShareSummary]()
            for structure0 in lensShareSummariesContainer {
                if let structure0 = structure0 {
                    lensShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensShareSummaries = lensShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLensesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let lensName = lensName {
            let lensNameQueryItem = ClientRuntime.URLQueryItem(name: "LensName".urlPercentEncoding(), value: Swift.String(lensName).urlPercentEncoding())
            items.append(lensNameQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let lensType = lensType {
            let lensTypeQueryItem = ClientRuntime.URLQueryItem(name: "LensType".urlPercentEncoding(), value: Swift.String(lensType.rawValue).urlPercentEncoding())
            items.append(lensTypeQueryItem)
        }
        if let lensStatus = lensStatus {
            let lensStatusQueryItem = ClientRuntime.URLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            items.append(lensStatusQueryItem)
        }
        return items
    }
}

extension ListLensesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/lenses"
    }
}

/// Input to list lenses.
public struct ListLensesInput: Swift.Equatable {
    /// The full name of the lens.
    public var lensName: Swift.String?
    /// The status of lenses to be returned.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?
    /// The type of lenses to be returned.
    public var lensType: WellArchitectedClientTypes.LensType?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensName: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil,
        lensType: WellArchitectedClientTypes.LensType? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensType = lensType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLensesInputBody: Swift.Equatable {
}

extension ListLensesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLensesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensSummaries = output.lensSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensSummaries = nil
            self.nextToken = nil
        }
    }
}

/// Output of a list lenses call.
public struct ListLensesOutputResponse: Swift.Equatable {
    /// List of lens summaries of available lenses.
    public var lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        lensSummaries: [WellArchitectedClientTypes.LensSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensSummaries = lensSummaries
        self.nextToken = nextToken
    }
}

struct ListLensesOutputResponseBody: Swift.Equatable {
    let lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    let nextToken: Swift.String?
}

extension ListLensesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensSummaries = "LensSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensSummary?].self, forKey: .lensSummaries)
        var lensSummariesDecoded0:[WellArchitectedClientTypes.LensSummary]? = nil
        if let lensSummariesContainer = lensSummariesContainer {
            lensSummariesDecoded0 = [WellArchitectedClientTypes.LensSummary]()
            for structure0 in lensSummariesContainer {
                if let structure0 = structure0 {
                    lensSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensSummaries = lensSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMilestonesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMilestonesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestonesSummaries"
    }
}

/// Input to list all milestones for a workload.
public struct ListMilestonesInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListMilestonesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMilestonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMilestonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMilestonesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMilestonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMilestonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.milestoneSummaries = output.milestoneSummaries
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.milestoneSummaries = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list milestones call.
public struct ListMilestonesOutputResponse: Swift.Equatable {
    /// A list of milestone summaries.
    public var milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneSummaries = milestoneSummaries
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    let nextToken: Swift.String?
}

extension ListMilestonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneSummaries = "MilestoneSummaries"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.MilestoneSummary?].self, forKey: .milestoneSummaries)
        var milestoneSummariesDecoded0:[WellArchitectedClientTypes.MilestoneSummary]? = nil
        if let milestoneSummariesContainer = milestoneSummariesContainer {
            milestoneSummariesDecoded0 = [WellArchitectedClientTypes.MilestoneSummary]()
            for structure0 in milestoneSummariesContainer {
                if let structure0 = structure0 {
                    milestoneSummariesDecoded0?.append(structure0)
                }
            }
        }
        milestoneSummaries = milestoneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

extension ListNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/notifications"
    }
}

public struct ListNotificationsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListNotificationsInputBody: Swift.Equatable {
    let workloadId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notificationSummaries = output.notificationSummaries
        } else {
            self.nextToken = nil
            self.notificationSummaries = nil
        }
    }
}

public struct ListNotificationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of lens notification summaries in a workload.
    public var notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

struct ListNotificationsOutputResponseBody: Swift.Equatable {
    let notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?
    let nextToken: Swift.String?
}

extension ListNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notificationSummaries = "NotificationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.NotificationSummary?].self, forKey: .notificationSummaries)
        var notificationSummariesDecoded0:[WellArchitectedClientTypes.NotificationSummary]? = nil
        if let notificationSummariesContainer = notificationSummariesContainer {
            notificationSummariesDecoded0 = [WellArchitectedClientTypes.NotificationSummary]()
            for structure0 in notificationSummariesContainer {
                if let structure0 = structure0 {
                    notificationSummariesDecoded0?.append(structure0)
                }
            }
        }
        notificationSummaries = notificationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListShareInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let lensNamePrefix = lensNamePrefix {
            let lensNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "LensNamePrefix".urlPercentEncoding(), value: Swift.String(lensNamePrefix).urlPercentEncoding())
            items.append(lensNamePrefixQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let shareResourceType = shareResourceType {
            let shareResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "ShareResourceType".urlPercentEncoding(), value: Swift.String(shareResourceType.rawValue).urlPercentEncoding())
            items.append(shareResourceTypeQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let workloadNamePrefix = workloadNamePrefix {
            let workloadNamePrefixQueryItem = ClientRuntime.URLQueryItem(name: "WorkloadNamePrefix".urlPercentEncoding(), value: Swift.String(workloadNamePrefix).urlPercentEncoding())
            items.append(workloadNamePrefixQueryItem)
        }
        return items
    }
}

extension ListShareInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/shareInvitations"
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsInput: Swift.Equatable {
    /// An optional string added to the beginning of each lens name returned in the results.
    public var lensNamePrefix: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of share invitations to be returned.
    public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init (
        lensNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.lensNamePrefix = lensNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shareResourceType = shareResourceType
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListShareInvitationsInputBody: Swift.Equatable {
}

extension ListShareInvitationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListShareInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListShareInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListShareInvitationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.shareInvitationSummaries = output.shareInvitationSummaries
        } else {
            self.nextToken = nil
            self.shareInvitationSummaries = nil
        }
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of share invitation summaries in a workload.
    public var shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.shareInvitationSummaries = shareInvitationSummaries
    }
}

struct ListShareInvitationsOutputResponseBody: Swift.Equatable {
    let shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?
    let nextToken: Swift.String?
}

extension ListShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case shareInvitationSummaries = "ShareInvitationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ShareInvitationSummary?].self, forKey: .shareInvitationSummaries)
        var shareInvitationSummariesDecoded0:[WellArchitectedClientTypes.ShareInvitationSummary]? = nil
        if let shareInvitationSummariesContainer = shareInvitationSummariesContainer {
            shareInvitationSummariesDecoded0 = [WellArchitectedClientTypes.ShareInvitationSummary]()
            for structure0 in shareInvitationSummariesContainer {
                if let structure0 = structure0 {
                    shareInvitationSummariesDecoded0?.append(structure0)
                }
            }
        }
        shareInvitationSummaries = shareInvitationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadArn = workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        workloadArn: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWorkloadSharesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let sharedWithPrefix = sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.URLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkloadSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID or IAM role with which the workload is shared.
    public var sharedWithPrefix: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.workloadId = workloadId
    }
}

struct ListWorkloadSharesInputBody: Swift.Equatable {
}

extension ListWorkloadSharesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkloadSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadSharesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkloadSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
            self.workloadShareSummaries = output.workloadShareSummaries
        } else {
            self.nextToken = nil
            self.workloadId = nil
            self.workloadShareSummaries = nil
        }
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A list of workload share summaries.
    public var workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadId = workloadId
        self.workloadShareSummaries = workloadShareSummaries
    }
}

struct ListWorkloadSharesOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
        case workloadShareSummaries = "WorkloadShareSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadShareSummary?].self, forKey: .workloadShareSummaries)
        var workloadShareSummariesDecoded0:[WellArchitectedClientTypes.WorkloadShareSummary]? = nil
        if let workloadShareSummariesContainer = workloadShareSummariesContainer {
            workloadShareSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadShareSummary]()
            for structure0 in workloadShareSummariesContainer {
                if let structure0 = structure0 {
                    workloadShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadShareSummaries = workloadShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkloadsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadNamePrefix = workloadNamePrefix {
            try encodeContainer.encode(workloadNamePrefix, forKey: .workloadNamePrefix)
        }
    }
}

extension ListWorkloadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workloadsSummaries"
    }
}

/// Input to list all workloads.
public struct ListWorkloadsInput: Swift.Equatable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListWorkloadsInputBody: Swift.Equatable {
    let workloadNamePrefix: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListWorkloadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadNamePrefix)
        workloadNamePrefix = workloadNamePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkloadsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkloadsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkloadsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkloadsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkloadsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadSummaries = output.workloadSummaries
        } else {
            self.nextToken = nil
            self.workloadSummaries = nil
        }
    }
}

/// Output of a list workloads call.
public struct ListWorkloadsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of workload summaries.
    public var workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadSummaries = workloadSummaries
    }
}

struct ListWorkloadsOutputResponseBody: Swift.Equatable {
    let workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadSummaries = "WorkloadSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadSummary?].self, forKey: .workloadSummaries)
        var workloadSummariesDecoded0:[WellArchitectedClientTypes.WorkloadSummary]? = nil
        if let workloadSummariesContainer = workloadSummariesContainer {
            workloadSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadSummary]()
            for structure0 in workloadSummariesContainer {
                if let structure0 = structure0 {
                    workloadSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadSummaries = workloadSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WellArchitectedClientTypes.Milestone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workload = "Workload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workload = workload {
            try encodeContainer.encode(workload, forKey: .workload)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A milestone return object.
    public struct Milestone: Swift.Equatable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload return object.
        public var workload: WellArchitectedClientTypes.Workload?

        public init (
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int = 0,
            recordedAt: ClientRuntime.Date? = nil,
            workload: WellArchitectedClientTypes.Workload? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workload = workload
        }
    }

}

extension WellArchitectedClientTypes.MilestoneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workloadSummary = "WorkloadSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if milestoneNumber != 0 {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = recordedAt {
            try encodeContainer.encode(recordedAt.timeIntervalSince1970, forKey: .recordedAt)
        }
        if let workloadSummary = workloadSummary {
            try encodeContainer.encode(workloadSummary, forKey: .workloadSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadSummary.self, forKey: .workloadSummary)
        workloadSummary = workloadSummaryDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A milestone summary return object.
    public struct MilestoneSummary: Swift.Equatable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload summary return object.
        public var workloadSummary: WellArchitectedClientTypes.WorkloadSummary?

        public init (
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int = 0,
            recordedAt: ClientRuntime.Date? = nil,
            workloadSummary: WellArchitectedClientTypes.WorkloadSummary? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workloadSummary = workloadSummary
        }
    }

}

extension WellArchitectedClientTypes.NotificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensUpgradeSummary = "LensUpgradeSummary"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensUpgradeSummary = lensUpgradeSummary {
            try encodeContainer.encode(lensUpgradeSummary, forKey: .lensUpgradeSummary)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.NotificationType.self, forKey: .type)
        type = typeDecoded
        let lensUpgradeSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensUpgradeSummary.self, forKey: .lensUpgradeSummary)
        lensUpgradeSummary = lensUpgradeSummaryDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A notification summary return object.
    public struct NotificationSummary: Swift.Equatable {
        /// Summary of lens upgrade.
        public var lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary?
        /// The type of notification.
        public var type: WellArchitectedClientTypes.NotificationType?

        public init (
            lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary? = nil,
            type: WellArchitectedClientTypes.NotificationType? = nil
        )
        {
            self.lensUpgradeSummary = lensUpgradeSummary
            self.type = type
        }
    }

}

extension WellArchitectedClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lensVersionDeprecated
        case lensVersionUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .lensVersionDeprecated,
                .lensVersionUpgraded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lensVersionDeprecated: return "LENS_VERSION_DEPRECATED"
            case .lensVersionUpgraded: return "LENS_VERSION_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// Permission granted on a workload share.
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .contributor,
                .readonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.PillarDifference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case questionDifferences = "QuestionDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let questionDifferences = questionDifferences {
            var questionDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionDifferences)
            for questiondifferences0 in questionDifferences {
                try questionDifferencesContainer.encode(questiondifferences0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
        let questionDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.QuestionDifference?].self, forKey: .questionDifferences)
        var questionDifferencesDecoded0:[WellArchitectedClientTypes.QuestionDifference]? = nil
        if let questionDifferencesContainer = questionDifferencesContainer {
            questionDifferencesDecoded0 = [WellArchitectedClientTypes.QuestionDifference]()
            for structure0 in questionDifferencesContainer {
                if let structure0 = structure0 {
                    questionDifferencesDecoded0?.append(structure0)
                }
            }
        }
        questionDifferences = questionDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A pillar difference return object.
    public struct PillarDifference: Swift.Equatable {
        /// Indicates the type of change to the pillar.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// List of question differences.
        public var questionDifferences: [WellArchitectedClientTypes.QuestionDifference]?

        public init (
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionDifferences: [WellArchitectedClientTypes.QuestionDifference]? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionDifferences = questionDifferences
        }
    }

}

extension WellArchitectedClientTypes.PillarReviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A pillar review summary of a lens review.
    public struct PillarReviewSummary: Swift.Equatable {
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?

        public init (
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.riskCounts = riskCounts
        }
    }

}

extension WellArchitectedClientTypes.QuestionDifference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let questionId = questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A question difference return object.
    public struct QuestionDifference: Swift.Equatable {
        /// Indicates the type of change to the question.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init (
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The risk for a given workload, lens review, pillar, or question.
    public enum Risk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case `none`
        case notApplicable
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Risk] {
            return [
                .high,
                .medium,
                .none,
                .notApplicable,
                .unanswered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .notApplicable: return "NOT_APPLICABLE"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Risk(rawValue: rawValue) ?? Risk.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user has reached their resource quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?
    /// Service Quotas requirement to identify originating service.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension WellArchitectedClientTypes.ShareInvitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The share invitation.
    public struct ShareInvitation: Swift.Equatable {
        /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?

        public init (
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            workloadId: Swift.String? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.workloadId = workloadId
        }
    }

}

extension WellArchitectedClientTypes {
    /// Share invitation action taken by contributor.
    public enum ShareInvitationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareInvitationAction] {
            return [
                .accept,
                .reject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareInvitationAction(rawValue: rawValue) ?? ShareInvitationAction.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ShareInvitationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensName = "LensName"
        case permissionType = "PermissionType"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensArn = lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A share invitation summary return object.
    public struct ShareInvitationSummary: Swift.Equatable {
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lensArn = lensArn
            self.lensName = lensName
            self.permissionType = permissionType
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ShareResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lens
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareResourceType] {
            return [
                .lens,
                .workload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lens: return "LENS"
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareResourceType(rawValue: rawValue) ?? ShareResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The status of a workload share.
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadArn = workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        tags: [Swift.String:Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tags = tags
        self.workloadArn = workloadArn
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    public var quotaCode: Swift.String?
    /// Service Quotas requirement to identify originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadArn = workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init (
        tagKeys: [Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.workloadArn = workloadArn
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAnswerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceUpdates = choiceUpdates {
            var choiceUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .choiceUpdates)
            for (dictKey0, choiceupdates0) in choiceUpdates {
                try choiceUpdatesContainer.encode(choiceupdates0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }
}

extension UpdateAnswerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        guard let questionId = questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

/// Input to update answer.
public struct UpdateAnswerInput: Swift.Equatable {
    /// A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.
    public var choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The reason why a question is not applicable to your workload.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool = false,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.workloadId = workloadId
    }
}

struct UpdateAnswerInputBody: Swift.Equatable {
    let selectedChoices: [Swift.String]?
    let choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    let notes: Swift.String?
    let isApplicable: Swift.Bool
    let reason: WellArchitectedClientTypes.AnswerReason?
}

extension UpdateAnswerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: WellArchitectedClientTypes.ChoiceUpdate?].self, forKey: .choiceUpdates)
        var choiceUpdatesDecoded0: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil
        if let choiceUpdatesContainer = choiceUpdatesContainer {
            choiceUpdatesDecoded0 = [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]()
            for (key0, choiceupdate0) in choiceUpdatesContainer {
                if let choiceupdate0 = choiceupdate0 {
                    choiceUpdatesDecoded0?[key0] = choiceupdate0
                }
            }
        }
        choiceUpdates = choiceUpdatesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let isApplicableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UpdateAnswerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnswerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnswerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnswerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnswerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update answer call.
public struct UpdateAnswerOutputResponse: Swift.Equatable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.workloadId = workloadId
    }
}

struct UpdateAnswerOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answer: WellArchitectedClientTypes.Answer?
}

extension UpdateAnswerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

extension UpdateLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensNotes = lensNotes {
            try encodeContainer.encode(lensNotes, forKey: .lensNotes)
        }
        if let pillarNotes = pillarNotes {
            var pillarNotesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pillarNotes)
            for (dictKey0, pillarnotes0) in pillarNotes {
                try pillarNotesContainer.encode(pillarnotes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateLensReviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

/// Input for update lens review.
public struct UpdateLensReviewInput: Swift.Equatable {
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload.
    public var pillarNotes: [Swift.String:Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String:Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewInputBody: Swift.Equatable {
    let lensNotes: Swift.String?
    let pillarNotes: [Swift.String:Swift.String]?
}

extension UpdateLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensNotes)
        lensNotes = lensNotesDecoded
        let pillarNotesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pillarNotes)
        var pillarNotesDecoded0: [Swift.String:Swift.String]? = nil
        if let pillarNotesContainer = pillarNotesContainer {
            pillarNotesDecoded0 = [Swift.String:Swift.String]()
            for (key0, notes0) in pillarNotesContainer {
                if let notes0 = notes0 {
                    pillarNotesDecoded0?[key0] = notes0
                }
            }
        }
        pillarNotes = pillarNotesDecoded0
    }
}

extension UpdateLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLensReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update lens review call.
public struct UpdateLensReviewOutputResponse: Swift.Equatable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init (
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let lensReview: WellArchitectedClientTypes.LensReview?
}

extension UpdateLensReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case workloadId = "WorkloadId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

extension UpdateShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareInvitationAction = shareInvitationAction {
            try encodeContainer.encode(shareInvitationAction.rawValue, forKey: .shareInvitationAction)
        }
    }
}

extension UpdateShareInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let shareInvitationId = shareInvitationId else {
            return nil
        }
        return "/shareInvitations/\(shareInvitationId.urlPercentEncoding())"
    }
}

/// Input for Update Share Invitation
public struct UpdateShareInvitationInput: Swift.Equatable {
    /// Share invitation action taken by contributor.
    /// This member is required.
    public var shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
    /// The ID assigned to the share invitation.
    /// This member is required.
    public var shareInvitationId: Swift.String?

    public init (
        shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction? = nil,
        shareInvitationId: Swift.String? = nil
    )
    {
        self.shareInvitationAction = shareInvitationAction
        self.shareInvitationId = shareInvitationId
    }
}

struct UpdateShareInvitationInputBody: Swift.Equatable {
    let shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
}

extension UpdateShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationActionDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitationAction.self, forKey: .shareInvitationAction)
        shareInvitationAction = shareInvitationActionDecoded
    }
}

extension UpdateShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareInvitation = output.shareInvitation
        } else {
            self.shareInvitation = nil
        }
    }
}

public struct UpdateShareInvitationOutputResponse: Swift.Equatable {
    /// The updated workload share invitation.
    public var shareInvitation: WellArchitectedClientTypes.ShareInvitation?

    public init (
        shareInvitation: WellArchitectedClientTypes.ShareInvitation? = nil
    )
    {
        self.shareInvitation = shareInvitation
    }
}

struct UpdateShareInvitationOutputResponseBody: Swift.Equatable {
    let shareInvitation: WellArchitectedClientTypes.ShareInvitation?
}

extension UpdateShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitation = "ShareInvitation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitation.self, forKey: .shareInvitation)
        shareInvitation = shareInvitationDecoded
    }
}

extension UpdateWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension UpdateWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input to update a workload.
public struct UpdateWorkloadInput: Swift.Equatable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// The description for the workload.
    public var description: Swift.String?
    /// The environment for the workload.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The improvement status for a workload.
    public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
    public var isReviewOwnerUpdateAcknowledged: Swift.Bool
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    public var workloadName: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        isReviewOwnerUpdateAcknowledged: Swift.Bool = false,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

struct UpdateWorkloadInputBody: Swift.Equatable {
    let workloadName: Swift.String?
    let description: Swift.String?
    let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    let accountIds: [Swift.String]?
    let awsRegions: [Swift.String]?
    let nonAwsRegions: [Swift.String]?
    let pillarPriorities: [Swift.String]?
    let architecturalDesign: Swift.String?
    let reviewOwner: Swift.String?
    let isReviewOwnerUpdateAcknowledged: Swift.Bool
    let industryType: Swift.String?
    let industry: Swift.String?
    let notes: Swift.String?
    let improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
}

extension UpdateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension UpdateWorkloadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkloadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of an update workload call.
public struct UpdateWorkloadOutputResponse: Swift.Equatable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init (
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct UpdateWorkloadOutputResponseBody: Swift.Equatable {
    let workload: WellArchitectedClientTypes.Workload?
}

extension UpdateWorkloadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension UpdateWorkloadShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

extension UpdateWorkloadShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let shareId = shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareInput: Swift.Equatable {
    /// Permission granted on a workload share.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The ID associated with the workload share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadShareInputBody: Swift.Equatable {
    let permissionType: WellArchitectedClientTypes.PermissionType?
}

extension UpdateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
    }
}

extension UpdateWorkloadShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkloadShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkloadShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkloadShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkloadShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workloadId = output.workloadId
            self.workloadShare = output.workloadShare
        } else {
            self.workloadId = nil
            self.workloadShare = nil
        }
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareOutputResponse: Swift.Equatable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A workload share return object.
    public var workloadShare: WellArchitectedClientTypes.WorkloadShare?

    public init (
        workloadId: Swift.String? = nil,
        workloadShare: WellArchitectedClientTypes.WorkloadShare? = nil
    )
    {
        self.workloadId = workloadId
        self.workloadShare = workloadShare
    }
}

struct UpdateWorkloadShareOutputResponseBody: Swift.Equatable {
    let workloadId: Swift.String?
    let workloadShare: WellArchitectedClientTypes.WorkloadShare?
}

extension UpdateWorkloadShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadId = "WorkloadId"
        case workloadShare = "WorkloadShare"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadShare.self, forKey: .workloadShare)
        workloadShare = workloadShareDecoded
    }
}

extension UpgradeLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

extension UpgradeLensReviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workloadId = workloadId else {
            return nil
        }
        guard let lensAlias = lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
    }
}

public struct UpgradeLensReviewInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after it has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens, for example, serverless. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct UpgradeLensReviewInputBody: Swift.Equatable {
    let milestoneName: Swift.String?
    let clientRequestToken: Swift.String?
}

extension UpgradeLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeLensReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeLensReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeLensReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeLensReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpgradeLensReviewOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user input is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [WellArchitectedClientTypes.ValidationExceptionField]?
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// The reason why the request failed validation.
    public var reason: WellArchitectedClientTypes.ValidationExceptionReason?

    public init (
        fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: WellArchitectedClientTypes.ValidationExceptionReason?
    let fields: [WellArchitectedClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[WellArchitectedClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [WellArchitectedClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension WellArchitectedClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name for which validation failed.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WellArchitectedClientTypes {
    /// The reason why the request failed validation.
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.VersionDifferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pillarDifferences = "PillarDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarDifferences = pillarDifferences {
            var pillarDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarDifferences)
            for pillardifferences0 in pillarDifferences {
                try pillarDifferencesContainer.encode(pillardifferences0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarDifference?].self, forKey: .pillarDifferences)
        var pillarDifferencesDecoded0:[WellArchitectedClientTypes.PillarDifference]? = nil
        if let pillarDifferencesContainer = pillarDifferencesContainer {
            pillarDifferencesDecoded0 = [WellArchitectedClientTypes.PillarDifference]()
            for structure0 in pillarDifferencesContainer {
                if let structure0 = structure0 {
                    pillarDifferencesDecoded0?.append(structure0)
                }
            }
        }
        pillarDifferences = pillarDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// The differences between the base and latest versions of the lens.
    public struct VersionDifferences: Swift.Equatable {
        /// The differences between the base and latest versions of the lens.
        public var pillarDifferences: [WellArchitectedClientTypes.PillarDifference]?

        public init (
            pillarDifferences: [WellArchitectedClientTypes.PillarDifference]? = nil
        )
        {
            self.pillarDifferences = pillarDifferences
        }
    }

}

extension WellArchitectedClientTypes.Workload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case owner = "Owner"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case reviewRestrictionDate = "ReviewRestrictionDate"
        case riskCounts = "RiskCounts"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for workloadaccountids0 in accountIds {
                try accountIdsContainer.encode(workloadaccountids0)
            }
        }
        if let architecturalDesign = architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for workloadawsregions0 in awsRegions {
                try awsRegionsContainer.encode(workloadawsregions0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if isReviewOwnerUpdateAcknowledged != false {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregions0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregions0)
            }
        }
        if let notes = notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for workloadpillarpriorities0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(workloadpillarpriorities0)
            }
        }
        if let reviewOwner = reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let reviewRestrictionDate = reviewRestrictionDate {
            try encodeContainer.encode(reviewRestrictionDate.timeIntervalSince1970, forKey: .reviewRestrictionDate)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let shareInvitationId = shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let reviewRestrictionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .reviewRestrictionDate)
        reviewRestrictionDate = reviewRestrictionDateDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A workload return object.
    public struct Workload: Swift.Equatable {
        /// The list of Amazon Web Services account IDs associated with the workload.
        public var accountIds: [Swift.String]?
        /// The URL of the architectural design for the workload.
        public var architecturalDesign: Swift.String?
        /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
        public var awsRegions: [Swift.String]?
        /// The description for the workload.
        public var description: Swift.String?
        /// The environment for the workload.
        public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The industry for the workload.
        public var industry: Swift.String?
        /// The industry type for the workload. If specified, must be one of the following:
        ///
        /// * Agriculture
        ///
        /// * Automobile
        ///
        /// * Defense
        ///
        /// * Design and Engineering
        ///
        /// * Digital Advertising
        ///
        /// * Education
        ///
        /// * Environmental Protection
        ///
        /// * Financial Services
        ///
        /// * Gaming
        ///
        /// * General Public Services
        ///
        /// * Healthcare
        ///
        /// * Hospitality
        ///
        /// * InfoTech
        ///
        /// * Justice and Public Safety
        ///
        /// * Life Sciences
        ///
        /// * Manufacturing
        ///
        /// * Media & Entertainment
        ///
        /// * Mining & Resources
        ///
        /// * Oil & Gas
        ///
        /// * Power & Utilities
        ///
        /// * Professional Services
        ///
        /// * Real Estate & Construction
        ///
        /// * Retail & Wholesale
        ///
        /// * Social Protection
        ///
        /// * Telecommunications
        ///
        /// * Travel, Transportation & Logistics
        ///
        /// * Other
        public var industryType: Swift.String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public var isReviewOwnerUpdateAcknowledged: Swift.Bool
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
        public var lenses: [Swift.String]?
        /// The list of non-Amazon Web Services Regions associated with the workload.
        public var nonAwsRegions: [Swift.String]?
        /// The notes associated with the workload.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
        public var pillarPriorities: [Swift.String]?
        /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
        public var reviewOwner: Swift.String?
        /// The date and time recorded.
        public var reviewRestrictionDate: ClientRuntime.Date?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags associated with the workload.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            accountIds: [Swift.String]? = nil,
            architecturalDesign: Swift.String? = nil,
            awsRegions: [Swift.String]? = nil,
            description: Swift.String? = nil,
            environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            industry: Swift.String? = nil,
            industryType: Swift.String? = nil,
            isReviewOwnerUpdateAcknowledged: Swift.Bool = false,
            lenses: [Swift.String]? = nil,
            nonAwsRegions: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            pillarPriorities: [Swift.String]? = nil,
            reviewOwner: Swift.String? = nil,
            reviewRestrictionDate: ClientRuntime.Date? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.accountIds = accountIds
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.owner = owner
            self.pillarPriorities = pillarPriorities
            self.reviewOwner = reviewOwner
            self.reviewRestrictionDate = reviewRestrictionDate
            self.riskCounts = riskCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    /// The environment for the workload.
    public enum WorkloadEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preproduction
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEnvironment] {
            return [
                .preproduction,
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preproduction: return "PREPRODUCTION"
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadEnvironment(rawValue: rawValue) ?? WorkloadEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The improvement status for a workload.
    public enum WorkloadImprovementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case notApplicable
        case notStarted
        case riskAcknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadImprovementStatus] {
            return [
                .complete,
                .inProgress,
                .notApplicable,
                .notStarted,
                .riskAcknowledged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .notApplicable: return "NOT_APPLICABLE"
            case .notStarted: return "NOT_STARTED"
            case .riskAcknowledged: return "RISK_ACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadImprovementStatus(rawValue: rawValue) ?? WorkloadImprovementStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.WorkloadShare: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case status = "Status"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedBy = sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload share return object.
    public struct WorkloadShare: Swift.Equatable {
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.status = status
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes.WorkloadShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload share summary return object.
    public struct WorkloadShareSummary: Swift.Equatable {
        /// Permission granted on a workload share.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the workload share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID or IAM role with which the workload is shared.
        public var sharedWith: Swift.String?
        /// The status of a workload share.
        public var status: WellArchitectedClientTypes.ShareStatus?

        public init (
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.WorkloadSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementStatus = "ImprovementStatus"
        case lenses = "Lenses"
        case owner = "Owner"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementStatus = improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for workloadlenses0 in lenses {
                try lensesContainer.encode(workloadlenses0)
            }
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskcounts0) in riskCounts {
                try riskCountsContainer.encode(riskcounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let workloadArn = workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload summary return object.
    public struct WorkloadSummary: Swift.Equatable {
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias].
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A map from risk names to the count of how questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init (
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.improvementStatus = improvementStatus
            self.lenses = lenses
            self.owner = owner
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}
