// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum AntipatternReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AntipatternReportStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AntipatternReportStatus(rawValue: rawValue) ?? AntipatternReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AntipatternSeveritySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of anti-patterns and their severity.
    public struct AntipatternSeveritySummary: Swift.Equatable {
        /// Contains the count of anti-patterns.
        public var count: Swift.Int?
        /// Contains the severity of anti-patterns.
        public var severity: MigrationHubStrategyClientTypes.Severity?

        public init (
            count: Swift.Int? = nil,
            severity: MigrationHubStrategyClientTypes.Severity? = nil
        )
        {
            self.count = count
            self.severity = severity
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AppType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iis
        case dotnetframework
        case java
        case oracle
        case other
        case sqlserver
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .iis,
                .dotnetframework,
                .java,
                .oracle,
                .other,
                .sqlserver,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iis: return "IIS"
            case .dotnetframework: return "DotNetFramework"
            case .java: return "Java"
            case .oracle: return "Oracle"
            case .other: return "Other"
            case .sqlserver: return "SQLServer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppType(rawValue: rawValue) ?? AppType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ApplicationComponentCriteria: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appName
        case appType
        case destination
        case notDefined
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationComponentCriteria] {
            return [
                .appName,
                .appType,
                .destination,
                .notDefined,
                .serverId,
                .strategy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appName: return "APP_NAME"
            case .appType: return "APP_TYPE"
            case .destination: return "DESTINATION"
            case .notDefined: return "NOT_DEFINED"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationComponentCriteria(rawValue: rawValue) ?? ApplicationComponentCriteria.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisStatus
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case appType
        case associatedServerId
        case databaseConfigDetail
        case id
        case inclusionStatus
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case moreServerAssociationExists
        case name
        case osDriver
        case osVersion
        case recommendationSet
        case resourceSubType
        case sourceCodeRepositories
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisStatus = analysisStatus {
            try encodeContainer.encode(analysisStatus.rawValue, forKey: .analysisStatus)
        }
        if let antipatternReportS3Object = antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let appType = appType {
            try encodeContainer.encode(appType.rawValue, forKey: .appType)
        }
        if let associatedServerId = associatedServerId {
            try encodeContainer.encode(associatedServerId, forKey: .associatedServerId)
        }
        if let databaseConfigDetail = databaseConfigDetail {
            try encodeContainer.encode(databaseConfigDetail, forKey: .databaseConfigDetail)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inclusionStatus = inclusionStatus {
            try encodeContainer.encode(inclusionStatus.rawValue, forKey: .inclusionStatus)
        }
        if let lastAnalyzedTimestamp = lastAnalyzedTimestamp {
            try encodeContainer.encode(lastAnalyzedTimestamp.timeIntervalSince1970, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for listantipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(listantipatternseveritysummary0)
            }
        }
        if let moreServerAssociationExists = moreServerAssociationExists {
            try encodeContainer.encode(moreServerAssociationExists, forKey: .moreServerAssociationExists)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osDriver = osDriver {
            try encodeContainer.encode(osDriver, forKey: .osDriver)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let recommendationSet = recommendationSet {
            try encodeContainer.encode(recommendationSet, forKey: .recommendationSet)
        }
        if let resourceSubType = resourceSubType {
            try encodeContainer.encode(resourceSubType.rawValue, forKey: .resourceSubType)
        }
        if let sourceCodeRepositories = sourceCodeRepositories {
            var sourceCodeRepositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCodeRepositories)
            for sourcecoderepositories0 in sourceCodeRepositories {
                try sourceCodeRepositoriesContainer.encode(sourcecoderepositories0)
            }
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommendationSetDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendationSet)
        recommendationSet = recommendationSetDecoded
        let analysisStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus.self, forKey: .analysisStatus)
        analysisStatus = analysisStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let databaseConfigDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseConfigDetail.self, forKey: .databaseConfigDetail)
        databaseConfigDetail = databaseConfigDetailDecoded
        let sourceCodeRepositoriesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SourceCodeRepository?].self, forKey: .sourceCodeRepositories)
        var sourceCodeRepositoriesDecoded0:[MigrationHubStrategyClientTypes.SourceCodeRepository]? = nil
        if let sourceCodeRepositoriesContainer = sourceCodeRepositoriesContainer {
            sourceCodeRepositoriesDecoded0 = [MigrationHubStrategyClientTypes.SourceCodeRepository]()
            for structure0 in sourceCodeRepositoriesContainer {
                if let structure0 = structure0 {
                    sourceCodeRepositoriesDecoded0?.append(structure0)
                }
            }
        }
        sourceCodeRepositories = sourceCodeRepositoriesDecoded0
        let appTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppType.self, forKey: .appType)
        appType = appTypeDecoded
        let resourceSubTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ResourceSubType.self, forKey: .resourceSubType)
        resourceSubType = resourceSubTypeDecoded
        let inclusionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.InclusionStatus.self, forKey: .inclusionStatus)
        inclusionStatus = inclusionStatusDecoded
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let osDriverDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osDriver)
        osDriver = osDriverDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
        let associatedServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedServerId)
        associatedServerId = associatedServerIdDecoded
        let moreServerAssociationExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .moreServerAssociationExists)
        moreServerAssociationExists = moreServerAssociationExistsDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains detailed information about an application component.
    public struct ApplicationComponentDetail: Swift.Equatable {
        /// The status of analysis, if the application component has source code or an associated database.
        public var analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus?
        /// The S3 bucket name and the Amazon S3 key name for the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public var antipatternReportStatusMessage: Swift.String?
        /// The type of application component.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// The ID of the server that the application component is running on.
        public var associatedServerId: Swift.String?
        /// Configuration details for the database associated with the application component.
        public var databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail?
        /// The ID of the application component.
        public var id: Swift.String?
        /// Indicates whether the application component has been included for server recommendation or not.
        public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
        /// The timestamp of when the application component was assessed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// Set to true if the application component is running on multiple servers.
        public var moreServerAssociationExists: Swift.Bool?
        /// The name of application component.
        public var name: Swift.String?
        /// OS driver.
        public var osDriver: Swift.String?
        /// OS version.
        public var osVersion: Swift.String?
        /// The top recommendation set for the application component.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The application component subtype.
        public var resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType?
        /// Details about the source code repository associated with the application component.
        public var sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]?
        /// A detailed description of the analysis status and any failure message.
        public var statusMessage: Swift.String?

        public init (
            analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus? = nil,
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            associatedServerId: Swift.String? = nil,
            databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail? = nil,
            id: Swift.String? = nil,
            inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            moreServerAssociationExists: Swift.Bool? = nil,
            name: Swift.String? = nil,
            osDriver: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType? = nil,
            sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.analysisStatus = analysisStatus
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.appType = appType
            self.associatedServerId = associatedServerId
            self.databaseConfigDetail = databaseConfigDetail
            self.id = id
            self.inclusionStatus = inclusionStatus
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.moreServerAssociationExists = moreServerAssociationExists
            self.name = name
            self.osDriver = osDriver
            self.osVersion = osVersion
            self.recommendationSet = recommendationSet
            self.resourceSubType = resourceSubType
            self.sourceCodeRepositories = sourceCodeRepositories
            self.statusMessage = statusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationComponentStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case recommendation
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyRecommendation.self, forKey: .status)
        status = statusDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains information about a strategy recommendation for an application component.
    public struct ApplicationComponentStrategy: Swift.Equatable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// Strategy recommendation for the application component.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of a strategy for an application component.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init (
            isPreferred: Swift.Bool? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.recommendation = recommendation
            self.status = status
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appType
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appType = appType {
            try encodeContainer.encode(appType.rawValue, forKey: .appType)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppType.self, forKey: .appType)
        appType = appTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of application components.
    public struct ApplicationComponentSummary: Swift.Equatable {
        /// Contains the name of application types.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// Contains the count of application type.
        public var count: Swift.Int?

        public init (
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            count: Swift.Int? = nil
        )
        {
            self.appType = appType
            self.count = count
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementPreference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementPreference = managementPreference {
            try encodeContainer.encode(managementPreference, forKey: .managementPreference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ManagementPreference.self, forKey: .managementPreference)
        managementPreference = managementPreferenceDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Application preferences that you specify.
    public struct ApplicationPreferences: Swift.Equatable {
        /// Application preferences that you specify to prefer managed environment.
        public var managementPreference: MigrationHubStrategyClientTypes.ManagementPreference?

        public init (
            managementPreference: MigrationHubStrategyClientTypes.ManagementPreference? = nil
        )
        {
            self.managementPreference = managementPreference
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AssessmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case listApplicationComponentStrategySummary
        case listApplicationComponentSummary
        case listServerStrategySummary
        case listServerSummary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antipatternReportS3Object = antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let lastAnalyzedTimestamp = lastAnalyzedTimestamp {
            try encodeContainer.encode(lastAnalyzedTimestamp.timeIntervalSince1970, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for listantipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(listantipatternseveritysummary0)
            }
        }
        if let listApplicationComponentStrategySummary = listApplicationComponentStrategySummary {
            var listApplicationComponentStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listApplicationComponentStrategySummary)
            for liststrategysummary0 in listApplicationComponentStrategySummary {
                try listApplicationComponentStrategySummaryContainer.encode(liststrategysummary0)
            }
        }
        if let listApplicationComponentSummary = listApplicationComponentSummary {
            var listApplicationComponentSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listApplicationComponentSummary)
            for listapplicationcomponentsummary0 in listApplicationComponentSummary {
                try listApplicationComponentSummaryContainer.encode(listapplicationcomponentsummary0)
            }
        }
        if let listServerStrategySummary = listServerStrategySummary {
            var listServerStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listServerStrategySummary)
            for liststrategysummary0 in listServerStrategySummary {
                try listServerStrategySummaryContainer.encode(liststrategysummary0)
            }
        }
        if let listServerSummary = listServerSummary {
            var listServerSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listServerSummary)
            for listserversummary0 in listServerSummary {
                try listServerSummaryContainer.encode(listserversummary0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listServerStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .listServerStrategySummary)
        var listServerStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let listServerStrategySummaryContainer = listServerStrategySummaryContainer {
            listServerStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in listServerStrategySummaryContainer {
                if let structure0 = structure0 {
                    listServerStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        listServerStrategySummary = listServerStrategySummaryDecoded0
        let listApplicationComponentStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .listApplicationComponentStrategySummary)
        var listApplicationComponentStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let listApplicationComponentStrategySummaryContainer = listApplicationComponentStrategySummaryContainer {
            listApplicationComponentStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in listApplicationComponentStrategySummaryContainer {
                if let structure0 = structure0 {
                    listApplicationComponentStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        listApplicationComponentStrategySummary = listApplicationComponentStrategySummaryDecoded0
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let listApplicationComponentSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentSummary?].self, forKey: .listApplicationComponentSummary)
        var listApplicationComponentSummaryDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentSummary]? = nil
        if let listApplicationComponentSummaryContainer = listApplicationComponentSummaryContainer {
            listApplicationComponentSummaryDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentSummary]()
            for structure0 in listApplicationComponentSummaryContainer {
                if let structure0 = structure0 {
                    listApplicationComponentSummaryDecoded0?.append(structure0)
                }
            }
        }
        listApplicationComponentSummary = listApplicationComponentSummaryDecoded0
        let listServerSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerSummary?].self, forKey: .listServerSummary)
        var listServerSummaryDecoded0:[MigrationHubStrategyClientTypes.ServerSummary]? = nil
        if let listServerSummaryContainer = listServerSummaryContainer {
            listServerSummaryDecoded0 = [MigrationHubStrategyClientTypes.ServerSummary]()
            for structure0 in listServerSummaryContainer {
                if let structure0 = structure0 {
                    listServerSummaryDecoded0?.append(structure0)
                }
            }
        }
        listServerSummary = listServerSummaryDecoded0
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of the assessment results.
    public struct AssessmentSummary: Swift.Equatable {
        /// The Amazon S3 object containing the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message of the anti-pattern report.
        public var antipatternReportStatusMessage: Swift.String?
        /// The time the assessment was performed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// List of AntipatternSeveritySummary.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// List of ApplicationComponentStrategySummary.
        public var listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ApplicationComponentSummary.
        public var listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]?
        /// List of ServerStrategySummary.
        public var listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ServerSummary.
        public var listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]?

        public init (
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]? = nil,
            listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.listApplicationComponentStrategySummary = listApplicationComponentStrategySummary
            self.listApplicationComponentSummary = listApplicationComponentSummary
            self.listServerStrategySummary = listServerStrategySummary
            self.listServerSummary = listServerSummary
        }
    }

}

extension MigrationHubStrategyClientTypes.AssociatedApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing details about applications as defined in Application Discovery Service.
    public struct AssociatedApplication: Swift.Equatable {
        /// ID of the application as defined in Application Discovery Service.
        public var id: Swift.String?
        /// Name of the application as defined in Application Discovery Service.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension MigrationHubStrategyClientTypes.AwsManagedResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for awsmanagedtargetdestinations0 in targetDestination {
                try targetDestinationContainer.encode(awsmanagedtargetdestinations0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AwsManagedTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.AwsManagedTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the choice of application destination that you specify.
    public struct AwsManagedResources: Swift.Equatable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]?

        public init (
            targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AwsManagedTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsManagedTargetDestination] {
            return [
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsManagedTargetDestination(rawValue: rawValue) ?? AwsManagedTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.BusinessGoals: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseCostReduction
        case modernizeInfrastructureWithCloudNativeTechnologies
        case reduceOperationalOverheadWithManagedServices
        case speedOfMigration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseCostReduction = licenseCostReduction {
            try encodeContainer.encode(licenseCostReduction, forKey: .licenseCostReduction)
        }
        if let modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies {
            try encodeContainer.encode(modernizeInfrastructureWithCloudNativeTechnologies, forKey: .modernizeInfrastructureWithCloudNativeTechnologies)
        }
        if let reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices {
            try encodeContainer.encode(reduceOperationalOverheadWithManagedServices, forKey: .reduceOperationalOverheadWithManagedServices)
        }
        if let speedOfMigration = speedOfMigration {
            try encodeContainer.encode(speedOfMigration, forKey: .speedOfMigration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speedOfMigrationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .speedOfMigration)
        speedOfMigration = speedOfMigrationDecoded
        let reduceOperationalOverheadWithManagedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reduceOperationalOverheadWithManagedServices)
        reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServicesDecoded
        let modernizeInfrastructureWithCloudNativeTechnologiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modernizeInfrastructureWithCloudNativeTechnologies)
        modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologiesDecoded
        let licenseCostReductionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCostReduction)
        licenseCostReduction = licenseCostReductionDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Business goals that you specify.
    public struct BusinessGoals: Swift.Equatable {
        /// Business goal to reduce license costs.
        public var licenseCostReduction: Swift.Int?
        /// Business goal to modernize infrastructure by moving to cloud native technologies.
        public var modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int?
        /// Business goal to reduce the operational overhead on the team by moving into managed services.
        public var reduceOperationalOverheadWithManagedServices: Swift.Int?
        /// Business goal to achieve migration at a fast pace.
        public var speedOfMigration: Swift.Int?

        public init (
            licenseCostReduction: Swift.Int? = nil,
            modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int? = nil,
            reduceOperationalOverheadWithManagedServices: Swift.Int? = nil,
            speedOfMigration: Swift.Int? = nil
        )
        {
            self.licenseCostReduction = licenseCostReduction
            self.modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies
            self.reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices
            self.speedOfMigration = speedOfMigration
        }
    }

}

extension MigrationHubStrategyClientTypes.Collector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorHealth
        case collectorId
        case collectorVersion
        case hostName
        case ipAddress
        case lastActivityTimeStamp
        case registeredTimeStamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorHealth = collectorHealth {
            try encodeContainer.encode(collectorHealth.rawValue, forKey: .collectorHealth)
        }
        if let collectorId = collectorId {
            try encodeContainer.encode(collectorId, forKey: .collectorId)
        }
        if let collectorVersion = collectorVersion {
            try encodeContainer.encode(collectorVersion, forKey: .collectorVersion)
        }
        if let hostName = hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let lastActivityTimeStamp = lastActivityTimeStamp {
            try encodeContainer.encode(lastActivityTimeStamp, forKey: .lastActivityTimeStamp)
        }
        if let registeredTimeStamp = registeredTimeStamp {
            try encodeContainer.encode(registeredTimeStamp, forKey: .registeredTimeStamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorId)
        collectorId = collectorIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let collectorHealthDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.CollectorHealth.self, forKey: .collectorHealth)
        collectorHealth = collectorHealthDecoded
        let collectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorVersion)
        collectorVersion = collectorVersionDecoded
        let registeredTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTimeStamp)
        registeredTimeStamp = registeredTimeStampDecoded
        let lastActivityTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastActivityTimeStamp)
        lastActivityTimeStamp = lastActivityTimeStampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Process data collector that runs in the environment that you specify.
    public struct Collector: Swift.Equatable {
        /// Indicates the health of a collector.
        public var collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth?
        /// The ID of the collector.
        public var collectorId: Swift.String?
        /// Current version of the collector that is running in the environment that you specify.
        public var collectorVersion: Swift.String?
        /// Hostname of the server that is hosting the collector.
        public var hostName: Swift.String?
        /// IP address of the server that is hosting the collector.
        public var ipAddress: Swift.String?
        /// Time when the collector last pinged the service.
        public var lastActivityTimeStamp: Swift.String?
        /// Time when the collector registered with the service.
        public var registeredTimeStamp: Swift.String?

        public init (
            collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth? = nil,
            collectorId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            hostName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            lastActivityTimeStamp: Swift.String? = nil,
            registeredTimeStamp: Swift.String? = nil
        )
        {
            self.collectorHealth = collectorHealth
            self.collectorId = collectorId
            self.collectorVersion = collectorVersion
            self.hostName = hostName
            self.ipAddress = ipAddress
            self.lastActivityTimeStamp = lastActivityTimeStamp
            self.registeredTimeStamp = registeredTimeStamp
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum CollectorHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collectorHealthy
        case collectorUnhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorHealth] {
            return [
                .collectorHealthy,
                .collectorUnhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collectorHealthy: return "COLLECTOR_HEALTHY"
            case .collectorUnhealthy: return "COLLECTOR_UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectorHealth(rawValue: rawValue) ?? CollectorHealth.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.DataCollectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case failed
        case inProgress
        case servers
        case startTime
        case status
        case success
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let failed = failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let inProgress = inProgress {
            try encodeContainer.encode(inProgress, forKey: .inProgress)
        }
        if let servers = servers {
            try encodeContainer.encode(servers, forKey: .servers)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let success = success {
            try encodeContainer.encode(success, forKey: .success)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let serversDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .servers)
        servers = serversDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
        let successDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .success)
        success = successDecoded
        let inProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgress)
        inProgress = inProgressDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Detailed information about an assessment.
    public struct DataCollectionDetails: Swift.Equatable {
        /// The time the assessment completes.
        public var completionTime: ClientRuntime.Date?
        /// The number of failed servers in the assessment.
        public var failed: Swift.Int?
        /// The number of servers with the assessment status IN_PROGESS.
        public var inProgress: Swift.Int?
        /// The total number of servers in the assessment.
        public var servers: Swift.Int?
        /// The start time of assessment.
        public var startTime: ClientRuntime.Date?
        /// The status of the assessment.
        public var status: MigrationHubStrategyClientTypes.AssessmentStatus?
        /// The number of successful servers in the assessment.
        public var success: Swift.Int?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            failed: Swift.Int? = nil,
            inProgress: Swift.Int? = nil,
            servers: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.AssessmentStatus? = nil,
            success: Swift.Int? = nil
        )
        {
            self.completionTime = completionTime
            self.failed = failed
            self.inProgress = inProgress
            self.servers = servers
            self.startTime = startTime
            self.status = status
            self.success = success
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ads
        case mpa
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .ads,
                .mpa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ApplicationDiscoveryService"
            case .mpa: return "MPA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.DatabaseConfigDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Configuration information used for assessing databases.
    public struct DatabaseConfigDetail: Swift.Equatable {
        /// AWS Secrets Manager key that holds the credentials that you use to connect to a database.
        public var secretName: Swift.String?

        public init (
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum DatabaseManagementPreference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case noPreference
        case selfManage
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseManagementPreference] {
            return [
                .awsManaged,
                .noPreference,
                .selfManage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS-managed"
            case .noPreference: return "No preference"
            case .selfManage: return "Self-manage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseManagementPreference(rawValue: rawValue) ?? DatabaseManagementPreference.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.DatabaseMigrationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heterogeneous
        case homogeneous
        case nopreference = "noPreference"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .heterogeneous(heterogeneous):
                try container.encode(heterogeneous, forKey: .heterogeneous)
            case let .homogeneous(homogeneous):
                try container.encode(homogeneous, forKey: .homogeneous)
            case let .nopreference(nopreference):
                try container.encode(nopreference, forKey: .nopreference)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let heterogeneousDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.Heterogeneous.self, forKey: .heterogeneous)
        if let heterogeneous = heterogeneousDecoded {
            self = .heterogeneous(heterogeneous)
            return
        }
        let homogeneousDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.Homogeneous.self, forKey: .homogeneous)
        if let homogeneous = homogeneousDecoded {
            self = .homogeneous(homogeneous)
            return
        }
        let nopreferenceDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference.self, forKey: .nopreference)
        if let nopreference = nopreferenceDecoded {
            self = .nopreference(nopreference)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences for migrating a database to AWS.
    public enum DatabaseMigrationPreference: Swift.Equatable {
        /// Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition.
        case heterogeneous(MigrationHubStrategyClientTypes.Heterogeneous)
        /// Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS.
        case homogeneous(MigrationHubStrategyClientTypes.Homogeneous)
        /// Indicated that you do not prefer heterogeneous or homogeneous.
        case nopreference(MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes.DatabasePreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseManagementPreference
        case databaseMigrationPreference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseManagementPreference = databaseManagementPreference {
            try encodeContainer.encode(databaseManagementPreference.rawValue, forKey: .databaseManagementPreference)
        }
        if let databaseMigrationPreference = databaseMigrationPreference {
            try encodeContainer.encode(databaseMigrationPreference, forKey: .databaseMigrationPreference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseManagementPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseManagementPreference.self, forKey: .databaseManagementPreference)
        databaseManagementPreference = databaseManagementPreferenceDecoded
        let databaseMigrationPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseMigrationPreference.self, forKey: .databaseMigrationPreference)
        databaseMigrationPreference = databaseMigrationPreferenceDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences on managing your databases on AWS.
    public struct DatabasePreferences: Swift.Equatable {
        /// Specifies whether you're interested in self-managed databases or databases managed by AWS.
        public var databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference?
        /// Specifies your preferred migration path.
        public var databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference?

        public init (
            databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference? = nil,
            databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference? = nil
        )
        {
            self.databaseManagementPreference = databaseManagementPreference
            self.databaseMigrationPreference = databaseMigrationPreference
        }
    }

}

extension GetApplicationComponentDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationComponentId = applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-details/\(applicationComponentId.urlPercentEncoding())"
    }
}

public struct GetApplicationComponentDetailsInput: Swift.Equatable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init (
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

struct GetApplicationComponentDetailsInputBody: Swift.Equatable {
}

extension GetApplicationComponentDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationComponentDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationComponentDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationComponentDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationComponentDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationComponentDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentDetail = output.applicationComponentDetail
            self.associatedApplications = output.associatedApplications
            self.associatedServerIds = output.associatedServerIds
            self.moreApplicationResource = output.moreApplicationResource
        } else {
            self.applicationComponentDetail = nil
            self.associatedApplications = nil
            self.associatedServerIds = nil
            self.moreApplicationResource = nil
        }
    }
}

public struct GetApplicationComponentDetailsOutputResponse: Swift.Equatable {
    /// Detailed information about an application component.
    public var applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail?
    /// The associated application group as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// A list of the IDs of the servers on which the application component is running.
    public var associatedServerIds: [Swift.String]?
    /// Set to true if the application component belongs to more than one application group.
    public var moreApplicationResource: Swift.Bool?

    public init (
        applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail? = nil,
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        associatedServerIds: [Swift.String]? = nil,
        moreApplicationResource: Swift.Bool? = nil
    )
    {
        self.applicationComponentDetail = applicationComponentDetail
        self.associatedApplications = associatedApplications
        self.associatedServerIds = associatedServerIds
        self.moreApplicationResource = moreApplicationResource
    }
}

struct GetApplicationComponentDetailsOutputResponseBody: Swift.Equatable {
    let applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail?
    let associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    let moreApplicationResource: Swift.Bool?
    let associatedServerIds: [Swift.String]?
}

extension GetApplicationComponentDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentDetail
        case associatedApplications
        case associatedServerIds
        case moreApplicationResource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationComponentDetail.self, forKey: .applicationComponentDetail)
        applicationComponentDetail = applicationComponentDetailDecoded
        let associatedApplicationsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssociatedApplication?].self, forKey: .associatedApplications)
        var associatedApplicationsDecoded0:[MigrationHubStrategyClientTypes.AssociatedApplication]? = nil
        if let associatedApplicationsContainer = associatedApplicationsContainer {
            associatedApplicationsDecoded0 = [MigrationHubStrategyClientTypes.AssociatedApplication]()
            for structure0 in associatedApplicationsContainer {
                if let structure0 = structure0 {
                    associatedApplicationsDecoded0?.append(structure0)
                }
            }
        }
        associatedApplications = associatedApplicationsDecoded0
        let moreApplicationResourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .moreApplicationResource)
        moreApplicationResource = moreApplicationResourceDecoded
        let associatedServerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedServerIds)
        var associatedServerIdsDecoded0:[Swift.String]? = nil
        if let associatedServerIdsContainer = associatedServerIdsContainer {
            associatedServerIdsDecoded0 = [Swift.String]()
            for string0 in associatedServerIdsContainer {
                if let string0 = string0 {
                    associatedServerIdsDecoded0?.append(string0)
                }
            }
        }
        associatedServerIds = associatedServerIdsDecoded0
    }
}

extension GetApplicationComponentStrategiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationComponentId = applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-strategies/\(applicationComponentId.urlPercentEncoding())"
    }
}

public struct GetApplicationComponentStrategiesInput: Swift.Equatable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init (
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

struct GetApplicationComponentStrategiesInputBody: Swift.Equatable {
}

extension GetApplicationComponentStrategiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationComponentStrategiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationComponentStrategiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationComponentStrategiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationComponentStrategiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationComponentStrategiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentStrategies = output.applicationComponentStrategies
        } else {
            self.applicationComponentStrategies = nil
        }
    }
}

public struct GetApplicationComponentStrategiesOutputResponse: Swift.Equatable {
    /// A list of application component strategy recommendations.
    public var applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]?

    public init (
        applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]? = nil
    )
    {
        self.applicationComponentStrategies = applicationComponentStrategies
    }
}

struct GetApplicationComponentStrategiesOutputResponseBody: Swift.Equatable {
    let applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]?
}

extension GetApplicationComponentStrategiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentStrategies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentStrategiesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentStrategy?].self, forKey: .applicationComponentStrategies)
        var applicationComponentStrategiesDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentStrategy]? = nil
        if let applicationComponentStrategiesContainer = applicationComponentStrategiesContainer {
            applicationComponentStrategiesDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]()
            for structure0 in applicationComponentStrategiesContainer {
                if let structure0 = structure0 {
                    applicationComponentStrategiesDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentStrategies = applicationComponentStrategiesDecoded0
    }
}

extension GetAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-assessment/\(id.urlPercentEncoding())"
    }
}

public struct GetAssessmentInput: Swift.Equatable {
    /// The assessmentid returned by [StartAssessment].
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetAssessmentInputBody: Swift.Equatable {
}

extension GetAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCollectionDetails = output.dataCollectionDetails
            self.id = output.id
        } else {
            self.dataCollectionDetails = nil
            self.id = nil
        }
    }
}

public struct GetAssessmentOutputResponse: Swift.Equatable {
    /// Detailed information about the assessment.
    public var dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails?
    /// The ID for the specific assessment task.
    public var id: Swift.String?

    public init (
        dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails? = nil,
        id: Swift.String? = nil
    )
    {
        self.dataCollectionDetails = dataCollectionDetails
        self.id = id
    }
}

struct GetAssessmentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails?
}

extension GetAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCollectionDetails
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataCollectionDetailsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DataCollectionDetails.self, forKey: .dataCollectionDetails)
        dataCollectionDetails = dataCollectionDetailsDecoded
    }
}

extension GetImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-import-file-task/\(id.urlPercentEncoding())"
    }
}

public struct GetImportFileTaskInput: Swift.Equatable {
    /// The ID of the import file task. This ID is returned in the response of [StartImportFileTask].
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetImportFileTaskInputBody: Swift.Equatable {
}

extension GetImportFileTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImportFileTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImportFileTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImportFileTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImportFileTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImportFileTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.id = output.id
            self.importName = output.importName
            self.inputS3Bucket = output.inputS3Bucket
            self.inputS3Key = output.inputS3Key
            self.numberOfRecordsFailed = output.numberOfRecordsFailed
            self.numberOfRecordsSuccess = output.numberOfRecordsSuccess
            self.startTime = output.startTime
            self.status = output.status
            self.statusReportS3Bucket = output.statusReportS3Bucket
            self.statusReportS3Key = output.statusReportS3Key
        } else {
            self.completionTime = nil
            self.id = nil
            self.importName = nil
            self.inputS3Bucket = nil
            self.inputS3Key = nil
            self.numberOfRecordsFailed = nil
            self.numberOfRecordsSuccess = nil
            self.startTime = nil
            self.status = nil
            self.statusReportS3Bucket = nil
            self.statusReportS3Key = nil
        }
    }
}

public struct GetImportFileTaskOutputResponse: Swift.Equatable {
    /// The time that the import task completed.
    public var completionTime: ClientRuntime.Date?
    /// The import file task id returned in the response of [StartImportFileTask].
    public var id: Swift.String?
    /// The name of the import task given in [StartImportFileTask].
    public var importName: Swift.String?
    /// The S3 bucket where import file is located.
    public var inputS3Bucket: Swift.String?
    /// The Amazon S3 key name of the import file.
    public var inputS3Key: Swift.String?
    /// The number of records that failed to be imported.
    public var numberOfRecordsFailed: Swift.Int?
    /// The number of records successfully imported.
    public var numberOfRecordsSuccess: Swift.Int?
    /// Start time of the import task.
    public var startTime: ClientRuntime.Date?
    /// Status of import file task.
    public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
    /// The S3 bucket name for status report of import task.
    public var statusReportS3Bucket: Swift.String?
    /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
    public var statusReportS3Key: Swift.String?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        importName: Swift.String? = nil,
        inputS3Bucket: Swift.String? = nil,
        inputS3Key: Swift.String? = nil,
        numberOfRecordsFailed: Swift.Int? = nil,
        numberOfRecordsSuccess: Swift.Int? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
        statusReportS3Bucket: Swift.String? = nil,
        statusReportS3Key: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.id = id
        self.importName = importName
        self.inputS3Bucket = inputS3Bucket
        self.inputS3Key = inputS3Key
        self.numberOfRecordsFailed = numberOfRecordsFailed
        self.numberOfRecordsSuccess = numberOfRecordsSuccess
        self.startTime = startTime
        self.status = status
        self.statusReportS3Bucket = statusReportS3Bucket
        self.statusReportS3Key = statusReportS3Key
    }
}

struct GetImportFileTaskOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
    let startTime: ClientRuntime.Date?
    let inputS3Bucket: Swift.String?
    let inputS3Key: Swift.String?
    let statusReportS3Bucket: Swift.String?
    let statusReportS3Key: Swift.String?
    let completionTime: ClientRuntime.Date?
    let numberOfRecordsSuccess: Swift.Int?
    let numberOfRecordsFailed: Swift.Int?
    let importName: Swift.String?
}

extension GetImportFileTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case id
        case importName
        case inputS3Bucket
        case inputS3Key
        case numberOfRecordsFailed
        case numberOfRecordsSuccess
        case startTime
        case status
        case statusReportS3Bucket
        case statusReportS3Key
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ImportFileTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let inputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Bucket)
        inputS3Bucket = inputS3BucketDecoded
        let inputS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Key)
        inputS3Key = inputS3KeyDecoded
        let statusReportS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Bucket)
        statusReportS3Bucket = statusReportS3BucketDecoded
        let statusReportS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Key)
        statusReportS3Key = statusReportS3KeyDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let numberOfRecordsSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsSuccess)
        numberOfRecordsSuccess = numberOfRecordsSuccessDecoded
        let numberOfRecordsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsFailed)
        numberOfRecordsFailed = numberOfRecordsFailedDecoded
        let importNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importName)
        importName = importNameDecoded
    }
}

extension GetPortfolioPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-portfolio-preferences"
    }
}

public struct GetPortfolioPreferencesInput: Swift.Equatable {

}

struct GetPortfolioPreferencesInputBody: Swift.Equatable {
}

extension GetPortfolioPreferencesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortfolioPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortfolioPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPortfolioPreferencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortfolioPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPortfolioPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationPreferences = output.applicationPreferences
            self.databasePreferences = output.databasePreferences
            self.prioritizeBusinessGoals = output.prioritizeBusinessGoals
        } else {
            self.applicationPreferences = nil
            self.databasePreferences = nil
            self.prioritizeBusinessGoals = nil
        }
    }
}

public struct GetPortfolioPreferencesOutputResponse: Swift.Equatable {
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init (
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

struct GetPortfolioPreferencesOutputResponseBody: Swift.Equatable {
    let prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?
    let applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    let databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
}

extension GetPortfolioPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prioritizeBusinessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.self, forKey: .prioritizeBusinessGoals)
        prioritizeBusinessGoals = prioritizeBusinessGoalsDecoded
        let applicationPreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationPreferences.self, forKey: .applicationPreferences)
        applicationPreferences = applicationPreferencesDecoded
        let databasePreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabasePreferences.self, forKey: .databasePreferences)
        databasePreferences = databasePreferencesDecoded
    }
}

extension GetPortfolioSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-portfolio-summary"
    }
}

public struct GetPortfolioSummaryInput: Swift.Equatable {

}

struct GetPortfolioSummaryInputBody: Swift.Equatable {
}

extension GetPortfolioSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortfolioSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortfolioSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPortfolioSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortfolioSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPortfolioSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentSummary = output.assessmentSummary
        } else {
            self.assessmentSummary = nil
        }
    }
}

public struct GetPortfolioSummaryOutputResponse: Swift.Equatable {
    /// An assessment summary for the portfolio including the number of servers to rehost and the overall number of anti-patterns.
    public var assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary?

    public init (
        assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary? = nil
    )
    {
        self.assessmentSummary = assessmentSummary
    }
}

struct GetPortfolioSummaryOutputResponseBody: Swift.Equatable {
    let assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary?
}

extension GetPortfolioSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentSummaryDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AssessmentSummary.self, forKey: .assessmentSummary)
        assessmentSummary = assessmentSummaryDecoded
    }
}

extension GetRecommendationReportDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-recommendation-report-details/\(id.urlPercentEncoding())"
    }
}

public struct GetRecommendationReportDetailsInput: Swift.Equatable {
    /// The recommendation report generation task id returned by [StartRecommendationReportGeneration].
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetRecommendationReportDetailsInputBody: Swift.Equatable {
}

extension GetRecommendationReportDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationReportDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationReportDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationReportDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationReportDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecommendationReportDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.recommendationReportDetails = output.recommendationReportDetails
        } else {
            self.id = nil
            self.recommendationReportDetails = nil
        }
    }
}

public struct GetRecommendationReportDetailsOutputResponse: Swift.Equatable {
    /// The ID of the recommendation report generation task. See the response of [StartRecommendationReportGeneration].
    public var id: Swift.String?
    /// Detailed information about the recommendation report.
    public var recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails?

    public init (
        id: Swift.String? = nil,
        recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails? = nil
    )
    {
        self.id = id
        self.recommendationReportDetails = recommendationReportDetails
    }
}

struct GetRecommendationReportDetailsOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails?
}

extension GetRecommendationReportDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case recommendationReportDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let recommendationReportDetailsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationReportDetails.self, forKey: .recommendationReportDetails)
        recommendationReportDetails = recommendationReportDetailsDecoded
    }
}

extension GetServerDetailsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetServerDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serverId = serverId else {
            return nil
        }
        return "/get-server-details/\(serverId.urlPercentEncoding())"
    }
}

public struct GetServerDetailsInput: Swift.Equatable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct GetServerDetailsInputBody: Swift.Equatable {
}

extension GetServerDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServerDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServerDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServerDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServerDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServerDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedApplications = output.associatedApplications
            self.nextToken = output.nextToken
            self.serverDetail = output.serverDetail
        } else {
            self.associatedApplications = nil
            self.nextToken = nil
            self.serverDetail = nil
        }
    }
}

public struct GetServerDetailsOutputResponse: Swift.Equatable {
    /// The associated application group the server belongs to, as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Detailed information about the server.
    public var serverDetail: MigrationHubStrategyClientTypes.ServerDetail?

    public init (
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        nextToken: Swift.String? = nil,
        serverDetail: MigrationHubStrategyClientTypes.ServerDetail? = nil
    )
    {
        self.associatedApplications = associatedApplications
        self.nextToken = nextToken
        self.serverDetail = serverDetail
    }
}

struct GetServerDetailsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverDetail: MigrationHubStrategyClientTypes.ServerDetail?
    let associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
}

extension GetServerDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedApplications
        case nextToken
        case serverDetail
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerDetail.self, forKey: .serverDetail)
        serverDetail = serverDetailDecoded
        let associatedApplicationsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssociatedApplication?].self, forKey: .associatedApplications)
        var associatedApplicationsDecoded0:[MigrationHubStrategyClientTypes.AssociatedApplication]? = nil
        if let associatedApplicationsContainer = associatedApplicationsContainer {
            associatedApplicationsDecoded0 = [MigrationHubStrategyClientTypes.AssociatedApplication]()
            for structure0 in associatedApplicationsContainer {
                if let structure0 = structure0 {
                    associatedApplicationsDecoded0?.append(structure0)
                }
            }
        }
        associatedApplications = associatedApplicationsDecoded0
    }
}

extension GetServerStrategiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serverId = serverId else {
            return nil
        }
        return "/get-server-strategies/\(serverId.urlPercentEncoding())"
    }
}

public struct GetServerStrategiesInput: Swift.Equatable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct GetServerStrategiesInputBody: Swift.Equatable {
}

extension GetServerStrategiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServerStrategiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServerStrategiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServerStrategiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServerStrategiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServerStrategiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverStrategies = output.serverStrategies
        } else {
            self.serverStrategies = nil
        }
    }
}

public struct GetServerStrategiesOutputResponse: Swift.Equatable {
    /// A list of strategy recommendations for the server.
    public var serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]?

    public init (
        serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]? = nil
    )
    {
        self.serverStrategies = serverStrategies
    }
}

struct GetServerStrategiesOutputResponseBody: Swift.Equatable {
    let serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]?
}

extension GetServerStrategiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverStrategies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverStrategiesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerStrategy?].self, forKey: .serverStrategies)
        var serverStrategiesDecoded0:[MigrationHubStrategyClientTypes.ServerStrategy]? = nil
        if let serverStrategiesContainer = serverStrategiesContainer {
            serverStrategiesDecoded0 = [MigrationHubStrategyClientTypes.ServerStrategy]()
            for structure0 in serverStrategiesContainer {
                if let structure0 = structure0 {
                    serverStrategiesDecoded0?.append(structure0)
                }
            }
        }
        serverStrategies = serverStrategiesDecoded0
    }
}

extension MigrationHubStrategyClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.GroupName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing information about distinct imports or groups for Strategy Recommendations.
    public struct Group: Swift.Equatable {
        /// The key of the specific import group.
        public var name: MigrationHubStrategyClientTypes.GroupName?
        /// The value of the specific import group.
        public var value: Swift.String?

        public init (
            name: MigrationHubStrategyClientTypes.GroupName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum GroupName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case externalId
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupName] {
            return [
                .externalId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .externalId: return "ExternalId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupName(rawValue: rawValue) ?? GroupName.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.Heterogeneous: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for heterogeneoustargetdatabaseengines0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(heterogeneoustargetdatabaseengines0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about heterogeneous database preferences.
    public struct Heterogeneous: Swift.Equatable {
        /// The target database engine for heterogeneous database migration preference.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]?

        public init (
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum HeterogeneousTargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [HeterogeneousTargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HeterogeneousTargetDatabaseEngine(rawValue: rawValue) ?? HeterogeneousTargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.Homogeneous: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for homogeneoustargetdatabaseengines0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(homogeneoustargetdatabaseengines0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about homogeneous database preferences.
    public struct Homogeneous: Swift.Equatable {
        /// The target database engine for homogeneous database migration preferences.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]?

        public init (
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum HomogeneousTargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [HomogeneousTargetDatabaseEngine] {
            return [
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomogeneousTargetDatabaseEngine(rawValue: rawValue) ?? HomogeneousTargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ImportFileTaskInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case id
        case importName
        case inputS3Bucket
        case inputS3Key
        case numberOfRecordsFailed
        case numberOfRecordsSuccess
        case startTime
        case status
        case statusReportS3Bucket
        case statusReportS3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let importName = importName {
            try encodeContainer.encode(importName, forKey: .importName)
        }
        if let inputS3Bucket = inputS3Bucket {
            try encodeContainer.encode(inputS3Bucket, forKey: .inputS3Bucket)
        }
        if let inputS3Key = inputS3Key {
            try encodeContainer.encode(inputS3Key, forKey: .inputS3Key)
        }
        if let numberOfRecordsFailed = numberOfRecordsFailed {
            try encodeContainer.encode(numberOfRecordsFailed, forKey: .numberOfRecordsFailed)
        }
        if let numberOfRecordsSuccess = numberOfRecordsSuccess {
            try encodeContainer.encode(numberOfRecordsSuccess, forKey: .numberOfRecordsSuccess)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReportS3Bucket = statusReportS3Bucket {
            try encodeContainer.encode(statusReportS3Bucket, forKey: .statusReportS3Bucket)
        }
        if let statusReportS3Key = statusReportS3Key {
            try encodeContainer.encode(statusReportS3Key, forKey: .statusReportS3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ImportFileTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let inputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Bucket)
        inputS3Bucket = inputS3BucketDecoded
        let inputS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Key)
        inputS3Key = inputS3KeyDecoded
        let statusReportS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Bucket)
        statusReportS3Bucket = statusReportS3BucketDecoded
        let statusReportS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Key)
        statusReportS3Key = statusReportS3KeyDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let numberOfRecordsSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsSuccess)
        numberOfRecordsSuccess = numberOfRecordsSuccessDecoded
        let numberOfRecordsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsFailed)
        numberOfRecordsFailed = numberOfRecordsFailedDecoded
        let importNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importName)
        importName = importNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the import file tasks you request.
    public struct ImportFileTaskInformation: Swift.Equatable {
        /// The time that the import task completes.
        public var completionTime: ClientRuntime.Date?
        /// The ID of the import file task.
        public var id: Swift.String?
        /// The name of the import task given in StartImportFileTask.
        public var importName: Swift.String?
        /// The S3 bucket where the import file is located.
        public var inputS3Bucket: Swift.String?
        /// The Amazon S3 key name of the import file.
        public var inputS3Key: Swift.String?
        /// The number of records that failed to be imported.
        public var numberOfRecordsFailed: Swift.Int?
        /// The number of records successfully imported.
        public var numberOfRecordsSuccess: Swift.Int?
        /// Start time of the import task.
        public var startTime: ClientRuntime.Date?
        /// Status of import file task.
        public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
        /// The S3 bucket name for status report of import task.
        public var statusReportS3Bucket: Swift.String?
        /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public var statusReportS3Key: Swift.String?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            importName: Swift.String? = nil,
            inputS3Bucket: Swift.String? = nil,
            inputS3Key: Swift.String? = nil,
            numberOfRecordsFailed: Swift.Int? = nil,
            numberOfRecordsSuccess: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
            statusReportS3Bucket: Swift.String? = nil,
            statusReportS3Key: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum ImportFileTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteFailed
        case deleteInProgress
        case deletePartialSuccess
        case deleteSuccess
        case importFailed
        case importInProgress
        case importPartialSuccess
        case importSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFileTaskStatus] {
            return [
                .deleteFailed,
                .deleteInProgress,
                .deletePartialSuccess,
                .deleteSuccess,
                .importFailed,
                .importInProgress,
                .importPartialSuccess,
                .importSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteFailed: return "DeleteFailed"
            case .deleteInProgress: return "DeleteInProgress"
            case .deletePartialSuccess: return "DeletePartialSuccess"
            case .deleteSuccess: return "DeleteSuccess"
            case .importFailed: return "ImportFailed"
            case .importInProgress: return "ImportInProgress"
            case .importPartialSuccess: return "ImportPartialSuccess"
            case .importSuccess: return "ImportSuccess"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFileTaskStatus(rawValue: rawValue) ?? ImportFileTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum InclusionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case excludeFromRecommendation
        case includeInRecommendation
        case sdkUnknown(Swift.String)

        public static var allCases: [InclusionStatus] {
            return [
                .excludeFromRecommendation,
                .includeInRecommendation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .excludeFromRecommendation: return "excludeFromAssessment"
            case .includeInRecommendation: return "includeInAssessment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InclusionStatus(rawValue: rawValue) ?? InclusionStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server experienced an internal error. Try again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentCriteria
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationComponentCriteria = applicationComponentCriteria {
            try encodeContainer.encode(applicationComponentCriteria.rawValue, forKey: .applicationComponentCriteria)
        }
        if let filterValue = filterValue {
            try encodeContainer.encode(filterValue, forKey: .filterValue)
        }
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for groupids0 in groupIdFilter {
                try groupIdFilterContainer.encode(groupids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort.rawValue, forKey: .sort)
        }
    }
}

extension ListApplicationComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-applicationcomponents"
    }
}

public struct ListApplicationComponentsInput: Swift.Equatable {
    /// Criteria for filtering the list of application components.
    public var applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria?
    /// Specify the value based on the application component criteria type. For example, if applicationComponentCriteria is set to SERVER_ID and filterValue is set to server1, then [ListApplicationComponents] returns all the application components running on server1.
    public var filterValue: Swift.String?
    /// The group ID specified in to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init (
        applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria? = nil,
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.applicationComponentCriteria = applicationComponentCriteria
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListApplicationComponentsInputBody: Swift.Equatable {
    let applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria?
    let filterValue: Swift.String?
    let sort: MigrationHubStrategyClientTypes.SortOrder?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentCriteria
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case sort
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentCriteriaDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationComponentCriteria.self, forKey: .applicationComponentCriteria)
        applicationComponentCriteria = applicationComponentCriteriaDecoded
        let filterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterValue)
        filterValue = filterValueDecoded
        let sortDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SortOrder.self, forKey: .sort)
        sort = sortDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleLockClientException" : self = .serviceLinkedRoleLockClientException(try ServiceLinkedRoleLockClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationComponentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceLinkedRoleLockClientException(ServiceLinkedRoleLockClientException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentInfos = output.applicationComponentInfos
            self.nextToken = output.nextToken
        } else {
            self.applicationComponentInfos = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationComponentsOutputResponse: Swift.Equatable {
    /// The list of application components with detailed information about each component.
    public var applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentInfos = applicationComponentInfos
        self.nextToken = nextToken
    }
}

struct ListApplicationComponentsOutputResponseBody: Swift.Equatable {
    let applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]?
    let nextToken: Swift.String?
}

extension ListApplicationComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentInfos
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentDetail?].self, forKey: .applicationComponentInfos)
        var applicationComponentInfosDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentDetail]? = nil
        if let applicationComponentInfosContainer = applicationComponentInfosContainer {
            applicationComponentInfosDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentDetail]()
            for structure0 in applicationComponentInfosContainer {
                if let structure0 = structure0 {
                    applicationComponentInfosDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentInfos = applicationComponentInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCollectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-collectors"
    }
}

public struct ListCollectorsInput: Swift.Equatable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollectorsInputBody: Swift.Equatable {
}

extension ListCollectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCollectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCollectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCollectorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCollectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCollectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectors = output.collectors
            self.nextToken = output.nextToken
        } else {
            self.collectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollectorsOutputResponse: Swift.Equatable {
    /// The list of all the installed collectors.
    public var collectors: [MigrationHubStrategyClientTypes.Collector]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        collectors: [MigrationHubStrategyClientTypes.Collector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

struct ListCollectorsOutputResponseBody: Swift.Equatable {
    let collectors: [MigrationHubStrategyClientTypes.Collector]?
    let nextToken: Swift.String?
}

extension ListCollectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Collector?].self, forKey: .collectors)
        var collectorsDecoded0:[MigrationHubStrategyClientTypes.Collector]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [MigrationHubStrategyClientTypes.Collector]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportFileTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-import-file-task"
    }
}

public struct ListImportFileTaskInput: Swift.Equatable {
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportFileTaskInputBody: Swift.Equatable {
}

extension ListImportFileTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListImportFileTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImportFileTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImportFileTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImportFileTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImportFileTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskInfos = output.taskInfos
        } else {
            self.nextToken = nil
            self.taskInfos = nil
        }
    }
}

public struct ListImportFileTaskOutputResponse: Swift.Equatable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Lists information about the files you import.
    public var taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]?

    public init (
        nextToken: Swift.String? = nil,
        taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskInfos = taskInfos
    }
}

struct ListImportFileTaskOutputResponseBody: Swift.Equatable {
    let taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]?
    let nextToken: Swift.String?
}

extension ListImportFileTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case taskInfos
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ImportFileTaskInformation?].self, forKey: .taskInfos)
        var taskInfosDecoded0:[MigrationHubStrategyClientTypes.ImportFileTaskInformation]? = nil
        if let taskInfosContainer = taskInfosContainer {
            taskInfosDecoded0 = [MigrationHubStrategyClientTypes.ImportFileTaskInformation]()
            for structure0 in taskInfosContainer {
                if let structure0 = structure0 {
                    taskInfosDecoded0?.append(structure0)
                }
            }
        }
        taskInfos = taskInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case serverCriteria
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterValue = filterValue {
            try encodeContainer.encode(filterValue, forKey: .filterValue)
        }
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for groupids0 in groupIdFilter {
                try groupIdFilterContainer.encode(groupids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverCriteria = serverCriteria {
            try encodeContainer.encode(serverCriteria.rawValue, forKey: .serverCriteria)
        }
        if let sort = sort {
            try encodeContainer.encode(sort.rawValue, forKey: .sort)
        }
    }
}

extension ListServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-servers"
    }
}

public struct ListServersInput: Swift.Equatable {
    /// Specifies the filter value, which is based on the type of server criteria. For example, if serverCriteria is OS_NAME, and the filterValue is equal to WindowsServer, then ListServers returns all of the servers matching the OS name WindowsServer.
    public var filterValue: Swift.String?
    /// Specifies the group ID to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Criteria for filtering servers.
    public var serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init (
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverCriteria = serverCriteria
        self.sort = sort
    }
}

struct ListServersInputBody: Swift.Equatable {
    let serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria?
    let filterValue: Swift.String?
    let sort: MigrationHubStrategyClientTypes.SortOrder?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case serverCriteria
        case sort
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCriteriaDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerCriteria.self, forKey: .serverCriteria)
        serverCriteria = serverCriteriaDecoded
        let filterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterValue)
        filterValue = filterValueDecoded
        let sortDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SortOrder.self, forKey: .sort)
        sort = sortDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverInfos = output.serverInfos
        } else {
            self.nextToken = nil
            self.serverInfos = nil
        }
    }
}

public struct ListServersOutputResponse: Swift.Equatable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The list of servers with detailed information about each server.
    public var serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]?

    public init (
        nextToken: Swift.String? = nil,
        serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverInfos = serverInfos
    }
}

struct ListServersOutputResponseBody: Swift.Equatable {
    let serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]?
    let nextToken: Swift.String?
}

extension ListServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serverInfos
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerDetail?].self, forKey: .serverInfos)
        var serverInfosDecoded0:[MigrationHubStrategyClientTypes.ServerDetail]? = nil
        if let serverInfosContainer = serverInfosContainer {
            serverInfosDecoded0 = [MigrationHubStrategyClientTypes.ServerDetail]()
            for structure0 in serverInfosContainer {
                if let structure0 = structure0 {
                    serverInfosDecoded0?.append(structure0)
                }
            }
        }
        serverInfos = serverInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MigrationHubStrategyClientTypes.ManagementPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsmanagedresources = "awsManagedResources"
        case nopreference = "noPreference"
        case sdkUnknown
        case selfmanageresources = "selfManageResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awsmanagedresources(awsmanagedresources):
                try container.encode(awsmanagedresources, forKey: .awsmanagedresources)
            case let .nopreference(nopreference):
                try container.encode(nopreference, forKey: .nopreference)
            case let .selfmanageresources(selfmanageresources):
                try container.encode(selfmanageresources, forKey: .selfmanageresources)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let awsmanagedresourcesDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.AwsManagedResources.self, forKey: .awsmanagedresources)
        if let awsmanagedresources = awsmanagedresourcesDecoded {
            self = .awsmanagedresources(awsmanagedresources)
            return
        }
        let selfmanageresourcesDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.SelfManageResources.self, forKey: .selfmanageresources)
        if let selfmanageresources = selfmanageresourcesDecoded {
            self = .selfmanageresources(selfmanageresources)
            return
        }
        let nopreferenceDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.NoManagementPreference.self, forKey: .nopreference)
        if let nopreference = nopreferenceDecoded {
            self = .nopreference(nopreference)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences for migrating an application to AWS.
    public enum ManagementPreference: Swift.Equatable {
        /// Indicates interest in solutions that are managed by AWS.
        case awsmanagedresources(MigrationHubStrategyClientTypes.AwsManagedResources)
        /// Indicates interest in managing your own resources on AWS.
        case selfmanageresources(MigrationHubStrategyClientTypes.SelfManageResources)
        /// No specific preference.
        case nopreference(MigrationHubStrategyClientTypes.NoManagementPreference)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes.NetworkInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interfaceName
        case ipAddress
        case macAddress
        case netMask
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interfaceName = interfaceName {
            try encodeContainer.encode(interfaceName, forKey: .interfaceName)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let netMask = netMask {
            try encodeContainer.encode(netMask, forKey: .netMask)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceName)
        interfaceName = interfaceNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let netMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netMask)
        netMask = netMaskDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the server's network for which the assessment was run.
    public struct NetworkInfo: Swift.Equatable {
        /// Information about the name of the interface of the server for which the assessment was run.
        /// This member is required.
        public var interfaceName: Swift.String?
        /// Information about the IP address of the server for which the assessment was run.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// Information about the MAC address of the server for which the assessment was run.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Information about the subnet mask of the server for which the assessment was run.
        /// This member is required.
        public var netMask: Swift.String?

        public init (
            interfaceName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            netMask: Swift.String? = nil
        )
        {
            self.interfaceName = interfaceName
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.netMask = netMask
        }
    }

}

extension MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for targetdatabaseengines0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(targetdatabaseengines0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.TargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.TargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.TargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about database migration preferences, when you have no particular preference.
    public struct NoDatabaseMigrationPreference: Swift.Equatable {
        /// The target database engine for database migration preference that you specify.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]?

        public init (
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes.NoManagementPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for nopreferencetargetdestinations0 in targetDestination {
                try targetDestinationContainer.encode(nopreferencetargetdestinations0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.NoPreferenceTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the choice of application destination that you specify.
    public struct NoManagementPreference: Swift.Equatable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]?

        public init (
            targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum NoPreferenceTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [NoPreferenceTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NoPreferenceTargetDestination(rawValue: rawValue) ?? NoPreferenceTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.OSInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the operating system.
    public struct OSInfo: Swift.Equatable {
        /// Information about the type of operating system.
        public var type: MigrationHubStrategyClientTypes.OSType?
        /// Information about the version of operating system.
        public var version: Swift.String?

        public init (
            type: MigrationHubStrategyClientTypes.OSType? = nil,
            version: Swift.String? = nil
        )
        {
            self.type = type
            self.version = version
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum OSType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OSType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OSType(rawValue: rawValue) ?? OSType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case excel
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .excel,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .excel: return "Excel"
            case .json: return "Json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.PrioritizeBusinessGoals: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessGoals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessGoals = businessGoals {
            try encodeContainer.encode(businessGoals, forKey: .businessGoals)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.BusinessGoals.self, forKey: .businessGoals)
        businessGoals = businessGoalsDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Rank of business goals based on priority.
    public struct PrioritizeBusinessGoals: Swift.Equatable {
        /// Rank of business goals based on priority.
        public var businessGoals: MigrationHubStrategyClientTypes.BusinessGoals?

        public init (
            businessGoals: MigrationHubStrategyClientTypes.BusinessGoals? = nil
        )
        {
            self.businessGoals = businessGoals
        }
    }

}

extension PutPortfolioPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPreferences = applicationPreferences {
            try encodeContainer.encode(applicationPreferences, forKey: .applicationPreferences)
        }
        if let databasePreferences = databasePreferences {
            try encodeContainer.encode(databasePreferences, forKey: .databasePreferences)
        }
        if let prioritizeBusinessGoals = prioritizeBusinessGoals {
            try encodeContainer.encode(prioritizeBusinessGoals, forKey: .prioritizeBusinessGoals)
        }
    }
}

extension PutPortfolioPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-portfolio-preferences"
    }
}

public struct PutPortfolioPreferencesInput: Swift.Equatable {
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of the business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init (
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

struct PutPortfolioPreferencesInputBody: Swift.Equatable {
    let prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?
    let applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    let databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
}

extension PutPortfolioPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prioritizeBusinessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.self, forKey: .prioritizeBusinessGoals)
        prioritizeBusinessGoals = prioritizeBusinessGoalsDecoded
        let applicationPreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationPreferences.self, forKey: .applicationPreferences)
        applicationPreferences = applicationPreferencesDecoded
        let databasePreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabasePreferences.self, forKey: .databasePreferences)
        databasePreferences = databasePreferencesDecoded
    }
}

extension PutPortfolioPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPortfolioPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPortfolioPreferencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPortfolioPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutPortfolioPreferencesOutputResponse: Swift.Equatable {

}

extension MigrationHubStrategyClientTypes.RecommendationReportDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case s3Bucket
        case s3Keys
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for s3keys0 in s3Keys {
                try s3KeysContainer.encode(s3keys0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationReportStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains detailed information about a recommendation report.
    public struct RecommendationReportDetails: Swift.Equatable {
        /// The time that the recommendation report generation task completes.
        public var completionTime: ClientRuntime.Date?
        /// The S3 bucket where the report file is located.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name of the report file.
        public var s3Keys: [Swift.String]?
        /// The time that the recommendation report generation task starts.
        public var startTime: ClientRuntime.Date?
        /// The status of the recommendation report generation task.
        public var status: MigrationHubStrategyClientTypes.RecommendationReportStatus?
        /// The status message for recommendation report generation.
        public var statusMessage: Swift.String?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.RecommendationReportStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum RecommendationReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationReportStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationReportStatus(rawValue: rawValue) ?? RecommendationReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.RecommendationSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case strategy
        case targetDestination
        case transformationTool
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let strategy = strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
        if let targetDestination = targetDestination {
            try encodeContainer.encode(targetDestination.rawValue, forKey: .targetDestination)
        }
        if let transformationTool = transformationTool {
            try encodeContainer.encode(transformationTool, forKey: .transformationTool)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformationToolDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationTool.self, forKey: .transformationTool)
        transformationTool = transformationToolDecoded
        let targetDestinationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TargetDestination.self, forKey: .targetDestination)
        targetDestination = targetDestinationDecoded
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains a recommendation set.
    public struct RecommendationSet: Swift.Equatable {
        /// The recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// The recommended target destination.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The target destination for the recommendation set.
        public var transformationTool: MigrationHubStrategyClientTypes.TransformationTool?

        public init (
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            transformationTool: MigrationHubStrategyClientTypes.TransformationTool? = nil
        )
        {
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.transformationTool = transformationTool
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified ID in the request is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ResourceSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case database
        case databaseProcess
        case process
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSubType] {
            return [
                .database,
                .databaseProcess,
                .process,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .database: return "Database"
            case .databaseProcess: return "DatabaseProcess"
            case .process: return "Process"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSubType(rawValue: rawValue) ?? ResourceSubType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum RunTimeAssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dcFailed
        case dcPartialSuccess
        case dcReqSent
        case dcStarted
        case dcStopped
        case dcSuccess
        case dcToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RunTimeAssessmentStatus] {
            return [
                .dcFailed,
                .dcPartialSuccess,
                .dcReqSent,
                .dcStarted,
                .dcStopped,
                .dcSuccess,
                .dcToBeScheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dcFailed: return "dataCollectionTaskFailed"
            case .dcPartialSuccess: return "dataCollectionTaskPartialSuccess"
            case .dcReqSent: return "dataCollectionTaskScheduled"
            case .dcStarted: return "dataCollectionTaskStarted"
            case .dcStopped: return "dataCollectionTaskStopped"
            case .dcSuccess: return "dataCollectionTaskSuccess"
            case .dcToBeScheduled: return "dataCollectionTaskToBeScheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunTimeAssessmentStatus(rawValue: rawValue) ?? RunTimeAssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3key = s3key {
            try encodeContainer.encode(s3key, forKey: .s3key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3key)
        s3key = s3keyDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the S3 bucket name and the Amazon S3 key name.
    public struct S3Object: Swift.Equatable {
        /// The S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name.
        public var s3key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3key = s3key
        }
    }

}

extension MigrationHubStrategyClientTypes.SelfManageResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for selfmanagetargetdestinations0 in targetDestination {
                try targetDestinationContainer.encode(selfmanagetargetdestinations0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SelfManageTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.SelfManageTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.SelfManageTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Self-managed resources.
    public struct SelfManageResources: Swift.Equatable {
        /// Self-managed resources target destination.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]?

        public init (
            targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum SelfManageTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [SelfManageTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelfManageTargetDestination(rawValue: rawValue) ?? SelfManageTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ServerCriteria: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destination
        case notDefined
        case osName
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCriteria] {
            return [
                .destination,
                .notDefined,
                .osName,
                .serverId,
                .strategy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destination: return "DESTINATION"
            case .notDefined: return "NOT_DEFINED"
            case .osName: return "OS_NAME"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerCriteria(rawValue: rawValue) ?? ServerCriteria.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ServerDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case applicationComponentStrategySummary
        case dataCollectionStatus
        case id
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case name
        case recommendationSet
        case serverType
        case statusMessage
        case systemInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antipatternReportS3Object = antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let applicationComponentStrategySummary = applicationComponentStrategySummary {
            var applicationComponentStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationComponentStrategySummary)
            for liststrategysummary0 in applicationComponentStrategySummary {
                try applicationComponentStrategySummaryContainer.encode(liststrategysummary0)
            }
        }
        if let dataCollectionStatus = dataCollectionStatus {
            try encodeContainer.encode(dataCollectionStatus.rawValue, forKey: .dataCollectionStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastAnalyzedTimestamp = lastAnalyzedTimestamp {
            try encodeContainer.encode(lastAnalyzedTimestamp.timeIntervalSince1970, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for listantipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(listantipatternseveritysummary0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationSet = recommendationSet {
            try encodeContainer.encode(recommendationSet, forKey: .recommendationSet)
        }
        if let serverType = serverType {
            try encodeContainer.encode(serverType, forKey: .serverType)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let systemInfo = systemInfo {
            try encodeContainer.encode(systemInfo, forKey: .systemInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommendationSetDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendationSet)
        recommendationSet = recommendationSetDecoded
        let dataCollectionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RunTimeAssessmentStatus.self, forKey: .dataCollectionStatus)
        dataCollectionStatus = dataCollectionStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let systemInfoDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SystemInfo.self, forKey: .systemInfo)
        systemInfo = systemInfoDecoded
        let applicationComponentStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .applicationComponentStrategySummary)
        var applicationComponentStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let applicationComponentStrategySummaryContainer = applicationComponentStrategySummaryContainer {
            applicationComponentStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in applicationComponentStrategySummaryContainer {
                if let structure0 = structure0 {
                    applicationComponentStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentStrategySummary = applicationComponentStrategySummaryDecoded0
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Detailed information about a server.
    public struct ServerDetail: Swift.Equatable {
        /// The S3 bucket name and Amazon S3 key name for anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// A message about the status of the anti-pattern report generation.
        public var antipatternReportStatusMessage: Swift.String?
        /// A list of strategy summaries.
        public var applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// The status of assessment for the server.
        public var dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus?
        /// The server ID.
        public var id: Swift.String?
        /// The timestamp of when the server was assessed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// The name of the server.
        public var name: Swift.String?
        /// A set of recommendations.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The type of server.
        public var serverType: Swift.String?
        /// A message about the status of data collection, which contains detailed descriptions of any error messages.
        public var statusMessage: Swift.String?
        /// System information about the server.
        public var systemInfo: MigrationHubStrategyClientTypes.SystemInfo?

        public init (
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus? = nil,
            id: Swift.String? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            name: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            serverType: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            systemInfo: MigrationHubStrategyClientTypes.SystemInfo? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.applicationComponentStrategySummary = applicationComponentStrategySummary
            self.dataCollectionStatus = dataCollectionStatus
            self.id = id
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.name = name
            self.recommendationSet = recommendationSet
            self.serverType = serverType
            self.statusMessage = statusMessage
            self.systemInfo = systemInfo
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum ServerOsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonlinux
        case endofsupportwindowsserver
        case other
        case redhat
        case windowsserver
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerOsType] {
            return [
                .amazonlinux,
                .endofsupportwindowsserver,
                .other,
                .redhat,
                .windowsserver,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonlinux: return "AmazonLinux"
            case .endofsupportwindowsserver: return "EndOfSupportWindowsServer"
            case .other: return "Other"
            case .redhat: return "Redhat"
            case .windowsserver: return "WindowsServer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerOsType(rawValue: rawValue) ?? ServerOsType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ServerStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case numberOfApplicationComponents
        case recommendation
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let numberOfApplicationComponents = numberOfApplicationComponents {
            try encodeContainer.encode(numberOfApplicationComponents, forKey: .numberOfApplicationComponents)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyRecommendation.self, forKey: .status)
        status = statusDecoded
        let numberOfApplicationComponentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfApplicationComponents)
        numberOfApplicationComponents = numberOfApplicationComponentsDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains information about a strategy recommendation for a server.
    public struct ServerStrategy: Swift.Equatable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// The number of application components with this strategy recommendation running on the server.
        public var numberOfApplicationComponents: Swift.Int?
        /// Strategy recommendation for the server.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of the strategy for the server.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init (
            isPreferred: Swift.Bool? = nil,
            numberOfApplicationComponents: Swift.Int? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.numberOfApplicationComponents = numberOfApplicationComponents
            self.recommendation = recommendation
            self.status = status
        }
    }

}

extension MigrationHubStrategyClientTypes.ServerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverOsType = "ServerOsType"
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverOsType = serverOsType {
            try encodeContainer.encode(serverOsType.rawValue, forKey: .serverOsType)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverOsTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerOsType.self, forKey: .serverOsType)
        serverOsType = serverOsTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing details about the servers imported by Application Discovery Service
    public struct ServerSummary: Swift.Equatable {
        /// Number of servers.
        public var count: Swift.Int?
        /// Type of operating system for the servers.
        public var serverOsType: MigrationHubStrategyClientTypes.ServerOsType?

        public init (
            count: Swift.Int? = nil,
            serverOsType: MigrationHubStrategyClientTypes.ServerOsType? = nil
        )
        {
            self.count = count
            self.serverOsType = serverOsType
        }
    }

}

extension ServiceLinkedRoleLockClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLinkedRoleLockClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception to indicate that the service-linked role (SLR) is locked.
public struct ServiceLinkedRoleLockClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLinkedRoleLockClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceLinkedRoleLockClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.SourceCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case sourceVersion
        case versionControl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let versionControl = versionControl {
            try encodeContainer.encode(versionControl.rawValue, forKey: .versionControl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionControlDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.VersionControl.self, forKey: .versionControl)
        versionControl = versionControlDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing source code information that is linked to an application component.
    public struct SourceCode: Swift.Equatable {
        /// The repository name for the source code.
        public var location: Swift.String?
        /// The branch of the source code.
        public var sourceVersion: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControl: MigrationHubStrategyClientTypes.VersionControl?

        public init (
            location: Swift.String? = nil,
            sourceVersion: Swift.String? = nil,
            versionControl: MigrationHubStrategyClientTypes.VersionControl? = nil
        )
        {
            self.location = location
            self.sourceVersion = sourceVersion
            self.versionControl = versionControl
        }
    }

}

extension MigrationHubStrategyClientTypes.SourceCodeRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case repository
        case versionControlType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let versionControlType = versionControlType {
            try encodeContainer.encode(versionControlType, forKey: .versionControlType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let versionControlTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionControlType)
        versionControlType = versionControlTypeDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing source code information that is linked to an application component.
    public struct SourceCodeRepository: Swift.Equatable {
        /// The branch of the source code.
        public var branch: Swift.String?
        /// The repository name for the source code.
        public var repository: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControlType: Swift.String?

        public init (
            branch: Swift.String? = nil,
            repository: Swift.String? = nil,
            versionControlType: Swift.String? = nil
        )
        {
            self.branch = branch
            self.repository = repository
            self.versionControlType = versionControlType
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum SrcCodeOrDbAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisFailed
        case analysisStarted
        case analysisSuccess
        case analysisToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [SrcCodeOrDbAnalysisStatus] {
            return [
                .analysisFailed,
                .analysisStarted,
                .analysisSuccess,
                .analysisToBeScheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisFailed: return "ANALYSIS_FAILED"
            case .analysisStarted: return "ANALYSIS_STARTED"
            case .analysisSuccess: return "ANALYSIS_SUCCESS"
            case .analysisToBeScheduled: return "ANALYSIS_TO_BE_SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SrcCodeOrDbAnalysisStatus(rawValue: rawValue) ?? SrcCodeOrDbAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3bucketForAnalysisData
        case s3bucketForReportData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3bucketForAnalysisData = s3bucketForAnalysisData {
            try encodeContainer.encode(s3bucketForAnalysisData, forKey: .s3bucketForAnalysisData)
        }
        if let s3bucketForReportData = s3bucketForReportData {
            try encodeContainer.encode(s3bucketForReportData, forKey: .s3bucketForReportData)
        }
    }
}

extension StartAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-assessment"
    }
}

public struct StartAssessmentInput: Swift.Equatable {
    /// The S3 bucket used by the collectors to send analysis data to the service. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForAnalysisData: Swift.String?
    /// The S3 bucket where all the reports generated by the service are stored. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?

    public init (
        s3bucketForAnalysisData: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil
    )
    {
        self.s3bucketForAnalysisData = s3bucketForAnalysisData
        self.s3bucketForReportData = s3bucketForReportData
    }
}

struct StartAssessmentInputBody: Swift.Equatable {
    let s3bucketForAnalysisData: Swift.String?
    let s3bucketForReportData: Swift.String?
}

extension StartAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3bucketForAnalysisData
        case s3bucketForReportData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3bucketForAnalysisDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForAnalysisData)
        s3bucketForAnalysisData = s3bucketForAnalysisDataDecoded
        let s3bucketForReportDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForReportData)
        s3bucketForReportData = s3bucketForReportDataDecoded
    }
}

extension StartAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentId = output.assessmentId
        } else {
            self.assessmentId = nil
        }
    }
}

public struct StartAssessmentOutputResponse: Swift.Equatable {
    /// The ID of the assessment.
    public var assessmentId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct StartAssessmentOutputResponseBody: Swift.Equatable {
    let assessmentId: Swift.String?
}

extension StartAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
    }
}

extension StartImportFileTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case dataSourceType
        case groupId
        case name
        case s3bucketForReportData
        case s3key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let dataSourceType = dataSourceType {
            try encodeContainer.encode(dataSourceType.rawValue, forKey: .dataSourceType)
        }
        if let groupId = groupId {
            var groupIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupId)
            for groupids0 in groupId {
                try groupIdContainer.encode(groupids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3bucketForReportData = s3bucketForReportData {
            try encodeContainer.encode(s3bucketForReportData, forKey: .s3bucketForReportData)
        }
        if let s3key = s3key {
            try encodeContainer.encode(s3key, forKey: .s3key)
        }
    }
}

extension StartImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-import-file-task"
    }
}

public struct StartImportFileTaskInput: Swift.Equatable {
    /// Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that the servers specified in the import file are available in AWS Application Discovery Service.
    public var dataSourceType: MigrationHubStrategyClientTypes.DataSourceType?
    /// Groups the resources in the import file together with a unique name. This ID can be as filter in ListApplicationComponents and ListServers.
    public var groupId: [MigrationHubStrategyClientTypes.Group]?
    /// A descriptive name for the request.
    /// This member is required.
    public var name: Swift.String?
    /// The S3 bucket where the import file is located. The bucket name is required to begin with migrationhub-strategy-.
    /// This member is required.
    public var s3Bucket: Swift.String?
    /// The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?
    /// The Amazon S3 key name of the import file.
    /// This member is required.
    public var s3key: Swift.String?

    public init (
        dataSourceType: MigrationHubStrategyClientTypes.DataSourceType? = nil,
        groupId: [MigrationHubStrategyClientTypes.Group]? = nil,
        name: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil,
        s3key: Swift.String? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.groupId = groupId
        self.name = name
        self.s3Bucket = s3Bucket
        self.s3bucketForReportData = s3bucketForReportData
        self.s3key = s3key
    }
}

struct StartImportFileTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3Bucket: Swift.String?
    let s3key: Swift.String?
    let dataSourceType: MigrationHubStrategyClientTypes.DataSourceType?
    let groupId: [MigrationHubStrategyClientTypes.Group]?
    let s3bucketForReportData: Swift.String?
}

extension StartImportFileTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case dataSourceType
        case groupId
        case name
        case s3bucketForReportData
        case s3key
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3key)
        s3key = s3keyDecoded
        let dataSourceTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DataSourceType.self, forKey: .dataSourceType)
        dataSourceType = dataSourceTypeDecoded
        let groupIdContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupId)
        var groupIdDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdContainer = groupIdContainer {
            groupIdDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdContainer {
                if let structure0 = structure0 {
                    groupIdDecoded0?.append(structure0)
                }
            }
        }
        groupId = groupIdDecoded0
        let s3bucketForReportDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForReportData)
        s3bucketForReportData = s3bucketForReportDataDecoded
    }
}

extension StartImportFileTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportFileTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImportFileTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportFileTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartImportFileTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct StartImportFileTaskOutputResponse: Swift.Equatable {
    /// The ID for a specific import task. The ID is unique within an AWS account.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartImportFileTaskOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension StartImportFileTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension StartRecommendationReportGenerationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIdFilter
        case outputFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for groupids0 in groupIdFilter {
                try groupIdFilterContainer.encode(groupids0)
            }
        }
        if let outputFormat = outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
    }
}

extension StartRecommendationReportGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-recommendation-report-generation"
    }
}

public struct StartRecommendationReportGenerationInput: Swift.Equatable {
    /// Groups the resources in the recommendation report with a unique name.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The output format for the recommendation report file. The default format is Microsoft Excel.
    public var outputFormat: MigrationHubStrategyClientTypes.OutputFormat?

    public init (
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        outputFormat: MigrationHubStrategyClientTypes.OutputFormat? = nil
    )
    {
        self.groupIdFilter = groupIdFilter
        self.outputFormat = outputFormat
    }
}

struct StartRecommendationReportGenerationInputBody: Swift.Equatable {
    let outputFormat: MigrationHubStrategyClientTypes.OutputFormat?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
}

extension StartRecommendationReportGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIdFilter
        case outputFormat
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputFormatDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
    }
}

extension StartRecommendationReportGenerationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRecommendationReportGenerationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRecommendationReportGenerationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRecommendationReportGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRecommendationReportGenerationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct StartRecommendationReportGenerationOutputResponse: Swift.Equatable {
    /// The ID of the recommendation report generation task.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartRecommendationReportGenerationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension StartRecommendationReportGenerationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
    }
}

extension StopAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stop-assessment"
    }
}

public struct StopAssessmentInput: Swift.Equatable {
    /// The assessmentId returned by [StartAssessment].
    /// This member is required.
    public var assessmentId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct StopAssessmentInputBody: Swift.Equatable {
    let assessmentId: Swift.String?
}

extension StopAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
    }
}

extension StopAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAssessmentOutputResponse: Swift.Equatable {

}

extension MigrationHubStrategyClientTypes {
    public enum Strategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case refactor
        case rehost
        case relocate
        case replatform
        case repurchase
        case retain
        case retirement
        case sdkUnknown(Swift.String)

        public static var allCases: [Strategy] {
            return [
                .refactor,
                .rehost,
                .relocate,
                .replatform,
                .repurchase,
                .retain,
                .retirement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .refactor: return "Refactor"
            case .rehost: return "Rehost"
            case .relocate: return "Relocate"
            case .replatform: return "Replatform"
            case .repurchase: return "Repurchase"
            case .retain: return "Retain"
            case .retirement: return "Retirement"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Strategy(rawValue: rawValue) ?? Strategy.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.StrategyOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case strategy
        case targetDestination
        case toolName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let strategy = strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
        if let targetDestination = targetDestination {
            try encodeContainer.encode(targetDestination.rawValue, forKey: .targetDestination)
        }
        if let toolName = toolName {
            try encodeContainer.encode(toolName.rawValue, forKey: .toolName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
        let toolNameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationToolName.self, forKey: .toolName)
        toolName = toolNameDecoded
        let targetDestinationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TargetDestination.self, forKey: .targetDestination)
        targetDestination = targetDestinationDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about all the available strategy options for migrating and modernizing an application component.
    public struct StrategyOption: Swift.Equatable {
        /// Indicates if a specific strategy is preferred for the application component.
        public var isPreferred: Swift.Bool?
        /// Type of transformation. For example, Rehost, Replatform, and so on.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// Destination information about where the application component can migrate to. For example, EC2, ECS, and so on.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The name of the tool that can be used to transform an application component using this strategy.
        public var toolName: MigrationHubStrategyClientTypes.TransformationToolName?

        public init (
            isPreferred: Swift.Bool? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            toolName: MigrationHubStrategyClientTypes.TransformationToolName? = nil
        )
        {
            self.isPreferred = isPreferred
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.toolName = toolName
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum StrategyRecommendation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notRecommended
        case recommended
        case viableOption
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyRecommendation] {
            return [
                .notRecommended,
                .recommended,
                .viableOption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notRecommended: return "notRecommended"
            case .recommended: return "recommended"
            case .viableOption: return "viableOption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StrategyRecommendation(rawValue: rawValue) ?? StrategyRecommendation.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.StrategySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case strategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let strategy = strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the summary of the strategy recommendations.
    public struct StrategySummary: Swift.Equatable {
        /// The count of recommendations per strategy.
        public var count: Swift.Int?
        /// The name of recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?

        public init (
            count: Swift.Int? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil
        )
        {
            self.count = count
            self.strategy = strategy
        }
    }

}

extension MigrationHubStrategyClientTypes.SystemInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuArchitecture
        case fileSystemType
        case networkInfoList
        case osInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpuArchitecture = cpuArchitecture {
            try encodeContainer.encode(cpuArchitecture, forKey: .cpuArchitecture)
        }
        if let fileSystemType = fileSystemType {
            try encodeContainer.encode(fileSystemType, forKey: .fileSystemType)
        }
        if let networkInfoList = networkInfoList {
            var networkInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInfoList)
            for networkinfolist0 in networkInfoList {
                try networkInfoListContainer.encode(networkinfolist0)
            }
        }
        if let osInfo = osInfo {
            try encodeContainer.encode(osInfo, forKey: .osInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osInfoDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSInfo.self, forKey: .osInfo)
        osInfo = osInfoDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let networkInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.NetworkInfo?].self, forKey: .networkInfoList)
        var networkInfoListDecoded0:[MigrationHubStrategyClientTypes.NetworkInfo]? = nil
        if let networkInfoListContainer = networkInfoListContainer {
            networkInfoListDecoded0 = [MigrationHubStrategyClientTypes.NetworkInfo]()
            for structure0 in networkInfoListContainer {
                if let structure0 = structure0 {
                    networkInfoListDecoded0?.append(structure0)
                }
            }
        }
        networkInfoList = networkInfoListDecoded0
        let cpuArchitectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpuArchitecture)
        cpuArchitecture = cpuArchitectureDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the server that hosts application components.
    public struct SystemInfo: Swift.Equatable {
        /// CPU architecture type for the server.
        public var cpuArchitecture: Swift.String?
        /// File system type for the server.
        public var fileSystemType: Swift.String?
        /// Networking information related to a server.
        public var networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]?
        /// Operating system corresponding to a server.
        public var osInfo: MigrationHubStrategyClientTypes.OSInfo?

        public init (
            cpuArchitecture: Swift.String? = nil,
            fileSystemType: Swift.String? = nil,
            networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]? = nil,
            osInfo: MigrationHubStrategyClientTypes.OSInfo? = nil
        )
        {
            self.cpuArchitecture = cpuArchitecture
            self.fileSystemType = fileSystemType
            self.networkInfoList = networkInfoList
            self.osInfo = osInfo
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum TargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDatabaseEngine(rawValue: rawValue) ?? TargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum TargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonDocumentdb
        case amazonDynamodb
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case amazonRds
        case amazonRdsMysql
        case amazonRdsPostgresql
        case auroraMysql
        case auroraPostgresql
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDestination] {
            return [
                .amazonDocumentdb,
                .amazonDynamodb,
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .amazonRds,
                .amazonRdsMysql,
                .amazonRdsPostgresql,
                .auroraMysql,
                .auroraPostgresql,
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonDocumentdb: return "Amazon DocumentDB"
            case .amazonDynamodb: return "Amazon DynamoDB"
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .amazonRds: return "Amazon Relational Database Service"
            case .amazonRdsMysql: return "Amazon Relational Database Service on MySQL"
            case .amazonRdsPostgresql: return "Amazon Relational Database Service on PostgreSQL"
            case .auroraMysql: return "Aurora MySQL"
            case .auroraPostgresql: return "Aurora PostgreSQL"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDestination(rawValue: rawValue) ?? TargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.TransformationTool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tranformationToolInstallationLink
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let tranformationToolInstallationLink = tranformationToolInstallationLink {
            try encodeContainer.encode(tranformationToolInstallationLink, forKey: .tranformationToolInstallationLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationToolName.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tranformationToolInstallationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tranformationToolInstallationLink)
        tranformationToolInstallationLink = tranformationToolInstallationLinkDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information of the transformation tool that can be used to migrate and modernize the application.
    public struct TransformationTool: Swift.Equatable {
        /// Description of the tool.
        public var description: Swift.String?
        /// Name of the tool.
        public var name: MigrationHubStrategyClientTypes.TransformationToolName?
        /// URL for installing the tool.
        public var tranformationToolInstallationLink: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: MigrationHubStrategyClientTypes.TransformationToolName? = nil,
            tranformationToolInstallationLink: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.tranformationToolInstallationLink = tranformationToolInstallationLink
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum TransformationToolName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app2container
        case dms
        case emp
        case inPlaceOsUpgrade
        case mgn
        case nativeSql
        case portingAssistant
        case sct
        case strategyRecommendationSupport
        case wwama
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformationToolName] {
            return [
                .app2container,
                .dms,
                .emp,
                .inPlaceOsUpgrade,
                .mgn,
                .nativeSql,
                .portingAssistant,
                .sct,
                .strategyRecommendationSupport,
                .wwama,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app2container: return "App2Container"
            case .dms: return "Database Migration Service"
            case .emp: return "End of Support Migration"
            case .inPlaceOsUpgrade: return "In Place Operating System Upgrade"
            case .mgn: return "Application Migration Service"
            case .nativeSql: return "Native SQL Server Backup/Restore"
            case .portingAssistant: return "Porting Assistant For .NET"
            case .sct: return "Schema Conversion Tool"
            case .strategyRecommendationSupport: return "Strategy Recommendation Support"
            case .wwama: return "Windows Web Application Migration Assistant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransformationToolName(rawValue: rawValue) ?? TransformationToolName.sdkUnknown(rawValue)
        }
    }
}

extension UpdateApplicationComponentConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentId
        case inclusionStatus
        case secretsManagerKey
        case sourceCodeList
        case strategyOption
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationComponentId = applicationComponentId {
            try encodeContainer.encode(applicationComponentId, forKey: .applicationComponentId)
        }
        if let inclusionStatus = inclusionStatus {
            try encodeContainer.encode(inclusionStatus.rawValue, forKey: .inclusionStatus)
        }
        if let secretsManagerKey = secretsManagerKey {
            try encodeContainer.encode(secretsManagerKey, forKey: .secretsManagerKey)
        }
        if let sourceCodeList = sourceCodeList {
            var sourceCodeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCodeList)
            for sourcecodelist0 in sourceCodeList {
                try sourceCodeListContainer.encode(sourcecodelist0)
            }
        }
        if let strategyOption = strategyOption {
            try encodeContainer.encode(strategyOption, forKey: .strategyOption)
        }
    }
}

extension UpdateApplicationComponentConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-applicationcomponent-config"
    }
}

public struct UpdateApplicationComponentConfigInput: Swift.Equatable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?
    /// Indicates whether the application component has been included for server recommendation or not.
    public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
    /// Database credentials.
    public var secretsManagerKey: Swift.String?
    /// The list of source code configurations to update for the application component.
    public var sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]?
    /// The preferred strategy options for the application component. Use values from the [GetApplicationComponentStrategies] response.
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init (
        applicationComponentId: Swift.String? = nil,
        inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
        secretsManagerKey: Swift.String? = nil,
        sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
        self.inclusionStatus = inclusionStatus
        self.secretsManagerKey = secretsManagerKey
        self.sourceCodeList = sourceCodeList
        self.strategyOption = strategyOption
    }
}

struct UpdateApplicationComponentConfigInputBody: Swift.Equatable {
    let applicationComponentId: Swift.String?
    let inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
    let strategyOption: MigrationHubStrategyClientTypes.StrategyOption?
    let sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]?
    let secretsManagerKey: Swift.String?
}

extension UpdateApplicationComponentConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentId
        case inclusionStatus
        case secretsManagerKey
        case sourceCodeList
        case strategyOption
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationComponentId)
        applicationComponentId = applicationComponentIdDecoded
        let inclusionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.InclusionStatus.self, forKey: .inclusionStatus)
        inclusionStatus = inclusionStatusDecoded
        let strategyOptionDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyOption.self, forKey: .strategyOption)
        strategyOption = strategyOptionDecoded
        let sourceCodeListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SourceCode?].self, forKey: .sourceCodeList)
        var sourceCodeListDecoded0:[MigrationHubStrategyClientTypes.SourceCode]? = nil
        if let sourceCodeListContainer = sourceCodeListContainer {
            sourceCodeListDecoded0 = [MigrationHubStrategyClientTypes.SourceCode]()
            for structure0 in sourceCodeListContainer {
                if let structure0 = structure0 {
                    sourceCodeListDecoded0?.append(structure0)
                }
            }
        }
        sourceCodeList = sourceCodeListDecoded0
        let secretsManagerKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerKey)
        secretsManagerKey = secretsManagerKeyDecoded
    }
}

extension UpdateApplicationComponentConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationComponentConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationComponentConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationComponentConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationComponentConfigOutputResponse: Swift.Equatable {

}

extension UpdateServerConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId
        case strategyOption
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let strategyOption = strategyOption {
            try encodeContainer.encode(strategyOption, forKey: .strategyOption)
        }
    }
}

extension UpdateServerConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-server-config"
    }
}

public struct UpdateServerConfigInput: Swift.Equatable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The preferred strategy options for the application component. See the response from [GetServerStrategies].
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init (
        serverId: Swift.String? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.serverId = serverId
        self.strategyOption = strategyOption
    }
}

struct UpdateServerConfigInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let strategyOption: MigrationHubStrategyClientTypes.StrategyOption?
}

extension UpdateServerConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId
        case strategyOption
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let strategyOptionDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyOption.self, forKey: .strategyOption)
        strategyOption = strategyOptionDecoded
    }
}

extension UpdateServerConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerConfigOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServerConfigOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request body isn't valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum VersionControl: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionControl] {
            return [
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionControl(rawValue: rawValue) ?? VersionControl.sdkUnknown(rawValue)
        }
    }
}
