// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptEulasInputBodyMiddleware: Middleware {
    public let id: String = "AcceptEulasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptEulasOutputError>
}

extension AcceptEulasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptEulasInput(clientToken: \(String(describing: clientToken)), eulaIds: \(String(describing: eulaIds)), studioId: \(String(describing: studioId)))"}
}

extension AcceptEulasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eulaIds = "eulaIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
    }
}

public struct AcceptEulasInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptEulasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptEulasOutputError>
}

public struct AcceptEulasInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptEulasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptEulasOutputError>
}

/// <p>A collection of EULA acceptances.</p>
public struct AcceptEulasInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The EULA ID.</p>
    public let eulaIds: [String]?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        eulaIds: [String]? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.eulaIds = eulaIds
        self.studioId = studioId
    }
}

struct AcceptEulasInputBody: Equatable {
    public let eulaIds: [String]?
}

extension AcceptEulasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eulaIds = "eulaIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
    }
}

extension AcceptEulasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptEulasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptEulasOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptEulasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptEulasOutputResponse(eulaAcceptances: \(String(describing: eulaAcceptances)))"}
}

extension AcceptEulasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
        } else {
            self.eulaAcceptances = nil
        }
    }
}

public struct AcceptEulasOutputResponse: Equatable {
    /// <p>A collection of EULA acceptances.</p>
    public let eulaAcceptances: [EulaAcceptance]?

    public init (
        eulaAcceptances: [EulaAcceptance]? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
    }
}

struct AcceptEulasOutputResponseBody: Equatable {
    public let eulaAcceptances: [EulaAcceptance]?
}

extension AcceptEulasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eulaAcceptances = "eulaAcceptances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActiveDirectoryComputerAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ActiveDirectoryComputerAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveDirectoryComputerAttribute(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.</p>
public struct ActiveDirectoryComputerAttribute: Equatable {
    /// <p>The name for the LDAP attribute.</p>
    public let name: String?
    /// <p>The value for the LDAP attribute.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension ActiveDirectoryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computerAttributes = "computerAttributes"
        case directoryId = "directoryId"
        case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension ActiveDirectoryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveDirectoryConfiguration(computerAttributes: \(String(describing: computerAttributes)), directoryId: \(String(describing: directoryId)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)))"}
}

/// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
public struct ActiveDirectoryConfiguration: Equatable {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    public let computerAttributes: [ActiveDirectoryComputerAttribute]?
    /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this studio component.</p>
    public let directoryId: String?
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    public let organizationalUnitDistinguishedName: String?

    public init (
        computerAttributes: [ActiveDirectoryComputerAttribute]? = nil,
        directoryId: String? = nil,
        organizationalUnitDistinguishedName: String? = nil
    )
    {
        self.computerAttributes = computerAttributes
        self.directoryId = directoryId
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
    }
}

extension ComputeFarmConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryUser = "activeDirectoryUser"
        case endpoint = "endpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryUser = activeDirectoryUser {
            try encodeContainer.encode(activeDirectoryUser, forKey: .activeDirectoryUser)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeDirectoryUser)
        activeDirectoryUser = activeDirectoryUserDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ComputeFarmConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComputeFarmConfiguration(activeDirectoryUser: \(String(describing: activeDirectoryUser)), endpoint: \(String(describing: endpoint)))"}
}

/// <p>The configuration for a render farm that is associated with a studio resource.</p>
public struct ComputeFarmConfiguration: Equatable {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    public let activeDirectoryUser: String?
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    public let endpoint: String?

    public init (
        activeDirectoryUser: String? = nil,
        endpoint: String? = nil
    )
    {
        self.activeDirectoryUser = activeDirectoryUser
        self.endpoint = endpoint
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateLaunchProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateLaunchProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLaunchProfileOutputError>
}

extension CreateLaunchProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLaunchProfileInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), ec2SubnetIds: \(String(describing: ec2SubnetIds)), launchProfileProtocolVersions: \(String(describing: launchProfileProtocolVersions)), name: \(String(describing: name)), streamConfiguration: \(String(describing: streamConfiguration)), studioComponentIds: \(String(describing: studioComponentIds)), studioId: \(String(describing: studioId)), tags: \(String(describing: tags)))"}
}

extension CreateLaunchProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLaunchProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLaunchProfileOutputError>
}

public struct CreateLaunchProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLaunchProfileOutputError>
}

/// <p>A collection of launch profiles.</p>
public struct CreateLaunchProfileInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The description.</p>
    public let description: String?
    public let ec2SubnetIds: [String]?
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    public let launchProfileProtocolVersions: [String]?
    /// <p>The name for the launch profile.</p>
    public let name: String?
    /// <p>A configuration for a streaming session.</p>
    public let streamConfiguration: StreamConfigurationCreate?
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    public let studioComponentIds: [String]?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        ec2SubnetIds: [String]? = nil,
        launchProfileProtocolVersions: [String]? = nil,
        name: String? = nil,
        streamConfiguration: StreamConfigurationCreate? = nil,
        studioComponentIds: [String]? = nil,
        studioId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateLaunchProfileInputBody: Equatable {
    public let description: String?
    public let ec2SubnetIds: [String]?
    public let launchProfileProtocolVersions: [String]?
    public let name: String?
    public let streamConfiguration: StreamConfigurationCreate?
    public let studioComponentIds: [String]?
    public let tags: [String:String]?
}

extension CreateLaunchProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLaunchProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLaunchProfileOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLaunchProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLaunchProfileOutputResponse(launchProfile: \(String(describing: launchProfile)))"}
}

extension CreateLaunchProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct CreateLaunchProfileOutputResponse: Equatable {
    /// <p>The launch profile.</p>
    public let launchProfile: LaunchProfile?

    public init (
        launchProfile: LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct CreateLaunchProfileOutputResponseBody: Equatable {
    public let launchProfile: LaunchProfile?
}

extension CreateLaunchProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

public struct CreateStreamingImageInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingImageOutputError>
}

extension CreateStreamingImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingImageInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), ec2ImageId: \(String(describing: ec2ImageId)), name: \(String(describing: name)), studioId: \(String(describing: studioId)), tags: \(String(describing: tags)))"}
}

extension CreateStreamingImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamingImageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingImageOutputError>
}

public struct CreateStreamingImageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingImageOutputError>
}

/// <p>A collection of streaming images.</p>
public struct CreateStreamingImageInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>A human-readable description of the streaming image.</p>
    public let description: String?
    /// <p>The ID of an EC2 machine image with which to create this streaming image.</p>
    public let ec2ImageId: String?
    /// <p>A friendly name for a streaming image resource.</p>
    public let name: String?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        ec2ImageId: String? = nil,
        name: String? = nil,
        studioId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.name = name
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingImageInputBody: Equatable {
    public let description: String?
    public let ec2ImageId: String?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateStreamingImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingImageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingImageOutputResponse(streamingImage: \(String(describing: streamingImage)))"}
}

extension CreateStreamingImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct CreateStreamingImageOutputResponse: Equatable {
    public let streamingImage: StreamingImage?

    public init (
        streamingImage: StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct CreateStreamingImageOutputResponseBody: Equatable {
    public let streamingImage: StreamingImage?
}

extension CreateStreamingImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

public struct CreateStreamingSessionInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionOutputError>
}

extension CreateStreamingSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingSessionInput(clientToken: \(String(describing: clientToken)), ec2InstanceType: \(String(describing: ec2InstanceType)), launchProfileId: \(String(describing: launchProfileId)), streamingImageId: \(String(describing: streamingImageId)), studioId: \(String(describing: studioId)), tags: \(String(describing: tags)))"}
}

extension CreateStreamingSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType.rawValue, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamingSessionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionOutputError>
}

public struct CreateStreamingSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionOutputError>
}

/// <p>A collection of streaming sessions.</p>
public struct CreateStreamingSessionInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The EC2 Instance type used for the streaming session.</p>
    public let ec2InstanceType: StreamingInstanceType?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The ID of the streaming image.</p>
    public let streamingImageId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        ec2InstanceType: StreamingInstanceType? = nil,
        launchProfileId: String? = nil,
        streamingImageId: String? = nil,
        studioId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.streamingImageId = streamingImageId
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingSessionInputBody: Equatable {
    public let ec2InstanceType: StreamingInstanceType?
    public let launchProfileId: String?
    public let streamingImageId: String?
    public let tags: [String:String]?
}

extension CreateStreamingSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(StreamingInstanceType.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingSessionOutputResponse(session: \(String(describing: session)))"}
}

extension CreateStreamingSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateStreamingSessionOutputResponse: Equatable {
    /// <p>The session.</p>
    public let session: StreamingSession?

    public init (
        session: StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct CreateStreamingSessionOutputResponseBody: Equatable {
    public let session: StreamingSession?
}

extension CreateStreamingSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case session = "session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

public struct CreateStreamingSessionStreamInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionStreamOutputError>
}

extension CreateStreamingSessionStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingSessionStreamInput(clientToken: \(String(describing: clientToken)), expirationInSeconds: \(String(describing: expirationInSeconds)), sessionId: \(String(describing: sessionId)), studioId: \(String(describing: studioId)))"}
}

extension CreateStreamingSessionStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expirationInSeconds = "expirationInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if expirationInSeconds != 0 {
            try encodeContainer.encode(expirationInSeconds, forKey: .expirationInSeconds)
        }
    }
}

public struct CreateStreamingSessionStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionStreamOutputError>
}

public struct CreateStreamingSessionStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingSessionStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingSessionStreamOutputError>
}

/// <p>A list collection streams.</p>
public struct CreateStreamingSessionStreamInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The expiration time in seconds.</p>
    public let expirationInSeconds: Int
    /// <p>The session ID.</p>
    public let sessionId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        expirationInSeconds: Int = 0,
        sessionId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInSeconds = expirationInSeconds
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct CreateStreamingSessionStreamInputBody: Equatable {
    public let expirationInSeconds: Int
}

extension CreateStreamingSessionStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expirationInSeconds = "expirationInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .expirationInSeconds)
        expirationInSeconds = expirationInSecondsDecoded
    }
}

extension CreateStreamingSessionStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionStreamOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingSessionStreamOutputResponse(stream: \(String(describing: stream)))"}
}

extension CreateStreamingSessionStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct CreateStreamingSessionStreamOutputResponse: Equatable {
    /// <p>The stream.</p>
    public let stream: StreamingSessionStream?

    public init (
        stream: StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct CreateStreamingSessionStreamOutputResponseBody: Equatable {
    public let stream: StreamingSessionStream?
}

extension CreateStreamingSessionStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stream = "stream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

public struct CreateStudioComponentInputBodyMiddleware: Middleware {
    public let id: String = "CreateStudioComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioComponentOutputError>
}

extension CreateStudioComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStudioComponentInput(clientToken: \(String(describing: clientToken)), configuration: \(String(describing: configuration)), description: \(String(describing: description)), ec2SecurityGroupIds: \(String(describing: ec2SecurityGroupIds)), initializationScripts: \(String(describing: initializationScripts)), name: \(String(describing: name)), scriptParameters: \(String(describing: scriptParameters)), studioId: \(String(describing: studioId)), subtype: \(String(describing: subtype)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateStudioComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateStudioComponentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioComponentOutputError>
}

public struct CreateStudioComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioComponentOutputError>
}

/// <p>The studio components.</p>
public struct CreateStudioComponentInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The configuration of the studio component, based on component type.</p>
    public let configuration: StudioComponentConfiguration?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The EC2 security groups that control access to the studio component.</p>
    public let ec2SecurityGroupIds: [String]?
    /// <p>Initialization scripts for studio components.</p>
    public let initializationScripts: [StudioComponentInitializationScript]?
    /// <p>The name for the studio component.</p>
    public let name: String?
    /// <p>Parameters for the studio component scripts.</p>
    public let scriptParameters: [ScriptParameterKeyValue]?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>The specific subtype of a studio component.</p>
    public let subtype: StudioComponentSubtype?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The type of the studio component.</p>
    public let type: StudioComponentType?

    public init (
        clientToken: String? = nil,
        configuration: StudioComponentConfiguration? = nil,
        description: String? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        initializationScripts: [StudioComponentInitializationScript]? = nil,
        name: String? = nil,
        scriptParameters: [ScriptParameterKeyValue]? = nil,
        studioId: String? = nil,
        subtype: StudioComponentSubtype? = nil,
        tags: [String:String]? = nil,
        type: StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioId = studioId
        self.subtype = subtype
        self.tags = tags
        self.type = type
    }
}

struct CreateStudioComponentInputBody: Equatable {
    public let configuration: StudioComponentConfiguration?
    public let description: String?
    public let ec2SecurityGroupIds: [String]?
    public let initializationScripts: [StudioComponentInitializationScript]?
    public let name: String?
    public let scriptParameters: [ScriptParameterKeyValue]?
    public let subtype: StudioComponentSubtype?
    public let tags: [String:String]?
    public let type: StudioComponentType?
}

extension CreateStudioComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateStudioComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStudioComponentOutputResponse(studioComponent: \(String(describing: studioComponent)))"}
}

extension CreateStudioComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct CreateStudioComponentOutputResponse: Equatable {
    /// <p>Information about the studio component.</p>
    public let studioComponent: StudioComponent?

    public init (
        studioComponent: StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct CreateStudioComponentOutputResponseBody: Equatable {
    public let studioComponent: StudioComponent?
}

extension CreateStudioComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

public struct CreateStudioInputBodyMiddleware: Middleware {
    public let id: String = "CreateStudioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioInput>
    public typealias MOutput = OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioOutputError>
}

extension CreateStudioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStudioInput(adminRoleArn: \(String(describing: adminRoleArn)), clientToken: \(String(describing: clientToken)), displayName: \(String(describing: displayName)), studioEncryptionConfiguration: \(String(describing: studioEncryptionConfiguration)), studioName: \(String(describing: studioName)), tags: \(String(describing: tags)), userRoleArn: \(String(describing: userRoleArn)))"}
}

extension CreateStudioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioName = "studioName"
        case tags = "tags"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

public struct CreateStudioInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioInput>
    public typealias MOutput = OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioOutputError>
}

public struct CreateStudioInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStudioInput>
    public typealias MOutput = OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStudioOutputError>
}

/// <p>A collection of studio resources.</p>
public struct CreateStudioInput: Equatable {
    /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
    public let adminRoleArn: String?
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>A friendly name for the studio.</p>
    public let displayName: String?
    /// <p>The studio encryption configuration.</p>
    public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
    /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
    public let studioName: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
    public let userRoleArn: String?

    public init (
        adminRoleArn: String? = nil,
        clientToken: String? = nil,
        displayName: String? = nil,
        studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil,
        studioName: String? = nil,
        tags: [String:String]? = nil,
        userRoleArn: String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioName = studioName
        self.tags = tags
        self.userRoleArn = userRoleArn
    }
}

struct CreateStudioInputBody: Equatable {
    public let adminRoleArn: String?
    public let displayName: String?
    public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
    public let studioName: String?
    public let tags: [String:String]?
    public let userRoleArn: String?
}

extension CreateStudioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioName = "studioName"
        case tags = "tags"
        case userRoleArn = "userRoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let userRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension CreateStudioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStudioOutputResponse(studio: \(String(describing: studio)))"}
}

extension CreateStudioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct CreateStudioOutputResponse: Equatable {
    /// <p>Information about a studio.</p>
    public let studio: Studio?

    public init (
        studio: Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct CreateStudioOutputResponseBody: Equatable {
    public let studio: Studio?
}

extension CreateStudioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension DeleteLaunchProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLaunchProfileInput(clientToken: \(String(describing: clientToken)), launchProfileId: \(String(describing: launchProfileId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteLaunchProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLaunchProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLaunchProfileInput>
    public typealias MOutput = OperationOutput<DeleteLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLaunchProfileOutputError>
}

public struct DeleteLaunchProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLaunchProfileInput>
    public typealias MOutput = OperationOutput<DeleteLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLaunchProfileOutputError>
}

public struct DeleteLaunchProfileInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        launchProfileId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileInputBody: Equatable {
}

extension DeleteLaunchProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLaunchProfileMemberInput(clientToken: \(String(describing: clientToken)), launchProfileId: \(String(describing: launchProfileId)), principalId: \(String(describing: principalId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteLaunchProfileMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLaunchProfileMemberInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<DeleteLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLaunchProfileMemberOutputError>
}

public struct DeleteLaunchProfileMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<DeleteLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLaunchProfileMemberOutputError>
}

public struct DeleteLaunchProfileMemberInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        launchProfileId: String? = nil,
        principalId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileMemberInputBody: Equatable {
}

extension DeleteLaunchProfileMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileMemberOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLaunchProfileMemberOutputResponse()"}
}

extension DeleteLaunchProfileMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLaunchProfileMemberOutputResponse: Equatable {

    public init() {}
}

struct DeleteLaunchProfileMemberOutputResponseBody: Equatable {
}

extension DeleteLaunchProfileMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLaunchProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLaunchProfileOutputResponse(launchProfile: \(String(describing: launchProfile)))"}
}

extension DeleteLaunchProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct DeleteLaunchProfileOutputResponse: Equatable {
    /// <p>The launch profile.</p>
    public let launchProfile: LaunchProfile?

    public init (
        launchProfile: LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct DeleteLaunchProfileOutputResponseBody: Equatable {
    public let launchProfile: LaunchProfile?
}

extension DeleteLaunchProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension DeleteStreamingImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingImageInput(clientToken: \(String(describing: clientToken)), streamingImageId: \(String(describing: streamingImageId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteStreamingImageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStreamingImageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingImageInput>
    public typealias MOutput = OperationOutput<DeleteStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingImageOutputError>
}

public struct DeleteStreamingImageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingImageInput>
    public typealias MOutput = OperationOutput<DeleteStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingImageOutputError>
}

public struct DeleteStreamingImageInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The streaming image ID.</p>
    public let streamingImageId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        streamingImageId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct DeleteStreamingImageInputBody: Equatable {
}

extension DeleteStreamingImageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamingImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingImageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingImageOutputResponse(streamingImage: \(String(describing: streamingImage)))"}
}

extension DeleteStreamingImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct DeleteStreamingImageOutputResponse: Equatable {
    /// <p>The streaming image.</p>
    public let streamingImage: StreamingImage?

    public init (
        streamingImage: StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct DeleteStreamingImageOutputResponseBody: Equatable {
    public let streamingImage: StreamingImage?
}

extension DeleteStreamingImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension DeleteStreamingSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingSessionInput(clientToken: \(String(describing: clientToken)), sessionId: \(String(describing: sessionId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteStreamingSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStreamingSessionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingSessionInput>
    public typealias MOutput = OperationOutput<DeleteStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingSessionOutputError>
}

public struct DeleteStreamingSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingSessionInput>
    public typealias MOutput = OperationOutput<DeleteStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingSessionOutputError>
}

public struct DeleteStreamingSessionInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The session ID.</p>
    public let sessionId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        sessionId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct DeleteStreamingSessionInputBody: Equatable {
}

extension DeleteStreamingSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamingSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingSessionOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingSessionOutputResponse(session: \(String(describing: session)))"}
}

extension DeleteStreamingSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct DeleteStreamingSessionOutputResponse: Equatable {
    /// <p>The session.</p>
    public let session: StreamingSession?

    public init (
        session: StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct DeleteStreamingSessionOutputResponseBody: Equatable {
    public let session: StreamingSession?
}

extension DeleteStreamingSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case session = "session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension DeleteStudioComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioComponentInput(clientToken: \(String(describing: clientToken)), studioComponentId: \(String(describing: studioComponentId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteStudioComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStudioComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioComponentInput>
    public typealias MOutput = OperationOutput<DeleteStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioComponentOutputError>
}

public struct DeleteStudioComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioComponentInput>
    public typealias MOutput = OperationOutput<DeleteStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioComponentOutputError>
}

public struct DeleteStudioComponentInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The studio component ID.</p>
    public let studioComponentId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        studioComponentId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct DeleteStudioComponentInputBody: Equatable {
}

extension DeleteStudioComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStudioComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioComponentOutputResponse(studioComponent: \(String(describing: studioComponent)))"}
}

extension DeleteStudioComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct DeleteStudioComponentOutputResponse: Equatable {
    /// <p>Information about the studio component.</p>
    public let studioComponent: StudioComponent?

    public init (
        studioComponent: StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct DeleteStudioComponentOutputResponseBody: Equatable {
    public let studioComponent: StudioComponent?
}

extension DeleteStudioComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension DeleteStudioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioInput(clientToken: \(String(describing: clientToken)), studioId: \(String(describing: studioId)))"}
}

extension DeleteStudioInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStudioInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioInput>
    public typealias MOutput = OperationOutput<DeleteStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioOutputError>
}

public struct DeleteStudioInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioInput>
    public typealias MOutput = OperationOutput<DeleteStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioOutputError>
}

public struct DeleteStudioInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct DeleteStudioInputBody: Equatable {
}

extension DeleteStudioInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStudioMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioMemberInput(clientToken: \(String(describing: clientToken)), principalId: \(String(describing: principalId)), studioId: \(String(describing: studioId)))"}
}

extension DeleteStudioMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStudioMemberInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStudioMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioMemberInput>
    public typealias MOutput = OperationOutput<DeleteStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioMemberOutputError>
}

public struct DeleteStudioMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStudioMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStudioMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStudioMemberInput>
    public typealias MOutput = OperationOutput<DeleteStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStudioMemberOutputError>
}

public struct DeleteStudioMemberInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        principalId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteStudioMemberInputBody: Equatable {
}

extension DeleteStudioMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStudioMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioMemberOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioMemberOutputResponse()"}
}

extension DeleteStudioMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStudioMemberOutputResponse: Equatable {

    public init() {}
}

struct DeleteStudioMemberOutputResponseBody: Equatable {
}

extension DeleteStudioMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStudioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStudioOutputResponse(studio: \(String(describing: studio)))"}
}

extension DeleteStudioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct DeleteStudioOutputResponse: Equatable {
    /// <p>Information about a studio.</p>
    public let studio: Studio?

    public init (
        studio: Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct DeleteStudioOutputResponseBody: Equatable {
    public let studio: Studio?
}

extension DeleteStudioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension Eula: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "content"
        case createdAt = "createdAt"
        case eulaId = "eulaId"
        case name = "name"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Eula: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Eula(content: \(String(describing: content)), createdAt: \(String(describing: createdAt)), eulaId: \(String(describing: eulaId)), name: \(String(describing: name)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Represents a EULA resource.</p>
public struct Eula: Equatable {
    /// <p>The EULA content.</p>
    public let content: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The EULA ID.</p>
    public let eulaId: String?
    /// <p>The name for the EULA.</p>
    public let name: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?

    public init (
        content: String? = nil,
        createdAt: Date? = nil,
        eulaId: String? = nil,
        name: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.content = content
        self.createdAt = createdAt
        self.eulaId = eulaId
        self.name = name
        self.updatedAt = updatedAt
    }
}

extension EulaAcceptance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptedAt = "acceptedAt"
        case acceptedBy = "acceptedBy"
        case accepteeId = "accepteeId"
        case eulaAcceptanceId = "eulaAcceptanceId"
        case eulaId = "eulaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedAt = acceptedAt {
            try encodeContainer.encode(acceptedAt.timeIntervalSince1970, forKey: .acceptedAt)
        }
        if let acceptedBy = acceptedBy {
            try encodeContainer.encode(acceptedBy, forKey: .acceptedBy)
        }
        if let accepteeId = accepteeId {
            try encodeContainer.encode(accepteeId, forKey: .accepteeId)
        }
        if let eulaAcceptanceId = eulaAcceptanceId {
            try encodeContainer.encode(eulaAcceptanceId, forKey: .eulaAcceptanceId)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .acceptedAt)
        acceptedAt = acceptedAtDecoded
        let acceptedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptedBy)
        acceptedBy = acceptedByDecoded
        let accepteeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accepteeId)
        accepteeId = accepteeIdDecoded
        let eulaAcceptanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eulaAcceptanceId)
        eulaAcceptanceId = eulaAcceptanceIdDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
    }
}

extension EulaAcceptance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EulaAcceptance(acceptedAt: \(String(describing: acceptedAt)), acceptedBy: \(String(describing: acceptedBy)), accepteeId: \(String(describing: accepteeId)), eulaAcceptanceId: \(String(describing: eulaAcceptanceId)), eulaId: \(String(describing: eulaId)))"}
}

public struct EulaAcceptance: Equatable {
    /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
    public let acceptedAt: Date?
    /// <p>The ID of the person who accepted the EULA.</p>
    public let acceptedBy: String?
    /// <p>The ID of the acceptee.</p>
    public let accepteeId: String?
    /// <p>The EULA acceptance ID.</p>
    public let eulaAcceptanceId: String?
    /// <p>The EULA ID.</p>
    public let eulaId: String?

    public init (
        acceptedAt: Date? = nil,
        acceptedBy: String? = nil,
        accepteeId: String? = nil,
        eulaAcceptanceId: String? = nil,
        eulaId: String? = nil
    )
    {
        self.acceptedAt = acceptedAt
        self.acceptedBy = acceptedBy
        self.accepteeId = accepteeId
        self.eulaAcceptanceId = eulaAcceptanceId
        self.eulaId = eulaId
    }
}

extension GetEulaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEulaInput(eulaId: \(String(describing: eulaId)))"}
}

extension GetEulaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEulaInputHeadersMiddleware: Middleware {
    public let id: String = "GetEulaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEulaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEulaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEulaInput>
    public typealias MOutput = OperationOutput<GetEulaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEulaOutputError>
}

public struct GetEulaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEulaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEulaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEulaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEulaInput>
    public typealias MOutput = OperationOutput<GetEulaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEulaOutputError>
}

public struct GetEulaInput: Equatable {
    /// <p>The EULA ID.</p>
    public let eulaId: String?

    public init (
        eulaId: String? = nil
    )
    {
        self.eulaId = eulaId
    }
}

struct GetEulaInputBody: Equatable {
}

extension GetEulaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEulaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEulaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEulaOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEulaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEulaOutputResponse(eula: \(String(describing: eula)))"}
}

extension GetEulaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEulaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eula = output.eula
        } else {
            self.eula = nil
        }
    }
}

public struct GetEulaOutputResponse: Equatable {
    /// <p>The EULA.</p>
    public let eula: Eula?

    public init (
        eula: Eula? = nil
    )
    {
        self.eula = eula
    }
}

struct GetEulaOutputResponseBody: Equatable {
    public let eula: Eula?
}

extension GetEulaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eula = "eula"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaDecoded = try containerValues.decodeIfPresent(Eula.self, forKey: .eula)
        eula = eulaDecoded
    }
}

extension GetLaunchProfileDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileDetailsInput(launchProfileId: \(String(describing: launchProfileId)), studioId: \(String(describing: studioId)))"}
}

extension GetLaunchProfileDetailsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLaunchProfileDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetLaunchProfileDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileDetailsInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileDetailsOutputError>
}

public struct GetLaunchProfileDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLaunchProfileDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileDetailsInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileDetailsOutputError>
}

public struct GetLaunchProfileDetailsInput: Equatable {
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        launchProfileId: String? = nil,
        studioId: String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileDetailsInputBody: Equatable {
}

extension GetLaunchProfileDetailsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLaunchProfileDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileDetailsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileDetailsOutputResponse(launchProfile: \(String(describing: launchProfile)), streamingImages: \(String(describing: streamingImages)), studioComponentSummaries: \(String(describing: studioComponentSummaries)))"}
}

extension GetLaunchProfileDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
            self.streamingImages = output.streamingImages
            self.studioComponentSummaries = output.studioComponentSummaries
        } else {
            self.launchProfile = nil
            self.streamingImages = nil
            self.studioComponentSummaries = nil
        }
    }
}

public struct GetLaunchProfileDetailsOutputResponse: Equatable {
    /// <p>The launch profile.</p>
    public let launchProfile: LaunchProfile?
    /// <p>A collection of streaming images.</p>
    public let streamingImages: [StreamingImage]?
    /// <p>A collection of studio component summaries.</p>
    public let studioComponentSummaries: [StudioComponentSummary]?

    public init (
        launchProfile: LaunchProfile? = nil,
        streamingImages: [StreamingImage]? = nil,
        studioComponentSummaries: [StudioComponentSummary]? = nil
    )
    {
        self.launchProfile = launchProfile
        self.streamingImages = streamingImages
        self.studioComponentSummaries = studioComponentSummaries
    }
}

struct GetLaunchProfileDetailsOutputResponseBody: Equatable {
    public let launchProfile: LaunchProfile?
    public let streamingImages: [StreamingImage]?
    public let studioComponentSummaries: [StudioComponentSummary]?
}

extension GetLaunchProfileDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfile = "launchProfile"
        case streamingImages = "streamingImages"
        case studioComponentSummaries = "studioComponentSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
        let studioComponentSummariesContainer = try containerValues.decodeIfPresent([StudioComponentSummary?].self, forKey: .studioComponentSummaries)
        var studioComponentSummariesDecoded0:[StudioComponentSummary]? = nil
        if let studioComponentSummariesContainer = studioComponentSummariesContainer {
            studioComponentSummariesDecoded0 = [StudioComponentSummary]()
            for structure0 in studioComponentSummariesContainer {
                if let structure0 = structure0 {
                    studioComponentSummariesDecoded0?.append(structure0)
                }
            }
        }
        studioComponentSummaries = studioComponentSummariesDecoded0
    }
}

extension GetLaunchProfileInitializationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileInitializationInput(launchProfileId: \(String(describing: launchProfileId)), launchProfileProtocolVersions: \(String(describing: launchProfileProtocolVersions)), launchPurpose: \(String(describing: launchPurpose)), platform: \(String(describing: platform)), studioId: \(String(describing: studioId)))"}
}

extension GetLaunchProfileInitializationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLaunchProfileInitializationInputHeadersMiddleware: Middleware {
    public let id: String = "GetLaunchProfileInitializationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileInitializationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileInitializationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileInitializationInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileInitializationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileInitializationOutputError>
}

public struct GetLaunchProfileInitializationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLaunchProfileInitializationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileInitializationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileInitializationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let launchProfileProtocolVersions = input.operationInput.launchProfileProtocolVersions {
            launchProfileProtocolVersions.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "launchProfileProtocolVersions".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let launchPurpose = input.operationInput.launchPurpose {
            let launchPurposeQueryItem = URLQueryItem(name: "launchPurpose".urlPercentEncoding(), value: String(launchPurpose).urlPercentEncoding())
            input.builder.withQueryItem(launchPurposeQueryItem)
        }
        if let platform = input.operationInput.platform {
            let platformQueryItem = URLQueryItem(name: "platform".urlPercentEncoding(), value: String(platform).urlPercentEncoding())
            input.builder.withQueryItem(platformQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileInitializationInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileInitializationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileInitializationOutputError>
}

public struct GetLaunchProfileInitializationInput: Equatable {
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>A collection of launch profile protocol versions.</p>
    public let launchProfileProtocolVersions: [String]?
    /// <p>The launch purpose.</p>
    public let launchPurpose: String?
    /// <p>The platform.</p>
    public let platform: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        launchProfileId: String? = nil,
        launchProfileProtocolVersions: [String]? = nil,
        launchPurpose: String? = nil,
        platform: String? = nil,
        studioId: String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.launchPurpose = launchPurpose
        self.platform = platform
        self.studioId = studioId
    }
}

struct GetLaunchProfileInitializationInputBody: Equatable {
}

extension GetLaunchProfileInitializationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLaunchProfileInitializationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileInitializationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileInitializationOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileInitializationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileInitializationOutputResponse(launchProfileInitialization: \(String(describing: launchProfileInitialization)))"}
}

extension GetLaunchProfileInitializationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileInitializationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfileInitialization = output.launchProfileInitialization
        } else {
            self.launchProfileInitialization = nil
        }
    }
}

public struct GetLaunchProfileInitializationOutputResponse: Equatable {
    /// <p>The launch profile initialization.</p>
    public let launchProfileInitialization: LaunchProfileInitialization?

    public init (
        launchProfileInitialization: LaunchProfileInitialization? = nil
    )
    {
        self.launchProfileInitialization = launchProfileInitialization
    }
}

struct GetLaunchProfileInitializationOutputResponseBody: Equatable {
    public let launchProfileInitialization: LaunchProfileInitialization?
}

extension GetLaunchProfileInitializationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfileInitialization = "launchProfileInitialization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileInitializationDecoded = try containerValues.decodeIfPresent(LaunchProfileInitialization.self, forKey: .launchProfileInitialization)
        launchProfileInitialization = launchProfileInitializationDecoded
    }
}

extension GetLaunchProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileInput(launchProfileId: \(String(describing: launchProfileId)), studioId: \(String(describing: studioId)))"}
}

extension GetLaunchProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLaunchProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileOutputError>
}

public struct GetLaunchProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileOutputError>
}

public struct GetLaunchProfileInput: Equatable {
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        launchProfileId: String? = nil,
        studioId: String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileInputBody: Equatable {
}

extension GetLaunchProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLaunchProfileMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileMemberInput(launchProfileId: \(String(describing: launchProfileId)), principalId: \(String(describing: principalId)), studioId: \(String(describing: studioId)))"}
}

extension GetLaunchProfileMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLaunchProfileMemberInputHeadersMiddleware: Middleware {
    public let id: String = "GetLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileMemberOutputError>
}

public struct GetLaunchProfileMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<GetLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchProfileMemberOutputError>
}

public struct GetLaunchProfileMemberInput: Equatable {
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        launchProfileId: String? = nil,
        principalId: String? = nil,
        studioId: String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetLaunchProfileMemberInputBody: Equatable {
}

extension GetLaunchProfileMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLaunchProfileMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileMemberOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileMemberOutputResponse(member: \(String(describing: member)))"}
}

extension GetLaunchProfileMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetLaunchProfileMemberOutputResponse: Equatable {
    /// <p>The member.</p>
    public let member: LaunchProfileMembership?

    public init (
        member: LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetLaunchProfileMemberOutputResponseBody: Equatable {
    public let member: LaunchProfileMembership?
}

extension GetLaunchProfileMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case member = "member"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetLaunchProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchProfileOutputResponse(launchProfile: \(String(describing: launchProfile)))"}
}

extension GetLaunchProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct GetLaunchProfileOutputResponse: Equatable {
    /// <p>The launch profile.</p>
    public let launchProfile: LaunchProfile?

    public init (
        launchProfile: LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct GetLaunchProfileOutputResponseBody: Equatable {
    public let launchProfile: LaunchProfile?
}

extension GetLaunchProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension GetStreamingImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingImageInput(streamingImageId: \(String(describing: streamingImageId)), studioId: \(String(describing: studioId)))"}
}

extension GetStreamingImageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStreamingImageInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingImageInput>
    public typealias MOutput = OperationOutput<GetStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingImageOutputError>
}

public struct GetStreamingImageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingImageInput>
    public typealias MOutput = OperationOutput<GetStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingImageOutputError>
}

public struct GetStreamingImageInput: Equatable {
    /// <p>The streaming image ID.</p>
    public let streamingImageId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        streamingImageId: String? = nil,
        studioId: String? = nil
    )
    {
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct GetStreamingImageInputBody: Equatable {
}

extension GetStreamingImageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStreamingImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingImageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingImageOutputResponse(streamingImage: \(String(describing: streamingImage)))"}
}

extension GetStreamingImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct GetStreamingImageOutputResponse: Equatable {
    /// <p>The streaming image.</p>
    public let streamingImage: StreamingImage?

    public init (
        streamingImage: StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct GetStreamingImageOutputResponseBody: Equatable {
    public let streamingImage: StreamingImage?
}

extension GetStreamingImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension GetStreamingSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingSessionInput(sessionId: \(String(describing: sessionId)), studioId: \(String(describing: studioId)))"}
}

extension GetStreamingSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStreamingSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingSessionInput>
    public typealias MOutput = OperationOutput<GetStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingSessionOutputError>
}

public struct GetStreamingSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingSessionInput>
    public typealias MOutput = OperationOutput<GetStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingSessionOutputError>
}

public struct GetStreamingSessionInput: Equatable {
    /// <p>The session ID.</p>
    public let sessionId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        sessionId: String? = nil,
        studioId: String? = nil
    )
    {
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct GetStreamingSessionInputBody: Equatable {
}

extension GetStreamingSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStreamingSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingSessionOutputResponse(session: \(String(describing: session)))"}
}

extension GetStreamingSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetStreamingSessionOutputResponse: Equatable {
    /// <p>The session.</p>
    public let session: StreamingSession?

    public init (
        session: StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct GetStreamingSessionOutputResponseBody: Equatable {
    public let session: StreamingSession?
}

extension GetStreamingSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case session = "session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension GetStreamingSessionStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingSessionStreamInput(sessionId: \(String(describing: sessionId)), streamId: \(String(describing: streamId)), studioId: \(String(describing: studioId)))"}
}

extension GetStreamingSessionStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStreamingSessionStreamInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamingSessionStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingSessionStreamInput>
    public typealias MOutput = OperationOutput<GetStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingSessionStreamOutputError>
}

public struct GetStreamingSessionStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamingSessionStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingSessionStreamInput>
    public typealias MOutput = OperationOutput<GetStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingSessionStreamOutputError>
}

public struct GetStreamingSessionStreamInput: Equatable {
    /// <p>The session ID.</p>
    public let sessionId: String?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        sessionId: String? = nil,
        streamId: String? = nil,
        studioId: String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamId = streamId
        self.studioId = studioId
    }
}

struct GetStreamingSessionStreamInputBody: Equatable {
}

extension GetStreamingSessionStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStreamingSessionStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionStreamOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingSessionStreamOutputResponse(stream: \(String(describing: stream)))"}
}

extension GetStreamingSessionStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamingSessionStreamOutputResponse: Equatable {
    /// <p>The stream.</p>
    public let stream: StreamingSessionStream?

    public init (
        stream: StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamingSessionStreamOutputResponseBody: Equatable {
    public let stream: StreamingSessionStream?
}

extension GetStreamingSessionStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stream = "stream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension GetStudioComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioComponentInput(studioComponentId: \(String(describing: studioComponentId)), studioId: \(String(describing: studioId)))"}
}

extension GetStudioComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStudioComponentInputHeadersMiddleware: Middleware {
    public let id: String = "GetStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioComponentInput>
    public typealias MOutput = OperationOutput<GetStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioComponentOutputError>
}

public struct GetStudioComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioComponentInput>
    public typealias MOutput = OperationOutput<GetStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioComponentOutputError>
}

public struct GetStudioComponentInput: Equatable {
    /// <p>The studio component ID.</p>
    public let studioComponentId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        studioComponentId: String? = nil,
        studioId: String? = nil
    )
    {
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct GetStudioComponentInputBody: Equatable {
}

extension GetStudioComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStudioComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioComponentOutputResponse(studioComponent: \(String(describing: studioComponent)))"}
}

extension GetStudioComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct GetStudioComponentOutputResponse: Equatable {
    /// <p>Information about the studio component.</p>
    public let studioComponent: StudioComponent?

    public init (
        studioComponent: StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct GetStudioComponentOutputResponseBody: Equatable {
    public let studioComponent: StudioComponent?
}

extension GetStudioComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension GetStudioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioInput(studioId: \(String(describing: studioId)))"}
}

extension GetStudioInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStudioInputHeadersMiddleware: Middleware {
    public let id: String = "GetStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioInput>
    public typealias MOutput = OperationOutput<GetStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioOutputError>
}

public struct GetStudioInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioInput>
    public typealias MOutput = OperationOutput<GetStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioOutputError>
}

public struct GetStudioInput: Equatable {
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        studioId: String? = nil
    )
    {
        self.studioId = studioId
    }
}

struct GetStudioInputBody: Equatable {
}

extension GetStudioInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStudioMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioMemberInput(principalId: \(String(describing: principalId)), studioId: \(String(describing: studioId)))"}
}

extension GetStudioMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStudioMemberInputHeadersMiddleware: Middleware {
    public let id: String = "GetStudioMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioMemberInput>
    public typealias MOutput = OperationOutput<GetStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioMemberOutputError>
}

public struct GetStudioMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStudioMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStudioMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStudioMemberInput>
    public typealias MOutput = OperationOutput<GetStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStudioMemberOutputError>
}

public struct GetStudioMemberInput: Equatable {
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        principalId: String? = nil,
        studioId: String? = nil
    )
    {
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetStudioMemberInputBody: Equatable {
}

extension GetStudioMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStudioMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioMemberOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioMemberOutputResponse(member: \(String(describing: member)))"}
}

extension GetStudioMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetStudioMemberOutputResponse: Equatable {
    /// <p>The member.</p>
    public let member: StudioMembership?

    public init (
        member: StudioMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetStudioMemberOutputResponseBody: Equatable {
    public let member: StudioMembership?
}

extension GetStudioMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case member = "member"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(StudioMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetStudioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStudioOutputResponse(studio: \(String(describing: studio)))"}
}

extension GetStudioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct GetStudioOutputResponse: Equatable {
    /// <p>Information about a studio.</p>
    public let studio: Studio?

    public init (
        studio: Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct GetStudioOutputResponseBody: Equatable {
    public let studio: Studio?
}

extension GetStudioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileId = "launchProfileId"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LaunchProfileState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(LaunchProfileStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(StreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension LaunchProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchProfile(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), ec2SubnetIds: \(String(describing: ec2SubnetIds)), launchProfileId: \(String(describing: launchProfileId)), launchProfileProtocolVersions: \(String(describing: launchProfileProtocolVersions)), name: \(String(describing: name)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), streamConfiguration: \(String(describing: streamConfiguration)), studioComponentIds: \(String(describing: studioComponentIds)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)), updatedBy: \(String(describing: updatedBy)))"}
}

public struct LaunchProfile: Equatable {
    /// <p>The ARN of the resource.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The user ID of the user that created the launch profile.</p>
    public let createdBy: String?
    /// <p>A human-readable description of the launch profile.</p>
    public let description: String?
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    public let ec2SubnetIds: [String]?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    public let launchProfileProtocolVersions: [String]?
    /// <p>A friendly name for the launch profile.</p>
    public let name: String?
    /// <p>The current state.</p>
    public let state: LaunchProfileState?
    /// <p>The status code.</p>
    public let statusCode: LaunchProfileStatusCode?
    /// <p>The status message for the launch profile.</p>
    public let statusMessage: String?
    /// <p>A configuration for a streaming session.</p>
    public let streamConfiguration: StreamConfiguration?
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    public let studioComponentIds: [String]?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?
    /// <p>The user ID of the user that most recently updated the resource.</p>
    public let updatedBy: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        ec2SubnetIds: [String]? = nil,
        launchProfileId: String? = nil,
        launchProfileProtocolVersions: [String]? = nil,
        name: String? = nil,
        state: LaunchProfileState? = nil,
        statusCode: LaunchProfileStatusCode? = nil,
        statusMessage: String? = nil,
        streamConfiguration: StreamConfiguration? = nil,
        studioComponentIds: [String]? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil,
        updatedBy: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.state = state
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.tags = tags
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension LaunchProfileInitialization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectory = "activeDirectory"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case launchProfileId = "launchProfileId"
        case launchProfileProtocolVersion = "launchProfileProtocolVersion"
        case launchPurpose = "launchPurpose"
        case name = "name"
        case platform = "platform"
        case systemInitializationScripts = "systemInitializationScripts"
        case userInitializationScripts = "userInitializationScripts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectory = activeDirectory {
            try encodeContainer.encode(activeDirectory, forKey: .activeDirectory)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for launchprofilesecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(launchprofilesecuritygroupidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let launchPurpose = launchPurpose {
            try encodeContainer.encode(launchPurpose, forKey: .launchPurpose)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let systemInitializationScripts = systemInitializationScripts {
            var systemInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemInitializationScripts)
            for launchprofileinitializationscriptlist0 in systemInitializationScripts {
                try systemInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
        if let userInitializationScripts = userInitializationScripts {
            var userInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userInitializationScripts)
            for launchprofileinitializationscriptlist0 in userInitializationScripts {
                try userInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryDecoded = try containerValues.decodeIfPresent(LaunchProfileInitializationActiveDirectory.self, forKey: .activeDirectory)
        activeDirectory = activeDirectoryDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let launchPurposeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchPurpose)
        launchPurpose = launchPurposeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let systemInitializationScriptsContainer = try containerValues.decodeIfPresent([LaunchProfileInitializationScript?].self, forKey: .systemInitializationScripts)
        var systemInitializationScriptsDecoded0:[LaunchProfileInitializationScript]? = nil
        if let systemInitializationScriptsContainer = systemInitializationScriptsContainer {
            systemInitializationScriptsDecoded0 = [LaunchProfileInitializationScript]()
            for structure0 in systemInitializationScriptsContainer {
                if let structure0 = structure0 {
                    systemInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        systemInitializationScripts = systemInitializationScriptsDecoded0
        let userInitializationScriptsContainer = try containerValues.decodeIfPresent([LaunchProfileInitializationScript?].self, forKey: .userInitializationScripts)
        var userInitializationScriptsDecoded0:[LaunchProfileInitializationScript]? = nil
        if let userInitializationScriptsContainer = userInitializationScriptsContainer {
            userInitializationScriptsDecoded0 = [LaunchProfileInitializationScript]()
            for structure0 in userInitializationScriptsContainer {
                if let structure0 = structure0 {
                    userInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        userInitializationScripts = userInitializationScriptsDecoded0
    }
}

extension LaunchProfileInitialization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchProfileInitialization(activeDirectory: \(String(describing: activeDirectory)), ec2SecurityGroupIds: \(String(describing: ec2SecurityGroupIds)), launchProfileId: \(String(describing: launchProfileId)), launchProfileProtocolVersion: \(String(describing: launchProfileProtocolVersion)), launchPurpose: \(String(describing: launchPurpose)), name: \(String(describing: name)), platform: \(String(describing: platform)), systemInitializationScripts: \(String(describing: systemInitializationScripts)), userInitializationScripts: \(String(describing: userInitializationScripts)))"}
}

public struct LaunchProfileInitialization: Equatable {
    /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
    public let activeDirectory: LaunchProfileInitializationActiveDirectory?
    /// <p>The EC2 security groups that control access to the studio component.</p>
    public let ec2SecurityGroupIds: [String]?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    public let launchProfileProtocolVersion: String?
    /// <p>The launch purpose.</p>
    public let launchPurpose: String?
    /// <p>The name for the launch profile.</p>
    public let name: String?
    /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
    public let platform: LaunchProfilePlatform?
    /// <p>The system initializtion scripts.</p>
    public let systemInitializationScripts: [LaunchProfileInitializationScript]?
    /// <p>The user initializtion scripts.</p>
    public let userInitializationScripts: [LaunchProfileInitializationScript]?

    public init (
        activeDirectory: LaunchProfileInitializationActiveDirectory? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        launchProfileId: String? = nil,
        launchProfileProtocolVersion: String? = nil,
        launchPurpose: String? = nil,
        name: String? = nil,
        platform: LaunchProfilePlatform? = nil,
        systemInitializationScripts: [LaunchProfileInitializationScript]? = nil,
        userInitializationScripts: [LaunchProfileInitializationScript]? = nil
    )
    {
        self.activeDirectory = activeDirectory
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersion = launchProfileProtocolVersion
        self.launchPurpose = launchPurpose
        self.name = name
        self.platform = platform
        self.systemInitializationScripts = systemInitializationScripts
        self.userInitializationScripts = userInitializationScripts
    }
}

extension LaunchProfileInitializationActiveDirectory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computerAttributes = "computerAttributes"
        case directoryId = "directoryId"
        case directoryName = "directoryName"
        case dnsIpAddresses = "dnsIpAddresses"
        case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
        case studioComponentId = "studioComponentId"
        case studioComponentName = "studioComponentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for activedirectorydnsipaddresslist0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(activedirectorydnsipaddresslist0)
            }
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension LaunchProfileInitializationActiveDirectory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchProfileInitializationActiveDirectory(computerAttributes: \(String(describing: computerAttributes)), directoryId: \(String(describing: directoryId)), directoryName: \(String(describing: directoryName)), dnsIpAddresses: \(String(describing: dnsIpAddresses)), organizationalUnitDistinguishedName: \(String(describing: organizationalUnitDistinguishedName)), studioComponentId: \(String(describing: studioComponentId)), studioComponentName: \(String(describing: studioComponentName)))"}
}

public struct LaunchProfileInitializationActiveDirectory: Equatable {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    public let computerAttributes: [ActiveDirectoryComputerAttribute]?
    /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this launch profile.</p>
    public let directoryId: String?
    /// <p>The directory name.</p>
    public let directoryName: String?
    /// <p>The DNS IP address.</p>
    public let dnsIpAddresses: [String]?
    /// <p>The name for the organizational unit distinguished name.</p>
    public let organizationalUnitDistinguishedName: String?
    /// <p>The unique identifier for a studio component resource.</p>
    public let studioComponentId: String?
    /// <p>The name for the studio component.</p>
    public let studioComponentName: String?

    public init (
        computerAttributes: [ActiveDirectoryComputerAttribute]? = nil,
        directoryId: String? = nil,
        directoryName: String? = nil,
        dnsIpAddresses: [String]? = nil,
        organizationalUnitDistinguishedName: String? = nil,
        studioComponentId: String? = nil,
        studioComponentName: String? = nil
    )
    {
        self.computerAttributes = computerAttributes
        self.directoryId = directoryId
        self.directoryName = directoryName
        self.dnsIpAddresses = dnsIpAddresses
        self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        self.studioComponentId = studioComponentId
        self.studioComponentName = studioComponentName
    }
}

extension LaunchProfileInitializationScript: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case script = "script"
        case studioComponentId = "studioComponentId"
        case studioComponentName = "studioComponentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .script)
        script = scriptDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension LaunchProfileInitializationScript: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchProfileInitializationScript(script: \(String(describing: script)), studioComponentId: \(String(describing: studioComponentId)), studioComponentName: \(String(describing: studioComponentName)))"}
}

public struct LaunchProfileInitializationScript: Equatable {
    /// <p>The initialization script.</p>
    public let script: String?
    /// <p>The unique identifier for a studio component resource.</p>
    public let studioComponentId: String?
    /// <p>The name for the studio component.</p>
    public let studioComponentName: String?

    public init (
        script: String? = nil,
        studioComponentId: String? = nil,
        studioComponentName: String? = nil
    )
    {
        self.script = script
        self.studioComponentId = studioComponentId
        self.studioComponentName = studioComponentName
    }
}

extension LaunchProfileMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension LaunchProfileMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchProfileMembership(identityStoreId: \(String(describing: identityStoreId)), persona: \(String(describing: persona)), principalId: \(String(describing: principalId)))"}
}

public struct LaunchProfileMembership: Equatable {
    /// <p>The ID of the identity store.</p>
    public let identityStoreId: String?
    /// <p>The persona.</p>
    public let persona: LaunchProfilePersona?
    /// <p>The principal ID.</p>
    public let principalId: String?

    public init (
        identityStoreId: String? = nil,
        persona: LaunchProfilePersona? = nil,
        principalId: String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.persona = persona
        self.principalId = principalId
    }
}

public enum LaunchProfilePersona {
    case user
    case sdkUnknown(String)
}

extension LaunchProfilePersona : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchProfilePersona] {
        return [
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchProfilePersona(rawValue: rawValue) ?? LaunchProfilePersona.sdkUnknown(rawValue)
    }
}

public enum LaunchProfilePlatform {
    case linux
    case windows
    case sdkUnknown(String)
}

extension LaunchProfilePlatform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchProfilePlatform] {
        return [
            .linux,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linux: return "LINUX"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchProfilePlatform(rawValue: rawValue) ?? LaunchProfilePlatform.sdkUnknown(rawValue)
    }
}

public enum LaunchProfileState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension LaunchProfileState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchProfileState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchProfileState(rawValue: rawValue) ?? LaunchProfileState.sdkUnknown(rawValue)
    }
}

public enum LaunchProfileStatusCode {
    case encryptionKeyAccessDenied
    case encryptionKeyNotFound
    case internalError
    case invalidSubnetsProvided
    case launchProfileCreated
    case launchProfileCreateInProgress
    case launchProfileDeleted
    case launchProfileDeleteInProgress
    case launchProfileUpdated
    case launchProfileUpdateInProgress
    case launchProfileWithStreamSessionsNotDeleted
    case streamingImageNotFound
    case streamingImageNotReady
    case sdkUnknown(String)
}

extension LaunchProfileStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchProfileStatusCode] {
        return [
            .encryptionKeyAccessDenied,
            .encryptionKeyNotFound,
            .internalError,
            .invalidSubnetsProvided,
            .launchProfileCreated,
            .launchProfileCreateInProgress,
            .launchProfileDeleted,
            .launchProfileDeleteInProgress,
            .launchProfileUpdated,
            .launchProfileUpdateInProgress,
            .launchProfileWithStreamSessionsNotDeleted,
            .streamingImageNotFound,
            .streamingImageNotReady,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
        case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
        case .internalError: return "INTERNAL_ERROR"
        case .invalidSubnetsProvided: return "INVALID_SUBNETS_PROVIDED"
        case .launchProfileCreated: return "LAUNCH_PROFILE_CREATED"
        case .launchProfileCreateInProgress: return "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
        case .launchProfileDeleted: return "LAUNCH_PROFILE_DELETED"
        case .launchProfileDeleteInProgress: return "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
        case .launchProfileUpdated: return "LAUNCH_PROFILE_UPDATED"
        case .launchProfileUpdateInProgress: return "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
        case .launchProfileWithStreamSessionsNotDeleted: return "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
        case .streamingImageNotFound: return "STREAMING_IMAGE_NOT_FOUND"
        case .streamingImageNotReady: return "STREAMING_IMAGE_NOT_READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchProfileStatusCode(rawValue: rawValue) ?? LaunchProfileStatusCode.sdkUnknown(rawValue)
    }
}

extension LicenseServiceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "endpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension LicenseServiceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LicenseServiceConfiguration(endpoint: \(String(describing: endpoint)))"}
}

/// <p>The configuration for a license service that is associated with a studio resource.</p>
public struct LicenseServiceConfiguration: Equatable {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    public let endpoint: String?

    public init (
        endpoint: String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

extension ListEulaAcceptancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEulaAcceptancesInput(eulaIds: \(String(describing: eulaIds)), nextToken: \(String(describing: nextToken)), studioId: \(String(describing: studioId)))"}
}

extension ListEulaAcceptancesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEulaAcceptancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEulaAcceptancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEulaAcceptancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEulaAcceptancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEulaAcceptancesInput>
    public typealias MOutput = OperationOutput<ListEulaAcceptancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEulaAcceptancesOutputError>
}

public struct ListEulaAcceptancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEulaAcceptancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEulaAcceptancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEulaAcceptancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let eulaIds = input.operationInput.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEulaAcceptancesInput>
    public typealias MOutput = OperationOutput<ListEulaAcceptancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEulaAcceptancesOutputError>
}

public struct ListEulaAcceptancesInput: Equatable {
    /// <p>A collection of EULA IDs.</p>
    public let eulaIds: [String]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        eulaIds: [String]? = nil,
        nextToken: String? = nil,
        studioId: String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListEulaAcceptancesInputBody: Equatable {
}

extension ListEulaAcceptancesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEulaAcceptancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulaAcceptancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulaAcceptancesOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulaAcceptancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEulaAcceptancesOutputResponse(eulaAcceptances: \(String(describing: eulaAcceptances)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEulaAcceptancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulaAcceptancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
            self.nextToken = output.nextToken
        } else {
            self.eulaAcceptances = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulaAcceptancesOutputResponse: Equatable {
    /// <p>A collection of EULA acceptances.</p>
    public let eulaAcceptances: [EulaAcceptance]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        eulaAcceptances: [EulaAcceptance]? = nil,
        nextToken: String? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
        self.nextToken = nextToken
    }
}

struct ListEulaAcceptancesOutputResponseBody: Equatable {
    public let eulaAcceptances: [EulaAcceptance]?
    public let nextToken: String?
}

extension ListEulaAcceptancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eulaAcceptances = "eulaAcceptances"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEulasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEulasInput(eulaIds: \(String(describing: eulaIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEulasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEulasInputHeadersMiddleware: Middleware {
    public let id: String = "ListEulasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEulasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEulasInput>
    public typealias MOutput = OperationOutput<ListEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEulasOutputError>
}

public struct ListEulasInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEulasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEulasInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let eulaIds = input.operationInput.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEulasInput>
    public typealias MOutput = OperationOutput<ListEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEulasOutputError>
}

public struct ListEulasInput: Equatable {
    /// <p>A collection of EULA IDs.</p>
    public let eulaIds: [String]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        eulaIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
    }
}

struct ListEulasInputBody: Equatable {
}

extension ListEulasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEulasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulasOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEulasOutputResponse(eulas: \(String(describing: eulas)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEulasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulas = output.eulas
            self.nextToken = output.nextToken
        } else {
            self.eulas = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulasOutputResponse: Equatable {
    /// <p>A collection of EULA resources.</p>
    public let eulas: [Eula]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        eulas: [Eula]? = nil,
        nextToken: String? = nil
    )
    {
        self.eulas = eulas
        self.nextToken = nextToken
    }
}

struct ListEulasOutputResponseBody: Equatable {
    public let eulas: [Eula]?
    public let nextToken: String?
}

extension ListEulasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eulas = "eulas"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulasContainer = try containerValues.decodeIfPresent([Eula?].self, forKey: .eulas)
        var eulasDecoded0:[Eula]? = nil
        if let eulasContainer = eulasContainer {
            eulasDecoded0 = [Eula]()
            for structure0 in eulasContainer {
                if let structure0 = structure0 {
                    eulasDecoded0?.append(structure0)
                }
            }
        }
        eulas = eulasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfileMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchProfileMembersInput(launchProfileId: \(String(describing: launchProfileId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), studioId: \(String(describing: studioId)))"}
}

extension ListLaunchProfileMembersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLaunchProfileMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListLaunchProfileMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchProfileMembersInput>
    public typealias MOutput = OperationOutput<ListLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchProfileMembersOutputError>
}

public struct ListLaunchProfileMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLaunchProfileMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchProfileMembersInput>
    public typealias MOutput = OperationOutput<ListLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchProfileMembersOutputError>
}

public struct ListLaunchProfileMembersInput: Equatable {
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        launchProfileId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        studioId: String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListLaunchProfileMembersInputBody: Equatable {
}

extension ListLaunchProfileMembersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLaunchProfileMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfileMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfileMembersOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfileMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchProfileMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLaunchProfileMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfileMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfileMembersOutputResponse: Equatable {
    /// <p>A list of members.</p>
    public let members: [LaunchProfileMembership]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        members: [LaunchProfileMembership]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListLaunchProfileMembersOutputResponseBody: Equatable {
    public let members: [LaunchProfileMembership]?
    public let nextToken: String?
}

extension ListLaunchProfileMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([LaunchProfileMembership?].self, forKey: .members)
        var membersDecoded0:[LaunchProfileMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [LaunchProfileMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principalId: \(String(describing: principalId)), states: \(String(describing: states)), studioId: \(String(describing: studioId)))"}
}

extension ListLaunchProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLaunchProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListLaunchProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchProfilesInput>
    public typealias MOutput = OperationOutput<ListLaunchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchProfilesOutputError>
}

public struct ListLaunchProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLaunchProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let principalId = input.operationInput.principalId {
            let principalIdQueryItem = URLQueryItem(name: "principalId".urlPercentEncoding(), value: String(principalId).urlPercentEncoding())
            input.builder.withQueryItem(principalIdQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "states".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchProfilesInput>
    public typealias MOutput = OperationOutput<ListLaunchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchProfilesOutputError>
}

public struct ListLaunchProfilesInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>A list of states.</p>
    public let states: [String]?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        principalId: String? = nil,
        states: [String]? = nil,
        studioId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.states = states
        self.studioId = studioId
    }
}

struct ListLaunchProfilesInputBody: Equatable {
}

extension ListLaunchProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLaunchProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfilesOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchProfilesOutputResponse(launchProfiles: \(String(describing: launchProfiles)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLaunchProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfiles = output.launchProfiles
            self.nextToken = output.nextToken
        } else {
            self.launchProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfilesOutputResponse: Equatable {
    /// <p>A collection of launch profiles.</p>
    public let launchProfiles: [LaunchProfile]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        launchProfiles: [LaunchProfile]? = nil,
        nextToken: String? = nil
    )
    {
        self.launchProfiles = launchProfiles
        self.nextToken = nextToken
    }
}

struct ListLaunchProfilesOutputResponseBody: Equatable {
    public let launchProfiles: [LaunchProfile]?
    public let nextToken: String?
}

extension ListLaunchProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfiles = "launchProfiles"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfilesContainer = try containerValues.decodeIfPresent([LaunchProfile?].self, forKey: .launchProfiles)
        var launchProfilesDecoded0:[LaunchProfile]? = nil
        if let launchProfilesContainer = launchProfilesContainer {
            launchProfilesDecoded0 = [LaunchProfile]()
            for structure0 in launchProfilesContainer {
                if let structure0 = structure0 {
                    launchProfilesDecoded0?.append(structure0)
                }
            }
        }
        launchProfiles = launchProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamingImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingImagesInput(nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)), studioId: \(String(describing: studioId)))"}
}

extension ListStreamingImagesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStreamingImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamingImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingImagesInput>
    public typealias MOutput = OperationOutput<ListStreamingImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingImagesOutputError>
}

public struct ListStreamingImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamingImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let owner = input.operationInput.owner {
            let ownerQueryItem = URLQueryItem(name: "owner".urlPercentEncoding(), value: String(owner).urlPercentEncoding())
            input.builder.withQueryItem(ownerQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingImagesInput>
    public typealias MOutput = OperationOutput<ListStreamingImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingImagesOutputError>
}

public struct ListStreamingImagesInput: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The owner.</p>
    public let owner: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        nextToken: String? = nil,
        owner: String? = nil,
        studioId: String? = nil
    )
    {
        self.nextToken = nextToken
        self.owner = owner
        self.studioId = studioId
    }
}

struct ListStreamingImagesInputBody: Equatable {
}

extension ListStreamingImagesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStreamingImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingImagesOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingImagesOutputResponse(nextToken: \(String(describing: nextToken)), streamingImages: \(String(describing: streamingImages)))"}
}

extension ListStreamingImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamingImages = output.streamingImages
        } else {
            self.nextToken = nil
            self.streamingImages = nil
        }
    }
}

public struct ListStreamingImagesOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A collection of streaming images.</p>
    public let streamingImages: [StreamingImage]?

    public init (
        nextToken: String? = nil,
        streamingImages: [StreamingImage]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingImages = streamingImages
    }
}

struct ListStreamingImagesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let streamingImages: [StreamingImage]?
}

extension ListStreamingImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case streamingImages = "streamingImages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
    }
}

extension ListStreamingSessionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingSessionsInput(createdBy: \(String(describing: createdBy)), nextToken: \(String(describing: nextToken)), sessionIds: \(String(describing: sessionIds)), studioId: \(String(describing: studioId)))"}
}

extension ListStreamingSessionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStreamingSessionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamingSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingSessionsInput>
    public typealias MOutput = OperationOutput<ListStreamingSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingSessionsOutputError>
}

public struct ListStreamingSessionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamingSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createdBy = input.operationInput.createdBy {
            let createdByQueryItem = URLQueryItem(name: "createdBy".urlPercentEncoding(), value: String(createdBy).urlPercentEncoding())
            input.builder.withQueryItem(createdByQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let sessionIds = input.operationInput.sessionIds {
            let sessionIdsQueryItem = URLQueryItem(name: "sessionIds".urlPercentEncoding(), value: String(sessionIds).urlPercentEncoding())
            input.builder.withQueryItem(sessionIdsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingSessionsInput>
    public typealias MOutput = OperationOutput<ListStreamingSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingSessionsOutputError>
}

public struct ListStreamingSessionsInput: Equatable {
    /// <p>The user ID.</p>
    public let createdBy: String?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A collection of session IDs.</p>
    public let sessionIds: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        createdBy: String? = nil,
        nextToken: String? = nil,
        sessionIds: String? = nil,
        studioId: String? = nil
    )
    {
        self.createdBy = createdBy
        self.nextToken = nextToken
        self.sessionIds = sessionIds
        self.studioId = studioId
    }
}

struct ListStreamingSessionsInputBody: Equatable {
}

extension ListStreamingSessionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStreamingSessionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingSessionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingSessionsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingSessionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingSessionsOutputResponse(nextToken: \(String(describing: nextToken)), sessions: \(String(describing: sessions)))"}
}

extension ListStreamingSessionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListStreamingSessionsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A collection of streaming sessions.</p>
    public let sessions: [StreamingSession]?

    public init (
        nextToken: String? = nil,
        sessions: [StreamingSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListStreamingSessionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let sessions: [StreamingSession]?
}

extension ListStreamingSessionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case sessions = "sessions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([StreamingSession?].self, forKey: .sessions)
        var sessionsDecoded0:[StreamingSession]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [StreamingSession]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

extension ListStudioComponentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudioComponentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), states: \(String(describing: states)), studioId: \(String(describing: studioId)), types: \(String(describing: types)))"}
}

extension ListStudioComponentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStudioComponentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStudioComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudioComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudioComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudioComponentsInput>
    public typealias MOutput = OperationOutput<ListStudioComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudioComponentsOutputError>
}

public struct ListStudioComponentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStudioComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudioComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudioComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let types = input.operationInput.types {
            types.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "types".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "states".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudioComponentsInput>
    public typealias MOutput = OperationOutput<ListStudioComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudioComponentsOutputError>
}

public struct ListStudioComponentsInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A list of states.</p>
    public let states: [String]?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>The types.</p>
    public let types: [String]?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        states: [String]? = nil,
        studioId: String? = nil,
        types: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.studioId = studioId
        self.types = types
    }
}

struct ListStudioComponentsInputBody: Equatable {
}

extension ListStudioComponentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStudioComponentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioComponentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioComponentsOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioComponentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudioComponentsOutputResponse(nextToken: \(String(describing: nextToken)), studioComponents: \(String(describing: studioComponents)))"}
}

extension ListStudioComponentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studioComponents = output.studioComponents
        } else {
            self.nextToken = nil
            self.studioComponents = nil
        }
    }
}

public struct ListStudioComponentsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A collection of studio components.</p>
    public let studioComponents: [StudioComponent]?

    public init (
        nextToken: String? = nil,
        studioComponents: [StudioComponent]? = nil
    )
    {
        self.nextToken = nextToken
        self.studioComponents = studioComponents
    }
}

struct ListStudioComponentsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let studioComponents: [StudioComponent]?
}

extension ListStudioComponentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case studioComponents = "studioComponents"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studioComponentsContainer = try containerValues.decodeIfPresent([StudioComponent?].self, forKey: .studioComponents)
        var studioComponentsDecoded0:[StudioComponent]? = nil
        if let studioComponentsContainer = studioComponentsContainer {
            studioComponentsDecoded0 = [StudioComponent]()
            for structure0 in studioComponentsContainer {
                if let structure0 = structure0 {
                    studioComponentsDecoded0?.append(structure0)
                }
            }
        }
        studioComponents = studioComponentsDecoded0
    }
}

extension ListStudioMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudioMembersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), studioId: \(String(describing: studioId)))"}
}

extension ListStudioMembersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStudioMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListStudioMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudioMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudioMembersInput>
    public typealias MOutput = OperationOutput<ListStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudioMembersOutputError>
}

public struct ListStudioMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStudioMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudioMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudioMembersInput>
    public typealias MOutput = OperationOutput<ListStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudioMembersOutputError>
}

public struct ListStudioMembersInput: Equatable {
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        studioId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListStudioMembersInputBody: Equatable {
}

extension ListStudioMembersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStudioMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioMembersOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudioMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStudioMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListStudioMembersOutputResponse: Equatable {
    /// <p>A list of members.</p>
    public let members: [StudioMembership]?
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        members: [StudioMembership]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListStudioMembersOutputResponseBody: Equatable {
    public let members: [StudioMembership]?
    public let nextToken: String?
}

extension ListStudioMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([StudioMembership?].self, forKey: .members)
        var membersDecoded0:[StudioMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [StudioMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStudiosInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudiosInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListStudiosInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStudiosInputHeadersMiddleware: Middleware {
    public let id: String = "ListStudiosInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudiosInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudiosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudiosInput>
    public typealias MOutput = OperationOutput<ListStudiosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudiosOutputError>
}

public struct ListStudiosInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStudiosInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStudiosInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStudiosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStudiosInput>
    public typealias MOutput = OperationOutput<ListStudiosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStudiosOutputError>
}

public struct ListStudiosInput: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListStudiosInputBody: Equatable {
}

extension ListStudiosInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStudiosOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudiosOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudiosOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudiosOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStudiosOutputResponse(nextToken: \(String(describing: nextToken)), studios: \(String(describing: studios)))"}
}

extension ListStudiosOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudiosOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studios = output.studios
        } else {
            self.nextToken = nil
            self.studios = nil
        }
    }
}

public struct ListStudiosOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no more results.</p>
    public let nextToken: String?
    /// <p>A collection of studios.</p>
    public let studios: [Studio]?

    public init (
        nextToken: String? = nil,
        studios: [Studio]? = nil
    )
    {
        self.nextToken = nextToken
        self.studios = studios
    }
}

struct ListStudiosOutputResponseBody: Equatable {
    public let nextToken: String?
    public let studios: [Studio]?
}

extension ListStudiosOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case studios = "studios"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studiosContainer = try containerValues.decodeIfPresent([Studio?].self, forKey: .studios)
        var studiosDecoded0:[Studio]? = nil
        if let studiosContainer = studiosContainer {
            studiosDecoded0 = [Studio]()
            for structure0 in studiosContainer {
                if let structure0 = structure0 {
                    studiosDecoded0?.append(structure0)
                }
            }
        }
        studios = studiosDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the target resource for tagging operations.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NewLaunchProfileMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NewLaunchProfileMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewLaunchProfileMember(persona: \(String(describing: persona)), principalId: \(String(describing: principalId)))"}
}

public struct NewLaunchProfileMember: Equatable {
    /// <p>The persona.</p>
    public let persona: LaunchProfilePersona?
    /// <p>The principal ID.</p>
    public let principalId: String?

    public init (
        persona: LaunchProfilePersona? = nil,
        principalId: String? = nil
    )
    {
        self.persona = persona
        self.principalId = principalId
    }
}

extension NewStudioMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NewStudioMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewStudioMember(persona: \(String(describing: persona)), principalId: \(String(describing: principalId)))"}
}

public struct NewStudioMember: Equatable {
    /// <p>The persona.</p>
    public let persona: StudioPersona?
    /// <p>The principal ID.</p>
    public let principalId: String?

    public init (
        persona: StudioPersona? = nil,
        principalId: String? = nil
    )
    {
        self.persona = persona
        self.principalId = principalId
    }
}

public struct PutLaunchProfileMembersInputBodyMiddleware: Middleware {
    public let id: String = "PutLaunchProfileMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLaunchProfileMembersOutputError>
}

extension PutLaunchProfileMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLaunchProfileMembersInput(clientToken: \(String(describing: clientToken)), identityStoreId: \(String(describing: identityStoreId)), launchProfileId: \(String(describing: launchProfileId)), members: \(String(describing: members)), studioId: \(String(describing: studioId)))"}
}

extension PutLaunchProfileMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newlaunchprofilememberlist0 in members {
                try membersContainer.encode(newlaunchprofilememberlist0)
            }
        }
    }
}

public struct PutLaunchProfileMembersInputHeadersMiddleware: Middleware {
    public let id: String = "PutLaunchProfileMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLaunchProfileMembersOutputError>
}

public struct PutLaunchProfileMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLaunchProfileMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLaunchProfileMembersOutputError>
}

/// <p>Information about a launch profile membership.</p>
public struct PutLaunchProfileMembersInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The ID of the identity store.</p>
    public let identityStoreId: String?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>A list of members.</p>
    public let members: [NewLaunchProfileMember]?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        identityStoreId: String? = nil,
        launchProfileId: String? = nil,
        members: [NewLaunchProfileMember]? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.launchProfileId = launchProfileId
        self.members = members
        self.studioId = studioId
    }
}

struct PutLaunchProfileMembersInputBody: Equatable {
    public let identityStoreId: String?
    public let members: [NewLaunchProfileMember]?
}

extension PutLaunchProfileMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NewLaunchProfileMember?].self, forKey: .members)
        var membersDecoded0:[NewLaunchProfileMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NewLaunchProfileMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutLaunchProfileMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLaunchProfileMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLaunchProfileMembersOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLaunchProfileMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLaunchProfileMembersOutputResponse()"}
}

extension PutLaunchProfileMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLaunchProfileMembersOutputResponse: Equatable {

    public init() {}
}

struct PutLaunchProfileMembersOutputResponseBody: Equatable {
}

extension PutLaunchProfileMembersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutStudioMembersInputBodyMiddleware: Middleware {
    public let id: String = "PutStudioMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStudioMembersOutputError>
}

extension PutStudioMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStudioMembersInput(clientToken: \(String(describing: clientToken)), identityStoreId: \(String(describing: identityStoreId)), members: \(String(describing: members)), studioId: \(String(describing: studioId)))"}
}

extension PutStudioMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newstudiomemberlist0 in members {
                try membersContainer.encode(newstudiomemberlist0)
            }
        }
    }
}

public struct PutStudioMembersInputHeadersMiddleware: Middleware {
    public let id: String = "PutStudioMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStudioMembersOutputError>
}

public struct PutStudioMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "PutStudioMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStudioMembersOutputError>
}

/// <p>A launch profile membership collection.</p>
public struct PutStudioMembersInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The ID of the identity store.</p>
    public let identityStoreId: String?
    /// <p>A list of members.</p>
    public let members: [NewStudioMember]?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        identityStoreId: String? = nil,
        members: [NewStudioMember]? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.members = members
        self.studioId = studioId
    }
}

struct PutStudioMembersInputBody: Equatable {
    public let identityStoreId: String?
    public let members: [NewStudioMember]?
}

extension PutStudioMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NewStudioMember?].self, forKey: .members)
        var membersDecoded0:[NewStudioMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NewStudioMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutStudioMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStudioMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStudioMembersOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStudioMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStudioMembersOutputResponse()"}
}

extension PutStudioMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutStudioMembersOutputResponse: Equatable {

    public init() {}
}

struct PutStudioMembersOutputResponseBody: Equatable {
}

extension PutStudioMembersOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScriptParameterKeyValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ScriptParameterKeyValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScriptParameterKeyValue(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A parameter for a studio component script, in the form of a key:value pair.</p>
public struct ScriptParameterKeyValue: Equatable {
    /// <p>A script parameter key.</p>
    public let key: String?
    /// <p>A script parameter value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SharedFileSystemConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "endpoint"
        case fileSystemId = "fileSystemId"
        case linuxMountPoint = "linuxMountPoint"
        case shareName = "shareName"
        case windowsMountDrive = "windowsMountDrive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let linuxMountPoint = linuxMountPoint {
            try encodeContainer.encode(linuxMountPoint, forKey: .linuxMountPoint)
        }
        if let shareName = shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
        if let windowsMountDrive = windowsMountDrive {
            try encodeContainer.encode(windowsMountDrive, forKey: .windowsMountDrive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let linuxMountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linuxMountPoint)
        linuxMountPoint = linuxMountPointDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareName)
        shareName = shareNameDecoded
        let windowsMountDriveDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowsMountDrive)
        windowsMountDrive = windowsMountDriveDecoded
    }
}

extension SharedFileSystemConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharedFileSystemConfiguration(endpoint: \(String(describing: endpoint)), fileSystemId: \(String(describing: fileSystemId)), linuxMountPoint: \(String(describing: linuxMountPoint)), shareName: \(String(describing: shareName)), windowsMountDrive: \(String(describing: windowsMountDrive)))"}
}

/// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
public struct SharedFileSystemConfiguration: Equatable {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    public let endpoint: String?
    /// <p>The unique identifier for a file system.</p>
    public let fileSystemId: String?
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    public let linuxMountPoint: String?
    /// <p>The name of the file share.</p>
    public let shareName: String?
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    public let windowsMountDrive: String?

    public init (
        endpoint: String? = nil,
        fileSystemId: String? = nil,
        linuxMountPoint: String? = nil,
        shareName: String? = nil,
        windowsMountDrive: String? = nil
    )
    {
        self.endpoint = endpoint
        self.fileSystemId = fileSystemId
        self.linuxMountPoint = linuxMountPoint
        self.shareName = shareName
        self.windowsMountDrive = windowsMountDrive
    }
}

extension StartStudioSSOConfigurationRepairInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStudioSSOConfigurationRepairInput(clientToken: \(String(describing: clientToken)), studioId: \(String(describing: studioId)))"}
}

extension StartStudioSSOConfigurationRepairInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartStudioSSOConfigurationRepairInputHeadersMiddleware: Middleware {
    public let id: String = "StartStudioSSOConfigurationRepairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStudioSSOConfigurationRepairInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStudioSSOConfigurationRepairInput>
    public typealias MOutput = OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStudioSSOConfigurationRepairOutputError>
}

public struct StartStudioSSOConfigurationRepairInputQueryItemMiddleware: Middleware {
    public let id: String = "StartStudioSSOConfigurationRepairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStudioSSOConfigurationRepairInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStudioSSOConfigurationRepairInput>
    public typealias MOutput = OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStudioSSOConfigurationRepairOutputError>
}

public struct StartStudioSSOConfigurationRepairInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct StartStudioSSOConfigurationRepairInputBody: Equatable {
}

extension StartStudioSSOConfigurationRepairInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartStudioSSOConfigurationRepairOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStudioSSOConfigurationRepairOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStudioSSOConfigurationRepairOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStudioSSOConfigurationRepairOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStudioSSOConfigurationRepairOutputResponse(studio: \(String(describing: studio)))"}
}

extension StartStudioSSOConfigurationRepairOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartStudioSSOConfigurationRepairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct StartStudioSSOConfigurationRepairOutputResponse: Equatable {
    /// <p>Information about a studio.</p>
    public let studio: Studio?

    public init (
        studio: Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct StartStudioSSOConfigurationRepairOutputResponseBody: Equatable {
    public let studio: Studio?
}

extension StartStudioSSOConfigurationRepairOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension StreamConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clipboardMode = "clipboardMode"
        case ec2InstanceTypes = "ec2InstanceTypes"
        case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
        case streamingImageIds = "streamingImageIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if maxSessionLengthInMinutes != 0 {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decode(Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
    }
}

extension StreamConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamConfiguration(clipboardMode: \(String(describing: clipboardMode)), ec2InstanceTypes: \(String(describing: ec2InstanceTypes)), maxSessionLengthInMinutes: \(String(describing: maxSessionLengthInMinutes)), streamingImageIds: \(String(describing: streamingImageIds)))"}
}

/// <p>A configuration for a streaming session.</p>
public struct StreamConfiguration: Equatable {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    public let clipboardMode: StreamingClipboardMode?
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    public let ec2InstanceTypes: [StreamingInstanceType]?
    /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
    public let maxSessionLengthInMinutes: Int
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    public let streamingImageIds: [String]?

    public init (
        clipboardMode: StreamingClipboardMode? = nil,
        ec2InstanceTypes: [StreamingInstanceType]? = nil,
        maxSessionLengthInMinutes: Int = 0,
        streamingImageIds: [String]? = nil
    )
    {
        self.clipboardMode = clipboardMode
        self.ec2InstanceTypes = ec2InstanceTypes
        self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
        self.streamingImageIds = streamingImageIds
    }
}

extension StreamConfigurationCreate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clipboardMode = "clipboardMode"
        case ec2InstanceTypes = "ec2InstanceTypes"
        case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
        case streamingImageIds = "streamingImageIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if maxSessionLengthInMinutes != 0 {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decode(Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
    }
}

extension StreamConfigurationCreate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamConfigurationCreate(clipboardMode: \(String(describing: clipboardMode)), ec2InstanceTypes: \(String(describing: ec2InstanceTypes)), maxSessionLengthInMinutes: \(String(describing: maxSessionLengthInMinutes)), streamingImageIds: \(String(describing: streamingImageIds)))"}
}

public struct StreamConfigurationCreate: Equatable {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    public let clipboardMode: StreamingClipboardMode?
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    public let ec2InstanceTypes: [StreamingInstanceType]?
    /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
    public let maxSessionLengthInMinutes: Int
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    public let streamingImageIds: [String]?

    public init (
        clipboardMode: StreamingClipboardMode? = nil,
        ec2InstanceTypes: [StreamingInstanceType]? = nil,
        maxSessionLengthInMinutes: Int = 0,
        streamingImageIds: [String]? = nil
    )
    {
        self.clipboardMode = clipboardMode
        self.ec2InstanceTypes = ec2InstanceTypes
        self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
        self.streamingImageIds = streamingImageIds
    }
}

public enum StreamingClipboardMode {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension StreamingClipboardMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingClipboardMode] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingClipboardMode(rawValue: rawValue) ?? StreamingClipboardMode.sdkUnknown(rawValue)
    }
}

extension StreamingImage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case encryptionConfiguration = "encryptionConfiguration"
        case eulaIds = "eulaIds"
        case name = "name"
        case owner = "owner"
        case platform = "platform"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(StreamingImageEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let eulaIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StreamingImageState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StreamingImageStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StreamingImage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingImage(arn: \(String(describing: arn)), description: \(String(describing: description)), ec2ImageId: \(String(describing: ec2ImageId)), encryptionConfiguration: \(String(describing: encryptionConfiguration)), eulaIds: \(String(describing: eulaIds)), name: \(String(describing: name)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), streamingImageId: \(String(describing: streamingImageId)), tags: \(String(describing: tags)))"}
}

public struct StreamingImage: Equatable {
    /// <p>The ARN of the resource.</p>
    public let arn: String?
    /// <p>A human-readable description of the streaming image.</p>
    public let description: String?
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    public let ec2ImageId: String?
    /// <p>The encryption configuration.</p>
    public let encryptionConfiguration: StreamingImageEncryptionConfiguration?
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    public let eulaIds: [String]?
    /// <p>A friendly name for a streaming image resource.</p>
    public let name: String?
    /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
    public let owner: String?
    /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
    public let platform: String?
    /// <p>The current state.</p>
    public let state: StreamingImageState?
    /// <p>The status code.</p>
    public let statusCode: StreamingImageStatusCode?
    /// <p>The status message for the streaming image.</p>
    public let statusMessage: String?
    /// <p>The ID of the streaming image.</p>
    public let streamingImageId: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        description: String? = nil,
        ec2ImageId: String? = nil,
        encryptionConfiguration: StreamingImageEncryptionConfiguration? = nil,
        eulaIds: [String]? = nil,
        name: String? = nil,
        owner: String? = nil,
        platform: String? = nil,
        state: StreamingImageState? = nil,
        statusCode: StreamingImageStatusCode? = nil,
        statusMessage: String? = nil,
        streamingImageId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.encryptionConfiguration = encryptionConfiguration
        self.eulaIds = eulaIds
        self.name = name
        self.owner = owner
        self.platform = platform
        self.state = state
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.streamingImageId = streamingImageId
        self.tags = tags
    }
}

extension StreamingImageEncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyArn = "keyArn"
        case keyType = "keyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(StreamingImageEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension StreamingImageEncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingImageEncryptionConfiguration(keyArn: \(String(describing: keyArn)), keyType: \(String(describing: keyType)))"}
}

public struct StreamingImageEncryptionConfiguration: Equatable {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    public let keyArn: String?
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    public let keyType: StreamingImageEncryptionConfigurationKeyType?

    public init (
        keyArn: String? = nil,
        keyType: StreamingImageEncryptionConfigurationKeyType? = nil
    )
    {
        self.keyArn = keyArn
        self.keyType = keyType
    }
}

/// <p></p>
public enum StreamingImageEncryptionConfigurationKeyType {
    case customerManagedKey
    case sdkUnknown(String)
}

extension StreamingImageEncryptionConfigurationKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingImageEncryptionConfigurationKeyType] {
        return [
            .customerManagedKey,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingImageEncryptionConfigurationKeyType(rawValue: rawValue) ?? StreamingImageEncryptionConfigurationKeyType.sdkUnknown(rawValue)
    }
}

public enum StreamingImageState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension StreamingImageState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingImageState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingImageState(rawValue: rawValue) ?? StreamingImageState.sdkUnknown(rawValue)
    }
}

/// <p>The status code.</p>
public enum StreamingImageStatusCode {
    case internalError
    case streamingImageCreateInProgress
    case streamingImageDeleted
    case streamingImageDeleteInProgress
    case streamingImageReady
    case streamingImageUpdateInProgress
    case sdkUnknown(String)
}

extension StreamingImageStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingImageStatusCode] {
        return [
            .internalError,
            .streamingImageCreateInProgress,
            .streamingImageDeleted,
            .streamingImageDeleteInProgress,
            .streamingImageReady,
            .streamingImageUpdateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalError: return "INTERNAL_ERROR"
        case .streamingImageCreateInProgress: return "STREAMING_IMAGE_CREATE_IN_PROGRESS"
        case .streamingImageDeleted: return "STREAMING_IMAGE_DELETED"
        case .streamingImageDeleteInProgress: return "STREAMING_IMAGE_DELETE_IN_PROGRESS"
        case .streamingImageReady: return "STREAMING_IMAGE_READY"
        case .streamingImageUpdateInProgress: return "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingImageStatusCode(rawValue: rawValue) ?? StreamingImageStatusCode.sdkUnknown(rawValue)
    }
}

public enum StreamingInstanceType {
    case g4dn12xlarge
    case g4dn16xlarge
    case g4dn2xlarge
    case g4dn4xlarge
    case g4dn8xlarge
    case g4dnXlarge
    case sdkUnknown(String)
}

extension StreamingInstanceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingInstanceType] {
        return [
            .g4dn12xlarge,
            .g4dn16xlarge,
            .g4dn2xlarge,
            .g4dn4xlarge,
            .g4dn8xlarge,
            .g4dnXlarge,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .g4dn12xlarge: return "g4dn.12xlarge"
        case .g4dn16xlarge: return "g4dn.16xlarge"
        case .g4dn2xlarge: return "g4dn.2xlarge"
        case .g4dn4xlarge: return "g4dn.4xlarge"
        case .g4dn8xlarge: return "g4dn.8xlarge"
        case .g4dnXlarge: return "g4dn.xlarge"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingInstanceType(rawValue: rawValue) ?? StreamingInstanceType.sdkUnknown(rawValue)
    }
}

extension StreamingSession: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case sessionId = "sessionId"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
        case terminateAt = "terminateAt"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let terminateAt = terminateAt {
            try encodeContainer.encode(terminateAt.timeIntervalSince1970, forKey: .terminateAt)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StreamingSessionState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StreamingSessionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let terminateAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .terminateAt)
        terminateAt = terminateAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension StreamingSession: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingSession(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), ec2InstanceType: \(String(describing: ec2InstanceType)), launchProfileId: \(String(describing: launchProfileId)), sessionId: \(String(describing: sessionId)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), streamingImageId: \(String(describing: streamingImageId)), tags: \(String(describing: tags)), terminateAt: \(String(describing: terminateAt)), updatedAt: \(String(describing: updatedAt)), updatedBy: \(String(describing: updatedBy)))"}
}

public struct StreamingSession: Equatable {
    /// <p>The ARN of the resource.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The user ID of the user that created the streaming session.</p>
    public let createdBy: String?
    /// <p>The EC2 Instance type used for the streaming session.</p>
    public let ec2InstanceType: String?
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    public let launchProfileId: String?
    /// <p>The session ID.</p>
    public let sessionId: String?
    /// <p>The current state.</p>
    public let state: StreamingSessionState?
    /// <p>The status code.</p>
    public let statusCode: StreamingSessionStatusCode?
    /// <p>The status message for the streaming session.</p>
    public let statusMessage: String?
    /// <p>The ID of the streaming image.</p>
    public let streamingImageId: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    public let terminateAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?
    /// <p>The user ID of the user that most recently updated the resource.</p>
    public let updatedBy: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        ec2InstanceType: String? = nil,
        launchProfileId: String? = nil,
        sessionId: String? = nil,
        state: StreamingSessionState? = nil,
        statusCode: StreamingSessionStatusCode? = nil,
        statusMessage: String? = nil,
        streamingImageId: String? = nil,
        tags: [String:String]? = nil,
        terminateAt: Date? = nil,
        updatedAt: Date? = nil,
        updatedBy: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.sessionId = sessionId
        self.state = state
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.streamingImageId = streamingImageId
        self.tags = tags
        self.terminateAt = terminateAt
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

/// <p>The streaming session state.</p>
public enum StreamingSessionState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case sdkUnknown(String)
}

extension StreamingSessionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingSessionState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingSessionState(rawValue: rawValue) ?? StreamingSessionState.sdkUnknown(rawValue)
    }
}

public enum StreamingSessionStatusCode {
    case activeDirectoryDomainJoinError
    case decryptStreamingImageError
    case initializationScriptError
    case insufficientCapacity
    case internalError
    case networkConnectionError
    case networkInterfaceError
    case streamingSessionCreateInProgress
    case streamingSessionDeleted
    case streamingSessionDeleteInProgress
    case streamingSessionReady
    case sdkUnknown(String)
}

extension StreamingSessionStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingSessionStatusCode] {
        return [
            .activeDirectoryDomainJoinError,
            .decryptStreamingImageError,
            .initializationScriptError,
            .insufficientCapacity,
            .internalError,
            .networkConnectionError,
            .networkInterfaceError,
            .streamingSessionCreateInProgress,
            .streamingSessionDeleted,
            .streamingSessionDeleteInProgress,
            .streamingSessionReady,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activeDirectoryDomainJoinError: return "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
        case .decryptStreamingImageError: return "DECRYPT_STREAMING_IMAGE_ERROR"
        case .initializationScriptError: return "INITIALIZATION_SCRIPT_ERROR"
        case .insufficientCapacity: return "INSUFFICIENT_CAPACITY"
        case .internalError: return "INTERNAL_ERROR"
        case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
        case .networkInterfaceError: return "NETWORK_INTERFACE_ERROR"
        case .streamingSessionCreateInProgress: return "STREAMING_SESSION_CREATE_IN_PROGRESS"
        case .streamingSessionDeleted: return "STREAMING_SESSION_DELETED"
        case .streamingSessionDeleteInProgress: return "STREAMING_SESSION_DELETE_IN_PROGRESS"
        case .streamingSessionReady: return "STREAMING_SESSION_READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingSessionStatusCode(rawValue: rawValue) ?? StreamingSessionStatusCode.sdkUnknown(rawValue)
    }
}

extension StreamingSessionStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case expiresAt = "expiresAt"
        case state = "state"
        case statusCode = "statusCode"
        case streamId = "streamId"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StreamingSessionStreamState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StreamingSessionStreamStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension StreamingSessionStream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingSessionStream(createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), expiresAt: \(String(describing: expiresAt)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), streamId: \(String(describing: streamId)), url: \(String(describing: url)))"}
}

public struct StreamingSessionStream: Equatable {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The user ID of the user that created the streaming session stream.</p>
    public let createdBy: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
    public let expiresAt: Date?
    /// <p>The current state.</p>
    public let state: StreamingSessionStreamState?
    /// <p>The streaming session stream status code.</p>
    public let statusCode: StreamingSessionStreamStatusCode?
    /// <p>The stream ID.</p>
    public let streamId: String?
    /// <p>The URL to connect to this stream using the DCV client.</p>
    public let url: String?

    public init (
        createdAt: Date? = nil,
        createdBy: String? = nil,
        expiresAt: Date? = nil,
        state: StreamingSessionStreamState? = nil,
        statusCode: StreamingSessionStreamStatusCode? = nil,
        streamId: String? = nil,
        url: String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.expiresAt = expiresAt
        self.state = state
        self.statusCode = statusCode
        self.streamId = streamId
        self.url = url
    }
}

public enum StreamingSessionStreamState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case sdkUnknown(String)
}

extension StreamingSessionStreamState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingSessionStreamState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingSessionStreamState(rawValue: rawValue) ?? StreamingSessionStreamState.sdkUnknown(rawValue)
    }
}

public enum StreamingSessionStreamStatusCode {
    case internalError
    case networkConnectionError
    case streamCreateInProgress
    case streamDeleted
    case streamDeleteInProgress
    case streamReady
    case sdkUnknown(String)
}

extension StreamingSessionStreamStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamingSessionStreamStatusCode] {
        return [
            .internalError,
            .networkConnectionError,
            .streamCreateInProgress,
            .streamDeleted,
            .streamDeleteInProgress,
            .streamReady,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalError: return "INTERNAL_ERROR"
        case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
        case .streamCreateInProgress: return "STREAM_CREATE_IN_PROGRESS"
        case .streamDeleted: return "STREAM_DELETED"
        case .streamDeleteInProgress: return "STREAM_DELETE_IN_PROGRESS"
        case .streamReady: return "STREAM_READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamingSessionStreamStatusCode(rawValue: rawValue) ?? StreamingSessionStreamStatusCode.sdkUnknown(rawValue)
    }
}

extension Studio: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminRoleArn = "adminRoleArn"
        case arn = "arn"
        case createdAt = "createdAt"
        case displayName = "displayName"
        case homeRegion = "homeRegion"
        case ssoClientId = "ssoClientId"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioId = "studioId"
        case studioName = "studioName"
        case studioUrl = "studioUrl"
        case tags = "tags"
        case updatedAt = "updatedAt"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let ssoClientId = ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioId = studioId {
            try encodeContainer.encode(studioId, forKey: .studioId)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let studioUrl = studioUrl {
            try encodeContainer.encode(studioUrl, forKey: .studioUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StudioState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StudioStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioId)
        studioId = studioIdDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let studioUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioUrl)
        studioUrl = studioUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension Studio: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Studio(adminRoleArn: \(String(describing: adminRoleArn)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), displayName: \(String(describing: displayName)), homeRegion: \(String(describing: homeRegion)), ssoClientId: \(String(describing: ssoClientId)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), studioEncryptionConfiguration: \(String(describing: studioEncryptionConfiguration)), studioId: \(String(describing: studioId)), studioName: \(String(describing: studioName)), studioUrl: \(String(describing: studioUrl)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)), userRoleArn: \(String(describing: userRoleArn)))"}
}

public struct Studio: Equatable {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    public let adminRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>A friendly name for the studio.</p>
    public let displayName: String?
    /// <p>The AWS region where the studio resource is located.</p>
    public let homeRegion: String?
    /// <p>The AWS SSO application client ID used to integrate with AWS SSO to enable AWS SSO users to log in to Nimble portal.</p>
    public let ssoClientId: String?
    /// <p>The current state of the studio resource.</p>
    public let state: StudioState?
    /// <p>Status codes that provide additional detail on the studio state.</p>
    public let statusCode: StudioStatusCode?
    /// <p>Additional detail on the studio state.</p>
    public let statusMessage: String?
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    public let studioId: String?
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    public let studioName: String?
    /// <p>The address of the web page for the studio.</p>
    public let studioUrl: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    public let userRoleArn: String?

    public init (
        adminRoleArn: String? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        displayName: String? = nil,
        homeRegion: String? = nil,
        ssoClientId: String? = nil,
        state: StudioState? = nil,
        statusCode: StudioStatusCode? = nil,
        statusMessage: String? = nil,
        studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil,
        studioId: String? = nil,
        studioName: String? = nil,
        studioUrl: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil,
        userRoleArn: String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.arn = arn
        self.createdAt = createdAt
        self.displayName = displayName
        self.homeRegion = homeRegion
        self.ssoClientId = ssoClientId
        self.state = state
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioId = studioId
        self.studioName = studioName
        self.studioUrl = studioUrl
        self.tags = tags
        self.updatedAt = updatedAt
        self.userRoleArn = userRoleArn
    }
}

extension StudioComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case configuration = "configuration"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case studioComponentId = "studioComponentId"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(StudioComponentState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StudioComponentStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension StudioComponent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioComponent(arn: \(String(describing: arn)), configuration: \(String(describing: configuration)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), ec2SecurityGroupIds: \(String(describing: ec2SecurityGroupIds)), initializationScripts: \(String(describing: initializationScripts)), name: \(String(describing: name)), scriptParameters: \(String(describing: scriptParameters)), state: \(String(describing: state)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), studioComponentId: \(String(describing: studioComponentId)), subtype: \(String(describing: subtype)), tags: \(String(describing: tags)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)), updatedBy: \(String(describing: updatedBy)))"}
}

/// <p>A network that is used by a studios users and workflows, including render farm, Active Directory, licensing, and file system.</p>
public struct StudioComponent: Equatable {
    /// <p>The ARN of the resource.</p>
    public let arn: String?
    /// <p>The configuration of the studio component, based on component type.</p>
    public let configuration: StudioComponentConfiguration?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The user ID of the user that created the studio component.</p>
    public let createdBy: String?
    /// <p>A human-readable description for the studio component resource.</p>
    public let description: String?
    /// <p>The EC2 security groups that control access to the studio component.</p>
    public let ec2SecurityGroupIds: [String]?
    /// <p>Initialization scripts for studio components.</p>
    public let initializationScripts: [StudioComponentInitializationScript]?
    /// <p>A friendly name for the studio component resource.</p>
    public let name: String?
    /// <p>Parameters for the studio component scripts.</p>
    public let scriptParameters: [ScriptParameterKeyValue]?
    /// <p>The current state.</p>
    public let state: StudioComponentState?
    /// <p>The status code.</p>
    public let statusCode: StudioComponentStatusCode?
    /// <p>The status message for the studio component.</p>
    public let statusMessage: String?
    /// <p>The unique identifier for a studio component resource.</p>
    public let studioComponentId: String?
    /// <p>The specific subtype of a studio component.</p>
    public let subtype: StudioComponentSubtype?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?
    /// <p>The type of the studio component.</p>
    public let type: StudioComponentType?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?
    /// <p>The user ID of the user that most recently updated the resource.</p>
    public let updatedBy: String?

    public init (
        arn: String? = nil,
        configuration: StudioComponentConfiguration? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        initializationScripts: [StudioComponentInitializationScript]? = nil,
        name: String? = nil,
        scriptParameters: [ScriptParameterKeyValue]? = nil,
        state: StudioComponentState? = nil,
        statusCode: StudioComponentStatusCode? = nil,
        statusMessage: String? = nil,
        studioComponentId: String? = nil,
        subtype: StudioComponentSubtype? = nil,
        tags: [String:String]? = nil,
        type: StudioComponentType? = nil,
        updatedAt: Date? = nil,
        updatedBy: String? = nil
    )
    {
        self.arn = arn
        self.configuration = configuration
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.state = state
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.studioComponentId = studioComponentId
        self.subtype = subtype
        self.tags = tags
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension StudioComponentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryConfiguration = "activeDirectoryConfiguration"
        case computeFarmConfiguration = "computeFarmConfiguration"
        case licenseServiceConfiguration = "licenseServiceConfiguration"
        case sharedFileSystemConfiguration = "sharedFileSystemConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryConfiguration = activeDirectoryConfiguration {
            try encodeContainer.encode(activeDirectoryConfiguration, forKey: .activeDirectoryConfiguration)
        }
        if let computeFarmConfiguration = computeFarmConfiguration {
            try encodeContainer.encode(computeFarmConfiguration, forKey: .computeFarmConfiguration)
        }
        if let licenseServiceConfiguration = licenseServiceConfiguration {
            try encodeContainer.encode(licenseServiceConfiguration, forKey: .licenseServiceConfiguration)
        }
        if let sharedFileSystemConfiguration = sharedFileSystemConfiguration {
            try encodeContainer.encode(sharedFileSystemConfiguration, forKey: .sharedFileSystemConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(ActiveDirectoryConfiguration.self, forKey: .activeDirectoryConfiguration)
        activeDirectoryConfiguration = activeDirectoryConfigurationDecoded
        let computeFarmConfigurationDecoded = try containerValues.decodeIfPresent(ComputeFarmConfiguration.self, forKey: .computeFarmConfiguration)
        computeFarmConfiguration = computeFarmConfigurationDecoded
        let licenseServiceConfigurationDecoded = try containerValues.decodeIfPresent(LicenseServiceConfiguration.self, forKey: .licenseServiceConfiguration)
        licenseServiceConfiguration = licenseServiceConfigurationDecoded
        let sharedFileSystemConfigurationDecoded = try containerValues.decodeIfPresent(SharedFileSystemConfiguration.self, forKey: .sharedFileSystemConfiguration)
        sharedFileSystemConfiguration = sharedFileSystemConfigurationDecoded
    }
}

extension StudioComponentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioComponentConfiguration(activeDirectoryConfiguration: \(String(describing: activeDirectoryConfiguration)), computeFarmConfiguration: \(String(describing: computeFarmConfiguration)), licenseServiceConfiguration: \(String(describing: licenseServiceConfiguration)), sharedFileSystemConfiguration: \(String(describing: sharedFileSystemConfiguration)))"}
}

/// <p>The configuration of the studio component, based on component type.</p>
public struct StudioComponentConfiguration: Equatable {
    /// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
    public let activeDirectoryConfiguration: ActiveDirectoryConfiguration?
    /// <p>The configuration for a render farm that is associated with a studio resource.</p>
    public let computeFarmConfiguration: ComputeFarmConfiguration?
    /// <p>The configuration for a license service that is associated with a studio resource.</p>
    public let licenseServiceConfiguration: LicenseServiceConfiguration?
    /// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
    public let sharedFileSystemConfiguration: SharedFileSystemConfiguration?

    public init (
        activeDirectoryConfiguration: ActiveDirectoryConfiguration? = nil,
        computeFarmConfiguration: ComputeFarmConfiguration? = nil,
        licenseServiceConfiguration: LicenseServiceConfiguration? = nil,
        sharedFileSystemConfiguration: SharedFileSystemConfiguration? = nil
    )
    {
        self.activeDirectoryConfiguration = activeDirectoryConfiguration
        self.computeFarmConfiguration = computeFarmConfiguration
        self.licenseServiceConfiguration = licenseServiceConfiguration
        self.sharedFileSystemConfiguration = sharedFileSystemConfiguration
    }
}

extension StudioComponentInitializationScript: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case launchProfileProtocolVersion = "launchProfileProtocolVersion"
        case platform = "platform"
        case runContext = "runContext"
        case script = "script"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let runContext = runContext {
            try encodeContainer.encode(runContext.rawValue, forKey: .runContext)
        }
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let runContextDecoded = try containerValues.decodeIfPresent(StudioComponentInitializationScriptRunContext.self, forKey: .runContext)
        runContext = runContextDecoded
        let scriptDecoded = try containerValues.decodeIfPresent(String.self, forKey: .script)
        script = scriptDecoded
    }
}

extension StudioComponentInitializationScript: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioComponentInitializationScript(launchProfileProtocolVersion: \(String(describing: launchProfileProtocolVersion)), platform: \(String(describing: platform)), runContext: \(String(describing: runContext)), script: \(String(describing: script)))"}
}

/// <p>Initialization scripts for studio components.</p>
public struct StudioComponentInitializationScript: Equatable {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    public let launchProfileProtocolVersion: String?
    /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
    public let platform: LaunchProfilePlatform?
    /// <p>The method to use when running the initialization script.</p>
    public let runContext: StudioComponentInitializationScriptRunContext?
    /// <p>The initialization script.</p>
    public let script: String?

    public init (
        launchProfileProtocolVersion: String? = nil,
        platform: LaunchProfilePlatform? = nil,
        runContext: StudioComponentInitializationScriptRunContext? = nil,
        script: String? = nil
    )
    {
        self.launchProfileProtocolVersion = launchProfileProtocolVersion
        self.platform = platform
        self.runContext = runContext
        self.script = script
    }
}

public enum StudioComponentInitializationScriptRunContext {
    case systemInitialization
    case userInitialization
    case sdkUnknown(String)
}

extension StudioComponentInitializationScriptRunContext : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioComponentInitializationScriptRunContext] {
        return [
            .systemInitialization,
            .userInitialization,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .systemInitialization: return "SYSTEM_INITIALIZATION"
        case .userInitialization: return "USER_INITIALIZATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioComponentInitializationScriptRunContext(rawValue: rawValue) ?? StudioComponentInitializationScriptRunContext.sdkUnknown(rawValue)
    }
}

/// <p>The current state of the studio component resource.</p> <p>While a studio component is being created, modified, or deleted, its state will equal "CREATE_IN_PROGRESS", "UPDATE_IN_PROGRESS", or "DELETE_IN_PROGRESS"</p> <p>These are called 'transition states'.</p> <p>No modifications may be made to the studio component while it is in a transition state.</p> <p>If creation of the resource fails, the state will change to `CREATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time.</p> <p>If updating the resource fails, the state will change to `UPDATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked.</p> <p>If deleting the resource fails, the state will change to `DELETE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the "DELETED" state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.</p>
public enum StudioComponentState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension StudioComponentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioComponentState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioComponentState(rawValue: rawValue) ?? StudioComponentState.sdkUnknown(rawValue)
    }
}

/// <p>The current status of the studio component resource.</p> <p>When the resource is in the 'READY' state, the status code signals what the last mutation made to the resource was.</p> <p>When the resource is in a CREATE_FAILED/UPDATE_FAILED/DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.</p>
public enum StudioComponentStatusCode {
    case activeDirectoryAlreadyExists
    case encryptionKeyAccessDenied
    case encryptionKeyNotFound
    case internalError
    case studioComponentCreated
    case studioComponentCreateInProgress
    case studioComponentDeleted
    case studioComponentDeleteInProgress
    case studioComponentUpdated
    case studioComponentUpdateInProgress
    case sdkUnknown(String)
}

extension StudioComponentStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioComponentStatusCode] {
        return [
            .activeDirectoryAlreadyExists,
            .encryptionKeyAccessDenied,
            .encryptionKeyNotFound,
            .internalError,
            .studioComponentCreated,
            .studioComponentCreateInProgress,
            .studioComponentDeleted,
            .studioComponentDeleteInProgress,
            .studioComponentUpdated,
            .studioComponentUpdateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activeDirectoryAlreadyExists: return "ACTIVE_DIRECTORY_ALREADY_EXISTS"
        case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
        case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
        case .internalError: return "INTERNAL_ERROR"
        case .studioComponentCreated: return "STUDIO_COMPONENT_CREATED"
        case .studioComponentCreateInProgress: return "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
        case .studioComponentDeleted: return "STUDIO_COMPONENT_DELETED"
        case .studioComponentDeleteInProgress: return "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
        case .studioComponentUpdated: return "STUDIO_COMPONENT_UPDATED"
        case .studioComponentUpdateInProgress: return "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioComponentStatusCode(rawValue: rawValue) ?? StudioComponentStatusCode.sdkUnknown(rawValue)
    }
}

public enum StudioComponentSubtype {
    case amazonFsxForLustre
    case amazonFsxForWindows
    case awsManagedMicrosoftAd
    case custom
    case sdkUnknown(String)
}

extension StudioComponentSubtype : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioComponentSubtype] {
        return [
            .amazonFsxForLustre,
            .amazonFsxForWindows,
            .awsManagedMicrosoftAd,
            .custom,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonFsxForLustre: return "AMAZON_FSX_FOR_LUSTRE"
        case .amazonFsxForWindows: return "AMAZON_FSX_FOR_WINDOWS"
        case .awsManagedMicrosoftAd: return "AWS_MANAGED_MICROSOFT_AD"
        case .custom: return "CUSTOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioComponentSubtype(rawValue: rawValue) ?? StudioComponentSubtype.sdkUnknown(rawValue)
    }
}

extension StudioComponentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case name = "name"
        case studioComponentId = "studioComponentId"
        case subtype = "subtype"
        case type = "type"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension StudioComponentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioComponentSummary(createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), name: \(String(describing: name)), studioComponentId: \(String(describing: studioComponentId)), subtype: \(String(describing: subtype)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)), updatedBy: \(String(describing: updatedBy)))"}
}

/// <p></p>
public struct StudioComponentSummary: Equatable {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The user ID of the user that created the studio component.</p>
    public let createdBy: String?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The name for the studio component.</p>
    public let name: String?
    /// <p>The unique identifier for a studio component resource.</p>
    public let studioComponentId: String?
    /// <p>The specific subtype of a studio component.</p>
    public let subtype: StudioComponentSubtype?
    /// <p>The type of the studio component.</p>
    public let type: StudioComponentType?
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    public let updatedAt: Date?
    /// <p>The user ID of the user that most recently updated the resource.</p>
    public let updatedBy: String?

    public init (
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        name: String? = nil,
        studioComponentId: String? = nil,
        subtype: StudioComponentSubtype? = nil,
        type: StudioComponentType? = nil,
        updatedAt: Date? = nil,
        updatedBy: String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.name = name
        self.studioComponentId = studioComponentId
        self.subtype = subtype
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public enum StudioComponentType {
    case activeDirectory
    case computeFarm
    case custom
    case licenseService
    case sharedFileSystem
    case sdkUnknown(String)
}

extension StudioComponentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioComponentType] {
        return [
            .activeDirectory,
            .computeFarm,
            .custom,
            .licenseService,
            .sharedFileSystem,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activeDirectory: return "ACTIVE_DIRECTORY"
        case .computeFarm: return "COMPUTE_FARM"
        case .custom: return "CUSTOM"
        case .licenseService: return "LICENSE_SERVICE"
        case .sharedFileSystem: return "SHARED_FILE_SYSTEM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioComponentType(rawValue: rawValue) ?? StudioComponentType.sdkUnknown(rawValue)
    }
}

extension StudioEncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyArn = "keyArn"
        case keyType = "keyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(StudioEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension StudioEncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioEncryptionConfiguration(keyArn: \(String(describing: keyArn)), keyType: \(String(describing: keyType)))"}
}

/// <p>Configuration of the encryption method that is used for the studio.</p>
public struct StudioEncryptionConfiguration: Equatable {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    public let keyArn: String?
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    public let keyType: StudioEncryptionConfigurationKeyType?

    public init (
        keyArn: String? = nil,
        keyType: StudioEncryptionConfigurationKeyType? = nil
    )
    {
        self.keyArn = keyArn
        self.keyType = keyType
    }
}

/// <p>The type of KMS key that is used to encrypt studio data.</p>
public enum StudioEncryptionConfigurationKeyType {
    case awsOwnedKey
    case customerManagedKey
    case sdkUnknown(String)
}

extension StudioEncryptionConfigurationKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioEncryptionConfigurationKeyType] {
        return [
            .awsOwnedKey,
            .customerManagedKey,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsOwnedKey: return "AWS_OWNED_KEY"
        case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioEncryptionConfigurationKeyType(rawValue: rawValue) ?? StudioEncryptionConfigurationKeyType.sdkUnknown(rawValue)
    }
}

extension StudioMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityStoreId = "identityStoreId"
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension StudioMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StudioMembership(identityStoreId: \(String(describing: identityStoreId)), persona: \(String(describing: persona)), principalId: \(String(describing: principalId)))"}
}

public struct StudioMembership: Equatable {
    /// <p>The ID of the identity store.</p>
    public let identityStoreId: String?
    /// <p>The persona.</p>
    public let persona: StudioPersona?
    /// <p>The principal ID.</p>
    public let principalId: String?

    public init (
        identityStoreId: String? = nil,
        persona: StudioPersona? = nil,
        principalId: String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.persona = persona
        self.principalId = principalId
    }
}

public enum StudioPersona {
    case administrator
    case sdkUnknown(String)
}

extension StudioPersona : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioPersona] {
        return [
            .administrator,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .administrator: return "ADMINISTRATOR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioPersona(rawValue: rawValue) ?? StudioPersona.sdkUnknown(rawValue)
    }
}

public enum StudioState {
    case createFailed
    case createInProgress
    case deleted
    case deleteFailed
    case deleteInProgress
    case ready
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension StudioState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioState] {
        return [
            .createFailed,
            .createInProgress,
            .deleted,
            .deleteFailed,
            .deleteInProgress,
            .ready,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleted: return "DELETED"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .ready: return "READY"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioState(rawValue: rawValue) ?? StudioState.sdkUnknown(rawValue)
    }
}

/// <p>The status code.</p>
public enum StudioStatusCode {
    case awsSsoAccessDenied
    case awsSsoConfigurationRepaired
    case awsSsoConfigurationRepairInProgress
    case awsSsoNotEnabled
    case encryptionKeyAccessDenied
    case encryptionKeyNotFound
    case internalError
    case roleCouldNotBeAssumed
    case roleNotOwnedByStudioOwner
    case studioCreated
    case studioCreateInProgress
    case studioDeleted
    case studioDeleteInProgress
    case studioUpdated
    case studioUpdateInProgress
    case studioWithLaunchProfilesNotDeleted
    case studioWithStreamingImagesNotDeleted
    case studioWithStudioComponentsNotDeleted
    case sdkUnknown(String)
}

extension StudioStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StudioStatusCode] {
        return [
            .awsSsoAccessDenied,
            .awsSsoConfigurationRepaired,
            .awsSsoConfigurationRepairInProgress,
            .awsSsoNotEnabled,
            .encryptionKeyAccessDenied,
            .encryptionKeyNotFound,
            .internalError,
            .roleCouldNotBeAssumed,
            .roleNotOwnedByStudioOwner,
            .studioCreated,
            .studioCreateInProgress,
            .studioDeleted,
            .studioDeleteInProgress,
            .studioUpdated,
            .studioUpdateInProgress,
            .studioWithLaunchProfilesNotDeleted,
            .studioWithStreamingImagesNotDeleted,
            .studioWithStudioComponentsNotDeleted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsSsoAccessDenied: return "AWS_SSO_ACCESS_DENIED"
        case .awsSsoConfigurationRepaired: return "AWS_SSO_CONFIGURATION_REPAIRED"
        case .awsSsoConfigurationRepairInProgress: return "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
        case .awsSsoNotEnabled: return "AWS_SSO_NOT_ENABLED"
        case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
        case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
        case .internalError: return "INTERNAL_ERROR"
        case .roleCouldNotBeAssumed: return "ROLE_COULD_NOT_BE_ASSUMED"
        case .roleNotOwnedByStudioOwner: return "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
        case .studioCreated: return "STUDIO_CREATED"
        case .studioCreateInProgress: return "STUDIO_CREATE_IN_PROGRESS"
        case .studioDeleted: return "STUDIO_DELETED"
        case .studioDeleteInProgress: return "STUDIO_DELETE_IN_PROGRESS"
        case .studioUpdated: return "STUDIO_UPDATED"
        case .studioUpdateInProgress: return "STUDIO_UPDATE_IN_PROGRESS"
        case .studioWithLaunchProfilesNotDeleted: return "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
        case .studioWithStreamingImagesNotDeleted: return "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
        case .studioWithStudioComponentsNotDeleted: return "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StudioStatusCode(rawValue: rawValue) ?? StudioStatusCode.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>The ARN for the role that manages access.</p>
public struct TagResourceInput: Equatable {
    /// <p>The ARN of the target resource for tagging operations.</p>
    public let resourceArn: String?
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the target resource for tagging operations.</p>
    public let resourceArn: String?
    /// <p>An array of tag keys to delete.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLaunchProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileOutputError>
}

extension UpdateLaunchProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchProfileInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), launchProfileId: \(String(describing: launchProfileId)), launchProfileProtocolVersions: \(String(describing: launchProfileProtocolVersions)), name: \(String(describing: name)), streamConfiguration: \(String(describing: streamConfiguration)), studioComponentIds: \(String(describing: studioComponentIds)), studioId: \(String(describing: studioId)))"}
}

extension UpdateLaunchProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
    }
}

public struct UpdateLaunchProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileOutputError>
}

public struct UpdateLaunchProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileOutputError>
}

/// <p>The launch profile ID.</p>
public struct UpdateLaunchProfileInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    public let launchProfileProtocolVersions: [String]?
    /// <p>The name for the launch profile.</p>
    public let name: String?
    /// <p>A configuration for a streaming session.</p>
    public let streamConfiguration: StreamConfigurationCreate?
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    public let studioComponentIds: [String]?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        launchProfileId: String? = nil,
        launchProfileProtocolVersions: [String]? = nil,
        name: String? = nil,
        streamConfiguration: StreamConfigurationCreate? = nil,
        studioComponentIds: [String]? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileInputBody: Equatable {
    public let description: String?
    public let launchProfileProtocolVersions: [String]?
    public let name: String?
    public let streamConfiguration: StreamConfigurationCreate?
    public let studioComponentIds: [String]?
}

extension UpdateLaunchProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
    }
}

public struct UpdateLaunchProfileMemberInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileMemberOutputError>
}

extension UpdateLaunchProfileMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchProfileMemberInput(clientToken: \(String(describing: clientToken)), launchProfileId: \(String(describing: launchProfileId)), persona: \(String(describing: persona)), principalId: \(String(describing: principalId)), studioId: \(String(describing: studioId)))"}
}

extension UpdateLaunchProfileMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case persona = "persona"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
    }
}

public struct UpdateLaunchProfileMemberInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileMemberOutputError>
}

public struct UpdateLaunchProfileMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchProfileMemberOutputError>
}

/// <p>The principal ID.</p>
public struct UpdateLaunchProfileMemberInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The launch profile ID.</p>
    public let launchProfileId: String?
    /// <p>The persona.</p>
    public let persona: LaunchProfilePersona?
    /// <p>The principal ID.</p>
    public let principalId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        launchProfileId: String? = nil,
        persona: LaunchProfilePersona? = nil,
        principalId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.persona = persona
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileMemberInputBody: Equatable {
    public let persona: LaunchProfilePersona?
}

extension UpdateLaunchProfileMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case persona = "persona"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
    }
}

extension UpdateLaunchProfileMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileMemberOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchProfileMemberOutputResponse(member: \(String(describing: member)))"}
}

extension UpdateLaunchProfileMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct UpdateLaunchProfileMemberOutputResponse: Equatable {
    /// <p>The member.</p>
    public let member: LaunchProfileMembership?

    public init (
        member: LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct UpdateLaunchProfileMemberOutputResponseBody: Equatable {
    public let member: LaunchProfileMembership?
}

extension UpdateLaunchProfileMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case member = "member"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension UpdateLaunchProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchProfileOutputResponse(launchProfile: \(String(describing: launchProfile)))"}
}

extension UpdateLaunchProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct UpdateLaunchProfileOutputResponse: Equatable {
    /// <p>The launch profile.</p>
    public let launchProfile: LaunchProfile?

    public init (
        launchProfile: LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct UpdateLaunchProfileOutputResponseBody: Equatable {
    public let launchProfile: LaunchProfile?
}

extension UpdateLaunchProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

public struct UpdateStreamingImageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStreamingImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingImageOutputError>
}

extension UpdateStreamingImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamingImageInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), streamingImageId: \(String(describing: streamingImageId)), studioId: \(String(describing: studioId)))"}
}

extension UpdateStreamingImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateStreamingImageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingImageOutputError>
}

public struct UpdateStreamingImageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingImageOutputError>
}

/// <p>The streaming image ID.</p>
public struct UpdateStreamingImageInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The name for the streaming image.</p>
    public let name: String?
    /// <p>The streaming image ID.</p>
    public let streamingImageId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        streamingImageId: String? = nil,
        studioId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct UpdateStreamingImageInputBody: Equatable {
    public let description: String?
    public let name: String?
}

extension UpdateStreamingImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStreamingImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamingImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingImageOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamingImageOutputResponse(streamingImage: \(String(describing: streamingImage)))"}
}

extension UpdateStreamingImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct UpdateStreamingImageOutputResponse: Equatable {
    /// <p></p>
    public let streamingImage: StreamingImage?

    public init (
        streamingImage: StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct UpdateStreamingImageOutputResponseBody: Equatable {
    public let streamingImage: StreamingImage?
}

extension UpdateStreamingImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

public struct UpdateStudioComponentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStudioComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioComponentOutputError>
}

extension UpdateStudioComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStudioComponentInput(clientToken: \(String(describing: clientToken)), configuration: \(String(describing: configuration)), description: \(String(describing: description)), ec2SecurityGroupIds: \(String(describing: ec2SecurityGroupIds)), initializationScripts: \(String(describing: initializationScripts)), name: \(String(describing: name)), scriptParameters: \(String(describing: scriptParameters)), studioComponentId: \(String(describing: studioComponentId)), studioId: \(String(describing: studioId)), subtype: \(String(describing: subtype)), type: \(String(describing: type)))"}
}

extension UpdateStudioComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateStudioComponentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioComponentOutputError>
}

public struct UpdateStudioComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioComponentOutputError>
}

/// <p>The studio component ID.</p>
public struct UpdateStudioComponentInput: Equatable {
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>The configuration of the studio component, based on component type.</p>
    public let configuration: StudioComponentConfiguration?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The EC2 security groups that control access to the studio component.</p>
    public let ec2SecurityGroupIds: [String]?
    /// <p>Initialization scripts for studio components.</p>
    public let initializationScripts: [StudioComponentInitializationScript]?
    /// <p>The name for the studio component.</p>
    public let name: String?
    /// <p>Parameters for the studio component scripts.</p>
    public let scriptParameters: [ScriptParameterKeyValue]?
    /// <p>The studio component ID.</p>
    public let studioComponentId: String?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>The specific subtype of a studio component.</p>
    public let subtype: StudioComponentSubtype?
    /// <p>The type of the studio component.</p>
    public let type: StudioComponentType?

    public init (
        clientToken: String? = nil,
        configuration: StudioComponentConfiguration? = nil,
        description: String? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        initializationScripts: [StudioComponentInitializationScript]? = nil,
        name: String? = nil,
        scriptParameters: [ScriptParameterKeyValue]? = nil,
        studioComponentId: String? = nil,
        studioId: String? = nil,
        subtype: StudioComponentSubtype? = nil,
        type: StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioComponentId = studioComponentId
        self.studioId = studioId
        self.subtype = subtype
        self.type = type
    }
}

struct UpdateStudioComponentInputBody: Equatable {
    public let configuration: StudioComponentConfiguration?
    public let description: String?
    public let ec2SecurityGroupIds: [String]?
    public let initializationScripts: [StudioComponentInitializationScript]?
    public let name: String?
    public let scriptParameters: [ScriptParameterKeyValue]?
    public let subtype: StudioComponentSubtype?
    public let type: StudioComponentType?
}

extension UpdateStudioComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case type = "type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateStudioComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioComponentOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStudioComponentOutputResponse(studioComponent: \(String(describing: studioComponent)))"}
}

extension UpdateStudioComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct UpdateStudioComponentOutputResponse: Equatable {
    /// <p>Information about the studio component.</p>
    public let studioComponent: StudioComponent?

    public init (
        studioComponent: StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct UpdateStudioComponentOutputResponseBody: Equatable {
    public let studioComponent: StudioComponent?
}

extension UpdateStudioComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

public struct UpdateStudioInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStudioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioOutputError>
}

extension UpdateStudioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStudioInput(adminRoleArn: \(String(describing: adminRoleArn)), clientToken: \(String(describing: clientToken)), displayName: \(String(describing: displayName)), studioId: \(String(describing: studioId)), userRoleArn: \(String(describing: userRoleArn)))"}
}

extension UpdateStudioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

public struct UpdateStudioInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioOutputError>
}

public struct UpdateStudioInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStudioOutputError>
}

/// <p>The studio ID.</p>
public struct UpdateStudioInput: Equatable {
    /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
    public let adminRoleArn: String?
    /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
    public var clientToken: String?
    /// <p>A friendly name for the studio.</p>
    public let displayName: String?
    /// <p>The studio ID.</p>
    public let studioId: String?
    /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
    public let userRoleArn: String?

    public init (
        adminRoleArn: String? = nil,
        clientToken: String? = nil,
        displayName: String? = nil,
        studioId: String? = nil,
        userRoleArn: String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioId = studioId
        self.userRoleArn = userRoleArn
    }
}

struct UpdateStudioInputBody: Equatable {
    public let adminRoleArn: String?
    public let displayName: String?
    public let userRoleArn: String?
}

extension UpdateStudioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case userRoleArn = "userRoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension UpdateStudioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStudioOutputResponse(studio: \(String(describing: studio)))"}
}

extension UpdateStudioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct UpdateStudioOutputResponse: Equatable {
    /// <p>Information about a studio.</p>
    public let studio: Studio?

    public init (
        studio: Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct UpdateStudioOutputResponseBody: Equatable {
    public let studio: Studio?
}

extension UpdateStudioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(code: \(String(describing: code)), context: \(String(describing: context)), message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A more specific error code.</p>
    public var code: String?
    /// <p>The exception context.</p>
    public var context: [String:String]?
    /// <p>A human-readable description of the error.</p>
    public var message: String?

    public init (
        code: String? = nil,
        context: [String:String]? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let code: String?
    public let context: [String:String]?
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
