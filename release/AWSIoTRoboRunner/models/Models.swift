// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.CartesianCoordinates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case x
        case y
        case z
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let x = self.x {
            try encodeContainer.encode(x, forKey: .x)
        }
        if let y = self.y {
            try encodeContainer.encode(y, forKey: .y)
        }
        if let z = self.z {
            try encodeContainer.encode(z, forKey: .z)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .x)
        x = xDecoded
        let yDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .y)
        y = yDecoded
        let zDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .z)
        z = zDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Cartesian coordinates in 3D space relative to the RoboRunner origin.
    public struct CartesianCoordinates: Swift.Equatable {
        /// X coordinate.
        /// This member is required.
        public var x: Swift.Double?
        /// Y coordinate.
        /// This member is required.
        public var y: Swift.Double?
        /// Z coordinate.
        public var z: Swift.Double?

        public init (
            x: Swift.Double? = nil,
            y: Swift.Double? = nil,
            z: Swift.Double? = nil
        )
        {
            self.x = x
            self.y = y
            self.z = z
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if a resource in a create request already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension CreateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createDestination"
    }
}

public struct CreateDestinationInput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// The state of the destination. Default used if not specified.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.clientToken = clientToken
        self.name = name
        self.site = site
        self.state = state
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension CreateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDestinationOutputResponse: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct CreateDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
}

extension CreateDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case state
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case countryCode
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSite"
    }
}

public struct CreateSiteInput: Swift.Equatable {
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    /// This member is required.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.countryCode = countryCode
        self.description = description
        self.name = name
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case countryCode
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateSiteOutputResponse: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateSiteOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension CreateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension CreateWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
    }
}

extension CreateWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorkerFleet"
    }
}

public struct CreateWorkerFleetInput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.clientToken = clientToken
        self.name = name
        self.site = site
    }
}

struct CreateWorkerFleetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let additionalFixedProperties: Swift.String?
}

extension CreateWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension CreateWorkerFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkerFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkerFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkerFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkerFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateWorkerFleetOutputResponse: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateWorkerFleetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension CreateWorkerFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension CreateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case clientToken
        case fleet
        case name
        case orientation
        case position
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }
}

extension CreateWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorker"
    }
}

public struct CreateWorkerInput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        fleet: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.clientToken = clientToken
        self.fleet = fleet
        self.name = name
        self.orientation = orientation
        self.position = position
        self.vendorProperties = vendorProperties
    }
}

struct CreateWorkerInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let fleet: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension CreateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case clientToken
        case fleet
        case name
        case orientation
        case position
        case vendorProperties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension CreateWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.site = output.site
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.site = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateWorkerOutputResponse: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.site = site
        self.updatedAt = updatedAt
    }
}

struct CreateWorkerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let site: Swift.String?
}

extension CreateWorkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case site
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeleteDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteDestination"
    }
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSite"
    }
}

public struct DeleteSiteInput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorkerFleet"
    }
}

public struct DeleteWorkerFleetInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkerFleetInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteWorkerFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkerFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkerFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkerFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkerFleetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorker"
    }
}

public struct DeleteWorkerInput: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkerInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkerOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTRoboRunnerClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case state
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Area within a facility where work can be performed.
    public struct Destination: Swift.Equatable {
        /// JSON document containing additional fixed properties regarding the destination
        public var additionalFixedProperties: Swift.String?
        /// Destination ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Filters access by the destination's identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// State of the destination.
        /// This member is required.
        public var state: IoTRoboRunnerClientTypes.DestinationState?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            additionalFixedProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            site: Swift.String? = nil,
            state: IoTRoboRunnerClientTypes.DestinationState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.site = site
            self.state = state
            self.updatedAt = updatedAt
        }
    }

}

extension IoTRoboRunnerClientTypes {
    /// State of the destination.
    public enum DestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decommissioned
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationState] {
            return [
                .decommissioned,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decommissioned: return "DECOMMISSIONED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationState(rawValue: rawValue) ?? DestinationState.sdkUnknown(rawValue)
        }
    }
}

extension GetDestinationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDestination"
    }
}

public struct GetDestinationInput: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.name = output.name
            self.site = output.site
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.name = nil
            self.site = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDestinationOutputResponse: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.site = site
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct GetDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension GetDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case state
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension GetSiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getSite"
    }
}

public struct GetSiteInput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSiteInputBody: Swift.Equatable {
}

extension GetSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.countryCode = output.countryCode
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.countryCode = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct GetSiteOutputResponse: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    /// This member is required.
    public var countryCode: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.countryCode = countryCode
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct GetSiteOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case createdAt
        case description
        case id
        case name
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetWorkerFleetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorkerFleet"
    }
}

public struct GetWorkerFleetInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkerFleetInputBody: Swift.Equatable {
}

extension GetWorkerFleetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkerFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkerFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkerFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkerFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkerFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.name = output.name
            self.site = output.site
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.name = nil
            self.site = nil
            self.updatedAt = nil
        }
    }
}

public struct GetWorkerFleetOutputResponse: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.site = site
        self.updatedAt = updatedAt
    }
}

struct GetWorkerFleetOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let additionalFixedProperties: Swift.String?
}

extension GetWorkerFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension GetWorkerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorker"
    }
}

public struct GetWorkerInput: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkerInputBody: Swift.Equatable {
}

extension GetWorkerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.additionalTransientProperties = output.additionalTransientProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleet = output.fleet
            self.id = output.id
            self.name = output.name
            self.orientation = output.orientation
            self.position = output.position
            self.site = output.site
            self.updatedAt = output.updatedAt
            self.vendorProperties = output.vendorProperties
        } else {
            self.additionalFixedProperties = nil
            self.additionalTransientProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.fleet = nil
            self.id = nil
            self.name = nil
            self.orientation = nil
            self.position = nil
            self.site = nil
            self.updatedAt = nil
            self.vendorProperties = nil
        }
    }
}

public struct GetWorkerOutputResponse: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        fleet: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.arn = arn
        self.createdAt = createdAt
        self.fleet = fleet
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.site = site
        self.updatedAt = updatedAt
        self.vendorProperties = vendorProperties
    }
}

struct GetWorkerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let fleet: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension GetWorkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case createdAt
        case fleet
        case id
        case name
        case orientation
        case position
        case site
        case updatedAt
        case vendorProperties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if something goes wrong within the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            return items
        }
    }
}

extension ListDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDestinations"
    }
}

public struct ListDestinationsInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// State of the destination.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
        self.state = state
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDestinationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutputResponse: Swift.Equatable {
    /// List of destinations.
    public var destinations: [IoTRoboRunnerClientTypes.Destination]?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?

    public init (
        destinations: [IoTRoboRunnerClientTypes.Destination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinations: [IoTRoboRunnerClientTypes.Destination]?
}

extension ListDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[IoTRoboRunnerClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [IoTRoboRunnerClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension ListSitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSites"
    }
}

public struct ListSitesInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single ListSites call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSitesInputBody: Swift.Equatable {
}

extension ListSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct ListSitesOutputResponse: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of facilities.
    public var sites: [IoTRoboRunnerClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [IoTRoboRunnerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct ListSitesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sites: [IoTRoboRunnerClientTypes.Site]?
}

extension ListSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sitesContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[IoTRoboRunnerClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [IoTRoboRunnerClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
    }
}

extension ListWorkerFleetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListWorkerFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkerFleets"
    }
}

public struct ListWorkerFleetsInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single ListWorkerFleets call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
    }
}

struct ListWorkerFleetsInputBody: Swift.Equatable {
}

extension ListWorkerFleetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkerFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkerFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkerFleetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkerFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkerFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workerFleets = output.workerFleets
        } else {
            self.nextToken = nil
            self.workerFleets = nil
        }
    }
}

public struct ListWorkerFleetsOutputResponse: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of worker fleets.
    public var workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]?

    public init (
        nextToken: Swift.String? = nil,
        workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]? = nil
    )
    {
        self.nextToken = nextToken
        self.workerFleets = workerFleets
    }
}

struct ListWorkerFleetsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]?
}

extension ListWorkerFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workerFleets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workerFleetsContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.WorkerFleet?].self, forKey: .workerFleets)
        var workerFleetsDecoded0:[IoTRoboRunnerClientTypes.WorkerFleet]? = nil
        if let workerFleetsContainer = workerFleetsContainer {
            workerFleetsDecoded0 = [IoTRoboRunnerClientTypes.WorkerFleet]()
            for structure0 in workerFleetsContainer {
                if let structure0 = structure0 {
                    workerFleetsDecoded0?.append(structure0)
                }
            }
        }
        workerFleets = workerFleetsDecoded0
    }
}

extension ListWorkersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fleet = fleet {
                let fleetQueryItem = ClientRuntime.URLQueryItem(name: "fleet".urlPercentEncoding(), value: Swift.String(fleet).urlPercentEncoding())
                items.append(fleetQueryItem)
            }
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListWorkersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkers"
    }
}

public struct ListWorkersInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    public var fleet: Swift.String?
    /// Maximum number of results to retrieve in a single ListWorkers call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init (
        fleet: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
    }
}

struct ListWorkersInputBody: Swift.Equatable {
}

extension ListWorkersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workers = output.workers
        } else {
            self.nextToken = nil
            self.workers = nil
        }
    }
}

public struct ListWorkersOutputResponse: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of workers.
    public var workers: [IoTRoboRunnerClientTypes.Worker]?

    public init (
        nextToken: Swift.String? = nil,
        workers: [IoTRoboRunnerClientTypes.Worker]? = nil
    )
    {
        self.nextToken = nextToken
        self.workers = workers
    }
}

struct ListWorkersOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workers: [IoTRoboRunnerClientTypes.Worker]?
}

extension ListWorkersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workersContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Worker?].self, forKey: .workers)
        var workersDecoded0:[IoTRoboRunnerClientTypes.Worker]? = nil
        if let workersContainer = workersContainer {
            workersDecoded0 = [IoTRoboRunnerClientTypes.Worker]()
            for structure0 in workersContainer {
                if let structure0 = structure0 {
                    workersDecoded0?.append(structure0)
                }
            }
        }
        workers = workersDecoded0
    }
}

extension IoTRoboRunnerClientTypes.Orientation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case degrees
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .degrees(degrees):
                try container.encode(degrees, forKey: .degrees)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let degreesDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .degrees)
        if let degrees = degreesDecoded {
            self = .degrees(degrees)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTRoboRunnerClientTypes {
    /// Worker orientation measured in units clockwise from north.
    public enum Orientation: Swift.Equatable {
        /// Degrees, limited on [0, 360)
        case degrees(Swift.Double)
        case sdkUnknown(Swift.String)
    }

}

extension IoTRoboRunnerClientTypes.PositionCoordinates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cartesiancoordinates = "cartesianCoordinates"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cartesiancoordinates(cartesiancoordinates):
                try container.encode(cartesiancoordinates, forKey: .cartesiancoordinates)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cartesiancoordinatesDecoded = try values.decodeIfPresent(IoTRoboRunnerClientTypes.CartesianCoordinates.self, forKey: .cartesiancoordinates)
        if let cartesiancoordinates = cartesiancoordinatesDecoded {
            self = .cartesiancoordinates(cartesiancoordinates)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTRoboRunnerClientTypes {
    /// Supported coordinates for worker position.
    public enum PositionCoordinates: Swift.Equatable {
        /// Cartesian coordinates.
        case cartesiancoordinates(IoTRoboRunnerClientTypes.CartesianCoordinates)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if a resource referenced in the request doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if the user's AWS account has reached a service limit and the operation cannot proceed.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.Site: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case createdAt
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Facility containing destinations, workers, activities, and tasks.
    public struct Site: Swift.Equatable {
        /// Site ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
        /// This member is required.
        public var countryCode: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the site. Mutable after creation and unique within a given account.
        /// This member is required.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.countryCode = countryCode
            self.createdAt = createdAt
            self.name = name
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if the api has been called too quickly be the client.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDestination"
    }
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?
    /// State of the destination.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.id = id
        self.name = name
        self.state = state
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDestinationOutputResponse: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.id = id
        self.name = name
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct UpdateDestinationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension UpdateDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case id
        case name
        case state
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSite"
    }
}

public struct UpdateSiteInput: Swift.Equatable {
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?

    public init (
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.countryCode = countryCode
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode
        case description
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.countryCode = output.countryCode
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.countryCode = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.countryCode = countryCode
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct UpdateSiteOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateSiteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case description
        case id
        case name
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension UpdateWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorkerFleet"
    }
}

public struct UpdateWorkerFleetInput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.id = id
        self.name = name
    }
}

struct UpdateWorkerFleetInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let additionalFixedProperties: Swift.String?
}

extension UpdateWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateWorkerFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkerFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkerFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkerFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkerFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateWorkerFleetOutputResponse: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct UpdateWorkerFleetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let additionalFixedProperties: Swift.String?
}

extension UpdateWorkerFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case id
        case name
        case updatedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case id
        case name
        case orientation
        case position
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }
}

extension UpdateWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorker"
    }
}

public struct UpdateWorkerInput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.vendorProperties = vendorProperties
    }
}

struct UpdateWorkerInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension UpdateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case id
        case name
        case orientation
        case position
        case vendorProperties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension UpdateWorkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.additionalTransientProperties = output.additionalTransientProperties
            self.arn = output.arn
            self.fleet = output.fleet
            self.id = output.id
            self.name = output.name
            self.orientation = output.orientation
            self.position = output.position
            self.updatedAt = output.updatedAt
            self.vendorProperties = output.vendorProperties
        } else {
            self.additionalFixedProperties = nil
            self.additionalTransientProperties = nil
            self.arn = nil
            self.fleet = nil
            self.id = nil
            self.name = nil
            self.orientation = nil
            self.position = nil
            self.updatedAt = nil
            self.vendorProperties = nil
        }
    }
}

public struct UpdateWorkerOutputResponse: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init (
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        fleet: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.arn = arn
        self.fleet = fleet
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.updatedAt = updatedAt
        self.vendorProperties = vendorProperties
    }
}

struct UpdateWorkerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let fleet: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
}

extension UpdateWorkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case fleet
        case id
        case name
        case orientation
        case position
        case updatedAt
        case vendorProperties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown if an invalid parameter is provided to an API.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.VendorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vendorAdditionalFixedProperties
        case vendorAdditionalTransientProperties
        case vendorWorkerId
        case vendorWorkerIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vendorAdditionalFixedProperties = self.vendorAdditionalFixedProperties {
            try encodeContainer.encode(vendorAdditionalFixedProperties, forKey: .vendorAdditionalFixedProperties)
        }
        if let vendorAdditionalTransientProperties = self.vendorAdditionalTransientProperties {
            try encodeContainer.encode(vendorAdditionalTransientProperties, forKey: .vendorAdditionalTransientProperties)
        }
        if let vendorWorkerId = self.vendorWorkerId {
            try encodeContainer.encode(vendorWorkerId, forKey: .vendorWorkerId)
        }
        if let vendorWorkerIpAddress = self.vendorWorkerIpAddress {
            try encodeContainer.encode(vendorWorkerIpAddress, forKey: .vendorWorkerIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorWorkerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorWorkerId)
        vendorWorkerId = vendorWorkerIdDecoded
        let vendorWorkerIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorWorkerIpAddress)
        vendorWorkerIpAddress = vendorWorkerIpAddressDecoded
        let vendorAdditionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorAdditionalTransientProperties)
        vendorAdditionalTransientProperties = vendorAdditionalTransientPropertiesDecoded
        let vendorAdditionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorAdditionalFixedProperties)
        vendorAdditionalFixedProperties = vendorAdditionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Properties of the worker that are provided by the vendor FMS.
    public struct VendorProperties: Swift.Equatable {
        /// JSON blob containing unstructured vendor properties that are fixed and won't change during regular operation.
        public var vendorAdditionalFixedProperties: Swift.String?
        /// JSON blob containing unstructured vendor properties that are transient and may change during regular operation.
        public var vendorAdditionalTransientProperties: Swift.String?
        /// The worker ID defined by the vendor FMS.
        /// This member is required.
        public var vendorWorkerId: Swift.String?
        /// The worker IP address defined by the vendor FMS.
        public var vendorWorkerIpAddress: Swift.String?

        public init (
            vendorAdditionalFixedProperties: Swift.String? = nil,
            vendorAdditionalTransientProperties: Swift.String? = nil,
            vendorWorkerId: Swift.String? = nil,
            vendorWorkerIpAddress: Swift.String? = nil
        )
        {
            self.vendorAdditionalFixedProperties = vendorAdditionalFixedProperties
            self.vendorAdditionalTransientProperties = vendorAdditionalTransientProperties
            self.vendorWorkerId = vendorWorkerId
            self.vendorWorkerIpAddress = vendorWorkerIpAddress
        }
    }

}

extension IoTRoboRunnerClientTypes.Worker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case createdAt
        case fleet
        case id
        case name
        case orientation
        case position
        case site
        case updatedAt
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// A unit capable of performing tasks.
    public struct Worker: Swift.Equatable {
        /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
        public var additionalFixedProperties: Swift.String?
        /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
        public var additionalTransientProperties: Swift.String?
        /// Full ARN of the worker.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Full ARN of the worker fleet.
        /// This member is required.
        public var fleet: Swift.String?
        /// Filters access by the workers identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Worker orientation measured in units clockwise from north.
        public var orientation: IoTRoboRunnerClientTypes.Orientation?
        /// Supported coordinates for worker position.
        public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Properties of the worker that are provided by the vendor FMS.
        public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

        public init (
            additionalFixedProperties: Swift.String? = nil,
            additionalTransientProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            fleet: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
            position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
            site: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.additionalTransientProperties = additionalTransientProperties
            self.arn = arn
            self.createdAt = createdAt
            self.fleet = fleet
            self.id = id
            self.name = name
            self.orientation = orientation
            self.position = position
            self.site = site
            self.updatedAt = updatedAt
            self.vendorProperties = vendorProperties
        }
    }

}

extension IoTRoboRunnerClientTypes.WorkerFleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// A collection of workers organized within a facility.
    public struct WorkerFleet: Swift.Equatable {
        /// JSON blob containing additional fixed properties regarding the worker fleet
        public var additionalFixedProperties: Swift.String?
        /// Full ARN of the worker fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Filters access by the worker fleet's identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            additionalFixedProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            site: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.site = site
            self.updatedAt = updatedAt
        }
    }

}
