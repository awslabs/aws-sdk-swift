// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct ActivateGatewayInputBodyMiddleware: Middleware {
    public let id: String = "ActivateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateGatewayOutputError>
}

extension ActivateGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateGatewayInput(activationKey: \(String(describing: activationKey)), gatewayName: \(String(describing: gatewayName)), gatewayRegion: \(String(describing: gatewayRegion)), gatewayTimezone: \(String(describing: gatewayTimezone)), gatewayType: \(String(describing: gatewayType)), mediumChangerType: \(String(describing: mediumChangerType)), tags: \(String(describing: tags)), tapeDriveType: \(String(describing: tapeDriveType)))"}
}

extension ActivateGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationKey = activationKey {
            try encodeContainer.encode(activationKey, forKey: .activationKey)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayRegion = gatewayRegion {
            try encodeContainer.encode(gatewayRegion, forKey: .gatewayRegion)
        }
        if let gatewayTimezone = gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
        if let gatewayType = gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
        if let mediumChangerType = mediumChangerType {
            try encodeContainer.encode(mediumChangerType, forKey: .mediumChangerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeDriveType = tapeDriveType {
            try encodeContainer.encode(tapeDriveType, forKey: .tapeDriveType)
        }
    }
}

public struct ActivateGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "ActivateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateGatewayOutputError>
}

public struct ActivateGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateGatewayInput>
    public typealias MOutput = OperationOutput<ActivateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateGatewayOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$ActivationKey</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$GatewayName</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$GatewayRegion</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$GatewayTimezone</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$GatewayType</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$MediumChangerType</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ActivateGatewayInput$TapeDriveType</a>
///                </p>
///             </li>
///          </ul>
public struct ActivateGatewayInput: Equatable {
    /// <p>Your gateway activation key. You can obtain the activation key by sending an HTTP GET
    ///          request with redirects enabled to the gateway IP address (port 80). The redirect URL
    ///          returned in the response provides you the activation key for your gateway in the query
    ///          string parameter <code>activationKey</code>. It may also include other activation-related
    ///          parameters, however, these are merely defaults -- the arguments you pass to the
    ///             <code>ActivateGateway</code> API call determine the actual configuration of your
    ///          gateway.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/get-activation-key.html">Getting activation
    ///             key</a> in the <i>AWS Storage Gateway User Guide</i>.</p>
    public let activationKey: String?
    /// <p>The name you configured for your gateway.</p>
    public let gatewayName: String?
    /// <p>A value that indicates the AWS Region where you want to store your data. The gateway AWS
    ///          Region specified must be the same AWS Region as the AWS Region in your <code>Host</code>
    ///          header in the request. For more information about available AWS Regions and endpoints for
    ///          AWS Storage Gateway, see <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">AWS
    ///             Storage Gateway endpoints and quotas</a> in the <i>AWS General
    ///             Reference</i>.</p>
    ///
    ///          <p>Valid Values: See <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">AWS
    ///             Storage Gateway endpoints and quotas</a> in the <i>AWS General
    ///             Reference</i>.
    ///
    ///       </p>
    public let gatewayRegion: String?
    /// <p>A value that indicates the time zone you want to set for the gateway. The time zone is
    ///          of the format "GMT-hr:mm" or "GMT+hr:mm". For example, GMT-4:00 indicates the time is 4
    ///          hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is
    ///          used, for example, for scheduling snapshots and your gateway's maintenance
    ///          schedule.</p>
    public let gatewayTimezone: String?
    /// <p>A value that defines the type of gateway to activate. The type specified is critical to
    ///          all later functions of the gateway and cannot be changed after activation. The default
    ///          value is <code>CACHED</code>.</p>
    ///
    ///          <p>Valid Values: <code>STORED</code> | <code>CACHED</code> | <code>VTL</code> |
    ///             <code>FILE_S3</code>
    ///          </p>
    public let gatewayType: String?
    /// <p>The value that indicates the type of medium changer to use for tape gateway. This field
    ///          is optional.</p>
    ///
    ///          <p>Valid Values: <code>STK-L700</code> | <code>AWS-Gateway-VTL</code> |
    ///             <code>IBM-03584L32-0402</code>
    ///          </p>
    public let mediumChangerType: String?
    /// <p>A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers that can be
    ///             represented in UTF-8 format, and the following special characters: + - = . _ : / @. The
    ///             maximum length of a tag's key is 128 characters, and the maximum length for a
    ///             tag's value is 256 characters.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The value that indicates the type of tape drive to use for tape gateway. This field is
    ///          optional.</p>
    ///
    ///          <p>Valid Values: <code>IBM-ULT3580-TD5</code>
    ///          </p>
    public let tapeDriveType: String?

    public init (
        activationKey: String? = nil,
        gatewayName: String? = nil,
        gatewayRegion: String? = nil,
        gatewayTimezone: String? = nil,
        gatewayType: String? = nil,
        mediumChangerType: String? = nil,
        tags: [Tag]? = nil,
        tapeDriveType: String? = nil
    )
    {
        self.activationKey = activationKey
        self.gatewayName = gatewayName
        self.gatewayRegion = gatewayRegion
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.mediumChangerType = mediumChangerType
        self.tags = tags
        self.tapeDriveType = tapeDriveType
    }
}

struct ActivateGatewayInputBody: Equatable {
    public let activationKey: String?
    public let gatewayName: String?
    public let gatewayTimezone: String?
    public let gatewayRegion: String?
    public let gatewayType: String?
    public let tapeDriveType: String?
    public let mediumChangerType: String?
    public let tags: [Tag]?
}

extension ActivateGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationKey = "ActivationKey"
        case gatewayName = "GatewayName"
        case gatewayRegion = "GatewayRegion"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case mediumChangerType = "MediumChangerType"
        case tags = "Tags"
        case tapeDriveType = "TapeDriveType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationKey)
        activationKey = activationKeyDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayRegion)
        gatewayRegion = gatewayRegionDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let tapeDriveTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeDriveType)
        tapeDriveType = tapeDriveTypeDecoded
        let mediumChangerTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediumChangerType)
        mediumChangerType = mediumChangerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ActivateGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateGatewayOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateGatewayOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ActivateGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActivateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>AWS Storage Gateway returns the Amazon Resource Name (ARN) of the activated gateway. It
///          is a string made of information such as your account, gateway name, and AWS Region. This
///          ARN is used to reference the gateway in other API operations as well as resource-based
///          authorization.</p>
///
///          <note>
///             <p>For gateways activated prior to September 02, 2015, the gateway ARN contains the
///             gateway name rather than the gateway ID. Changing the name of the gateway has no effect
///             on the gateway ARN.</p>
///          </note>
public struct ActivateGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ActivateGatewayOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension ActivateGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public enum ActiveDirectoryStatus {
    case accessDenied
    case detached
    case joined
    case joining
    case networkError
    case timeout
    case unknownError
    case sdkUnknown(String)
}

extension ActiveDirectoryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActiveDirectoryStatus] {
        return [
            .accessDenied,
            .detached,
            .joined,
            .joining,
            .networkError,
            .timeout,
            .unknownError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .detached: return "DETACHED"
        case .joined: return "JOINED"
        case .joining: return "JOINING"
        case .networkError: return "NETWORK_ERROR"
        case .timeout: return "TIMEOUT"
        case .unknownError: return "UNKNOWN_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActiveDirectoryStatus(rawValue: rawValue) ?? ActiveDirectoryStatus.sdkUnknown(rawValue)
    }
}

public struct AddCacheInputBodyMiddleware: Middleware {
    public let id: String = "AddCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCacheInput>
    public typealias MOutput = OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCacheOutputError>
}

extension AddCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCacheInput(diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddCacheInputHeadersMiddleware: Middleware {
    public let id: String = "AddCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCacheInput>
    public typealias MOutput = OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCacheOutputError>
}

public struct AddCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "AddCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCacheInput>
    public typealias MOutput = OperationOutput<AddCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCacheOutputError>
}

public struct AddCacheInput: Equatable {
    /// <p>An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the <a>ListLocalDisks</a> API.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        diskIds: [String]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheInputBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
}

extension AddCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCacheOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCacheOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddCacheOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddCacheOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension AddCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

/// <p>AddTagsToResourceInput</p>
public struct AddTagsToResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
    public let resourceARN: String?
    /// <p>The key-value pair that represents the tag you want to add to the resource. The value
    ///          can be an empty string.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension AddTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse(resourceARN: \(String(describing: resourceARN)))"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// <p>AddTagsToResourceOutput</p>
public struct AddTagsToResourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct AddTagsToResourceOutputResponseBody: Equatable {
    public let resourceARN: String?
}

extension AddTagsToResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

public struct AddUploadBufferInputBodyMiddleware: Middleware {
    public let id: String = "AddUploadBufferInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUploadBufferOutputError>
}

extension AddUploadBufferInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddUploadBufferInput(diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddUploadBufferInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddUploadBufferInputHeadersMiddleware: Middleware {
    public let id: String = "AddUploadBufferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUploadBufferOutputError>
}

public struct AddUploadBufferInputQueryItemMiddleware: Middleware {
    public let id: String = "AddUploadBufferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<AddUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddUploadBufferInput>
    public typealias MOutput = OperationOutput<AddUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddUploadBufferOutputError>
}

public struct AddUploadBufferInput: Equatable {
    /// <p>An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the <a>ListLocalDisks</a> API.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        diskIds: [String]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferInputBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
}

extension AddUploadBufferInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddUploadBufferOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddUploadBufferOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddUploadBufferOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddUploadBufferOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddUploadBufferOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddUploadBufferOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct AddUploadBufferOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddUploadBufferOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension AddUploadBufferOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AddWorkingStorageInputBodyMiddleware: Middleware {
    public let id: String = "AddWorkingStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddWorkingStorageOutputError>
}

extension AddWorkingStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddWorkingStorageInput(diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddWorkingStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskIds = diskIds {
            var diskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskIds)
            for diskids0 in diskIds {
                try diskIdsContainer.encode(diskids0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct AddWorkingStorageInputHeadersMiddleware: Middleware {
    public let id: String = "AddWorkingStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddWorkingStorageOutputError>
}

public struct AddWorkingStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "AddWorkingStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<AddWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddWorkingStorageInput>
    public typealias MOutput = OperationOutput<AddWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddWorkingStorageOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>AddWorkingStorageInput$DiskIds</a>
///                </p>
///             </li>
///          </ul>
public struct AddWorkingStorageInput: Equatable {
    /// <p>An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the <a>ListLocalDisks</a> API.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        diskIds: [String]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageInputBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
}

extension AddWorkingStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
    }
}

extension AddWorkingStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddWorkingStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddWorkingStorageOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddWorkingStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddWorkingStorageOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension AddWorkingStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway for which working
///          storage was configured.</p>
public struct AddWorkingStorageOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct AddWorkingStorageOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension AddWorkingStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct AssignTapePoolInputBodyMiddleware: Middleware {
    public let id: String = "AssignTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignTapePoolOutputError>
}

extension AssignTapePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignTapePoolInput(bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), poolId: \(String(describing: poolId)), tapeARN: \(String(describing: tapeARN)))"}
}

extension AssignTapePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct AssignTapePoolInputHeadersMiddleware: Middleware {
    public let id: String = "AssignTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignTapePoolOutputError>
}

public struct AssignTapePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "AssignTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignTapePoolInput>
    public typealias MOutput = OperationOutput<AssignTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignTapePoolOutputError>
}

public struct AssignTapePoolInput: Equatable {
    /// <p>Set permissions to bypass governance retention. If the lock type of the archived tape is
    ///             <code>Governance</code>, the tape's archived age is not older than
    ///             <code>RetentionLockInDays</code>, and the user does not already have
    ///             <code>BypassGovernanceRetention</code>, setting this to TRUE enables the user to bypass
    ///          the retention lock. This parameter is set to true by default for calls from the
    ///          console.</p>
    ///
    ///          <p>Valid values: <code>TRUE</code> | <code>FALSE</code>
    ///          </p>
    public let bypassGovernanceRetention: Bool
    /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the
    ///          tape pool.</p>
    public let tapeARN: String?

    public init (
        bypassGovernanceRetention: Bool = false,
        poolId: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.poolId = poolId
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolInputBody: Equatable {
    public let tapeARN: String?
    public let poolId: String?
    public let bypassGovernanceRetention: Bool
}

extension AssignTapePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case poolId = "PoolId"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension AssignTapePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignTapePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignTapePoolOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignTapePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignTapePoolOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension AssignTapePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssignTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

public struct AssignTapePoolOutputResponse: Equatable {
    /// <p>The unique Amazon Resource Names (ARN) of the virtual tape that was added to the tape
    ///          pool.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct AssignTapePoolOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension AssignTapePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct AssociateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "AssociateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemOutputError>
}

extension AssociateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFileSystemInput(auditDestinationARN: \(String(describing: auditDestinationARN)), cacheAttributes: \(String(describing: cacheAttributes)), clientToken: \(String(describing: clientToken)), gatewayARN: \(String(describing: gatewayARN)), locationARN: \(String(describing: locationARN)), password: \(String(describing: password)), tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}

extension AssociateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct AssociateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemOutputError>
}

public struct AssociateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFileSystemInput>
    public typealias MOutput = OperationOutput<AssociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFileSystemOutputError>
}

public struct AssociateFileSystemInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the storage used for the audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>The refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>A unique string value that you supply that is used by the file gateway to ensure
    ///          idempotent file system association creation.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the
    ///          Amazon FSx file gateway.</p>
    public let locationARN: String?
    /// <p>The password of the user credential.</p>
    public let password: String?
    /// <p>A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.</p>
    public let tags: [Tag]?
    /// <p>The user name of the user credential that has permission to access the root share D$ of
    ///          the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
    ///          user group.</p>
    public let userName: String?

    public init (
        auditDestinationARN: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        clientToken: String? = nil,
        gatewayARN: String? = nil,
        locationARN: String? = nil,
        password: String? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.locationARN = locationARN
        self.password = password
        self.tags = tags
        self.userName = userName
    }
}

struct AssociateFileSystemInputBody: Equatable {
    public let userName: String?
    public let password: String?
    public let clientToken: String?
    public let gatewayARN: String?
    public let locationARN: String?
    public let tags: [Tag]?
    public let auditDestinationARN: String?
    public let cacheAttributes: CacheAttributes?
}

extension AssociateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case password = "Password"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
    }
}

extension AssociateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFileSystemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFileSystemOutputResponse(fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)))"}
}

extension AssociateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct AssociateFileSystemOutputResponse: Equatable {
    /// <p>The ARN of the newly created file system association.</p>
    public let fileSystemAssociationARN: String?

    public init (
        fileSystemAssociationARN: String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct AssociateFileSystemOutputResponseBody: Equatable {
    public let fileSystemAssociationARN: String?
}

extension AssociateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

public struct AttachVolumeInputBodyMiddleware: Middleware {
    public let id: String = "AttachVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachVolumeOutputError>
}

extension AttachVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachVolumeInput(diskId: \(String(describing: diskId)), gatewayARN: \(String(describing: gatewayARN)), networkInterfaceId: \(String(describing: networkInterfaceId)), targetName: \(String(describing: targetName)), volumeARN: \(String(describing: volumeARN)))"}
}

extension AttachVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct AttachVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "AttachVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachVolumeOutputError>
}

public struct AttachVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachVolumeInput>
    public typealias MOutput = OperationOutput<AttachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachVolumeOutputError>
}

/// <p>AttachVolumeInput</p>
public struct AttachVolumeInput: Equatable {
    /// <p>The unique device ID or other distinguishing data that identifies the local disk used to
    ///          create the volume. This value is only required when you are attaching a stored
    ///          volume.</p>
    public let diskId: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway that you want to attach the volume
    ///          to.</p>
    public let gatewayARN: String?
    /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
    ///          the network interfaces available on a gateway.</p>
    ///
    ///          <p>Valid Values: A valid IP address.</p>
    public let networkInterfaceId: String?
    /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying <code>TargetName</code> as
    ///             <i>myvolume</i> results in the target ARN of
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
    ///          The target name must be unique across all volumes on a gateway.</p>
    ///
    ///          <p>If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.</p>
    public let targetName: String?
    /// <p>The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.</p>
    public let volumeARN: String?

    public init (
        diskId: String? = nil,
        gatewayARN: String? = nil,
        networkInterfaceId: String? = nil,
        targetName: String? = nil,
        volumeARN: String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.networkInterfaceId = networkInterfaceId
        self.targetName = targetName
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeInputBody: Equatable {
    public let gatewayARN: String?
    public let targetName: String?
    public let volumeARN: String?
    public let networkInterfaceId: String?
    public let diskId: String?
}

extension AttachVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case networkInterfaceId = "NetworkInterfaceId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskId)
        diskId = diskIdDecoded
    }
}

extension AttachVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachVolumeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachVolumeOutputResponse(targetARN: \(String(describing: targetARN)), volumeARN: \(String(describing: volumeARN)))"}
}

extension AttachVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AttachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

/// <p>AttachVolumeOutput</p>
public struct AttachVolumeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name for
    ///          the initiator that was used to connect to the target.</p>
    public let targetARN: String?
    /// <p>The Amazon Resource Name (ARN) of the volume that was attached to the gateway.</p>
    public let volumeARN: String?

    public init (
        targetARN: String? = nil,
        volumeARN: String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct AttachVolumeOutputResponseBody: Equatable {
    public let volumeARN: String?
    public let targetARN: String?
}

extension AttachVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension AutomaticTapeCreationPolicyInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrules0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrules0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension AutomaticTapeCreationPolicyInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomaticTapeCreationPolicyInfo(automaticTapeCreationRules: \(String(describing: automaticTapeCreationRules)), gatewayARN: \(String(describing: gatewayARN)))"}
}

/// <p>Information about the gateway's automatic tape creation policies, including the
///          automatic tape creation rules and the gateway that is using the policies.</p>
public struct AutomaticTapeCreationPolicyInfo: Equatable {
    /// <p>An automatic tape creation policy consists of a list of automatic tape creation rules.
    ///          This returns the rules that determine when and how to automatically create new
    ///          tapes.</p>
    public let automaticTapeCreationRules: [AutomaticTapeCreationRule]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        automaticTapeCreationRules: [AutomaticTapeCreationRule]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.automaticTapeCreationRules = automaticTapeCreationRules
        self.gatewayARN = gatewayARN
    }
}

extension AutomaticTapeCreationRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case minimumNumTapes = "MinimumNumTapes"
        case poolId = "PoolId"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minimumNumTapes = minimumNumTapes {
            try encodeContainer.encode(minimumNumTapes, forKey: .minimumNumTapes)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tapeBarcodePrefix = tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let minimumNumTapesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumNumTapes)
        minimumNumTapes = minimumNumTapesDecoded
        let wormDecoded = try containerValues.decode(Bool.self, forKey: .worm)
        worm = wormDecoded
    }
}

extension AutomaticTapeCreationRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomaticTapeCreationRule(minimumNumTapes: \(String(describing: minimumNumTapes)), poolId: \(String(describing: poolId)), tapeBarcodePrefix: \(String(describing: tapeBarcodePrefix)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), worm: \(String(describing: worm)))"}
}

/// <p>An automatic tape creation policy consists of automatic tape creation rules where each
///          rule defines when and how to create new tapes. For more information about automatic tape
///          creation, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically">Creating Tapes Automatically</a>.</p>
public struct AutomaticTapeCreationRule: Equatable {
    /// <p>The minimum number of available virtual tapes that the gateway maintains at all times.
    ///          If the number of tapes on the gateway goes below this value, the gateway creates as many
    ///          new tapes as are needed to have <code>MinimumNumTapes</code> on the gateway. For more
    ///          information about automatic tape creation, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/GettingStartedCreateTapes.html#CreateTapesAutomatically">Creating Tapes Automatically</a>.</p>
    public let minimumNumTapes: Int?
    /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the Amazon S3 storage class that is associated with the pool. When you
    ///          use your backup application to eject the tape, the tape is archived directly into the
    ///          storage class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>A prefix that you append to the barcode of the virtual tape that you are creating. This
    ///          prefix makes the barcode unique.</p>
    ///
    ///          <note>
    ///             <p>The prefix must be 1-4 characters in length and must be one of the uppercase letters
    ///             from A to Z.</p>
    ///          </note>
    public let tapeBarcodePrefix: String?
    /// <p>The size, in bytes, of the virtual tape capacity.</p>
    public let tapeSizeInBytes: Int?
    /// <p>Set to <code>true</code> to indicate that tapes are to be archived as
    ///          write-once-read-many (WORM). Set to <code>false</code> when WORM is not enabled for
    ///          tapes.</p>
    public let worm: Bool

    public init (
        minimumNumTapes: Int? = nil,
        poolId: String? = nil,
        tapeBarcodePrefix: String? = nil,
        tapeSizeInBytes: Int? = nil,
        worm: Bool = false
    )
    {
        self.minimumNumTapes = minimumNumTapes
        self.poolId = poolId
        self.tapeBarcodePrefix = tapeBarcodePrefix
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

public enum AvailabilityMonitorTestStatus {
    case complete
    case failed
    case pending
    case sdkUnknown(String)
}

extension AvailabilityMonitorTestStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AvailabilityMonitorTestStatus] {
        return [
            .complete,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AvailabilityMonitorTestStatus(rawValue: rawValue) ?? AvailabilityMonitorTestStatus.sdkUnknown(rawValue)
    }
}

extension BandwidthRateLimitInterval: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case daysOfWeek = "DaysOfWeek"
        case endHourOfDay = "EndHourOfDay"
        case endMinuteOfHour = "EndMinuteOfHour"
        case startHourOfDay = "StartHourOfDay"
        case startMinuteOfHour = "StartMinuteOfHour"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let daysOfWeek = daysOfWeek {
            var daysOfWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfWeek)
            for daysofweek0 in daysOfWeek {
                try daysOfWeekContainer.encode(daysofweek0)
            }
        }
        if let endHourOfDay = endHourOfDay {
            try encodeContainer.encode(endHourOfDay, forKey: .endHourOfDay)
        }
        if let endMinuteOfHour = endMinuteOfHour {
            try encodeContainer.encode(endMinuteOfHour, forKey: .endMinuteOfHour)
        }
        if let startHourOfDay = startHourOfDay {
            try encodeContainer.encode(startHourOfDay, forKey: .startHourOfDay)
        }
        if let startMinuteOfHour = startMinuteOfHour {
            try encodeContainer.encode(startMinuteOfHour, forKey: .startMinuteOfHour)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startHourOfDayDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startHourOfDay)
        startHourOfDay = startHourOfDayDecoded
        let startMinuteOfHourDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startMinuteOfHour)
        startMinuteOfHour = startMinuteOfHourDecoded
        let endHourOfDayDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endHourOfDay)
        endHourOfDay = endHourOfDayDecoded
        let endMinuteOfHourDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endMinuteOfHour)
        endMinuteOfHour = endMinuteOfHourDecoded
        let daysOfWeekContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .daysOfWeek)
        var daysOfWeekDecoded0:[Int]? = nil
        if let daysOfWeekContainer = daysOfWeekContainer {
            daysOfWeekDecoded0 = [Int]()
            for integer0 in daysOfWeekContainer {
                if let integer0 = integer0 {
                    daysOfWeekDecoded0?.append(integer0)
                }
            }
        }
        daysOfWeek = daysOfWeekDecoded0
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension BandwidthRateLimitInterval: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BandwidthRateLimitInterval(averageDownloadRateLimitInBitsPerSec: \(String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(String(describing: averageUploadRateLimitInBitsPerSec)), daysOfWeek: \(String(describing: daysOfWeek)), endHourOfDay: \(String(describing: endHourOfDay)), endMinuteOfHour: \(String(describing: endMinuteOfHour)), startHourOfDay: \(String(describing: startHourOfDay)), startMinuteOfHour: \(String(describing: startMinuteOfHour)))"}
}

/// <p>
///          Describes a bandwidth rate limit interval for a gateway. A bandwidth
///          rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit
///          interval defines a period of time on one or more days of the week, during which bandwidth rate
///          limits are specified for uploading, downloading, or both.
///       </p>
public struct BandwidthRateLimitInterval: Equatable {
    /// <p>
    ///          The average download rate limit component of the bandwidth rate limit interval,
    ///          in bits per second. This field does not appear in the response if the download rate limit is not set.
    ///       </p>
    public let averageDownloadRateLimitInBitsPerSec: Int?
    /// <p>
    ///          The average upload rate limit component of the bandwidth rate limit interval,
    ///          in bits per second. This field does not appear in the response if the upload rate limit is not set.
    ///       </p>
    public let averageUploadRateLimitInBitsPerSec: Int?
    /// <p> The days of the week component of the bandwidth rate limit interval, represented as
    ///          ordinal numbers from 0 to 6, where 0 represents Sunday and 6 represents Saturday. </p>
    public let daysOfWeek: [Int]?
    /// <p>
    ///          The hour of the day to end the bandwidth rate limit interval.
    ///       </p>
    public let endHourOfDay: Int?
    /// <p>
    ///          The minute of the hour to end the bandwidth rate limit interval.
    ///       </p>
    ///
    ///          <important>
    ///             <p>
    ///             The bandwidth rate limit interval ends at the end of the minute. To end an interval
    ///             at the end of an hour, use the value <code>59</code>.
    ///          </p>
    ///          </important>
    public let endMinuteOfHour: Int?
    /// <p>
    ///          The hour of the day to start the bandwidth rate limit interval.
    ///       </p>
    public let startHourOfDay: Int?
    /// <p>
    ///          The minute of the hour to start the bandwidth rate limit interval.
    ///          The interval begins at the start of that minute. To begin an interval exactly at
    ///          the start of the hour, use the value <code>0</code>.
    ///       </p>
    public let startMinuteOfHour: Int?

    public init (
        averageDownloadRateLimitInBitsPerSec: Int? = nil,
        averageUploadRateLimitInBitsPerSec: Int? = nil,
        daysOfWeek: [Int]? = nil,
        endHourOfDay: Int? = nil,
        endMinuteOfHour: Int? = nil,
        startHourOfDay: Int? = nil,
        startMinuteOfHour: Int? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.daysOfWeek = daysOfWeek
        self.endHourOfDay = endHourOfDay
        self.endMinuteOfHour = endMinuteOfHour
        self.startHourOfDay = startHourOfDay
        self.startMinuteOfHour = startMinuteOfHour
    }
}

extension CacheAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheStaleTimeoutInSeconds = "CacheStaleTimeoutInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds {
            try encodeContainer.encode(cacheStaleTimeoutInSeconds, forKey: .cacheStaleTimeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheStaleTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .cacheStaleTimeoutInSeconds)
        cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSecondsDecoded
    }
}

extension CacheAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CacheAttributes(cacheStaleTimeoutInSeconds: \(String(describing: cacheStaleTimeoutInSeconds)))"}
}

/// <p>The refresh cache information for the file share.</p>
public struct CacheAttributes: Equatable {
    /// <p>Refreshes a file share's cache by using Time To Live (TTL). TTL is the length of
    ///          time since the last refresh after which access to the directory would cause the file
    ///          gateway to first refresh that directory's contents from the Amazon S3 bucket or Amazon FSx file system. The TTL
    ///          duration is in seconds.</p>
    ///
    ///          <p>Valid Values: 300 to 2,592,000 seconds (5 minutes to 30 days)</p>
    public let cacheStaleTimeoutInSeconds: Int?

    public init (
        cacheStaleTimeoutInSeconds: Int? = nil
    )
    {
        self.cacheStaleTimeoutInSeconds = cacheStaleTimeoutInSeconds
    }
}

extension CachediSCSIVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case kMSKey = "KMSKey"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let sourceSnapshotId = sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension CachediSCSIVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachediSCSIVolume(createdDate: \(String(describing: createdDate)), kMSKey: \(String(describing: kMSKey)), sourceSnapshotId: \(String(describing: sourceSnapshotId)), targetName: \(String(describing: targetName)), volumeARN: \(String(describing: volumeARN)), volumeAttachmentStatus: \(String(describing: volumeAttachmentStatus)), volumeId: \(String(describing: volumeId)), volumeProgress: \(String(describing: volumeProgress)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)), volumeStatus: \(String(describing: volumeStatus)), volumeType: \(String(describing: volumeType)), volumeUsedInBytes: \(String(describing: volumeUsedInBytes)), volumeiSCSIAttributes: \(String(describing: volumeiSCSIAttributes)))"}
}

/// <p>Describes an iSCSI cached volume.</p>
public struct CachediSCSIVolume: Equatable {
    /// <p>The date the volume was created. Volumes created prior to March 28, 2017 don’t have this
    ///          timestamp.</p>
    public let createdDate: Date?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>If the cached volume was created from a snapshot, this field contains the snapshot ID
    ///          used, e.g., snap-78e22663. Otherwise, this field is not included.</p>
    public let sourceSnapshotId: String?
    /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying <code>TargetName</code> as
    ///             <i>myvolume</i> results in the target ARN of
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
    ///          The target name must be unique across all volumes on a gateway.</p>
    ///
    ///          <p>If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.</p>
    public let targetName: String?
    /// <p>The Amazon Resource Name (ARN) of the storage volume.</p>
    public let volumeARN: String?
    /// <p>A value that indicates whether a storage volume is attached to or detached from a
    ///          gateway. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume">Moving
    ///             your volumes to a different gateway</a>.</p>
    public let volumeAttachmentStatus: String?
    /// <p>The unique identifier of the volume, e.g., vol-AE4B946D.</p>
    public let volumeId: String?
    /// <p>Represents the percentage complete if the volume is restoring or bootstrapping that
    ///          represents the percent of data transferred. This field does not appear in the response if
    ///          the cached volume is not restoring or bootstrapping.</p>
    public let volumeProgress: Double?
    /// <p>The size, in bytes, of the volume capacity.</p>
    public let volumeSizeInBytes: Int
    /// <p>One of the VolumeStatus values that indicates the state of the storage volume.</p>
    public let volumeStatus: String?
    /// <p>One of the VolumeType enumeration values that describes the type of the volume.</p>
    public let volumeType: String?
    /// <p>The size of the data stored on the volume in bytes. This value is calculated based on
    ///          the number of blocks that are touched, instead of the actual amount of data written. This
    ///          value can be useful for sequential write patterns but less accurate for random write
    ///          patterns. <code>VolumeUsedInBytes</code> is different from the compressed size of the
    ///          volume, which is the value that is used to calculate your bill.</p>
    ///
    ///          <note>
    ///             <p>This value is not available for volumes created prior to May 13, 2015, until you
    ///             store data on the volume.</p>
    ///          </note>
    public let volumeUsedInBytes: Int?
    /// <p>An <a>VolumeiSCSIAttributes</a> object that represents a collection of iSCSI
    ///          attributes for one stored volume.</p>
    public let volumeiSCSIAttributes: VolumeiSCSIAttributes?

    public init (
        createdDate: Date? = nil,
        kMSKey: String? = nil,
        sourceSnapshotId: String? = nil,
        targetName: String? = nil,
        volumeARN: String? = nil,
        volumeAttachmentStatus: String? = nil,
        volumeId: String? = nil,
        volumeProgress: Double? = nil,
        volumeSizeInBytes: Int = 0,
        volumeStatus: String? = nil,
        volumeType: String? = nil,
        volumeUsedInBytes: Int? = nil,
        volumeiSCSIAttributes: VolumeiSCSIAttributes? = nil
    )
    {
        self.createdDate = createdDate
        self.kMSKey = kMSKey
        self.sourceSnapshotId = sourceSnapshotId
        self.targetName = targetName
        self.volumeARN = volumeARN
        self.volumeAttachmentStatus = volumeAttachmentStatus
        self.volumeId = volumeId
        self.volumeProgress = volumeProgress
        self.volumeSizeInBytes = volumeSizeInBytes
        self.volumeStatus = volumeStatus
        self.volumeType = volumeType
        self.volumeUsedInBytes = volumeUsedInBytes
        self.volumeiSCSIAttributes = volumeiSCSIAttributes
    }
}

public struct CancelArchivalInputBodyMiddleware: Middleware {
    public let id: String = "CancelArchivalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelArchivalOutputError>
}

extension CancelArchivalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelArchivalInput(gatewayARN: \(String(describing: gatewayARN)), tapeARN: \(String(describing: tapeARN)))"}
}

extension CancelArchivalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct CancelArchivalInputHeadersMiddleware: Middleware {
    public let id: String = "CancelArchivalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelArchivalOutputError>
}

public struct CancelArchivalInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelArchivalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelArchivalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelArchivalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelArchivalInput>
    public typealias MOutput = OperationOutput<CancelArchivalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelArchivalOutputError>
}

/// <p>CancelArchivalInput</p>
public struct CancelArchivalInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving
    ///          for.</p>
    public let tapeARN: String?

    public init (
        gatewayARN: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeARN: String?
}

extension CancelArchivalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelArchivalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelArchivalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelArchivalOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelArchivalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelArchivalOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension CancelArchivalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelArchivalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>CancelArchivalOutput</p>
public struct CancelArchivalOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the virtual tape for which archiving was
    ///          canceled.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelArchivalOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension CancelArchivalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct CancelRetrievalInputBodyMiddleware: Middleware {
    public let id: String = "CancelRetrievalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRetrievalOutputError>
}

extension CancelRetrievalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelRetrievalInput(gatewayARN: \(String(describing: gatewayARN)), tapeARN: \(String(describing: tapeARN)))"}
}

extension CancelRetrievalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct CancelRetrievalInputHeadersMiddleware: Middleware {
    public let id: String = "CancelRetrievalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRetrievalOutputError>
}

public struct CancelRetrievalInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelRetrievalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelRetrievalInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelRetrievalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelRetrievalInput>
    public typealias MOutput = OperationOutput<CancelRetrievalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelRetrievalOutputError>
}

/// <p>CancelRetrievalInput</p>
public struct CancelRetrievalInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval
    ///          for.</p>
    public let tapeARN: String?

    public init (
        gatewayARN: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeARN: String?
}

extension CancelRetrievalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension CancelRetrievalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRetrievalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelRetrievalOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRetrievalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelRetrievalOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension CancelRetrievalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelRetrievalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>CancelRetrievalOutput</p>
public struct CancelRetrievalOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the virtual tape for which retrieval was
    ///          canceled.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CancelRetrievalOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension CancelRetrievalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public enum CaseSensitivity {
    case casesensitive
    case clientspecified
    case sdkUnknown(String)
}

extension CaseSensitivity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CaseSensitivity] {
        return [
            .casesensitive,
            .clientspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .casesensitive: return "CaseSensitive"
        case .clientspecified: return "ClientSpecified"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CaseSensitivity(rawValue: rawValue) ?? CaseSensitivity.sdkUnknown(rawValue)
    }
}

extension ChapInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension ChapInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChapInfo(initiatorName: \(String(describing: initiatorName)), secretToAuthenticateInitiator: \(String(describing: secretToAuthenticateInitiator)), secretToAuthenticateTarget: \(String(describing: secretToAuthenticateTarget)), targetARN: \(String(describing: targetARN)))"}
}

/// <p>Describes Challenge-Handshake Authentication Protocol (CHAP) information that supports
///          authentication between your gateway and iSCSI initiators.</p>
public struct ChapInfo: Equatable {
    /// <p>The iSCSI initiator that connects to the target.</p>
    public let initiatorName: String?
    /// <p>The secret key that the initiator (for example, the Windows client) must provide to
    ///          participate in mutual CHAP with the target.</p>
    public let secretToAuthenticateInitiator: String?
    /// <p>The secret key that the target must provide to participate in mutual CHAP with the
    ///          initiator (e.g., Windows client).</p>
    public let secretToAuthenticateTarget: String?
    /// <p>The Amazon Resource Name (ARN) of the volume.</p>
    ///
    ///          <p>Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).</p>
    public let targetARN: String?

    public init (
        initiatorName: String? = nil,
        secretToAuthenticateInitiator: String? = nil,
        secretToAuthenticateTarget: String? = nil,
        targetARN: String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
        self.secretToAuthenticateTarget = secretToAuthenticateTarget
        self.targetARN = targetARN
    }
}

public struct CreateCachediSCSIVolumeInputBodyMiddleware: Middleware {
    public let id: String = "CreateCachediSCSIVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachediSCSIVolumeOutputError>
}

extension CreateCachediSCSIVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCachediSCSIVolumeInput(clientToken: \(String(describing: clientToken)), gatewayARN: \(String(describing: gatewayARN)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), networkInterfaceId: \(String(describing: networkInterfaceId)), snapshotId: \(String(describing: snapshotId)), sourceVolumeARN: \(String(describing: sourceVolumeARN)), tags: \(String(describing: tags)), targetName: \(String(describing: targetName)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)))"}
}

extension CreateCachediSCSIVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let sourceVolumeARN = sourceVolumeARN {
            try encodeContainer.encode(sourceVolumeARN, forKey: .sourceVolumeARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
    }
}

public struct CreateCachediSCSIVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCachediSCSIVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachediSCSIVolumeOutputError>
}

public struct CreateCachediSCSIVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCachediSCSIVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateCachediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachediSCSIVolumeOutputError>
}

public struct CreateCachediSCSIVolumeInput: Equatable {
    /// <p>A unique identifier that you use to retry a request. If you retry a request, use the
    ///          same <code>ClientToken</code> you specified in the initial request.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
    ///          the network interfaces available on a gateway.</p>
    ///
    ///          <p>Valid Values: A valid IP address.</p>
    public let networkInterfaceId: String?
    /// <p>The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached
    ///          volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
    ///          otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
    ///             Reference</i>.</p>
    public let snapshotId: String?
    /// <p>The ARN for an existing volume. Specifying this ARN makes the new volume into an exact
    ///          copy of the specified existing volume's latest recovery point. The
    ///             <code>VolumeSizeInBytes</code> value for this new volume must be equal to or larger than
    ///          the size of the existing volume, in bytes.</p>
    public let sourceVolumeARN: String?
    /// <p>A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers that you can
    ///             represent in UTF-8 format, and the following special characters: + - = . _ : / @. The
    ///             maximum length of a tag's key is 128 characters, and the maximum length for a
    ///             tag's value is 256 characters.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying <code>TargetName</code> as
    ///             <i>myvolume</i> results in the target ARN of
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
    ///          The target name must be unique across all volumes on a gateway.</p>
    ///
    ///          <p>If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.</p>
    public let targetName: String?
    /// <p>The size of the volume in bytes.</p>
    public let volumeSizeInBytes: Int

    public init (
        clientToken: String? = nil,
        gatewayARN: String? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        networkInterfaceId: String? = nil,
        snapshotId: String? = nil,
        sourceVolumeARN: String? = nil,
        tags: [Tag]? = nil,
        targetName: String? = nil,
        volumeSizeInBytes: Int = 0
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.networkInterfaceId = networkInterfaceId
        self.snapshotId = snapshotId
        self.sourceVolumeARN = sourceVolumeARN
        self.tags = tags
        self.targetName = targetName
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateCachediSCSIVolumeInputBody: Equatable {
    public let gatewayARN: String?
    public let volumeSizeInBytes: Int
    public let snapshotId: String?
    public let targetName: String?
    public let sourceVolumeARN: String?
    public let networkInterfaceId: String?
    public let clientToken: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let tags: [Tag]?
}

extension CreateCachediSCSIVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case snapshotId = "SnapshotId"
        case sourceVolumeARN = "SourceVolumeARN"
        case tags = "Tags"
        case targetName = "TargetName"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let sourceVolumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceVolumeARN)
        sourceVolumeARN = sourceVolumeARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCachediSCSIVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCachediSCSIVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachediSCSIVolumeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachediSCSIVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCachediSCSIVolumeOutputResponse(targetARN: \(String(describing: targetARN)), volumeARN: \(String(describing: volumeARN)))"}
}

extension CreateCachediSCSIVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCachediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
        } else {
            self.targetARN = nil
            self.volumeARN = nil
        }
    }
}

public struct CreateCachediSCSIVolumeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that
    ///          initiators can use to connect to the target.</p>
    public let targetARN: String?
    /// <p>The Amazon Resource Name (ARN) of the configured volume.</p>
    public let volumeARN: String?

    public init (
        targetARN: String? = nil,
        volumeARN: String? = nil
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
    }
}

struct CreateCachediSCSIVolumeOutputResponseBody: Equatable {
    public let volumeARN: String?
    public let targetARN: String?
}

extension CreateCachediSCSIVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

public struct CreateNFSFileShareInputBodyMiddleware: Middleware {
    public let id: String = "CreateNFSFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNFSFileShareOutputError>
}

extension CreateNFSFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNFSFileShareInput(cacheAttributes: \(String(describing: cacheAttributes)), clientList: \(String(describing: clientList)), clientToken: \(String(describing: clientToken)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareName: \(String(describing: fileShareName)), gatewayARN: \(String(describing: gatewayARN)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), locationARN: \(String(describing: locationARN)), nFSFileShareDefaults: \(String(describing: nFSFileShareDefaults)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), role: \(String(describing: role)), squash: \(String(describing: squash)), tags: \(String(describing: tags)))"}
}

extension CreateNFSFileShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateNFSFileShareInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNFSFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNFSFileShareOutputError>
}

public struct CreateNFSFileShareInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNFSFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNFSFileShareInput>
    public typealias MOutput = OperationOutput<CreateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNFSFileShareOutputError>
}

/// <p>CreateNFSFileShareInput</p>
public struct CreateNFSFileShareInput: Equatable {
    /// <p>Specifies refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The list of clients that are allowed to access the file gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.</p>
    public let clientList: [String]?
    /// <p>A unique string value that you supply that is used by file gateway to ensure idempotent
    ///          file share creation.</p>
    public let clientToken: String?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>The Amazon Resource Name (ARN) of the file gateway on which you want to create a file
    ///          share.</p>
    public let gatewayARN: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".</p>
    public let locationARN: String?
    /// <p>File share default values. Optional.</p>
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that a file gateway assumes
    ///          when it accesses the underlying storage.</p>
    public let role: String?
    /// <p>A value that maps a user to anonymous user.</p>
    ///
    ///          <p>Valid values are the following:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NoSquash</code>: No one is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
    ///             </li>
    ///          </ul>
    public let squash: String?
    /// <p>A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
    ///          key-value pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        cacheAttributes: CacheAttributes? = nil,
        clientList: [String]? = nil,
        clientToken: String? = nil,
        defaultStorageClass: String? = nil,
        fileShareName: String? = nil,
        gatewayARN: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        locationARN: String? = nil,
        nFSFileShareDefaults: NFSFileShareDefaults? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        role: String? = nil,
        squash: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
    }
}

struct CreateNFSFileShareInputBody: Equatable {
    public let clientToken: String?
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    public let gatewayARN: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let role: String?
    public let locationARN: String?
    public let defaultStorageClass: String?
    public let objectACL: ObjectACL?
    public let clientList: [String]?
    public let squash: String?
    public let readOnly: Bool?
    public let guessMIMETypeEnabled: Bool?
    public let requesterPays: Bool?
    public let tags: [Tag]?
    public let fileShareName: String?
    public let cacheAttributes: CacheAttributes?
    public let notificationPolicy: String?
}

extension CreateNFSFileShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clientList)
        var clientListDecoded0:[String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension CreateNFSFileShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNFSFileShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNFSFileShareOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNFSFileShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNFSFileShareOutputResponse(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension CreateNFSFileShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// <p>CreateNFSFileShareOutput</p>
public struct CreateNFSFileShareOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the newly created file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateNFSFileShareOutputResponseBody: Equatable {
    public let fileShareARN: String?
}

extension CreateNFSFileShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct CreateSMBFileShareInputBodyMiddleware: Middleware {
    public let id: String = "CreateSMBFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMBFileShareOutputError>
}

extension CreateSMBFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSMBFileShareInput(accessBasedEnumeration: \(String(describing: accessBasedEnumeration)), adminUserList: \(String(describing: adminUserList)), auditDestinationARN: \(String(describing: auditDestinationARN)), authentication: \(String(describing: authentication)), cacheAttributes: \(String(describing: cacheAttributes)), caseSensitivity: \(String(describing: caseSensitivity)), clientToken: \(String(describing: clientToken)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareName: \(String(describing: fileShareName)), gatewayARN: \(String(describing: gatewayARN)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), invalidUserList: \(String(describing: invalidUserList)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), locationARN: \(String(describing: locationARN)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), role: \(String(describing: role)), sMBACLEnabled: \(String(describing: sMBACLEnabled)), tags: \(String(describing: tags)), validUserList: \(String(describing: validUserList)))"}
}

extension CreateSMBFileShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }
}

public struct CreateSMBFileShareInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSMBFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMBFileShareOutputError>
}

public struct CreateSMBFileShareInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSMBFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSMBFileShareInput>
    public typealias MOutput = OperationOutput<CreateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSMBFileShareOutputError>
}

/// <p>CreateSMBFileShareInput</p>
public struct CreateSMBFileShareInput: Equatable {
    /// <p>The files and folders on this share will only be visible to users with read
    ///          access.</p>
    public let accessBasedEnumeration: Bool?
    /// <p>A list of users or groups in the Active Directory that will be granted administrator
    ///          privileges on the file share. These users can do all file operations as the super-user.
    ///          Acceptable formats include: <code>DOMAIN\User1</code>, <code>user1</code>,
    ///             <code>@group1</code>, and <code>@DOMAIN\group1</code>.</p>
    ///
    ///          <important>
    ///             <p>Use this option very carefully, because any user in this list can do anything they
    ///             like on the file share, regardless of file permissions.</p>
    ///          </important>
    public let adminUserList: [String]?
    /// <p>The Amazon Resource Name (ARN) of the storage used for audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>The authentication method that users use to access the file share. The default is
    ///             <code>ActiveDirectory</code>.</p>
    ///
    ///          <p>Valid Values: <code>ActiveDirectory</code> | <code>GuestAccess</code>
    ///          </p>
    public let authentication: String?
    /// <p>Specifies refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The case of an object name in an Amazon S3 bucket. For <code>ClientSpecified</code>, the
    ///          client determines the case sensitivity. For <code>CaseSensitive</code>, the gateway
    ///          determines the case sensitivity. The default value is <code>ClientSpecified</code>.</p>
    public let caseSensitivity: CaseSensitivity?
    /// <p>A unique string value that you supply that is used by file gateway to ensure idempotent
    ///          file share creation.</p>
    public let clientToken: String?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>The ARN of the file gateway on which you want to create a file share.</p>
    public let gatewayARN: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>A list of users or groups in the Active Directory that are not allowed to access the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let invalidUserList: [String]?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".</p>
    public let locationARN: String?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that a file gateway assumes
    ///          when it accesses the underlying storage.</p>
    public let role: String?
    /// <p>Set this value to <code>true</code> to enable access control list (ACL) on the SMB file
    ///          share. Set it to <code>false</code> to map file and directory permissions to the POSIX
    ///          permissions.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
    ///             control access to an SMB file share</a> in the <i>AWS Storage Gateway User
    ///             Guide</i>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let sMBACLEnabled: Bool?
    /// <p>A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
    ///          key-value pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>A list of users or groups in the Active Directory that are allowed to access the file
    ///             <a href=""></a> share. A group must be prefixed with the @ character. Acceptable formats
    ///          include: <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let validUserList: [String]?

    public init (
        accessBasedEnumeration: Bool? = nil,
        adminUserList: [String]? = nil,
        auditDestinationARN: String? = nil,
        authentication: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        caseSensitivity: CaseSensitivity? = nil,
        clientToken: String? = nil,
        defaultStorageClass: String? = nil,
        fileShareName: String? = nil,
        gatewayARN: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        invalidUserList: [String]? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        locationARN: String? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        role: String? = nil,
        sMBACLEnabled: Bool? = nil,
        tags: [Tag]? = nil,
        validUserList: [String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.authentication = authentication
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.sMBACLEnabled = sMBACLEnabled
        self.tags = tags
        self.validUserList = validUserList
    }
}

struct CreateSMBFileShareInputBody: Equatable {
    public let clientToken: String?
    public let gatewayARN: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let role: String?
    public let locationARN: String?
    public let defaultStorageClass: String?
    public let objectACL: ObjectACL?
    public let readOnly: Bool?
    public let guessMIMETypeEnabled: Bool?
    public let requesterPays: Bool?
    public let sMBACLEnabled: Bool?
    public let accessBasedEnumeration: Bool?
    public let adminUserList: [String]?
    public let validUserList: [String]?
    public let invalidUserList: [String]?
    public let auditDestinationARN: String?
    public let authentication: String?
    public let caseSensitivity: CaseSensitivity?
    public let tags: [Tag]?
    public let fileShareName: String?
    public let cacheAttributes: CacheAttributes?
    public let notificationPolicy: String?
}

extension CreateSMBFileShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case clientToken = "ClientToken"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareName = "FileShareName"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validUserList)
        var validUserListDecoded0:[String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension CreateSMBFileShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSMBFileShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSMBFileShareOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSMBFileShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSMBFileShareOutputResponse(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension CreateSMBFileShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// <p>CreateSMBFileShareOutput</p>
public struct CreateSMBFileShareOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the newly created file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct CreateSMBFileShareOutputResponseBody: Equatable {
    public let fileShareARN: String?
}

extension CreateSMBFileShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInputBodyMiddleware: Middleware {
    public let id: String = "CreateSnapshotFromVolumeRecoveryPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

extension CreateSnapshotFromVolumeRecoveryPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotFromVolumeRecoveryPointInput(snapshotDescription: \(String(describing: snapshotDescription)), tags: \(String(describing: tags)), volumeARN: \(String(describing: volumeARN)))"}
}

extension CreateSnapshotFromVolumeRecoveryPointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSnapshotFromVolumeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

public struct CreateSnapshotFromVolumeRecoveryPointInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSnapshotFromVolumeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotFromVolumeRecoveryPointInput>
    public typealias MOutput = OperationOutput<CreateSnapshotFromVolumeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotFromVolumeRecoveryPointOutputError>
}

public struct CreateSnapshotFromVolumeRecoveryPointInput: Equatable {
    /// <p>Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
    ///          Block Store snapshots panel in the <b>Description</b> field, and
    ///          in the AWS Storage Gateway snapshot <b>Details</b> pane,
    ///             <b>Description</b> field.</p>
    public let snapshotDescription: String?
    /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.</p>
    public let volumeARN: String?

    public init (
        snapshotDescription: String? = nil,
        tags: [Tag]? = nil,
        volumeARN: String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotFromVolumeRecoveryPointInputBody: Equatable {
    public let volumeARN: String?
    public let snapshotDescription: String?
    public let tags: [Tag]?
}

extension CreateSnapshotFromVolumeRecoveryPointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotFromVolumeRecoveryPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotFromVolumeRecoveryPointOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotFromVolumeRecoveryPointOutputResponse(snapshotId: \(String(describing: snapshotId)), volumeARN: \(String(describing: volumeARN)), volumeRecoveryPointTime: \(String(describing: volumeRecoveryPointTime)))"}
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSnapshotFromVolumeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
            self.volumeRecoveryPointTime = output.volumeRecoveryPointTime
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
            self.volumeRecoveryPointTime = nil
        }
    }
}

public struct CreateSnapshotFromVolumeRecoveryPointOutputResponse: Equatable {
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: String?
    /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.</p>
    public let volumeARN: String?
    /// <p>The time the volume was created from the recovery point.</p>
    public let volumeRecoveryPointTime: String?

    public init (
        snapshotId: String? = nil,
        volumeARN: String? = nil,
        volumeRecoveryPointTime: String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
        self.volumeRecoveryPointTime = volumeRecoveryPointTime
    }
}

struct CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Equatable {
    public let snapshotId: String?
    public let volumeARN: String?
    public let volumeRecoveryPointTime: String?
}

extension CreateSnapshotFromVolumeRecoveryPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

public struct CreateSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

extension CreateSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotInput(snapshotDescription: \(String(describing: snapshotDescription)), tags: \(String(describing: tags)), volumeARN: \(String(describing: volumeARN)))"}
}

extension CreateSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotDescription = snapshotDescription {
            try encodeContainer.encode(snapshotDescription, forKey: .snapshotDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct CreateSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

public struct CreateSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSnapshotInput>
    public typealias MOutput = OperationOutput<CreateSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSnapshotOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>CreateSnapshotInput$SnapshotDescription</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>CreateSnapshotInput$VolumeARN</a>
///                </p>
///             </li>
///          </ul>
public struct CreateSnapshotInput: Equatable {
    /// <p>Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
    ///          Block Store snapshots panel in the <b>Description</b> field, and
    ///          in the AWS Storage Gateway snapshot <b>Details</b> pane,
    ///             <b>Description</b> field.</p>
    public let snapshotDescription: String?
    /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes.</p>
    public let volumeARN: String?

    public init (
        snapshotDescription: String? = nil,
        tags: [Tag]? = nil,
        volumeARN: String? = nil
    )
    {
        self.snapshotDescription = snapshotDescription
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotInputBody: Equatable {
    public let volumeARN: String?
    public let snapshotDescription: String?
    public let tags: [Tag]?
}

extension CreateSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotDescription = "SnapshotDescription"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotDescription)
        snapshotDescription = snapshotDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSnapshotOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSnapshotOutputResponse(snapshotId: \(String(describing: snapshotId)), volumeARN: \(String(describing: volumeARN)))"}
}

extension CreateSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snapshotId = output.snapshotId
            self.volumeARN = output.volumeARN
        } else {
            self.snapshotId = nil
            self.volumeARN = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct CreateSnapshotOutputResponse: Equatable {
    /// <p>The snapshot ID that is used to refer to the snapshot in future operations such as
    ///          describing snapshots (Amazon Elastic Compute Cloud API <code>DescribeSnapshots</code>) or
    ///          creating a volume from a snapshot (<a>CreateStorediSCSIVolume</a>).</p>
    public let snapshotId: String?
    /// <p>The Amazon Resource Name (ARN) of the volume of which the snapshot was taken.</p>
    public let volumeARN: String?

    public init (
        snapshotId: String? = nil,
        volumeARN: String? = nil
    )
    {
        self.snapshotId = snapshotId
        self.volumeARN = volumeARN
    }
}

struct CreateSnapshotOutputResponseBody: Equatable {
    public let volumeARN: String?
    public let snapshotId: String?
}

extension CreateSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snapshotId = "SnapshotId"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

public struct CreateStorediSCSIVolumeInputBodyMiddleware: Middleware {
    public let id: String = "CreateStorediSCSIVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorediSCSIVolumeOutputError>
}

extension CreateStorediSCSIVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStorediSCSIVolumeInput(diskId: \(String(describing: diskId)), gatewayARN: \(String(describing: gatewayARN)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), networkInterfaceId: \(String(describing: networkInterfaceId)), preserveExistingData: \(String(describing: preserveExistingData)), snapshotId: \(String(describing: snapshotId)), tags: \(String(describing: tags)), targetName: \(String(describing: targetName)))"}
}

extension CreateStorediSCSIVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if preserveExistingData != false {
            try encodeContainer.encode(preserveExistingData, forKey: .preserveExistingData)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
    }
}

public struct CreateStorediSCSIVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStorediSCSIVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorediSCSIVolumeOutputError>
}

public struct CreateStorediSCSIVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStorediSCSIVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStorediSCSIVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStorediSCSIVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStorediSCSIVolumeInput>
    public typealias MOutput = OperationOutput<CreateStorediSCSIVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStorediSCSIVolumeOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>CreateStorediSCSIVolumeInput$DiskId</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>CreateStorediSCSIVolumeInput$NetworkInterfaceId</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>CreateStorediSCSIVolumeInput$PreserveExistingData</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>CreateStorediSCSIVolumeInput$SnapshotId</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>CreateStorediSCSIVolumeInput$TargetName</a>
///                </p>
///             </li>
///          </ul>
public struct CreateStorediSCSIVolumeInput: Equatable {
    /// <p>The unique identifier for the gateway local disk that is configured as a stored volume.
    ///          Use <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/API_ListLocalDisks.html">ListLocalDisks</a> to
    ///          list disk IDs for a gateway.</p>
    public let diskId: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
    ///          addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
    ///          the network interfaces available on a gateway.</p>
    ///
    ///          <p>Valid Values: A valid IP address.</p>
    public let networkInterfaceId: String?
    /// <p>Set to <code>true</code> if you want to preserve the data on the local disk. Otherwise,
    ///          set to <code>false</code> to create an empty volume.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let preserveExistingData: Bool
    /// <p>The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored
    ///          volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
    ///          otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
    ///             Reference</i>.</p>
    public let snapshotId: String?
    /// <p>A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying <code>TargetName</code> as
    ///             <i>myvolume</i> results in the target ARN of
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
    ///          The target name must be unique across all volumes on a gateway.</p>
    ///
    ///          <p>If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.</p>
    public let targetName: String?

    public init (
        diskId: String? = nil,
        gatewayARN: String? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        networkInterfaceId: String? = nil,
        preserveExistingData: Bool = false,
        snapshotId: String? = nil,
        tags: [Tag]? = nil,
        targetName: String? = nil
    )
    {
        self.diskId = diskId
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.networkInterfaceId = networkInterfaceId
        self.preserveExistingData = preserveExistingData
        self.snapshotId = snapshotId
        self.tags = tags
        self.targetName = targetName
    }
}

struct CreateStorediSCSIVolumeInputBody: Equatable {
    public let gatewayARN: String?
    public let diskId: String?
    public let snapshotId: String?
    public let preserveExistingData: Bool
    public let targetName: String?
    public let networkInterfaceId: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let tags: [Tag]?
}

extension CreateStorediSCSIVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskId = "DiskId"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case networkInterfaceId = "NetworkInterfaceId"
        case preserveExistingData = "PreserveExistingData"
        case snapshotId = "SnapshotId"
        case tags = "Tags"
        case targetName = "TargetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let preserveExistingDataDecoded = try containerValues.decode(Bool.self, forKey: .preserveExistingData)
        preserveExistingData = preserveExistingDataDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStorediSCSIVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStorediSCSIVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStorediSCSIVolumeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStorediSCSIVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStorediSCSIVolumeOutputResponse(targetARN: \(String(describing: targetARN)), volumeARN: \(String(describing: volumeARN)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)))"}
}

extension CreateStorediSCSIVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStorediSCSIVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetARN = output.targetARN
            self.volumeARN = output.volumeARN
            self.volumeSizeInBytes = output.volumeSizeInBytes
        } else {
            self.targetARN = nil
            self.volumeARN = nil
            self.volumeSizeInBytes = 0
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct CreateStorediSCSIVolumeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume target, which includes the iSCSI name that
    ///          initiators can use to connect to the target.</p>
    public let targetARN: String?
    /// <p>The Amazon Resource Name (ARN) of the configured volume.</p>
    public let volumeARN: String?
    /// <p>The size of the volume in bytes.</p>
    public let volumeSizeInBytes: Int

    public init (
        targetARN: String? = nil,
        volumeARN: String? = nil,
        volumeSizeInBytes: Int = 0
    )
    {
        self.targetARN = targetARN
        self.volumeARN = volumeARN
        self.volumeSizeInBytes = volumeSizeInBytes
    }
}

struct CreateStorediSCSIVolumeOutputResponseBody: Equatable {
    public let volumeARN: String?
    public let volumeSizeInBytes: Int
    public let targetARN: String?
}

extension CreateStorediSCSIVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetARN = "TargetARN"
        case volumeARN = "VolumeARN"
        case volumeSizeInBytes = "VolumeSizeInBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

public struct CreateTapePoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapePoolOutputError>
}

extension CreateTapePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapePoolInput(poolName: \(String(describing: poolName)), retentionLockTimeInDays: \(String(describing: retentionLockTimeInDays)), retentionLockType: \(String(describing: retentionLockType)), storageClass: \(String(describing: storageClass)), tags: \(String(describing: tags)))"}
}

extension CreateTapePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let retentionLockTimeInDays = retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateTapePoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapePoolOutputError>
}

public struct CreateTapePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapePoolInput>
    public typealias MOutput = OperationOutput<CreateTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapePoolOutputError>
}

public struct CreateTapePoolInput: Equatable {
    /// <p>The name of the new custom tape pool.</p>
    public let poolName: String?
    /// <p>Tape retention lock time is set in days. Tape retention lock can be enabled for up to
    ///          100 years (36,500 days).</p>
    public let retentionLockTimeInDays: Int?
    /// <p>Tape retention lock can be configured in two modes. When configured in governance mode,
    ///          AWS accounts with specific IAM permissions are authorized to remove the tape retention lock
    ///          from archived virtual tapes. When configured in compliance mode, the tape retention lock
    ///          cannot be removed by any user, including the root AWS account.</p>
    public let retentionLockType: RetentionLockType?
    /// <p>The storage class that is associated with the new custom pool. When you use your backup
    ///          application to eject the tape, the tape is archived directly into the storage class (S3
    ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    public let storageClass: TapeStorageClass?
    /// <p>A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        poolName: String? = nil,
        retentionLockTimeInDays: Int? = nil,
        retentionLockType: RetentionLockType? = nil,
        storageClass: TapeStorageClass? = nil,
        tags: [Tag]? = nil
    )
    {
        self.poolName = poolName
        self.retentionLockTimeInDays = retentionLockTimeInDays
        self.retentionLockType = retentionLockType
        self.storageClass = storageClass
        self.tags = tags
    }
}

struct CreateTapePoolInputBody: Equatable {
    public let poolName: String?
    public let storageClass: TapeStorageClass?
    public let retentionLockType: RetentionLockType?
    public let retentionLockTimeInDays: Int?
    public let tags: [Tag]?
}

extension CreateTapePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolName = "PoolName"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapePoolOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapePoolOutputResponse(poolARN: \(String(describing: poolARN)))"}
}

extension CreateTapePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct CreateTapePoolOutputResponse: Equatable {
    /// <p>The unique Amazon Resource Name (ARN) that represents the custom tape pool. Use the
    ///             <a>ListTapePools</a> operation to return a list of tape pools for your
    ///          account and AWS Region.</p>
    public let poolARN: String?

    public init (
        poolARN: String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct CreateTapePoolOutputResponseBody: Equatable {
    public let poolARN: String?
}

extension CreateTapePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

public struct CreateTapeWithBarcodeInputBodyMiddleware: Middleware {
    public let id: String = "CreateTapeWithBarcodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapeWithBarcodeOutputError>
}

extension CreateTapeWithBarcodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapeWithBarcodeInput(gatewayARN: \(String(describing: gatewayARN)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), poolId: \(String(describing: poolId)), tags: \(String(describing: tags)), tapeBarcode: \(String(describing: tapeBarcode)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), worm: \(String(describing: worm)))"}
}

extension CreateTapeWithBarcodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

public struct CreateTapeWithBarcodeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTapeWithBarcodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapeWithBarcodeOutputError>
}

public struct CreateTapeWithBarcodeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTapeWithBarcodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapeWithBarcodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapeWithBarcodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapeWithBarcodeInput>
    public typealias MOutput = OperationOutput<CreateTapeWithBarcodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapeWithBarcodeOutputError>
}

/// <p>CreateTapeWithBarcodeInput</p>
public struct CreateTapeWithBarcodeInput: Equatable {
    /// <p>The unique Amazon Resource Name (ARN) that represents the gateway to associate the
    ///          virtual tape with. Use the <a>ListGateways</a> operation to return a list of
    ///          gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each
    ///          tag is a key-value pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The barcode that you want to assign to the tape.</p>
    ///
    ///          <note>
    ///             <p>Barcodes cannot be reused. This includes barcodes used for tapes that have been
    ///             deleted.</p>
    ///          </note>
    public let tapeBarcode: String?
    /// <p>The size, in bytes, of the virtual tape that you want to create.</p>
    ///
    ///          <note>
    ///             <p>The size must be aligned by gigabyte (1024*1024*1024 bytes).</p>
    ///          </note>
    public let tapeSizeInBytes: Int?
    /// <p>Set to <code>TRUE</code> if the tape you are creating is to be configured as a
    ///          write-once-read-many (WORM) tape.</p>
    public let worm: Bool

    public init (
        gatewayARN: String? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        poolId: String? = nil,
        tags: [Tag]? = nil,
        tapeBarcode: String? = nil,
        tapeSizeInBytes: Int? = nil,
        worm: Bool = false
    )
    {
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcode = tapeBarcode
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapeWithBarcodeInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeSizeInBytes: Int?
    public let tapeBarcode: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let poolId: String?
    public let worm: Bool
    public let tags: [Tag]?
}

extension CreateTapeWithBarcodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Bool.self, forKey: .worm)
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapeWithBarcodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapeWithBarcodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapeWithBarcodeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapeWithBarcodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapeWithBarcodeOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension CreateTapeWithBarcodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTapeWithBarcodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>CreateTapeOutput</p>
public struct CreateTapeWithBarcodeOutputResponse: Equatable {
    /// <p>A unique Amazon Resource Name (ARN) that represents the virtual tape that was
    ///          created.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct CreateTapeWithBarcodeOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension CreateTapeWithBarcodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct CreateTapesInputBodyMiddleware: Middleware {
    public let id: String = "CreateTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapesInput>
    public typealias MOutput = OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapesOutputError>
}

extension CreateTapesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapesInput(clientToken: \(String(describing: clientToken)), gatewayARN: \(String(describing: gatewayARN)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), numTapesToCreate: \(String(describing: numTapesToCreate)), poolId: \(String(describing: poolId)), tags: \(String(describing: tags)), tapeBarcodePrefix: \(String(describing: tapeBarcodePrefix)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), worm: \(String(describing: worm)))"}
}

extension CreateTapesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let numTapesToCreate = numTapesToCreate {
            try encodeContainer.encode(numTapesToCreate, forKey: .numTapesToCreate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let tapeBarcodePrefix = tapeBarcodePrefix {
            try encodeContainer.encode(tapeBarcodePrefix, forKey: .tapeBarcodePrefix)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }
}

public struct CreateTapesInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapesInput>
    public typealias MOutput = OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapesOutputError>
}

public struct CreateTapesInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTapesInput>
    public typealias MOutput = OperationOutput<CreateTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTapesOutputError>
}

/// <p>CreateTapesInput</p>
public struct CreateTapesInput: Equatable {
    /// <p>A unique identifier that you use to retry a request. If you retry a request, use the
    ///          same <code>ClientToken</code> you specified in the initial request.</p>
    ///
    ///          <note>
    ///             <p>Using the same <code>ClientToken</code> prevents creating the tape multiple
    ///             times.</p>
    ///          </note>
    public let clientToken: String?
    /// <p>The unique Amazon Resource Name (ARN) that represents the gateway to associate the
    ///          virtual tapes with. Use the <a>ListGateways</a> operation to return a list of
    ///          gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The number of virtual tapes that you want to create.</p>
    public let numTapesToCreate: Int?
    /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>A prefix that you append to the barcode of the virtual tape you are creating. This
    ///          prefix makes the barcode unique.</p>
    ///
    ///          <note>
    ///             <p>The prefix must be 1-4 characters in length and must be one of the uppercase letters
    ///             from A to Z.</p>
    ///          </note>
    public let tapeBarcodePrefix: String?
    /// <p>The size, in bytes, of the virtual tapes that you want to create.</p>
    ///
    ///          <note>
    ///             <p>The size must be aligned by gigabyte (1024*1024*1024 bytes).</p>
    ///          </note>
    public let tapeSizeInBytes: Int?
    /// <p>Set to <code>TRUE</code> if the tape you are creating is to be configured as a
    ///          write-once-read-many (WORM) tape.</p>
    public let worm: Bool

    public init (
        clientToken: String? = nil,
        gatewayARN: String? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        numTapesToCreate: Int? = nil,
        poolId: String? = nil,
        tags: [Tag]? = nil,
        tapeBarcodePrefix: String? = nil,
        tapeSizeInBytes: Int? = nil,
        worm: Bool = false
    )
    {
        self.clientToken = clientToken
        self.gatewayARN = gatewayARN
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.numTapesToCreate = numTapesToCreate
        self.poolId = poolId
        self.tags = tags
        self.tapeBarcodePrefix = tapeBarcodePrefix
        self.tapeSizeInBytes = tapeSizeInBytes
        self.worm = worm
    }
}

struct CreateTapesInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeSizeInBytes: Int?
    public let clientToken: String?
    public let numTapesToCreate: Int?
    public let tapeBarcodePrefix: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let poolId: String?
    public let worm: Bool
    public let tags: [Tag]?
}

extension CreateTapesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case gatewayARN = "GatewayARN"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case numTapesToCreate = "NumTapesToCreate"
        case poolId = "PoolId"
        case tags = "Tags"
        case tapeBarcodePrefix = "TapeBarcodePrefix"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case worm = "Worm"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let numTapesToCreateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numTapesToCreate)
        numTapesToCreate = numTapesToCreateDecoded
        let tapeBarcodePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcodePrefix)
        tapeBarcodePrefix = tapeBarcodePrefixDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Bool.self, forKey: .worm)
        worm = wormDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTapesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTapesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTapesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTapesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTapesOutputResponse(tapeARNs: \(String(describing: tapeARNs)))"}
}

extension CreateTapesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTapesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARNs = output.tapeARNs
        } else {
            self.tapeARNs = nil
        }
    }
}

/// <p>CreateTapeOutput</p>
public struct CreateTapesOutputResponse: Equatable {
    /// <p>A list of unique Amazon Resource Names (ARNs) that represents the virtual tapes that
    ///          were created.</p>
    public let tapeARNs: [String]?

    public init (
        tapeARNs: [String]? = nil
    )
    {
        self.tapeARNs = tapeARNs
    }
}

struct CreateTapesOutputResponseBody: Equatable {
    public let tapeARNs: [String]?
}

extension CreateTapesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
    }
}

public struct DeleteAutomaticTapeCreationPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAutomaticTapeCreationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

extension DeleteAutomaticTapeCreationPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAutomaticTapeCreationPolicyInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteAutomaticTapeCreationPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteAutomaticTapeCreationPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAutomaticTapeCreationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

public struct DeleteAutomaticTapeCreationPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAutomaticTapeCreationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAutomaticTapeCreationPolicyOutputError>
}

public struct DeleteAutomaticTapeCreationPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyInputBody: Equatable {
    public let gatewayARN: String?
}

extension DeleteAutomaticTapeCreationPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutomaticTapeCreationPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAutomaticTapeCreationPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutomaticTapeCreationPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAutomaticTapeCreationPolicyOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteAutomaticTapeCreationPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct DeleteAutomaticTapeCreationPolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteAutomaticTapeCreationPolicyOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension DeleteAutomaticTapeCreationPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteBandwidthRateLimitInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBandwidthRateLimitOutputError>
}

extension DeleteBandwidthRateLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBandwidthRateLimitInput(bandwidthType: \(String(describing: bandwidthType)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteBandwidthRateLimitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthType = bandwidthType {
            try encodeContainer.encode(bandwidthType, forKey: .bandwidthType)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteBandwidthRateLimitInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBandwidthRateLimitOutputError>
}

public struct DeleteBandwidthRateLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DeleteBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBandwidthRateLimitOutputError>
}

/// <p>A JSON object containing the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>DeleteBandwidthRateLimitInput$BandwidthType</a>
///                </p>
///             </li>
///          </ul>
public struct DeleteBandwidthRateLimitInput: Equatable {
    /// <p>One of the BandwidthType values that indicates the gateway bandwidth rate limit to
    ///          delete.</p>
    ///
    ///          <p>Valid Values: <code>UPLOAD</code> | <code>DOWNLOAD</code> | <code>ALL</code>
    ///          </p>
    public let bandwidthType: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        bandwidthType: String? = nil,
        gatewayARN: String? = nil
    )
    {
        self.bandwidthType = bandwidthType
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitInputBody: Equatable {
    public let gatewayARN: String?
    public let bandwidthType: String?
}

extension DeleteBandwidthRateLimitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidthType = "BandwidthType"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bandwidthType)
        bandwidthType = bandwidthTypeDecoded
    }
}

extension DeleteBandwidthRateLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBandwidthRateLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBandwidthRateLimitOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBandwidthRateLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBandwidthRateLimitOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteBandwidthRateLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway whose bandwidth
///          rate information was deleted.</p>
public struct DeleteBandwidthRateLimitOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteBandwidthRateLimitOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension DeleteBandwidthRateLimitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteChapCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChapCredentialsOutputError>
}

extension DeleteChapCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChapCredentialsInput(initiatorName: \(String(describing: initiatorName)), targetARN: \(String(describing: targetARN)))"}
}

extension DeleteChapCredentialsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct DeleteChapCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChapCredentialsOutputError>
}

public struct DeleteChapCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChapCredentialsInput>
    public typealias MOutput = OperationOutput<DeleteChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChapCredentialsOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>DeleteChapCredentialsInput$InitiatorName</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DeleteChapCredentialsInput$TargetARN</a>
///                </p>
///             </li>
///          </ul>
public struct DeleteChapCredentialsInput: Equatable {
    /// <p>The iSCSI initiator that connects to the target.</p>
    public let initiatorName: String?
    /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.</p>
    public let targetARN: String?

    public init (
        initiatorName: String? = nil,
        targetARN: String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsInputBody: Equatable {
    public let targetARN: String?
    public let initiatorName: String?
}

extension DeleteChapCredentialsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

extension DeleteChapCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChapCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChapCredentialsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChapCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChapCredentialsOutputResponse(initiatorName: \(String(describing: initiatorName)), targetARN: \(String(describing: targetARN)))"}
}

extension DeleteChapCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DeleteChapCredentialsOutputResponse: Equatable {
    /// <p>The iSCSI initiator that connects to the target.</p>
    public let initiatorName: String?
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    public let targetARN: String?

    public init (
        initiatorName: String? = nil,
        targetARN: String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct DeleteChapCredentialsOutputResponseBody: Equatable {
    public let targetARN: String?
    public let initiatorName: String?
}

extension DeleteChapCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

public struct DeleteFileShareInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileShareOutputError>
}

extension DeleteFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileShareInput(fileShareARN: \(String(describing: fileShareARN)), forceDelete: \(String(describing: forceDelete)))"}
}

extension DeleteFileShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DeleteFileShareInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileShareOutputError>
}

public struct DeleteFileShareInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileShareInput>
    public typealias MOutput = OperationOutput<DeleteFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileShareOutputError>
}

/// <p>DeleteFileShareInput</p>
public struct DeleteFileShareInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share to be deleted.</p>
    public let fileShareARN: String?
    /// <p>If this value is set to <code>true</code>, the operation deletes a file share
    ///          immediately and aborts all data uploads to AWS. Otherwise, the file share is not deleted
    ///          until all data is uploaded to AWS. This process aborts the data upload process, and the
    ///          file share enters the <code>FORCE_DELETING</code> status.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let forceDelete: Bool

    public init (
        fileShareARN: String? = nil,
        forceDelete: Bool = false
    )
    {
        self.fileShareARN = fileShareARN
        self.forceDelete = forceDelete
    }
}

struct DeleteFileShareInputBody: Equatable {
    public let fileShareARN: String?
    public let forceDelete: Bool
}

extension DeleteFileShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let forceDeleteDecoded = try containerValues.decode(Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFileShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileShareOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileShareOutputResponse(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension DeleteFileShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFileShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// <p>DeleteFileShareOutput</p>
public struct DeleteFileShareOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct DeleteFileShareOutputResponseBody: Equatable {
    public let fileShareARN: String?
}

extension DeleteFileShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct DeleteGatewayInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayOutputError>
}

extension DeleteGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DeleteGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayOutputError>
}

/// <p>A JSON object containing the ID of the gateway to delete.</p>
public struct DeleteGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayInputBody: Equatable {
    public let gatewayARN: String?
}

extension DeleteGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DeleteGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DeleteGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the ID of the deleted gateway.</p>
public struct DeleteGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DeleteGatewayOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension DeleteGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DeleteSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

extension DeleteSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotScheduleInput(volumeARN: \(String(describing: volumeARN)))"}
}

extension DeleteSnapshotScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DeleteSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DeleteSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSnapshotScheduleOutputError>
}

public struct DeleteSnapshotScheduleInput: Equatable {
    /// <p>The volume which snapshot schedule to delete.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleInputBody: Equatable {
    public let volumeARN: String?
}

extension DeleteSnapshotScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSnapshotScheduleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSnapshotScheduleOutputResponse(volumeARN: \(String(describing: volumeARN)))"}
}

extension DeleteSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

public struct DeleteSnapshotScheduleOutputResponse: Equatable {
    /// <p>The volume which snapshot schedule was deleted.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteSnapshotScheduleOutputResponseBody: Equatable {
    public let volumeARN: String?
}

extension DeleteSnapshotScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct DeleteTapeArchiveInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTapeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeArchiveOutputError>
}

extension DeleteTapeArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapeArchiveInput(bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), tapeARN: \(String(describing: tapeARN)))"}
}

extension DeleteTapeArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct DeleteTapeArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTapeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeArchiveOutputError>
}

public struct DeleteTapeArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTapeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeArchiveInput>
    public typealias MOutput = OperationOutput<DeleteTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeArchiveOutputError>
}

/// <p>DeleteTapeArchiveInput</p>
public struct DeleteTapeArchiveInput: Equatable {
    /// <p>Set to <code>TRUE</code> to delete an archived tape that belongs to a custom pool with
    ///          tape retention lock. Only archived tapes with tape retention lock set to
    ///             <code>governance</code> can be deleted. Archived tapes with tape retention lock set to
    ///             <code>compliance</code> can't be deleted.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf
    ///          (VTS).</p>
    public let tapeARN: String?

    public init (
        bypassGovernanceRetention: Bool = false,
        tapeARN: String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveInputBody: Equatable {
    public let tapeARN: String?
    public let bypassGovernanceRetention: Bool
}

extension DeleteTapeArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapeArchiveOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapeArchiveOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension DeleteTapeArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>DeleteTapeArchiveOutput</p>
public struct DeleteTapeArchiveOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the virtual tape that was deleted from the virtual
    ///          tape shelf (VTS).</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeArchiveOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension DeleteTapeArchiveOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct DeleteTapeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTapeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeOutputError>
}

extension DeleteTapeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapeInput(bypassGovernanceRetention: \(String(describing: bypassGovernanceRetention)), gatewayARN: \(String(describing: gatewayARN)), tapeARN: \(String(describing: tapeARN)))"}
}

extension DeleteTapeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bypassGovernanceRetention != false {
            try encodeContainer.encode(bypassGovernanceRetention, forKey: .bypassGovernanceRetention)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct DeleteTapeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTapeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeOutputError>
}

public struct DeleteTapeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTapeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapeInput>
    public typealias MOutput = OperationOutput<DeleteTapeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapeOutputError>
}

/// <p>DeleteTapeInput</p>
public struct DeleteTapeInput: Equatable {
    /// <p>Set to <code>TRUE</code> to delete an archived tape that belongs to a custom pool with
    ///          tape retention lock. Only archived tapes with tape retention lock set to
    ///             <code>governance</code> can be deleted. Archived tapes with tape retention lock set to
    ///             <code>compliance</code> can't be deleted.</p>
    public let bypassGovernanceRetention: Bool
    /// <p>The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is
    ///          associated with. Use the <a>ListGateways</a> operation to return a list of
    ///          gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape to delete.</p>
    public let tapeARN: String?

    public init (
        bypassGovernanceRetention: Bool = false,
        gatewayARN: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.bypassGovernanceRetention = bypassGovernanceRetention
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeARN: String?
    public let bypassGovernanceRetention: Bool
}

extension DeleteTapeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bypassGovernanceRetention = "BypassGovernanceRetention"
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let bypassGovernanceRetentionDecoded = try containerValues.decode(Bool.self, forKey: .bypassGovernanceRetention)
        bypassGovernanceRetention = bypassGovernanceRetentionDecoded
    }
}

extension DeleteTapeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapeOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension DeleteTapeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTapeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>DeleteTapeOutput</p>
public struct DeleteTapeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted virtual tape.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct DeleteTapeOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension DeleteTapeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct DeleteTapePoolInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTapePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapePoolOutputError>
}

extension DeleteTapePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapePoolInput(poolARN: \(String(describing: poolARN)))"}
}

extension DeleteTapePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case poolARN = "PoolARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
    }
}

public struct DeleteTapePoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTapePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapePoolOutputError>
}

public struct DeleteTapePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTapePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTapePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTapePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTapePoolInput>
    public typealias MOutput = OperationOutput<DeleteTapePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTapePoolOutputError>
}

public struct DeleteTapePoolInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom tape pool to delete.</p>
    public let poolARN: String?

    public init (
        poolARN: String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolInputBody: Equatable {
    public let poolARN: String?
}

extension DeleteTapePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

extension DeleteTapePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTapePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTapePoolOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTapePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTapePoolOutputResponse(poolARN: \(String(describing: poolARN)))"}
}

extension DeleteTapePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteTapePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.poolARN = output.poolARN
        } else {
            self.poolARN = nil
        }
    }
}

public struct DeleteTapePoolOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom tape pool being deleted.</p>
    public let poolARN: String?

    public init (
        poolARN: String? = nil
    )
    {
        self.poolARN = poolARN
    }
}

struct DeleteTapePoolOutputResponseBody: Equatable {
    public let poolARN: String?
}

extension DeleteTapePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case poolARN = "PoolARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
    }
}

public struct DeleteVolumeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVolumeOutputError>
}

extension DeleteVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVolumeInput(volumeARN: \(String(describing: volumeARN)))"}
}

extension DeleteVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DeleteVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVolumeOutputError>
}

public struct DeleteVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVolumeInput>
    public typealias MOutput = OperationOutput<DeleteVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVolumeOutputError>
}

/// <p>A JSON object containing the <a>DeleteVolumeInput$VolumeARN</a> to
///          delete.</p>
public struct DeleteVolumeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeInputBody: Equatable {
    public let volumeARN: String?
}

extension DeleteVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeleteVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVolumeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVolumeOutputResponse(volumeARN: \(String(describing: volumeARN)))"}
}

extension DeleteVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the storage volume that was
///          deleted.</p>
public struct DeleteVolumeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the storage volume that was deleted. It is the same
    ///          ARN you provided in the request.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DeleteVolumeOutputResponseBody: Equatable {
    public let volumeARN: String?
}

extension DeleteVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct DescribeAvailabilityMonitorTestInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityMonitorTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityMonitorTestOutputError>
}

extension DescribeAvailabilityMonitorTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailabilityMonitorTestInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeAvailabilityMonitorTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeAvailabilityMonitorTestInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityMonitorTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityMonitorTestOutputError>
}

public struct DescribeAvailabilityMonitorTestInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAvailabilityMonitorTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<DescribeAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailabilityMonitorTestOutputError>
}

public struct DescribeAvailabilityMonitorTestInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeAvailabilityMonitorTestInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeAvailabilityMonitorTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeAvailabilityMonitorTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailabilityMonitorTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailabilityMonitorTestOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailabilityMonitorTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailabilityMonitorTestOutputResponse(gatewayARN: \(String(describing: gatewayARN)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

extension DescribeAvailabilityMonitorTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.gatewayARN = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAvailabilityMonitorTestOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The time the high availability monitoring test was started. If a test hasn't been
    ///          performed, the value of this field is null.</p>
    public let startTime: Date?
    /// <p>The status of the high availability monitoring test. If a test hasn't been
    ///          performed, the value of this field is null.</p>
    public let status: AvailabilityMonitorTestStatus?

    public init (
        gatewayARN: String? = nil,
        startTime: Date? = nil,
        status: AvailabilityMonitorTestStatus? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeAvailabilityMonitorTestOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let status: AvailabilityMonitorTestStatus?
    public let startTime: Date?
}

extension DescribeAvailabilityMonitorTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AvailabilityMonitorTestStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

public struct DescribeBandwidthRateLimitInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitOutputError>
}

extension DescribeBandwidthRateLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBandwidthRateLimitInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeBandwidthRateLimitInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitOutputError>
}

public struct DescribeBandwidthRateLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway.</p>
public struct DescribeBandwidthRateLimitInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeBandwidthRateLimitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBandwidthRateLimitOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBandwidthRateLimitOutputResponse(averageDownloadRateLimitInBitsPerSec: \(String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(String(describing: averageUploadRateLimitInBitsPerSec)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.averageDownloadRateLimitInBitsPerSec = output.averageDownloadRateLimitInBitsPerSec
            self.averageUploadRateLimitInBitsPerSec = output.averageUploadRateLimitInBitsPerSec
            self.gatewayARN = output.gatewayARN
        } else {
            self.averageDownloadRateLimitInBitsPerSec = nil
            self.averageUploadRateLimitInBitsPerSec = nil
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DescribeBandwidthRateLimitOutputResponse: Equatable {
    /// <p>The average download bandwidth rate limit in bits per second. This field does not appear
    ///          in the response if the download rate limit is not set.</p>
    public let averageDownloadRateLimitInBitsPerSec: Int?
    /// <p>The average upload bandwidth rate limit in bits per second. This field does not appear
    ///          in the response if the upload rate limit is not set.</p>
    public let averageUploadRateLimitInBitsPerSec: Int?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Int? = nil,
        averageUploadRateLimitInBitsPerSec: Int? = nil,
        gatewayARN: String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let averageUploadRateLimitInBitsPerSec: Int?
    public let averageDownloadRateLimitInBitsPerSec: Int?
}

extension DescribeBandwidthRateLimitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

public struct DescribeBandwidthRateLimitScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

extension DescribeBandwidthRateLimitScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBandwidthRateLimitScheduleInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeBandwidthRateLimitScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

public struct DescribeBandwidthRateLimitScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBandwidthRateLimitScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<DescribeBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBandwidthRateLimitScheduleOutputError>
}

public struct DescribeBandwidthRateLimitScheduleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeBandwidthRateLimitScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBandwidthRateLimitScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBandwidthRateLimitScheduleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBandwidthRateLimitScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBandwidthRateLimitScheduleOutputResponse(bandwidthRateLimitIntervals: \(String(describing: bandwidthRateLimitIntervals)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeBandwidthRateLimitScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bandwidthRateLimitIntervals = output.bandwidthRateLimitIntervals
            self.gatewayARN = output.gatewayARN
        } else {
            self.bandwidthRateLimitIntervals = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeBandwidthRateLimitScheduleOutputResponse: Equatable {
    /// <p>
    ///          An array that contains the bandwidth rate limit intervals for a tape or volume gateway.
    ///       </p>
    public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct DescribeBandwidthRateLimitScheduleOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]?
}

extension DescribeBandwidthRateLimitScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

public struct DescribeCacheInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCacheOutputError>
}

extension DescribeCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCacheInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeCacheInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCacheOutputError>
}

public struct DescribeCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCacheInput>
    public typealias MOutput = OperationOutput<DescribeCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCacheOutputError>
}

public struct DescribeCacheInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCacheOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCacheOutputResponse(cacheAllocatedInBytes: \(String(describing: cacheAllocatedInBytes)), cacheDirtyPercentage: \(String(describing: cacheDirtyPercentage)), cacheHitPercentage: \(String(describing: cacheHitPercentage)), cacheMissPercentage: \(String(describing: cacheMissPercentage)), cacheUsedPercentage: \(String(describing: cacheUsedPercentage)), diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cacheAllocatedInBytes = output.cacheAllocatedInBytes
            self.cacheDirtyPercentage = output.cacheDirtyPercentage
            self.cacheHitPercentage = output.cacheHitPercentage
            self.cacheMissPercentage = output.cacheMissPercentage
            self.cacheUsedPercentage = output.cacheUsedPercentage
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
        } else {
            self.cacheAllocatedInBytes = 0
            self.cacheDirtyPercentage = 0.0
            self.cacheHitPercentage = 0.0
            self.cacheMissPercentage = 0.0
            self.cacheUsedPercentage = 0.0
            self.diskIds = nil
            self.gatewayARN = nil
        }
    }
}

public struct DescribeCacheOutputResponse: Equatable {
    /// <p>The amount of cache in bytes allocated to a gateway.</p>
    public let cacheAllocatedInBytes: Int
    /// <p>The file share's contribution to the overall percentage of the gateway's cache
    ///          that has not been persisted to AWS. The sample is taken at the end of the reporting
    ///          period.</p>
    public let cacheDirtyPercentage: Double
    /// <p>Percent of application read operations from the file shares that are served from cache.
    ///          The sample is taken at the end of the reporting period.</p>
    public let cacheHitPercentage: Double
    /// <p>Percent of application read operations from the file shares that are not served from
    ///          cache. The sample is taken at the end of the reporting period.</p>
    public let cacheMissPercentage: Double
    /// <p>Percent use of the gateway's cache storage. This metric applies only to the
    ///          gateway-cached volume setup. The sample is taken at the end of the reporting period.</p>
    public let cacheUsedPercentage: Double
    /// <p>An array of strings that identify disks that are to be configured as working storage.
    ///          Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
    ///          from the <a>ListLocalDisks</a> API.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        cacheAllocatedInBytes: Int = 0,
        cacheDirtyPercentage: Double = 0.0,
        cacheHitPercentage: Double = 0.0,
        cacheMissPercentage: Double = 0.0,
        cacheUsedPercentage: Double = 0.0,
        diskIds: [String]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.cacheAllocatedInBytes = cacheAllocatedInBytes
        self.cacheDirtyPercentage = cacheDirtyPercentage
        self.cacheHitPercentage = cacheHitPercentage
        self.cacheMissPercentage = cacheMissPercentage
        self.cacheUsedPercentage = cacheUsedPercentage
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
    }
}

struct DescribeCacheOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
    public let cacheAllocatedInBytes: Int
    public let cacheUsedPercentage: Double
    public let cacheDirtyPercentage: Double
    public let cacheHitPercentage: Double
    public let cacheMissPercentage: Double
}

extension DescribeCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheAllocatedInBytes = "CacheAllocatedInBytes"
        case cacheDirtyPercentage = "CacheDirtyPercentage"
        case cacheHitPercentage = "CacheHitPercentage"
        case cacheMissPercentage = "CacheMissPercentage"
        case cacheUsedPercentage = "CacheUsedPercentage"
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let cacheAllocatedInBytesDecoded = try containerValues.decode(Int.self, forKey: .cacheAllocatedInBytes)
        cacheAllocatedInBytes = cacheAllocatedInBytesDecoded
        let cacheUsedPercentageDecoded = try containerValues.decode(Double.self, forKey: .cacheUsedPercentage)
        cacheUsedPercentage = cacheUsedPercentageDecoded
        let cacheDirtyPercentageDecoded = try containerValues.decode(Double.self, forKey: .cacheDirtyPercentage)
        cacheDirtyPercentage = cacheDirtyPercentageDecoded
        let cacheHitPercentageDecoded = try containerValues.decode(Double.self, forKey: .cacheHitPercentage)
        cacheHitPercentage = cacheHitPercentageDecoded
        let cacheMissPercentageDecoded = try containerValues.decode(Double.self, forKey: .cacheMissPercentage)
        cacheMissPercentage = cacheMissPercentageDecoded
    }
}

public struct DescribeCachediSCSIVolumesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCachediSCSIVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCachediSCSIVolumesOutputError>
}

extension DescribeCachediSCSIVolumesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCachediSCSIVolumesInput(volumeARNs: \(String(describing: volumeARNs)))"}
}

extension DescribeCachediSCSIVolumesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearns0 in volumeARNs {
                try volumeARNsContainer.encode(volumearns0)
            }
        }
    }
}

public struct DescribeCachediSCSIVolumesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCachediSCSIVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCachediSCSIVolumesOutputError>
}

public struct DescribeCachediSCSIVolumesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCachediSCSIVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCachediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCachediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCachediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeCachediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCachediSCSIVolumesOutputError>
}

public struct DescribeCachediSCSIVolumesInput: Equatable {
    /// <p>An array of strings where each string represents the Amazon Resource Name (ARN) of a
    ///          cached volume. All of the specified cached volumes must be from the same gateway. Use <a>ListVolumes</a> to get volume ARNs for a gateway.</p>
    public let volumeARNs: [String]?

    public init (
        volumeARNs: [String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeCachediSCSIVolumesInputBody: Equatable {
    public let volumeARNs: [String]?
}

extension DescribeCachediSCSIVolumesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeCachediSCSIVolumesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCachediSCSIVolumesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCachediSCSIVolumesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCachediSCSIVolumesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCachediSCSIVolumesOutputResponse(cachediSCSIVolumes: \(String(describing: cachediSCSIVolumes)))"}
}

extension DescribeCachediSCSIVolumesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCachediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cachediSCSIVolumes = output.cachediSCSIVolumes
        } else {
            self.cachediSCSIVolumes = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DescribeCachediSCSIVolumesOutputResponse: Equatable {
    /// <p>An array of objects where each object contains metadata about one cached volume.</p>
    public let cachediSCSIVolumes: [CachediSCSIVolume]?

    public init (
        cachediSCSIVolumes: [CachediSCSIVolume]? = nil
    )
    {
        self.cachediSCSIVolumes = cachediSCSIVolumes
    }
}

struct DescribeCachediSCSIVolumesOutputResponseBody: Equatable {
    public let cachediSCSIVolumes: [CachediSCSIVolume]?
}

extension DescribeCachediSCSIVolumesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachediSCSIVolumes = "CachediSCSIVolumes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachediSCSIVolumesContainer = try containerValues.decodeIfPresent([CachediSCSIVolume?].self, forKey: .cachediSCSIVolumes)
        var cachediSCSIVolumesDecoded0:[CachediSCSIVolume]? = nil
        if let cachediSCSIVolumesContainer = cachediSCSIVolumesContainer {
            cachediSCSIVolumesDecoded0 = [CachediSCSIVolume]()
            for structure0 in cachediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    cachediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        cachediSCSIVolumes = cachediSCSIVolumesDecoded0
    }
}

public struct DescribeChapCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChapCredentialsOutputError>
}

extension DescribeChapCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChapCredentialsInput(targetARN: \(String(describing: targetARN)))"}
}

extension DescribeChapCredentialsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct DescribeChapCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChapCredentialsOutputError>
}

public struct DescribeChapCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChapCredentialsInput>
    public typealias MOutput = OperationOutput<DescribeChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChapCredentialsOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the iSCSI volume
///          target.</p>
public struct DescribeChapCredentialsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
    ///          specified VolumeARN.</p>
    public let targetARN: String?

    public init (
        targetARN: String? = nil
    )
    {
        self.targetARN = targetARN
    }
}

struct DescribeChapCredentialsInputBody: Equatable {
    public let targetARN: String?
}

extension DescribeChapCredentialsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetARN = "TargetARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
    }
}

extension DescribeChapCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChapCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChapCredentialsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChapCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChapCredentialsOutputResponse(chapCredentials: \(String(describing: chapCredentials)))"}
}

extension DescribeChapCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.chapCredentials = output.chapCredentials
        } else {
            self.chapCredentials = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DescribeChapCredentialsOutputResponse: Equatable {
    /// <p>An array of <a>ChapInfo</a> objects that represent CHAP credentials. Each
    ///          object in the array contains CHAP credential information for one target-initiator pair. If
    ///          no CHAP credentials are set, an empty array is returned. CHAP credential information is
    ///          provided in a JSON object with the following fields:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>InitiatorName</b>: The iSCSI initiator that connects to
    ///                the target.</p>
    ///
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SecretToAuthenticateInitiator</b>: The secret key that
    ///                the initiator (for example, the Windows client) must provide to participate in mutual
    ///                CHAP with the target.</p>
    ///
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SecretToAuthenticateTarget</b>: The secret key that the
    ///                target must provide to participate in mutual CHAP with the initiator (e.g. Windows
    ///                client).</p>
    ///
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TargetARN</b>: The Amazon Resource Name (ARN) of the
    ///                storage volume.</p>
    ///
    ///             </li>
    ///          </ul>
    public let chapCredentials: [ChapInfo]?

    public init (
        chapCredentials: [ChapInfo]? = nil
    )
    {
        self.chapCredentials = chapCredentials
    }
}

struct DescribeChapCredentialsOutputResponseBody: Equatable {
    public let chapCredentials: [ChapInfo]?
}

extension DescribeChapCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case chapCredentials = "ChapCredentials"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chapCredentialsContainer = try containerValues.decodeIfPresent([ChapInfo?].self, forKey: .chapCredentials)
        var chapCredentialsDecoded0:[ChapInfo]? = nil
        if let chapCredentialsContainer = chapCredentialsContainer {
            chapCredentialsDecoded0 = [ChapInfo]()
            for structure0 in chapCredentialsContainer {
                if let structure0 = structure0 {
                    chapCredentialsDecoded0?.append(structure0)
                }
            }
        }
        chapCredentials = chapCredentialsDecoded0
    }
}

public struct DescribeFileSystemAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAssociationsOutputError>
}

extension DescribeFileSystemAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemAssociationsInput(fileSystemAssociationARNList: \(String(describing: fileSystemAssociationARNList)))"}
}

extension DescribeFileSystemAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARNList = fileSystemAssociationARNList {
            var fileSystemAssociationARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemAssociationARNList)
            for filesystemassociationarnlist0 in fileSystemAssociationARNList {
                try fileSystemAssociationARNListContainer.encode(filesystemassociationarnlist0)
            }
        }
    }
}

public struct DescribeFileSystemAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAssociationsOutputError>
}

public struct DescribeFileSystemAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFileSystemAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFileSystemAssociationsOutputError>
}

public struct DescribeFileSystemAssociationsInput: Equatable {
    /// <p>An array containing the Amazon Resource Name (ARN) of each file system association to be described.</p>
    public let fileSystemAssociationARNList: [String]?

    public init (
        fileSystemAssociationARNList: [String]? = nil
    )
    {
        self.fileSystemAssociationARNList = fileSystemAssociationARNList
    }
}

struct DescribeFileSystemAssociationsInputBody: Equatable {
    public let fileSystemAssociationARNList: [String]?
}

extension DescribeFileSystemAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARNList = "FileSystemAssociationARNList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fileSystemAssociationARNList)
        var fileSystemAssociationARNListDecoded0:[String]? = nil
        if let fileSystemAssociationARNListContainer = fileSystemAssociationARNListContainer {
            fileSystemAssociationARNListDecoded0 = [String]()
            for string0 in fileSystemAssociationARNListContainer {
                if let string0 = string0 {
                    fileSystemAssociationARNListDecoded0?.append(string0)
                }
            }
        }
        fileSystemAssociationARNList = fileSystemAssociationARNListDecoded0
    }
}

extension DescribeFileSystemAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemAssociationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFileSystemAssociationsOutputResponse(fileSystemAssociationInfoList: \(String(describing: fileSystemAssociationInfoList)))"}
}

extension DescribeFileSystemAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemAssociationInfoList = output.fileSystemAssociationInfoList
        } else {
            self.fileSystemAssociationInfoList = nil
        }
    }
}

public struct DescribeFileSystemAssociationsOutputResponse: Equatable {
    /// <p>An array containing the <code>FileSystemAssociationInfo</code> data type of each file system association to be described.
    ///          </p>
    public let fileSystemAssociationInfoList: [FileSystemAssociationInfo]?

    public init (
        fileSystemAssociationInfoList: [FileSystemAssociationInfo]? = nil
    )
    {
        self.fileSystemAssociationInfoList = fileSystemAssociationInfoList
    }
}

struct DescribeFileSystemAssociationsOutputResponseBody: Equatable {
    public let fileSystemAssociationInfoList: [FileSystemAssociationInfo]?
}

extension DescribeFileSystemAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationInfoList = "FileSystemAssociationInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationInfoListContainer = try containerValues.decodeIfPresent([FileSystemAssociationInfo?].self, forKey: .fileSystemAssociationInfoList)
        var fileSystemAssociationInfoListDecoded0:[FileSystemAssociationInfo]? = nil
        if let fileSystemAssociationInfoListContainer = fileSystemAssociationInfoListContainer {
            fileSystemAssociationInfoListDecoded0 = [FileSystemAssociationInfo]()
            for structure0 in fileSystemAssociationInfoListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationInfoList = fileSystemAssociationInfoListDecoded0
    }
}

public struct DescribeGatewayInformationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeGatewayInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayInformationOutputError>
}

extension DescribeGatewayInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayInformationInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeGatewayInformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeGatewayInformationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGatewayInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayInformationOutputError>
}

public struct DescribeGatewayInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGatewayInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayInformationInput>
    public typealias MOutput = OperationOutput<DescribeGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayInformationOutputError>
}

/// <p>A JSON object containing the ID of the gateway.</p>
public struct DescribeGatewayInformationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeGatewayInformationInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeGatewayInformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeGatewayInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayInformationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayInformationOutputResponse(cloudWatchLogGroupARN: \(String(describing: cloudWatchLogGroupARN)), deprecationDate: \(String(describing: deprecationDate)), ec2InstanceId: \(String(describing: ec2InstanceId)), ec2InstanceRegion: \(String(describing: ec2InstanceRegion)), endpointType: \(String(describing: endpointType)), gatewayARN: \(String(describing: gatewayARN)), gatewayId: \(String(describing: gatewayId)), gatewayName: \(String(describing: gatewayName)), gatewayNetworkInterfaces: \(String(describing: gatewayNetworkInterfaces)), gatewayState: \(String(describing: gatewayState)), gatewayTimezone: \(String(describing: gatewayTimezone)), gatewayType: \(String(describing: gatewayType)), hostEnvironment: \(String(describing: hostEnvironment)), lastSoftwareUpdate: \(String(describing: lastSoftwareUpdate)), nextUpdateAvailabilityDate: \(String(describing: nextUpdateAvailabilityDate)), softwareUpdatesEndDate: \(String(describing: softwareUpdatesEndDate)), tags: \(String(describing: tags)), vPCEndpoint: \(String(describing: vPCEndpoint)))"}
}

extension DescribeGatewayInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudWatchLogGroupARN = output.cloudWatchLogGroupARN
            self.deprecationDate = output.deprecationDate
            self.ec2InstanceId = output.ec2InstanceId
            self.ec2InstanceRegion = output.ec2InstanceRegion
            self.endpointType = output.endpointType
            self.gatewayARN = output.gatewayARN
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayNetworkInterfaces = output.gatewayNetworkInterfaces
            self.gatewayState = output.gatewayState
            self.gatewayTimezone = output.gatewayTimezone
            self.gatewayType = output.gatewayType
            self.hostEnvironment = output.hostEnvironment
            self.lastSoftwareUpdate = output.lastSoftwareUpdate
            self.nextUpdateAvailabilityDate = output.nextUpdateAvailabilityDate
            self.softwareUpdatesEndDate = output.softwareUpdatesEndDate
            self.tags = output.tags
            self.vPCEndpoint = output.vPCEndpoint
        } else {
            self.cloudWatchLogGroupARN = nil
            self.deprecationDate = nil
            self.ec2InstanceId = nil
            self.ec2InstanceRegion = nil
            self.endpointType = nil
            self.gatewayARN = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayNetworkInterfaces = nil
            self.gatewayState = nil
            self.gatewayTimezone = nil
            self.gatewayType = nil
            self.hostEnvironment = nil
            self.lastSoftwareUpdate = nil
            self.nextUpdateAvailabilityDate = nil
            self.softwareUpdatesEndDate = nil
            self.tags = nil
            self.vPCEndpoint = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DescribeGatewayInformationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that is used to
    ///          monitor events in the gateway.</p>
    public let cloudWatchLogGroupARN: String?
    /// <p>Date after which this gateway will not receive software updates for new features and bug
    ///          fixes.</p>
    public let deprecationDate: String?
    /// <p>The ID of the Amazon EC2 instance that was used to launch the gateway.</p>
    public let ec2InstanceId: String?
    /// <p>The AWS Region where the Amazon EC2 instance is located.</p>
    public let ec2InstanceRegion: String?
    /// <p>The type of endpoint for your gateway.</p>
    ///
    ///          <p>Valid Values: <code>STANDARD</code> | <code>FIPS</code>
    ///          </p>
    public let endpointType: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The unique identifier assigned to your gateway during activation. This ID becomes part
    ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
    ///          operations.</p>
    public let gatewayId: String?
    /// <p>The name you configured for your gateway.</p>
    public let gatewayName: String?
    /// <p>A <a>NetworkInterface</a> array that contains descriptions of the gateway
    ///          network interfaces.</p>
    public let gatewayNetworkInterfaces: [NetworkInterface]?
    /// <p>A value that indicates the operating state of the gateway.</p>
    public let gatewayState: String?
    /// <p>A value that indicates the time zone configured for the gateway.</p>
    public let gatewayTimezone: String?
    /// <p>The type of the gateway.</p>
    public let gatewayType: String?
    /// <p>The type of hypervisor environment used by the host.</p>
    public let hostEnvironment: HostEnvironment?
    /// <p>The date on which the last software update was applied to the gateway. If the gateway
    ///          has never been updated, this field does not return a value in the response.</p>
    public let lastSoftwareUpdate: String?
    /// <p>The date on which an update to the gateway is available. This date is in the time zone
    ///          of the gateway. If the gateway is not available for an update this field is not returned in
    ///          the response.</p>
    public let nextUpdateAvailabilityDate: String?
    /// <p>Date after which this gateway will not receive software updates for new features.</p>
    public let softwareUpdatesEndDate: String?
    /// <p>A list of up to 50 tags assigned to the gateway, sorted alphabetically by key name. Each
    ///          tag is a key-value pair. For a gateway with more than 10 tags assigned, you can view all
    ///          tags using the <code>ListTagsForResource</code> API operation.</p>
    public let tags: [Tag]?
    /// <p>The configuration settings for the virtual private cloud (VPC) endpoint for your
    ///          gateway.</p>
    public let vPCEndpoint: String?

    public init (
        cloudWatchLogGroupARN: String? = nil,
        deprecationDate: String? = nil,
        ec2InstanceId: String? = nil,
        ec2InstanceRegion: String? = nil,
        endpointType: String? = nil,
        gatewayARN: String? = nil,
        gatewayId: String? = nil,
        gatewayName: String? = nil,
        gatewayNetworkInterfaces: [NetworkInterface]? = nil,
        gatewayState: String? = nil,
        gatewayTimezone: String? = nil,
        gatewayType: String? = nil,
        hostEnvironment: HostEnvironment? = nil,
        lastSoftwareUpdate: String? = nil,
        nextUpdateAvailabilityDate: String? = nil,
        softwareUpdatesEndDate: String? = nil,
        tags: [Tag]? = nil,
        vPCEndpoint: String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.deprecationDate = deprecationDate
        self.ec2InstanceId = ec2InstanceId
        self.ec2InstanceRegion = ec2InstanceRegion
        self.endpointType = endpointType
        self.gatewayARN = gatewayARN
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayNetworkInterfaces = gatewayNetworkInterfaces
        self.gatewayState = gatewayState
        self.gatewayTimezone = gatewayTimezone
        self.gatewayType = gatewayType
        self.hostEnvironment = hostEnvironment
        self.lastSoftwareUpdate = lastSoftwareUpdate
        self.nextUpdateAvailabilityDate = nextUpdateAvailabilityDate
        self.softwareUpdatesEndDate = softwareUpdatesEndDate
        self.tags = tags
        self.vPCEndpoint = vPCEndpoint
    }
}

struct DescribeGatewayInformationOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let gatewayId: String?
    public let gatewayName: String?
    public let gatewayTimezone: String?
    public let gatewayState: String?
    public let gatewayNetworkInterfaces: [NetworkInterface]?
    public let gatewayType: String?
    public let nextUpdateAvailabilityDate: String?
    public let lastSoftwareUpdate: String?
    public let ec2InstanceId: String?
    public let ec2InstanceRegion: String?
    public let tags: [Tag]?
    public let vPCEndpoint: String?
    public let cloudWatchLogGroupARN: String?
    public let hostEnvironment: HostEnvironment?
    public let endpointType: String?
    public let softwareUpdatesEndDate: String?
    public let deprecationDate: String?
}

extension DescribeGatewayInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case deprecationDate = "DeprecationDate"
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case endpointType = "EndpointType"
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayNetworkInterfaces = "GatewayNetworkInterfaces"
        case gatewayState = "GatewayState"
        case gatewayTimezone = "GatewayTimezone"
        case gatewayType = "GatewayType"
        case hostEnvironment = "HostEnvironment"
        case lastSoftwareUpdate = "LastSoftwareUpdate"
        case nextUpdateAvailabilityDate = "NextUpdateAvailabilityDate"
        case softwareUpdatesEndDate = "SoftwareUpdatesEndDate"
        case tags = "Tags"
        case vPCEndpoint = "VPCEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let gatewayStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayState)
        gatewayState = gatewayStateDecoded
        let gatewayNetworkInterfacesContainer = try containerValues.decodeIfPresent([NetworkInterface?].self, forKey: .gatewayNetworkInterfaces)
        var gatewayNetworkInterfacesDecoded0:[NetworkInterface]? = nil
        if let gatewayNetworkInterfacesContainer = gatewayNetworkInterfacesContainer {
            gatewayNetworkInterfacesDecoded0 = [NetworkInterface]()
            for structure0 in gatewayNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    gatewayNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        gatewayNetworkInterfaces = gatewayNetworkInterfacesDecoded0
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let nextUpdateAvailabilityDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextUpdateAvailabilityDate)
        nextUpdateAvailabilityDate = nextUpdateAvailabilityDateDecoded
        let lastSoftwareUpdateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSoftwareUpdate)
        lastSoftwareUpdate = lastSoftwareUpdateDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let vPCEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCEndpoint)
        vPCEndpoint = vPCEndpointDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
        let hostEnvironmentDecoded = try containerValues.decodeIfPresent(HostEnvironment.self, forKey: .hostEnvironment)
        hostEnvironment = hostEnvironmentDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let softwareUpdatesEndDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .softwareUpdatesEndDate)
        softwareUpdatesEndDate = softwareUpdatesEndDateDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
    }
}

public struct DescribeMaintenanceStartTimeInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceStartTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceStartTimeOutputError>
}

extension DescribeMaintenanceStartTimeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceStartTimeInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeMaintenanceStartTimeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeMaintenanceStartTimeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceStartTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceStartTimeOutputError>
}

public struct DescribeMaintenanceStartTimeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceStartTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceStartTimeOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway.</p>
public struct DescribeMaintenanceStartTimeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeMaintenanceStartTimeInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeMaintenanceStartTimeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeMaintenanceStartTimeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceStartTimeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceStartTimeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceStartTimeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceStartTimeOutputResponse(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), gatewayARN: \(String(describing: gatewayARN)), hourOfDay: \(String(describing: hourOfDay)), minuteOfHour: \(String(describing: minuteOfHour)), timezone: \(String(describing: timezone)))"}
}

extension DescribeMaintenanceStartTimeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dayOfMonth = output.dayOfMonth
            self.dayOfWeek = output.dayOfWeek
            self.gatewayARN = output.gatewayARN
            self.hourOfDay = output.hourOfDay
            self.minuteOfHour = output.minuteOfHour
            self.timezone = output.timezone
        } else {
            self.dayOfMonth = nil
            self.dayOfWeek = nil
            self.gatewayARN = nil
            self.hourOfDay = nil
            self.minuteOfHour = nil
            self.timezone = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>DescribeMaintenanceStartTimeOutput$DayOfMonth</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DescribeMaintenanceStartTimeOutput$DayOfWeek</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DescribeMaintenanceStartTimeOutput$HourOfDay</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DescribeMaintenanceStartTimeOutput$MinuteOfHour</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>DescribeMaintenanceStartTimeOutput$Timezone</a>
///                </p>
///             </li>
///          </ul>
public struct DescribeMaintenanceStartTimeOutputResponse: Equatable {
    /// <p>The day of the month component of the maintenance start time represented as an ordinal
    ///          number from 1 to 28, where 1 represents the first day of the month and 28 represents the
    ///          last day of the month.</p>
    public let dayOfMonth: Int?
    /// <p>An ordinal number between 0 and 6 that represents the day of the week, where 0
    ///          represents Sunday and 6 represents Saturday. The day of week is in the time zone of the
    ///          gateway.</p>
    public let dayOfWeek: Int?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The hour component of the maintenance start time represented as <i>hh</i>,
    ///          where <i>hh</i> is the hour (0 to 23). The hour of the day is in the time
    ///          zone of the gateway.</p>
    public let hourOfDay: Int?
    /// <p>The minute component of the maintenance start time represented as
    ///             <i>mm</i>, where <i>mm</i> is the minute (0 to 59). The
    ///          minute of the hour is in the time zone of the gateway.</p>
    public let minuteOfHour: Int?
    /// <p>A value that indicates the time zone that is set for the gateway. The start time and day
    ///          of week specified should be in the time zone of the gateway.</p>
    public let timezone: String?

    public init (
        dayOfMonth: Int? = nil,
        dayOfWeek: Int? = nil,
        gatewayARN: String? = nil,
        hourOfDay: Int? = nil,
        minuteOfHour: Int? = nil,
        timezone: String? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
        self.timezone = timezone
    }
}

struct DescribeMaintenanceStartTimeOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let hourOfDay: Int?
    public let minuteOfHour: Int?
    public let dayOfWeek: Int?
    public let dayOfMonth: Int?
    public let timezone: String?
}

extension DescribeMaintenanceStartTimeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
        case timezone = "Timezone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

public struct DescribeNFSFileSharesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNFSFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNFSFileSharesOutputError>
}

extension DescribeNFSFileSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNFSFileSharesInput(fileShareARNList: \(String(describing: fileShareARNList)))"}
}

extension DescribeNFSFileSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearnlist0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearnlist0)
            }
        }
    }
}

public struct DescribeNFSFileSharesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNFSFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNFSFileSharesOutputError>
}

public struct DescribeNFSFileSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNFSFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNFSFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNFSFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNFSFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeNFSFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNFSFileSharesOutputError>
}

/// <p>DescribeNFSFileSharesInput</p>
public struct DescribeNFSFileSharesInput: Equatable {
    /// <p>An array containing the Amazon Resource Name (ARN) of each file share to be
    ///          described.</p>
    public let fileShareARNList: [String]?

    public init (
        fileShareARNList: [String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeNFSFileSharesInputBody: Equatable {
    public let fileShareARNList: [String]?
}

extension DescribeNFSFileSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeNFSFileSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNFSFileSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNFSFileSharesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNFSFileSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNFSFileSharesOutputResponse(nFSFileShareInfoList: \(String(describing: nFSFileShareInfoList)))"}
}

extension DescribeNFSFileSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNFSFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nFSFileShareInfoList = output.nFSFileShareInfoList
        } else {
            self.nFSFileShareInfoList = nil
        }
    }
}

/// <p>DescribeNFSFileSharesOutput</p>
public struct DescribeNFSFileSharesOutputResponse: Equatable {
    /// <p>An array containing a description for each requested file share.</p>
    public let nFSFileShareInfoList: [NFSFileShareInfo]?

    public init (
        nFSFileShareInfoList: [NFSFileShareInfo]? = nil
    )
    {
        self.nFSFileShareInfoList = nFSFileShareInfoList
    }
}

struct DescribeNFSFileSharesOutputResponseBody: Equatable {
    public let nFSFileShareInfoList: [NFSFileShareInfo]?
}

extension DescribeNFSFileSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nFSFileShareInfoList = "NFSFileShareInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nFSFileShareInfoListContainer = try containerValues.decodeIfPresent([NFSFileShareInfo?].self, forKey: .nFSFileShareInfoList)
        var nFSFileShareInfoListDecoded0:[NFSFileShareInfo]? = nil
        if let nFSFileShareInfoListContainer = nFSFileShareInfoListContainer {
            nFSFileShareInfoListDecoded0 = [NFSFileShareInfo]()
            for structure0 in nFSFileShareInfoListContainer {
                if let structure0 = structure0 {
                    nFSFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        nFSFileShareInfoList = nFSFileShareInfoListDecoded0
    }
}

public struct DescribeSMBFileSharesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSMBFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBFileSharesOutputError>
}

extension DescribeSMBFileSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSMBFileSharesInput(fileShareARNList: \(String(describing: fileShareARNList)))"}
}

extension DescribeSMBFileSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARNList = fileShareARNList {
            var fileShareARNListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileShareARNList)
            for filesharearnlist0 in fileShareARNList {
                try fileShareARNListContainer.encode(filesharearnlist0)
            }
        }
    }
}

public struct DescribeSMBFileSharesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSMBFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBFileSharesOutputError>
}

public struct DescribeSMBFileSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSMBFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBFileSharesInput>
    public typealias MOutput = OperationOutput<DescribeSMBFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBFileSharesOutputError>
}

/// <p>DescribeSMBFileSharesInput</p>
public struct DescribeSMBFileSharesInput: Equatable {
    /// <p>An array containing the Amazon Resource Name (ARN) of each file share to be
    ///          described.</p>
    public let fileShareARNList: [String]?

    public init (
        fileShareARNList: [String]? = nil
    )
    {
        self.fileShareARNList = fileShareARNList
    }
}

struct DescribeSMBFileSharesInputBody: Equatable {
    public let fileShareARNList: [String]?
}

extension DescribeSMBFileSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARNList = "FileShareARNList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .fileShareARNList)
        var fileShareARNListDecoded0:[String]? = nil
        if let fileShareARNListContainer = fileShareARNListContainer {
            fileShareARNListDecoded0 = [String]()
            for string0 in fileShareARNListContainer {
                if let string0 = string0 {
                    fileShareARNListDecoded0?.append(string0)
                }
            }
        }
        fileShareARNList = fileShareARNListDecoded0
    }
}

extension DescribeSMBFileSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBFileSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSMBFileSharesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBFileSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSMBFileSharesOutputResponse(sMBFileShareInfoList: \(String(describing: sMBFileShareInfoList)))"}
}

extension DescribeSMBFileSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSMBFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sMBFileShareInfoList = output.sMBFileShareInfoList
        } else {
            self.sMBFileShareInfoList = nil
        }
    }
}

/// <p>DescribeSMBFileSharesOutput</p>
public struct DescribeSMBFileSharesOutputResponse: Equatable {
    /// <p>An array containing a description for each requested file share.</p>
    public let sMBFileShareInfoList: [SMBFileShareInfo]?

    public init (
        sMBFileShareInfoList: [SMBFileShareInfo]? = nil
    )
    {
        self.sMBFileShareInfoList = sMBFileShareInfoList
    }
}

struct DescribeSMBFileSharesOutputResponseBody: Equatable {
    public let sMBFileShareInfoList: [SMBFileShareInfo]?
}

extension DescribeSMBFileSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMBFileShareInfoList = "SMBFileShareInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMBFileShareInfoListContainer = try containerValues.decodeIfPresent([SMBFileShareInfo?].self, forKey: .sMBFileShareInfoList)
        var sMBFileShareInfoListDecoded0:[SMBFileShareInfo]? = nil
        if let sMBFileShareInfoListContainer = sMBFileShareInfoListContainer {
            sMBFileShareInfoListDecoded0 = [SMBFileShareInfo]()
            for structure0 in sMBFileShareInfoListContainer {
                if let structure0 = structure0 {
                    sMBFileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        sMBFileShareInfoList = sMBFileShareInfoListDecoded0
    }
}

public struct DescribeSMBSettingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSMBSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBSettingsOutputError>
}

extension DescribeSMBSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSMBSettingsInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeSMBSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeSMBSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSMBSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBSettingsOutputError>
}

public struct DescribeSMBSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSMBSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSMBSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSMBSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSMBSettingsInput>
    public typealias MOutput = OperationOutput<DescribeSMBSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSMBSettingsOutputError>
}

public struct DescribeSMBSettingsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeSMBSettingsInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeSMBSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeSMBSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSMBSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSMBSettingsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSMBSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSMBSettingsOutputResponse(activeDirectoryStatus: \(String(describing: activeDirectoryStatus)), domainName: \(String(describing: domainName)), fileSharesVisible: \(String(describing: fileSharesVisible)), gatewayARN: \(String(describing: gatewayARN)), sMBGuestPasswordSet: \(String(describing: sMBGuestPasswordSet)), sMBSecurityStrategy: \(String(describing: sMBSecurityStrategy)))"}
}

extension DescribeSMBSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSMBSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.domainName = output.domainName
            self.fileSharesVisible = output.fileSharesVisible
            self.gatewayARN = output.gatewayARN
            self.sMBGuestPasswordSet = output.sMBGuestPasswordSet
            self.sMBSecurityStrategy = output.sMBSecurityStrategy
        } else {
            self.activeDirectoryStatus = nil
            self.domainName = nil
            self.fileSharesVisible = nil
            self.gatewayARN = nil
            self.sMBGuestPasswordSet = nil
            self.sMBSecurityStrategy = nil
        }
    }
}

public struct DescribeSMBSettingsOutputResponse: Equatable {
    /// <p>Indicates the status of a gateway that is a member of the Active Directory
    ///          domain.</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACCESS_DENIED</code>: Indicates that the <code>JoinDomain</code> operation
    ///                failed due to an authentication error.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DETACHED</code>: Indicates that gateway is not joined to a domain.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JOINED</code>: Indicates that the gateway has successfully joined a
    ///                domain.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JOINING</code>: Indicates that a <code>JoinDomain</code> operation is in
    ///                progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NETWORK_ERROR</code>: Indicates that <code>JoinDomain</code> operation
    ///                failed due to a network or connectivity error.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TIMEOUT</code>: Indicates that the <code>JoinDomain</code> operation failed
    ///                because the operation didn't complete within the allotted time.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN_ERROR</code>: Indicates that the <code>JoinDomain</code> operation
    ///                failed due to another type of error.</p>
    ///             </li>
    ///          </ul>
    public let activeDirectoryStatus: ActiveDirectoryStatus?
    /// <p>The name of the domain that the gateway is joined to.</p>
    public let domainName: String?
    /// <p>The shares on this gateway appear when listing shares.</p>
    public let fileSharesVisible: Bool?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>This value is <code>true</code> if a password for the guest user <code>smbguest</code>
    ///          is set, otherwise <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let sMBGuestPasswordSet: Bool?
    /// <p>The type of security strategy that was specified for file gateway.</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ClientSpecified</code>: If you use this option, requests are established
    ///                based on what is negotiated by the client. This option is recommended when you want
    ///                to maximize compatibility across different clients in your environment.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MandatorySigning</code>: If you use this option, file gateway only allows
    ///                connections from SMBv2 or SMBv3 clients that have signing enabled. This option works
    ///                with SMB clients on Microsoft Windows Vista, Windows Server 2008 or newer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MandatoryEncryption</code>: If you use this option, file gateway only allows
    ///                connections from SMBv3 clients that have encryption enabled. This option is highly
    ///                recommended for environments that handle sensitive data. This option works with SMB
    ///                clients on Microsoft Windows 8, Windows Server 2012 or newer.</p>
    ///             </li>
    ///          </ul>
    public let sMBSecurityStrategy: SMBSecurityStrategy?

    public init (
        activeDirectoryStatus: ActiveDirectoryStatus? = nil,
        domainName: String? = nil,
        fileSharesVisible: Bool? = nil,
        gatewayARN: String? = nil,
        sMBGuestPasswordSet: Bool? = nil,
        sMBSecurityStrategy: SMBSecurityStrategy? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.domainName = domainName
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
        self.sMBGuestPasswordSet = sMBGuestPasswordSet
        self.sMBSecurityStrategy = sMBSecurityStrategy
    }
}

struct DescribeSMBSettingsOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let domainName: String?
    public let activeDirectoryStatus: ActiveDirectoryStatus?
    public let sMBGuestPasswordSet: Bool?
    public let sMBSecurityStrategy: SMBSecurityStrategy?
    public let fileSharesVisible: Bool?
}

extension DescribeSMBSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case domainName = "DomainName"
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
        case sMBGuestPasswordSet = "SMBGuestPasswordSet"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
        let sMBGuestPasswordSetDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sMBGuestPasswordSet)
        sMBGuestPasswordSet = sMBGuestPasswordSetDecoded
        let sMBSecurityStrategyDecoded = try containerValues.decodeIfPresent(SMBSecurityStrategy.self, forKey: .sMBSecurityStrategy)
        sMBSecurityStrategy = sMBSecurityStrategyDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
    }
}

public struct DescribeSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotScheduleOutputError>
}

extension DescribeSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotScheduleInput(volumeARN: \(String(describing: volumeARN)))"}
}

extension DescribeSnapshotScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DescribeSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotScheduleOutputError>
}

public struct DescribeSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<DescribeSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSnapshotScheduleOutputError>
}

/// <p>A JSON object containing the <a>DescribeSnapshotScheduleInput$VolumeARN</a>
///          of the volume.</p>
public struct DescribeSnapshotScheduleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleInputBody: Equatable {
    public let volumeARN: String?
}

extension DescribeSnapshotScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DescribeSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSnapshotScheduleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSnapshotScheduleOutputResponse(description: \(String(describing: description)), recurrenceInHours: \(String(describing: recurrenceInHours)), startAt: \(String(describing: startAt)), tags: \(String(describing: tags)), timezone: \(String(describing: timezone)), volumeARN: \(String(describing: volumeARN)))"}
}

extension DescribeSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.recurrenceInHours = output.recurrenceInHours
            self.startAt = output.startAt
            self.tags = output.tags
            self.timezone = output.timezone
            self.volumeARN = output.volumeARN
        } else {
            self.description = nil
            self.recurrenceInHours = nil
            self.startAt = nil
            self.tags = nil
            self.timezone = nil
            self.volumeARN = nil
        }
    }
}

public struct DescribeSnapshotScheduleOutputResponse: Equatable {
    /// <p>The snapshot description.</p>
    public let description: String?
    /// <p>The number of hours between snapshots.</p>
    public let recurrenceInHours: Int?
    /// <p>The hour of the day at which the snapshot schedule begins represented as
    ///             <i>hh</i>, where <i>hh</i> is the hour (0 to 23). The hour
    ///          of the day is in the time zone of the gateway.</p>
    public let startAt: Int?
    /// <p>A list of up to 50 tags assigned to the snapshot schedule, sorted alphabetically by key
    ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
    ///          view all tags using the <code>ListTagsForResource</code> API operation.</p>
    public let tags: [Tag]?
    /// <p>A value that indicates the time zone of the gateway.</p>
    public let timezone: String?
    /// <p>The Amazon Resource Name (ARN) of the volume that was specified in the request.</p>
    public let volumeARN: String?

    public init (
        description: String? = nil,
        recurrenceInHours: Int? = nil,
        startAt: Int? = nil,
        tags: [Tag]? = nil,
        timezone: String? = nil,
        volumeARN: String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.timezone = timezone
        self.volumeARN = volumeARN
    }
}

struct DescribeSnapshotScheduleOutputResponseBody: Equatable {
    public let volumeARN: String?
    public let startAt: Int?
    public let recurrenceInHours: Int?
    public let description: String?
    public let timezone: String?
    public let tags: [Tag]?
}

extension DescribeSnapshotScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case timezone = "Timezone"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeStorediSCSIVolumesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStorediSCSIVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorediSCSIVolumesOutputError>
}

extension DescribeStorediSCSIVolumesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStorediSCSIVolumesInput(volumeARNs: \(String(describing: volumeARNs)))"}
}

extension DescribeStorediSCSIVolumesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARNs = volumeARNs {
            var volumeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeARNs)
            for volumearns0 in volumeARNs {
                try volumeARNsContainer.encode(volumearns0)
            }
        }
    }
}

public struct DescribeStorediSCSIVolumesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStorediSCSIVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorediSCSIVolumesOutputError>
}

public struct DescribeStorediSCSIVolumesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStorediSCSIVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStorediSCSIVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStorediSCSIVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStorediSCSIVolumesInput>
    public typealias MOutput = OperationOutput<DescribeStorediSCSIVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStorediSCSIVolumesOutputError>
}

/// <p>A JSON object containing a list of <a>DescribeStorediSCSIVolumesInput$VolumeARNs</a>.</p>
public struct DescribeStorediSCSIVolumesInput: Equatable {
    /// <p>An array of strings where each string represents the Amazon Resource Name (ARN) of a
    ///          stored volume. All of the specified stored volumes must be from the same gateway. Use <a>ListVolumes</a> to get volume ARNs for a gateway.</p>
    public let volumeARNs: [String]?

    public init (
        volumeARNs: [String]? = nil
    )
    {
        self.volumeARNs = volumeARNs
    }
}

struct DescribeStorediSCSIVolumesInputBody: Equatable {
    public let volumeARNs: [String]?
}

extension DescribeStorediSCSIVolumesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARNs = "VolumeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .volumeARNs)
        var volumeARNsDecoded0:[String]? = nil
        if let volumeARNsContainer = volumeARNsContainer {
            volumeARNsDecoded0 = [String]()
            for string0 in volumeARNsContainer {
                if let string0 = string0 {
                    volumeARNsDecoded0?.append(string0)
                }
            }
        }
        volumeARNs = volumeARNsDecoded0
    }
}

extension DescribeStorediSCSIVolumesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStorediSCSIVolumesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStorediSCSIVolumesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorediSCSIVolumesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStorediSCSIVolumesOutputResponse(storediSCSIVolumes: \(String(describing: storediSCSIVolumes)))"}
}

extension DescribeStorediSCSIVolumesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStorediSCSIVolumesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.storediSCSIVolumes = output.storediSCSIVolumes
        } else {
            self.storediSCSIVolumes = nil
        }
    }
}

public struct DescribeStorediSCSIVolumesOutputResponse: Equatable {
    /// <p>Describes a single unit of output from <a>DescribeStorediSCSIVolumes</a>. The
    ///          following fields are returned:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ChapEnabled</code>: Indicates whether mutual CHAP is enabled for the iSCSI
    ///                target.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LunNumber</code>: The logical disk number.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetworkInterfaceId</code>: The network interface ID of the stored volume that
    ///                initiator use to map the stored volume as an iSCSI target.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetworkInterfacePort</code>: The port used to communicate with iSCSI
    ///                targets.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PreservedExistingData</code>: Indicates when the stored volume was created,
    ///                existing data on the underlying local disk was preserved.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SourceSnapshotId</code>: If the stored volume was created from a snapshot, this
    ///                field contains the snapshot ID used, e.g. <code>snap-1122aabb</code>. Otherwise, this
    ///                field is not included.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>StorediSCSIVolumes</code>: An array of StorediSCSIVolume objects where each
    ///                object contains metadata about one stored volume.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TargetARN</code>: The Amazon Resource Name (ARN) of the volume target.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeARN</code>: The Amazon Resource Name (ARN) of the stored volume.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeDiskId</code>: The disk ID of the local disk that was specified in the
    ///                   <a>CreateStorediSCSIVolume</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeId</code>: The unique identifier of the storage volume, e.g.
    ///                   <code>vol-1122AABB</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeiSCSIAttributes</code>: An <a>VolumeiSCSIAttributes</a> object
    ///                that represents a collection of iSCSI attributes for one stored volume.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeProgress</code>: Represents the percentage complete if the volume is
    ///                restoring or bootstrapping that represents the percent of data transferred. This
    ///                field does not appear in the response if the stored volume is not restoring or
    ///                bootstrapping.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeSizeInBytes</code>: The size of the volume in bytes.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeStatus</code>: One of the <code>VolumeStatus</code> values that indicates
    ///                the state of the volume.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VolumeType</code>: One of the enumeration values describing the type of the
    ///                volume. Currently, only <code>STORED</code> volumes are supported.</p>
    ///             </li>
    ///          </ul>
    public let storediSCSIVolumes: [StorediSCSIVolume]?

    public init (
        storediSCSIVolumes: [StorediSCSIVolume]? = nil
    )
    {
        self.storediSCSIVolumes = storediSCSIVolumes
    }
}

struct DescribeStorediSCSIVolumesOutputResponseBody: Equatable {
    public let storediSCSIVolumes: [StorediSCSIVolume]?
}

extension DescribeStorediSCSIVolumesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storediSCSIVolumes = "StorediSCSIVolumes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storediSCSIVolumesContainer = try containerValues.decodeIfPresent([StorediSCSIVolume?].self, forKey: .storediSCSIVolumes)
        var storediSCSIVolumesDecoded0:[StorediSCSIVolume]? = nil
        if let storediSCSIVolumesContainer = storediSCSIVolumesContainer {
            storediSCSIVolumesDecoded0 = [StorediSCSIVolume]()
            for structure0 in storediSCSIVolumesContainer {
                if let structure0 = structure0 {
                    storediSCSIVolumesDecoded0?.append(structure0)
                }
            }
        }
        storediSCSIVolumes = storediSCSIVolumesDecoded0
    }
}

public struct DescribeTapeArchivesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTapeArchivesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeArchivesOutputError>
}

extension DescribeTapeArchivesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapeArchivesInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), tapeARNs: \(String(describing: tapeARNs)))"}
}

extension DescribeTapeArchivesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct DescribeTapeArchivesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTapeArchivesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeArchivesOutputError>
}

public struct DescribeTapeArchivesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTapeArchivesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeArchivesInput>
    public typealias MOutput = OperationOutput<DescribeTapeArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeArchivesOutputError>
}

/// <p>DescribeTapeArchivesInput</p>
public struct DescribeTapeArchivesInput: Equatable {
    /// <p>Specifies that the number of virtual tapes described be limited to the specified
    ///          number.</p>
    public let limit: Int?
    /// <p>An opaque string that indicates the position at which to begin describing virtual
    ///          tapes.</p>
    public let marker: String?
    /// <p>Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
    ///          tapes you want to describe.</p>
    public let tapeARNs: [String]?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        tapeARNs: [String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapeArchivesInputBody: Equatable {
    public let tapeARNs: [String]?
    public let marker: String?
    public let limit: Int?
}

extension DescribeTapeArchivesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeArchivesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeArchivesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapeArchivesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeArchivesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapeArchivesOutputResponse(marker: \(String(describing: marker)), tapeArchives: \(String(describing: tapeArchives)))"}
}

extension DescribeTapeArchivesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTapeArchivesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.tapeArchives = output.tapeArchives
        } else {
            self.marker = nil
            self.tapeArchives = nil
        }
    }
}

/// <p>DescribeTapeArchivesOutput</p>
public struct DescribeTapeArchivesOutputResponse: Equatable {
    /// <p>An opaque string that indicates the position at which the virtual tapes that were
    ///          fetched for description ended. Use this marker in your next request to fetch the next set
    ///          of virtual tapes in the virtual tape shelf (VTS). If there are no more virtual tapes to
    ///          describe, this field does not appear in the response.</p>
    public let marker: String?
    /// <p>An array of virtual tape objects in the virtual tape shelf (VTS). The description
    ///          includes of the Amazon Resource Name (ARN) of the virtual tapes. The information returned
    ///          includes the Amazon Resource Names (ARNs) of the tapes, size of the tapes, status of the
    ///          tapes, progress of the description, and tape barcode.</p>
    public let tapeArchives: [TapeArchive]?

    public init (
        marker: String? = nil,
        tapeArchives: [TapeArchive]? = nil
    )
    {
        self.marker = marker
        self.tapeArchives = tapeArchives
    }
}

struct DescribeTapeArchivesOutputResponseBody: Equatable {
    public let tapeArchives: [TapeArchive]?
    public let marker: String?
}

extension DescribeTapeArchivesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case tapeArchives = "TapeArchives"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeArchivesContainer = try containerValues.decodeIfPresent([TapeArchive?].self, forKey: .tapeArchives)
        var tapeArchivesDecoded0:[TapeArchive]? = nil
        if let tapeArchivesContainer = tapeArchivesContainer {
            tapeArchivesDecoded0 = [TapeArchive]()
            for structure0 in tapeArchivesContainer {
                if let structure0 = structure0 {
                    tapeArchivesDecoded0?.append(structure0)
                }
            }
        }
        tapeArchives = tapeArchivesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTapeRecoveryPointsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTapeRecoveryPointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeRecoveryPointsOutputError>
}

extension DescribeTapeRecoveryPointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapeRecoveryPointsInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension DescribeTapeRecoveryPointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct DescribeTapeRecoveryPointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTapeRecoveryPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeRecoveryPointsOutputError>
}

public struct DescribeTapeRecoveryPointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTapeRecoveryPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<DescribeTapeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapeRecoveryPointsOutputError>
}

/// <p>DescribeTapeRecoveryPointsInput</p>
public struct DescribeTapeRecoveryPointsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Specifies that the number of virtual tape recovery points that are described be limited
    ///          to the specified number.</p>
    public let limit: Int?
    /// <p>An opaque string that indicates the position at which to begin describing the virtual
    ///          tape recovery points.</p>
    public let marker: String?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeTapeRecoveryPointsInputBody: Equatable {
    public let gatewayARN: String?
    public let marker: String?
    public let limit: Int?
}

extension DescribeTapeRecoveryPointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapeRecoveryPointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapeRecoveryPointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapeRecoveryPointsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapeRecoveryPointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapeRecoveryPointsOutputResponse(gatewayARN: \(String(describing: gatewayARN)), marker: \(String(describing: marker)), tapeRecoveryPointInfos: \(String(describing: tapeRecoveryPointInfos)))"}
}

extension DescribeTapeRecoveryPointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTapeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.tapeRecoveryPointInfos = output.tapeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.tapeRecoveryPointInfos = nil
        }
    }
}

/// <p>DescribeTapeRecoveryPointsOutput</p>
public struct DescribeTapeRecoveryPointsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>An opaque string that indicates the position at which the virtual tape recovery points
    ///          that were listed for description ended.</p>
    ///
    ///          <p>Use this marker in your next request to list the next set of virtual tape recovery
    ///          points in the list. If there are no more recovery points to describe, this field does not
    ///          appear in the response.</p>
    public let marker: String?
    /// <p>An array of TapeRecoveryPointInfos that are available for the specified gateway.</p>
    public let tapeRecoveryPointInfos: [TapeRecoveryPointInfo]?

    public init (
        gatewayARN: String? = nil,
        marker: String? = nil,
        tapeRecoveryPointInfos: [TapeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.tapeRecoveryPointInfos = tapeRecoveryPointInfos
    }
}

struct DescribeTapeRecoveryPointsOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let tapeRecoveryPointInfos: [TapeRecoveryPointInfo]?
    public let marker: String?
}

extension DescribeTapeRecoveryPointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case tapeRecoveryPointInfos = "TapeRecoveryPointInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([TapeRecoveryPointInfo?].self, forKey: .tapeRecoveryPointInfos)
        var tapeRecoveryPointInfosDecoded0:[TapeRecoveryPointInfo]? = nil
        if let tapeRecoveryPointInfosContainer = tapeRecoveryPointInfosContainer {
            tapeRecoveryPointInfosDecoded0 = [TapeRecoveryPointInfo]()
            for structure0 in tapeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    tapeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeRecoveryPointInfos = tapeRecoveryPointInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeTapesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapesOutputError>
}

extension DescribeTapesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapesInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), tapeARNs: \(String(describing: tapeARNs)))"}
}

extension DescribeTapesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct DescribeTapesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapesOutputError>
}

public struct DescribeTapesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTapesInput>
    public typealias MOutput = OperationOutput<DescribeTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTapesOutputError>
}

/// <p>DescribeTapesInput</p>
public struct DescribeTapesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Specifies that the number of virtual tapes described be limited to the specified
    ///          number.</p>
    ///
    ///          <note>
    ///             <p>Amazon Web Services may impose its own limit, if this field is not set.</p>
    ///          </note>
    public let limit: Int?
    /// <p>A marker value, obtained in a previous call to <code>DescribeTapes</code>. This marker
    ///          indicates which page of results to retrieve.</p>
    ///
    ///          <p>If not specified, the first page of results is retrieved.</p>
    public let marker: String?
    /// <p>Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
    ///          tapes you want to describe. If this parameter is not specified, Tape gateway returns a
    ///          description of all virtual tapes associated with the specified gateway.</p>
    public let tapeARNs: [String]?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        tapeARNs: [String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct DescribeTapesInputBody: Equatable {
    public let gatewayARN: String?
    public let tapeARNs: [String]?
    public let marker: String?
    public let limit: Int?
}

extension DescribeTapesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tapeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeTapesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTapesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTapesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTapesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTapesOutputResponse(marker: \(String(describing: marker)), tapes: \(String(describing: tapes)))"}
}

extension DescribeTapesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTapesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.tapes = output.tapes
        } else {
            self.marker = nil
            self.tapes = nil
        }
    }
}

/// <p>DescribeTapesOutput</p>
public struct DescribeTapesOutputResponse: Equatable {
    /// <p>An opaque string that can be used as part of a subsequent <code>DescribeTapes</code>
    ///          call to retrieve the next page of results.</p>
    ///
    ///          <p>If a response does not contain a marker, then there are no more results to be
    ///          retrieved.</p>
    public let marker: String?
    /// <p>An array of virtual tape descriptions.</p>
    public let tapes: [Tape]?

    public init (
        marker: String? = nil,
        tapes: [Tape]? = nil
    )
    {
        self.marker = marker
        self.tapes = tapes
    }
}

struct DescribeTapesOutputResponseBody: Equatable {
    public let tapes: [Tape]?
    public let marker: String?
}

extension DescribeTapesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case tapes = "Tapes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapesContainer = try containerValues.decodeIfPresent([Tape?].self, forKey: .tapes)
        var tapesDecoded0:[Tape]? = nil
        if let tapesContainer = tapesContainer {
            tapesDecoded0 = [Tape]()
            for structure0 in tapesContainer {
                if let structure0 = structure0 {
                    tapesDecoded0?.append(structure0)
                }
            }
        }
        tapes = tapesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeUploadBufferInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUploadBufferInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUploadBufferOutputError>
}

extension DescribeUploadBufferInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUploadBufferInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeUploadBufferInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeUploadBufferInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUploadBufferInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUploadBufferOutputError>
}

public struct DescribeUploadBufferInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUploadBufferInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUploadBufferInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUploadBufferOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUploadBufferInput>
    public typealias MOutput = OperationOutput<DescribeUploadBufferOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUploadBufferOutputError>
}

public struct DescribeUploadBufferInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeUploadBufferInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeUploadBufferInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeUploadBufferOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUploadBufferOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUploadBufferOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUploadBufferOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUploadBufferOutputResponse(diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)), uploadBufferAllocatedInBytes: \(String(describing: uploadBufferAllocatedInBytes)), uploadBufferUsedInBytes: \(String(describing: uploadBufferUsedInBytes)))"}
}

extension DescribeUploadBufferOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUploadBufferOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.uploadBufferAllocatedInBytes = output.uploadBufferAllocatedInBytes
            self.uploadBufferUsedInBytes = output.uploadBufferUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.uploadBufferAllocatedInBytes = 0
            self.uploadBufferUsedInBytes = 0
        }
    }
}

public struct DescribeUploadBufferOutputResponse: Equatable {
    /// <p>An array of the gateway's local disk IDs that are configured as working storage.
    ///          Each local disk ID is specified as a string (minimum length of 1 and maximum length of
    ///          300). If no local disks are configured as working storage, then the DiskIds array is
    ///          empty.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The total number of bytes allocated in the gateway's as upload buffer.</p>
    public let uploadBufferAllocatedInBytes: Int
    /// <p>The total number of bytes being used in the gateway's upload buffer.</p>
    public let uploadBufferUsedInBytes: Int

    public init (
        diskIds: [String]? = nil,
        gatewayARN: String? = nil,
        uploadBufferAllocatedInBytes: Int = 0,
        uploadBufferUsedInBytes: Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes
        self.uploadBufferUsedInBytes = uploadBufferUsedInBytes
    }
}

struct DescribeUploadBufferOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
    public let uploadBufferUsedInBytes: Int
    public let uploadBufferAllocatedInBytes: Int
}

extension DescribeUploadBufferOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case uploadBufferAllocatedInBytes = "UploadBufferAllocatedInBytes"
        case uploadBufferUsedInBytes = "UploadBufferUsedInBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let uploadBufferUsedInBytesDecoded = try containerValues.decode(Int.self, forKey: .uploadBufferUsedInBytes)
        uploadBufferUsedInBytes = uploadBufferUsedInBytesDecoded
        let uploadBufferAllocatedInBytesDecoded = try containerValues.decode(Int.self, forKey: .uploadBufferAllocatedInBytes)
        uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytesDecoded
    }
}

public struct DescribeVTLDevicesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeVTLDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVTLDevicesOutputError>
}

extension DescribeVTLDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVTLDevicesInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), vTLDeviceARNs: \(String(describing: vTLDeviceARNs)))"}
}

extension DescribeVTLDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vTLDeviceARNs = "VTLDeviceARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let vTLDeviceARNs = vTLDeviceARNs {
            var vTLDeviceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vTLDeviceARNs)
            for vtldevicearns0 in vTLDeviceARNs {
                try vTLDeviceARNsContainer.encode(vtldevicearns0)
            }
        }
    }
}

public struct DescribeVTLDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVTLDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVTLDevicesOutputError>
}

public struct DescribeVTLDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVTLDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVTLDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVTLDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVTLDevicesInput>
    public typealias MOutput = OperationOutput<DescribeVTLDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVTLDevicesOutputError>
}

/// <p>DescribeVTLDevicesInput</p>
public struct DescribeVTLDevicesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Specifies that the number of VTL devices described be limited to the specified
    ///          number.</p>
    public let limit: Int?
    /// <p>An opaque string that indicates the position at which to begin describing the VTL
    ///          devices.</p>
    public let marker: String?
    /// <p>An array of strings, where each string represents the Amazon Resource Name (ARN) of a
    ///          VTL device.</p>
    ///
    ///          <note>
    ///             <p>All of the specified VTL devices must be from the same gateway. If no VTL devices are
    ///             specified, the result will contain all devices on the specified gateway.</p>
    ///          </note>
    public let vTLDeviceARNs: [String]?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        vTLDeviceARNs: [String]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
        self.vTLDeviceARNs = vTLDeviceARNs
    }
}

struct DescribeVTLDevicesInputBody: Equatable {
    public let gatewayARN: String?
    public let vTLDeviceARNs: [String]?
    public let marker: String?
    public let limit: Int?
}

extension DescribeVTLDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
        case vTLDeviceARNs = "VTLDeviceARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vTLDeviceARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vTLDeviceARNs)
        var vTLDeviceARNsDecoded0:[String]? = nil
        if let vTLDeviceARNsContainer = vTLDeviceARNsContainer {
            vTLDeviceARNsDecoded0 = [String]()
            for string0 in vTLDeviceARNsContainer {
                if let string0 = string0 {
                    vTLDeviceARNsDecoded0?.append(string0)
                }
            }
        }
        vTLDeviceARNs = vTLDeviceARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeVTLDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVTLDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVTLDevicesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVTLDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVTLDevicesOutputResponse(gatewayARN: \(String(describing: gatewayARN)), marker: \(String(describing: marker)), vTLDevices: \(String(describing: vTLDevices)))"}
}

extension DescribeVTLDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVTLDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.vTLDevices = output.vTLDevices
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.vTLDevices = nil
        }
    }
}

/// <p>DescribeVTLDevicesOutput</p>
public struct DescribeVTLDevicesOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>An opaque string that indicates the position at which the VTL devices that were fetched
    ///          for description ended. Use the marker in your next request to fetch the next set of VTL
    ///          devices in the list. If there are no more VTL devices to describe, this field does not
    ///          appear in the response.</p>
    public let marker: String?
    /// <p>An array of VTL device objects composed of the Amazon Resource Name (ARN) of the VTL
    ///          devices.</p>
    public let vTLDevices: [VTLDevice]?

    public init (
        gatewayARN: String? = nil,
        marker: String? = nil,
        vTLDevices: [VTLDevice]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.vTLDevices = vTLDevices
    }
}

struct DescribeVTLDevicesOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let vTLDevices: [VTLDevice]?
    public let marker: String?
}

extension DescribeVTLDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case vTLDevices = "VTLDevices"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let vTLDevicesContainer = try containerValues.decodeIfPresent([VTLDevice?].self, forKey: .vTLDevices)
        var vTLDevicesDecoded0:[VTLDevice]? = nil
        if let vTLDevicesContainer = vTLDevicesContainer {
            vTLDevicesDecoded0 = [VTLDevice]()
            for structure0 in vTLDevicesContainer {
                if let structure0 = structure0 {
                    vTLDevicesDecoded0?.append(structure0)
                }
            }
        }
        vTLDevices = vTLDevicesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeWorkingStorageInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWorkingStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkingStorageOutputError>
}

extension DescribeWorkingStorageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkingStorageInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DescribeWorkingStorageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DescribeWorkingStorageInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkingStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkingStorageOutputError>
}

public struct DescribeWorkingStorageInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkingStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkingStorageInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkingStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkingStorageInput>
    public typealias MOutput = OperationOutput<DescribeWorkingStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkingStorageOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway.</p>
public struct DescribeWorkingStorageInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DescribeWorkingStorageInputBody: Equatable {
    public let gatewayARN: String?
}

extension DescribeWorkingStorageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DescribeWorkingStorageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkingStorageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkingStorageOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkingStorageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkingStorageOutputResponse(diskIds: \(String(describing: diskIds)), gatewayARN: \(String(describing: gatewayARN)), workingStorageAllocatedInBytes: \(String(describing: workingStorageAllocatedInBytes)), workingStorageUsedInBytes: \(String(describing: workingStorageUsedInBytes)))"}
}

extension DescribeWorkingStorageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkingStorageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.diskIds = output.diskIds
            self.gatewayARN = output.gatewayARN
            self.workingStorageAllocatedInBytes = output.workingStorageAllocatedInBytes
            self.workingStorageUsedInBytes = output.workingStorageUsedInBytes
        } else {
            self.diskIds = nil
            self.gatewayARN = nil
            self.workingStorageAllocatedInBytes = 0
            self.workingStorageUsedInBytes = 0
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct DescribeWorkingStorageOutputResponse: Equatable {
    /// <p>An array of the gateway's local disk IDs that are configured as working storage.
    ///          Each local disk ID is specified as a string (minimum length of 1 and maximum length of
    ///          300). If no local disks are configured as working storage, then the DiskIds array is
    ///          empty.</p>
    public let diskIds: [String]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The total working storage in bytes allocated for the gateway. If no working storage is
    ///          configured for the gateway, this field returns 0.</p>
    public let workingStorageAllocatedInBytes: Int
    /// <p>The total working storage in bytes in use by the gateway. If no working storage is
    ///          configured for the gateway, this field returns 0.</p>
    public let workingStorageUsedInBytes: Int

    public init (
        diskIds: [String]? = nil,
        gatewayARN: String? = nil,
        workingStorageAllocatedInBytes: Int = 0,
        workingStorageUsedInBytes: Int = 0
    )
    {
        self.diskIds = diskIds
        self.gatewayARN = gatewayARN
        self.workingStorageAllocatedInBytes = workingStorageAllocatedInBytes
        self.workingStorageUsedInBytes = workingStorageUsedInBytes
    }
}

struct DescribeWorkingStorageOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let diskIds: [String]?
    public let workingStorageUsedInBytes: Int
    public let workingStorageAllocatedInBytes: Int
}

extension DescribeWorkingStorageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case diskIds = "DiskIds"
        case gatewayARN = "GatewayARN"
        case workingStorageAllocatedInBytes = "WorkingStorageAllocatedInBytes"
        case workingStorageUsedInBytes = "WorkingStorageUsedInBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let diskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskIds)
        var diskIdsDecoded0:[String]? = nil
        if let diskIdsContainer = diskIdsContainer {
            diskIdsDecoded0 = [String]()
            for string0 in diskIdsContainer {
                if let string0 = string0 {
                    diskIdsDecoded0?.append(string0)
                }
            }
        }
        diskIds = diskIdsDecoded0
        let workingStorageUsedInBytesDecoded = try containerValues.decode(Int.self, forKey: .workingStorageUsedInBytes)
        workingStorageUsedInBytes = workingStorageUsedInBytesDecoded
        let workingStorageAllocatedInBytesDecoded = try containerValues.decode(Int.self, forKey: .workingStorageAllocatedInBytes)
        workingStorageAllocatedInBytes = workingStorageAllocatedInBytesDecoded
    }
}

public struct DetachVolumeInputBodyMiddleware: Middleware {
    public let id: String = "DetachVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachVolumeOutputError>
}

extension DetachVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachVolumeInput(forceDetach: \(String(describing: forceDetach)), volumeARN: \(String(describing: volumeARN)))"}
}

extension DetachVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceDetach = forceDetach {
            try encodeContainer.encode(forceDetach, forKey: .forceDetach)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct DetachVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "DetachVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachVolumeOutputError>
}

public struct DetachVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachVolumeInput>
    public typealias MOutput = OperationOutput<DetachVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachVolumeOutputError>
}

/// <p>AttachVolumeInput</p>
public struct DetachVolumeInput: Equatable {
    /// <p>Set to <code>true</code> to forcibly remove the iSCSI connection of the target volume
    ///          and detach the volume. The default is <code>false</code>. If this value is set to
    ///             <code>false</code>, you must manually disconnect the iSCSI connection from the target
    ///          volume.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let forceDetach: Bool?
    /// <p>The Amazon Resource Name (ARN) of the volume to detach from the gateway.</p>
    public let volumeARN: String?

    public init (
        forceDetach: Bool? = nil,
        volumeARN: String? = nil
    )
    {
        self.forceDetach = forceDetach
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeInputBody: Equatable {
    public let volumeARN: String?
    public let forceDetach: Bool?
}

extension DetachVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forceDetach = "ForceDetach"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let forceDetachDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceDetach)
        forceDetach = forceDetachDecoded
    }
}

extension DetachVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachVolumeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachVolumeOutputResponse(volumeARN: \(String(describing: volumeARN)))"}
}

extension DetachVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetachVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// <p>AttachVolumeOutput</p>
public struct DetachVolumeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume that was detached.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct DetachVolumeOutputResponseBody: Equatable {
    public let volumeARN: String?
}

extension DetachVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension DeviceiSCSIAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case chapEnabled = "ChapEnabled"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decode(Int.self, forKey: .networkInterfacePort)
        networkInterfacePort = networkInterfacePortDecoded
        let chapEnabledDecoded = try containerValues.decode(Bool.self, forKey: .chapEnabled)
        chapEnabled = chapEnabledDecoded
    }
}

extension DeviceiSCSIAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceiSCSIAttributes(chapEnabled: \(String(describing: chapEnabled)), networkInterfaceId: \(String(describing: networkInterfaceId)), networkInterfacePort: \(String(describing: networkInterfacePort)), targetARN: \(String(describing: targetARN)))"}
}

/// <p>Lists iSCSI information about a VTL device.</p>
public struct DeviceiSCSIAttributes: Equatable {
    /// <p>Indicates whether mutual CHAP is enabled for the iSCSI target.</p>
    public let chapEnabled: Bool
    /// <p>The network interface identifier of the VTL device.</p>
    public let networkInterfaceId: String?
    /// <p>The port used to communicate with iSCSI VTL device targets.</p>
    public let networkInterfacePort: Int
    /// <p>Specifies the unique Amazon Resource Name (ARN) that encodes the iSCSI qualified
    ///          name(iqn) of a tape drive or media changer target.</p>
    public let targetARN: String?

    public init (
        chapEnabled: Bool = false,
        networkInterfaceId: String? = nil,
        networkInterfacePort: Int = 0,
        targetARN: String? = nil
    )
    {
        self.chapEnabled = chapEnabled
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfacePort = networkInterfacePort
        self.targetARN = targetARN
    }
}

public struct DisableGatewayInputBodyMiddleware: Middleware {
    public let id: String = "DisableGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableGatewayOutputError>
}

extension DisableGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableGatewayInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DisableGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct DisableGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DisableGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableGatewayOutputError>
}

public struct DisableGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableGatewayInput>
    public typealias MOutput = OperationOutput<DisableGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableGatewayOutputError>
}

/// <p>DisableGatewayInput</p>
public struct DisableGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayInputBody: Equatable {
    public let gatewayARN: String?
}

extension DisableGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension DisableGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableGatewayOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableGatewayOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension DisableGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisableGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>DisableGatewayOutput</p>
public struct DisableGatewayOutputResponse: Equatable {
    /// <p>The unique Amazon Resource Name (ARN) of the disabled gateway.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct DisableGatewayOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension DisableGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct DisassociateFileSystemInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemOutputError>
}

extension DisassociateFileSystemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFileSystemInput(fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)), forceDelete: \(String(describing: forceDelete)))"}
}

extension DisassociateFileSystemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if forceDelete != false {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

public struct DisassociateFileSystemInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemOutputError>
}

public struct DisassociateFileSystemInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFileSystemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFileSystemInput>
    public typealias MOutput = OperationOutput<DisassociateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFileSystemOutputError>
}

public struct DisassociateFileSystemInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file system association to be deleted.</p>
    public let fileSystemAssociationARN: String?
    /// <p>If this value is set to true, the operation disassociates an Amazon FSx file system
    ///          immediately. It ends all data uploads to the file system, and the file system association
    ///          enters the <code>FORCE_DELETING</code> status. If this value is set to false, the Amazon
    ///          FSx file system does not disassociate until all data is uploaded.</p>
    public let forceDelete: Bool

    public init (
        fileSystemAssociationARN: String? = nil,
        forceDelete: Bool = false
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.forceDelete = forceDelete
    }
}

struct DisassociateFileSystemInputBody: Equatable {
    public let fileSystemAssociationARN: String?
    public let forceDelete: Bool
}

extension DisassociateFileSystemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case forceDelete = "ForceDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let forceDeleteDecoded = try containerValues.decode(Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DisassociateFileSystemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFileSystemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFileSystemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFileSystemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFileSystemOutputResponse(fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)))"}
}

extension DisassociateFileSystemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct DisassociateFileSystemOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the deleted file system association.</p>
    public let fileSystemAssociationARN: String?

    public init (
        fileSystemAssociationARN: String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct DisassociateFileSystemOutputResponseBody: Equatable {
    public let fileSystemAssociationARN: String?
}

extension DisassociateFileSystemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

extension Disk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskAllocationResource = "DiskAllocationResource"
        case diskAllocationType = "DiskAllocationType"
        case diskAttributeList = "DiskAttributeList"
        case diskId = "DiskId"
        case diskNode = "DiskNode"
        case diskPath = "DiskPath"
        case diskSizeInBytes = "DiskSizeInBytes"
        case diskStatus = "DiskStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskAllocationResource = diskAllocationResource {
            try encodeContainer.encode(diskAllocationResource, forKey: .diskAllocationResource)
        }
        if let diskAllocationType = diskAllocationType {
            try encodeContainer.encode(diskAllocationType, forKey: .diskAllocationType)
        }
        if let diskAttributeList = diskAttributeList {
            var diskAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .diskAttributeList)
            for diskattributelist0 in diskAttributeList {
                try diskAttributeListContainer.encode(diskattributelist0)
            }
        }
        if let diskId = diskId {
            try encodeContainer.encode(diskId, forKey: .diskId)
        }
        if let diskNode = diskNode {
            try encodeContainer.encode(diskNode, forKey: .diskNode)
        }
        if let diskPath = diskPath {
            try encodeContainer.encode(diskPath, forKey: .diskPath)
        }
        if diskSizeInBytes != 0 {
            try encodeContainer.encode(diskSizeInBytes, forKey: .diskSizeInBytes)
        }
        if let diskStatus = diskStatus {
            try encodeContainer.encode(diskStatus, forKey: .diskStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskId)
        diskId = diskIdDecoded
        let diskPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskPath)
        diskPath = diskPathDecoded
        let diskNodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskNode)
        diskNode = diskNodeDecoded
        let diskStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskStatus)
        diskStatus = diskStatusDecoded
        let diskSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .diskSizeInBytes)
        diskSizeInBytes = diskSizeInBytesDecoded
        let diskAllocationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskAllocationType)
        diskAllocationType = diskAllocationTypeDecoded
        let diskAllocationResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskAllocationResource)
        diskAllocationResource = diskAllocationResourceDecoded
        let diskAttributeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .diskAttributeList)
        var diskAttributeListDecoded0:[String]? = nil
        if let diskAttributeListContainer = diskAttributeListContainer {
            diskAttributeListDecoded0 = [String]()
            for string0 in diskAttributeListContainer {
                if let string0 = string0 {
                    diskAttributeListDecoded0?.append(string0)
                }
            }
        }
        diskAttributeList = diskAttributeListDecoded0
    }
}

extension Disk: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Disk(diskAllocationResource: \(String(describing: diskAllocationResource)), diskAllocationType: \(String(describing: diskAllocationType)), diskAttributeList: \(String(describing: diskAttributeList)), diskId: \(String(describing: diskId)), diskNode: \(String(describing: diskNode)), diskPath: \(String(describing: diskPath)), diskSizeInBytes: \(String(describing: diskSizeInBytes)), diskStatus: \(String(describing: diskStatus)))"}
}

/// <p>Represents a gateway's local disk.</p>
public struct Disk: Equatable {
    /// <p>The iSCSI qualified name (IQN) that is defined for a disk. This field is not included in
    ///          the response if the local disk is not defined as an iSCSI target. The format of this field
    ///          is <i>targetIqn::LUNNumber::region-volumeId</i>.</p>
    public let diskAllocationResource: String?
    /// <p>One of the <code>DiskAllocationType</code> enumeration values that identifies how a
    ///          local disk is used.</p>
    ///
    ///          <p>Valid Values: <code>UPLOAD_BUFFER</code> | <code>CACHE_STORAGE</code>
    ///          </p>
    public let diskAllocationType: String?
    /// <p>A list of values that represents attributes of a local disk.</p>
    public let diskAttributeList: [String]?
    /// <p>The unique device ID or other distinguishing data that identifies a local disk.</p>
    public let diskId: String?
    /// <p>The device node of a local disk as assigned by the virtualization environment.</p>
    public let diskNode: String?
    /// <p>The path of a local disk in the gateway virtual machine (VM).</p>
    public let diskPath: String?
    /// <p>The local disk size in bytes.</p>
    public let diskSizeInBytes: Int
    /// <p>A value that represents the status of a local disk.</p>
    public let diskStatus: String?

    public init (
        diskAllocationResource: String? = nil,
        diskAllocationType: String? = nil,
        diskAttributeList: [String]? = nil,
        diskId: String? = nil,
        diskNode: String? = nil,
        diskPath: String? = nil,
        diskSizeInBytes: Int = 0,
        diskStatus: String? = nil
    )
    {
        self.diskAllocationResource = diskAllocationResource
        self.diskAllocationType = diskAllocationType
        self.diskAttributeList = diskAttributeList
        self.diskId = diskId
        self.diskNode = diskNode
        self.diskPath = diskPath
        self.diskSizeInBytes = diskSizeInBytes
        self.diskStatus = diskStatus
    }
}

public enum ErrorCode {
    case activationkeyexpired
    case activationkeyinvalid
    case activationkeynotfound
    case authenticationfailure
    case bandwidththrottleschedulenotfound
    case blocked
    case cannotexportsnapshot
    case chapcredentialnotfound
    case diskalreadyallocated
    case diskdoesnotexist
    case disksizegreaterthanvolumemaxsize
    case disksizelessthanvolumesize
    case disksizenotgigaligned
    case duplicatecertificateinfo
    case duplicateschedule
    case endpointnotfound
    case gatewayinternalerror
    case gatewaynotconnected
    case gatewaynotfound
    case gatewayproxynetworkconnectionbusy
    case iamnotsupported
    case initiatorinvalid
    case initiatornotfound
    case internalerror
    case invalidendpoint
    case invalidgateway
    case invalidparameters
    case invalidschedule
    case joindomaininprogress
    case localstoragelimitexceeded
    case lunalreadyallocated
    case luninvalid
    case maximumcontentlengthexceeded
    case maximumtapecartridgecountexceeded
    case maximumvolumecountexceeded
    case networkconfigurationchanged
    case nodisksavailable
    case notimplemented
    case notsupported
    case operationaborted
    case outdatedgateway
    case parametersnotimplemented
    case regioninvalid
    case requesttimeout
    case serviceunavailable
    case snapshotdeleted
    case snapshotidinvalid
    case snapshotinprogress
    case snapshotnotfound
    case snapshotschedulenotfound
    case stagingareafull
    case storagefailure
    case tapecartridgenotfound
    case targetalreadyexists
    case targetinvalid
    case targetnotfound
    case unauthorizedoperation
    case volumealreadyexists
    case volumeidinvalid
    case volumeinuse
    case volumenotfound
    case volumenotready
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .activationkeyexpired,
            .activationkeyinvalid,
            .activationkeynotfound,
            .authenticationfailure,
            .bandwidththrottleschedulenotfound,
            .blocked,
            .cannotexportsnapshot,
            .chapcredentialnotfound,
            .diskalreadyallocated,
            .diskdoesnotexist,
            .disksizegreaterthanvolumemaxsize,
            .disksizelessthanvolumesize,
            .disksizenotgigaligned,
            .duplicatecertificateinfo,
            .duplicateschedule,
            .endpointnotfound,
            .gatewayinternalerror,
            .gatewaynotconnected,
            .gatewaynotfound,
            .gatewayproxynetworkconnectionbusy,
            .iamnotsupported,
            .initiatorinvalid,
            .initiatornotfound,
            .internalerror,
            .invalidendpoint,
            .invalidgateway,
            .invalidparameters,
            .invalidschedule,
            .joindomaininprogress,
            .localstoragelimitexceeded,
            .lunalreadyallocated,
            .luninvalid,
            .maximumcontentlengthexceeded,
            .maximumtapecartridgecountexceeded,
            .maximumvolumecountexceeded,
            .networkconfigurationchanged,
            .nodisksavailable,
            .notimplemented,
            .notsupported,
            .operationaborted,
            .outdatedgateway,
            .parametersnotimplemented,
            .regioninvalid,
            .requesttimeout,
            .serviceunavailable,
            .snapshotdeleted,
            .snapshotidinvalid,
            .snapshotinprogress,
            .snapshotnotfound,
            .snapshotschedulenotfound,
            .stagingareafull,
            .storagefailure,
            .tapecartridgenotfound,
            .targetalreadyexists,
            .targetinvalid,
            .targetnotfound,
            .unauthorizedoperation,
            .volumealreadyexists,
            .volumeidinvalid,
            .volumeinuse,
            .volumenotfound,
            .volumenotready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activationkeyexpired: return "ActivationKeyExpired"
        case .activationkeyinvalid: return "ActivationKeyInvalid"
        case .activationkeynotfound: return "ActivationKeyNotFound"
        case .authenticationfailure: return "AuthenticationFailure"
        case .bandwidththrottleschedulenotfound: return "BandwidthThrottleScheduleNotFound"
        case .blocked: return "Blocked"
        case .cannotexportsnapshot: return "CannotExportSnapshot"
        case .chapcredentialnotfound: return "ChapCredentialNotFound"
        case .diskalreadyallocated: return "DiskAlreadyAllocated"
        case .diskdoesnotexist: return "DiskDoesNotExist"
        case .disksizegreaterthanvolumemaxsize: return "DiskSizeGreaterThanVolumeMaxSize"
        case .disksizelessthanvolumesize: return "DiskSizeLessThanVolumeSize"
        case .disksizenotgigaligned: return "DiskSizeNotGigAligned"
        case .duplicatecertificateinfo: return "DuplicateCertificateInfo"
        case .duplicateschedule: return "DuplicateSchedule"
        case .endpointnotfound: return "EndpointNotFound"
        case .gatewayinternalerror: return "GatewayInternalError"
        case .gatewaynotconnected: return "GatewayNotConnected"
        case .gatewaynotfound: return "GatewayNotFound"
        case .gatewayproxynetworkconnectionbusy: return "GatewayProxyNetworkConnectionBusy"
        case .iamnotsupported: return "IAMNotSupported"
        case .initiatorinvalid: return "InitiatorInvalid"
        case .initiatornotfound: return "InitiatorNotFound"
        case .internalerror: return "InternalError"
        case .invalidendpoint: return "InvalidEndpoint"
        case .invalidgateway: return "InvalidGateway"
        case .invalidparameters: return "InvalidParameters"
        case .invalidschedule: return "InvalidSchedule"
        case .joindomaininprogress: return "JoinDomainInProgress"
        case .localstoragelimitexceeded: return "LocalStorageLimitExceeded"
        case .lunalreadyallocated: return "LunAlreadyAllocated "
        case .luninvalid: return "LunInvalid"
        case .maximumcontentlengthexceeded: return "MaximumContentLengthExceeded"
        case .maximumtapecartridgecountexceeded: return "MaximumTapeCartridgeCountExceeded"
        case .maximumvolumecountexceeded: return "MaximumVolumeCountExceeded"
        case .networkconfigurationchanged: return "NetworkConfigurationChanged"
        case .nodisksavailable: return "NoDisksAvailable"
        case .notimplemented: return "NotImplemented"
        case .notsupported: return "NotSupported"
        case .operationaborted: return "OperationAborted"
        case .outdatedgateway: return "OutdatedGateway"
        case .parametersnotimplemented: return "ParametersNotImplemented"
        case .regioninvalid: return "RegionInvalid"
        case .requesttimeout: return "RequestTimeout"
        case .serviceunavailable: return "ServiceUnavailable"
        case .snapshotdeleted: return "SnapshotDeleted"
        case .snapshotidinvalid: return "SnapshotIdInvalid"
        case .snapshotinprogress: return "SnapshotInProgress"
        case .snapshotnotfound: return "SnapshotNotFound"
        case .snapshotschedulenotfound: return "SnapshotScheduleNotFound"
        case .stagingareafull: return "StagingAreaFull"
        case .storagefailure: return "StorageFailure"
        case .tapecartridgenotfound: return "TapeCartridgeNotFound"
        case .targetalreadyexists: return "TargetAlreadyExists"
        case .targetinvalid: return "TargetInvalid"
        case .targetnotfound: return "TargetNotFound"
        case .unauthorizedoperation: return "UnauthorizedOperation"
        case .volumealreadyexists: return "VolumeAlreadyExists"
        case .volumeidinvalid: return "VolumeIdInvalid"
        case .volumeinuse: return "VolumeInUse"
        case .volumenotfound: return "VolumeNotFound"
        case .volumenotready: return "VolumeNotReady"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension FileShareInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareStatus = "FileShareStatus"
        case fileShareType = "FileShareType"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let fileShareType = fileShareType {
            try encodeContainer.encode(fileShareType.rawValue, forKey: .fileShareType)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareTypeDecoded = try containerValues.decodeIfPresent(FileShareType.self, forKey: .fileShareType)
        fileShareType = fileShareTypeDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension FileShareInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileShareInfo(fileShareARN: \(String(describing: fileShareARN)), fileShareId: \(String(describing: fileShareId)), fileShareStatus: \(String(describing: fileShareStatus)), fileShareType: \(String(describing: fileShareType)), gatewayARN: \(String(describing: gatewayARN)))"}
}

/// <p>Describes a file share.</p>
public struct FileShareInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?
    /// <p>The ID of the file share.</p>
    public let fileShareId: String?
    /// <p>The status of the file share.</p>
    ///
    ///          <p>Valid Values: <code>CREATING</code> | <code>UPDATING</code> | <code>AVAILABLE</code> |
    ///             <code>DELETING</code>
    ///          </p>
    public let fileShareStatus: String?
    /// <p>The type of the file share.</p>
    public let fileShareType: FileShareType?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        fileShareARN: String? = nil,
        fileShareId: String? = nil,
        fileShareStatus: String? = nil,
        fileShareType: FileShareType? = nil,
        gatewayARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.fileShareId = fileShareId
        self.fileShareStatus = fileShareStatus
        self.fileShareType = fileShareType
        self.gatewayARN = gatewayARN
    }
}

/// <p>The type of the file share.</p>
public enum FileShareType {
    case nfs
    case smb
    case sdkUnknown(String)
}

extension FileShareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileShareType] {
        return [
            .nfs,
            .smb,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .nfs: return "NFS"
        case .smb: return "SMB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileShareType(rawValue: rawValue) ?? FileShareType.sdkUnknown(rawValue)
    }
}

extension FileSystemAssociationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case gatewayARN = "GatewayARN"
        case locationARN = "LocationARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationStatus = fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
    }
}

extension FileSystemAssociationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemAssociationInfo(auditDestinationARN: \(String(describing: auditDestinationARN)), cacheAttributes: \(String(describing: cacheAttributes)), fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)), fileSystemAssociationStatus: \(String(describing: fileSystemAssociationStatus)), gatewayARN: \(String(describing: gatewayARN)), locationARN: \(String(describing: locationARN)), tags: \(String(describing: tags)))"}
}

/// <p>Describes the object returned by <code>DescribeFileSystemAssociations</code> that
///          describes a created file system association.</p>
public struct FileSystemAssociationInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the storage used for the audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>The refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The Amazon Resource Name (ARN) of the file system association.</p>
    public let fileSystemAssociationARN: String?
    /// <p>The status of the file system association.
    ///          Valid Values: <code>AVAILABLE</code> | <code>CREATING</code> | <code>DELETING</code> |
    ///          <code>FORCE_DELETING</code> | <code>MISCONFIGURED</code> | <code>UPDATING</code> | <code>UNAVAILABLE</code>
    ///          </p>
    public let fileSystemAssociationStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The ARN of the backend Amazon FSx file system used for storing file data. For
    ///          information, see <a href="https://docs.aws.amazon.com/fsx/latest/APIReference/API_FileSystem.html">FileSystem</a> in the <i>Amazon FSx
    ///                API Reference</i>.</p>
    public let locationARN: String?
    /// <p>A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key name. Each tag is a key-value pair.</p>
    public let tags: [Tag]?

    public init (
        auditDestinationARN: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        fileSystemAssociationARN: String? = nil,
        fileSystemAssociationStatus: String? = nil,
        gatewayARN: String? = nil,
        locationARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.fileSystemAssociationStatus = fileSystemAssociationStatus
        self.gatewayARN = gatewayARN
        self.locationARN = locationARN
        self.tags = tags
    }
}

extension FileSystemAssociationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case fileSystemAssociationId = "FileSystemAssociationId"
        case fileSystemAssociationStatus = "FileSystemAssociationStatus"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let fileSystemAssociationId = fileSystemAssociationId {
            try encodeContainer.encode(fileSystemAssociationId, forKey: .fileSystemAssociationId)
        }
        if let fileSystemAssociationStatus = fileSystemAssociationStatus {
            try encodeContainer.encode(fileSystemAssociationStatus, forKey: .fileSystemAssociationStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationId)
        fileSystemAssociationId = fileSystemAssociationIdDecoded
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let fileSystemAssociationStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationStatus)
        fileSystemAssociationStatus = fileSystemAssociationStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension FileSystemAssociationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemAssociationSummary(fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)), fileSystemAssociationId: \(String(describing: fileSystemAssociationId)), fileSystemAssociationStatus: \(String(describing: fileSystemAssociationStatus)), gatewayARN: \(String(describing: gatewayARN)))"}
}

/// <p>Gets the summary returned by <code>ListFileSystemAssociation</code>, which is a summary
///          of a created file system association.</p>
public struct FileSystemAssociationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file system association.</p>
    public let fileSystemAssociationARN: String?
    /// <p>The ID of the file system association.</p>
    public let fileSystemAssociationId: String?
    /// <p>The status of the file share. Valid Values: <code>AVAILABLE</code> | <code>CREATING</code> | <code>DELETING</code> |
    ///          <code>FORCE_DELETING</code> | <code>MISCONFIGURED</code> | <code>UPDATING</code> | <code>UNAVAILABLE</code>
    ///          </p>
    public let fileSystemAssociationStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        fileSystemAssociationARN: String? = nil,
        fileSystemAssociationId: String? = nil,
        fileSystemAssociationStatus: String? = nil,
        gatewayARN: String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.fileSystemAssociationId = fileSystemAssociationId
        self.fileSystemAssociationStatus = fileSystemAssociationStatus
        self.gatewayARN = gatewayARN
    }
}

extension GatewayInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2InstanceId = "Ec2InstanceId"
        case ec2InstanceRegion = "Ec2InstanceRegion"
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case gatewayName = "GatewayName"
        case gatewayOperationalState = "GatewayOperationalState"
        case gatewayType = "GatewayType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ec2InstanceRegion = ec2InstanceRegion {
            try encodeContainer.encode(ec2InstanceRegion, forKey: .ec2InstanceRegion)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayOperationalState = gatewayOperationalState {
            try encodeContainer.encode(gatewayOperationalState, forKey: .gatewayOperationalState)
        }
        if let gatewayType = gatewayType {
            try encodeContainer.encode(gatewayType, forKey: .gatewayType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayType)
        gatewayType = gatewayTypeDecoded
        let gatewayOperationalStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayOperationalState)
        gatewayOperationalState = gatewayOperationalStateDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ec2InstanceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceRegion)
        ec2InstanceRegion = ec2InstanceRegionDecoded
    }
}

extension GatewayInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayInfo(ec2InstanceId: \(String(describing: ec2InstanceId)), ec2InstanceRegion: \(String(describing: ec2InstanceRegion)), gatewayARN: \(String(describing: gatewayARN)), gatewayId: \(String(describing: gatewayId)), gatewayName: \(String(describing: gatewayName)), gatewayOperationalState: \(String(describing: gatewayOperationalState)), gatewayType: \(String(describing: gatewayType)))"}
}

/// <p>Describes a gateway object.</p>
public struct GatewayInfo: Equatable {
    /// <p>The ID of the Amazon EC2 instance that was used to launch the gateway.</p>
    public let ec2InstanceId: String?
    /// <p>The AWS Region where the Amazon EC2 instance is located.</p>
    public let ec2InstanceRegion: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The unique identifier assigned to your gateway during activation. This ID becomes part
    ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
    ///          operations.</p>
    public let gatewayId: String?
    /// <p>The name of the gateway.</p>
    public let gatewayName: String?
    /// <p>The state of the gateway.</p>
    ///
    ///          <p>Valid Values: <code>DISABLED</code> | <code>ACTIVE</code>
    ///          </p>
    public let gatewayOperationalState: String?
    /// <p>The type of the gateway.</p>
    public let gatewayType: String?

    public init (
        ec2InstanceId: String? = nil,
        ec2InstanceRegion: String? = nil,
        gatewayARN: String? = nil,
        gatewayId: String? = nil,
        gatewayName: String? = nil,
        gatewayOperationalState: String? = nil,
        gatewayType: String? = nil
    )
    {
        self.ec2InstanceId = ec2InstanceId
        self.ec2InstanceRegion = ec2InstanceRegion
        self.gatewayARN = gatewayARN
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayOperationalState = gatewayOperationalState
        self.gatewayType = gatewayType
    }
}

public enum HostEnvironment {
    case ec2
    case hyperV
    case kvm
    case other
    case vmware
    case sdkUnknown(String)
}

extension HostEnvironment : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HostEnvironment] {
        return [
            .ec2,
            .hyperV,
            .kvm,
            .other,
            .vmware,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2: return "EC2"
        case .hyperV: return "HYPER-V"
        case .kvm: return "KVM"
        case .other: return "OTHER"
        case .vmware: return "VMWARE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HostEnvironment(rawValue: rawValue) ?? HostEnvironment.sdkUnknown(rawValue)
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(error: \(String(describing: error)), message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error has occurred during the request. For more information, see the
///          error and message fields.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
    ///          of the error.</p>
    public var error: StorageGatewayError?
    /// <p>A human-readable message describing the error that occurred.</p>
    public var message: String?

    public init (
        error: StorageGatewayError? = nil,
        message: String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
    public let error: StorageGatewayError?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

extension InvalidGatewayRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGatewayRequestException(error: \(String(describing: error)), message: \(String(describing: message)))"}
}

extension InvalidGatewayRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidGatewayRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception occurred because an invalid gateway request was issued to the service. For
///          more information, see the error and message fields.</p>
public struct InvalidGatewayRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A <a>StorageGatewayError</a> that provides more detail about the cause of the
    ///          error.</p>
    public var error: StorageGatewayError?
    /// <p>A human-readable message describing the error that occurred.</p>
    public var message: String?

    public init (
        error: StorageGatewayError? = nil,
        message: String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct InvalidGatewayRequestExceptionBody: Equatable {
    public let message: String?
    public let error: StorageGatewayError?
}

extension InvalidGatewayRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

public struct JoinDomainInputBodyMiddleware: Middleware {
    public let id: String = "JoinDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<JoinDomainInput>
    public typealias MOutput = OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<JoinDomainOutputError>
}

extension JoinDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JoinDomainInput(domainControllers: \(String(describing: domainControllers)), domainName: \(String(describing: domainName)), gatewayARN: \(String(describing: gatewayARN)), organizationalUnit: \(String(describing: organizationalUnit)), password: \(String(describing: password)), timeoutInSeconds: \(String(describing: timeoutInSeconds)), userName: \(String(describing: userName)))"}
}

extension JoinDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainControllers = domainControllers {
            var domainControllersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainControllers)
            for hosts0 in domainControllers {
                try domainControllersContainer.encode(hosts0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let organizationalUnit = organizationalUnit {
            try encodeContainer.encode(organizationalUnit, forKey: .organizationalUnit)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct JoinDomainInputHeadersMiddleware: Middleware {
    public let id: String = "JoinDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<JoinDomainInput>
    public typealias MOutput = OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<JoinDomainOutputError>
}

public struct JoinDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "JoinDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<JoinDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<JoinDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<JoinDomainInput>
    public typealias MOutput = OperationOutput<JoinDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<JoinDomainOutputError>
}

/// <p>JoinDomainInput</p>
public struct JoinDomainInput: Equatable {
    /// <p>List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need
    ///          to specify the port number include it after the colon (“:”). For example,
    ///             <code>mydc.mydomain.com:389</code>.</p>
    public let domainControllers: [String]?
    /// <p>The name of the domain that you want the gateway to join.</p>
    public let domainName: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <code>ListGateways</code>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The organizational unit (OU) is a container in an Active Directory that can hold users,
    ///          groups, computers, and other OUs and this parameter specifies the OU that the gateway will
    ///          join within the AD domain.</p>
    public let organizationalUnit: String?
    /// <p>Sets the password of the user who has permission to add the gateway to the Active
    ///          Directory domain.</p>
    public let password: String?
    /// <p>Specifies the time in seconds, in which the <code>JoinDomain</code> operation must
    ///          complete. The default is 20 seconds.</p>
    public let timeoutInSeconds: Int?
    /// <p>Sets the user name of user who has permission to add the gateway to the Active Directory
    ///          domain. The domain user account should be enabled to join computers to the domain. For
    ///          example, you can use the domain administrator account or an account with delegated
    ///          permissions to join computers to the domain.</p>
    public let userName: String?

    public init (
        domainControllers: [String]? = nil,
        domainName: String? = nil,
        gatewayARN: String? = nil,
        organizationalUnit: String? = nil,
        password: String? = nil,
        timeoutInSeconds: Int? = nil,
        userName: String? = nil
    )
    {
        self.domainControllers = domainControllers
        self.domainName = domainName
        self.gatewayARN = gatewayARN
        self.organizationalUnit = organizationalUnit
        self.password = password
        self.timeoutInSeconds = timeoutInSeconds
        self.userName = userName
    }
}

struct JoinDomainInputBody: Equatable {
    public let gatewayARN: String?
    public let domainName: String?
    public let organizationalUnit: String?
    public let domainControllers: [String]?
    public let timeoutInSeconds: Int?
    public let userName: String?
    public let password: String?
}

extension JoinDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainControllers = "DomainControllers"
        case domainName = "DomainName"
        case gatewayARN = "GatewayARN"
        case organizationalUnit = "OrganizationalUnit"
        case password = "Password"
        case timeoutInSeconds = "TimeoutInSeconds"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnit)
        organizationalUnit = organizationalUnitDecoded
        let domainControllersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domainControllers)
        var domainControllersDecoded0:[String]? = nil
        if let domainControllersContainer = domainControllersContainer {
            domainControllersDecoded0 = [String]()
            for string0 in domainControllersContainer {
                if let string0 = string0 {
                    domainControllersDecoded0?.append(string0)
                }
            }
        }
        domainControllers = domainControllersDecoded0
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension JoinDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension JoinDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum JoinDomainOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension JoinDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JoinDomainOutputResponse(activeDirectoryStatus: \(String(describing: activeDirectoryStatus)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension JoinDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: JoinDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activeDirectoryStatus = output.activeDirectoryStatus
            self.gatewayARN = output.gatewayARN
        } else {
            self.activeDirectoryStatus = nil
            self.gatewayARN = nil
        }
    }
}

/// <p>JoinDomainOutput</p>
public struct JoinDomainOutputResponse: Equatable {
    /// <p>Indicates the status of the gateway as a member of the Active Directory domain.</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACCESS_DENIED</code>: Indicates that the <code>JoinDomain</code> operation
    ///                failed due to an authentication error.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DETACHED</code>: Indicates that gateway is not joined to a domain.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JOINED</code>: Indicates that the gateway has successfully joined a
    ///                domain.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>JOINING</code>: Indicates that a <code>JoinDomain</code> operation is in
    ///                progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NETWORK_ERROR</code>: Indicates that <code>JoinDomain</code> operation
    ///                failed due to a network or connectivity error.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TIMEOUT</code>: Indicates that the <code>JoinDomain</code> operation failed
    ///                because the operation didn't complete within the allotted time.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNKNOWN_ERROR</code>: Indicates that the <code>JoinDomain</code> operation
    ///                failed due to another type of error.</p>
    ///             </li>
    ///          </ul>
    public let activeDirectoryStatus: ActiveDirectoryStatus?
    /// <p>The unique Amazon Resource Name (ARN) of the gateway that joined the domain.</p>
    public let gatewayARN: String?

    public init (
        activeDirectoryStatus: ActiveDirectoryStatus? = nil,
        gatewayARN: String? = nil
    )
    {
        self.activeDirectoryStatus = activeDirectoryStatus
        self.gatewayARN = gatewayARN
    }
}

struct JoinDomainOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let activeDirectoryStatus: ActiveDirectoryStatus?
}

extension JoinDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activeDirectoryStatus = "ActiveDirectoryStatus"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let activeDirectoryStatusDecoded = try containerValues.decodeIfPresent(ActiveDirectoryStatus.self, forKey: .activeDirectoryStatus)
        activeDirectoryStatus = activeDirectoryStatusDecoded
    }
}

public struct ListAutomaticTapeCreationPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListAutomaticTapeCreationPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

extension ListAutomaticTapeCreationPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAutomaticTapeCreationPoliciesInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ListAutomaticTapeCreationPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListAutomaticTapeCreationPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAutomaticTapeCreationPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

public struct ListAutomaticTapeCreationPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAutomaticTapeCreationPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAutomaticTapeCreationPoliciesInput>
    public typealias MOutput = OperationOutput<ListAutomaticTapeCreationPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAutomaticTapeCreationPoliciesOutputError>
}

public struct ListAutomaticTapeCreationPoliciesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListAutomaticTapeCreationPoliciesInputBody: Equatable {
    public let gatewayARN: String?
}

extension ListAutomaticTapeCreationPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutomaticTapeCreationPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAutomaticTapeCreationPoliciesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutomaticTapeCreationPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAutomaticTapeCreationPoliciesOutputResponse(automaticTapeCreationPolicyInfos: \(String(describing: automaticTapeCreationPolicyInfos)))"}
}

extension ListAutomaticTapeCreationPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAutomaticTapeCreationPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automaticTapeCreationPolicyInfos = output.automaticTapeCreationPolicyInfos
        } else {
            self.automaticTapeCreationPolicyInfos = nil
        }
    }
}

public struct ListAutomaticTapeCreationPoliciesOutputResponse: Equatable {
    /// <p>Gets a listing of information about the gateway's automatic tape creation policies,
    ///          including the automatic tape creation rules and the gateway that is using the
    ///          policies.</p>
    public let automaticTapeCreationPolicyInfos: [AutomaticTapeCreationPolicyInfo]?

    public init (
        automaticTapeCreationPolicyInfos: [AutomaticTapeCreationPolicyInfo]? = nil
    )
    {
        self.automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfos
    }
}

struct ListAutomaticTapeCreationPoliciesOutputResponseBody: Equatable {
    public let automaticTapeCreationPolicyInfos: [AutomaticTapeCreationPolicyInfo]?
}

extension ListAutomaticTapeCreationPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automaticTapeCreationPolicyInfos = "AutomaticTapeCreationPolicyInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationPolicyInfosContainer = try containerValues.decodeIfPresent([AutomaticTapeCreationPolicyInfo?].self, forKey: .automaticTapeCreationPolicyInfos)
        var automaticTapeCreationPolicyInfosDecoded0:[AutomaticTapeCreationPolicyInfo]? = nil
        if let automaticTapeCreationPolicyInfosContainer = automaticTapeCreationPolicyInfosContainer {
            automaticTapeCreationPolicyInfosDecoded0 = [AutomaticTapeCreationPolicyInfo]()
            for structure0 in automaticTapeCreationPolicyInfosContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationPolicyInfosDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationPolicyInfos = automaticTapeCreationPolicyInfosDecoded0
    }
}

public struct ListFileSharesInputBodyMiddleware: Middleware {
    public let id: String = "ListFileSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSharesOutputError>
}

extension ListFileSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFileSharesInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListFileSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListFileSharesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFileSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSharesOutputError>
}

public struct ListFileSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFileSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSharesInput>
    public typealias MOutput = OperationOutput<ListFileSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSharesOutputError>
}

/// <p>ListFileShareInput</p>
public struct ListFileSharesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If
    ///          this field is not present, all file shares under your account are listed.</p>
    public let gatewayARN: String?
    /// <p>The maximum number of file shares to return in the response. The value must be an
    ///          integer with a value greater than zero. Optional.</p>
    public let limit: Int?
    /// <p>Opaque pagination token returned from a previous ListFileShares operation. If present,
    ///             <code>Marker</code> specifies where to continue the list from after a previous call to
    ///          ListFileShares. Optional.</p>
    public let marker: String?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSharesInputBody: Equatable {
    public let gatewayARN: String?
    public let limit: Int?
    public let marker: String?
}

extension ListFileSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFileSharesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFileSharesOutputResponse(fileShareInfoList: \(String(describing: fileShareInfoList)), marker: \(String(describing: marker)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListFileSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFileSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareInfoList = output.fileShareInfoList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileShareInfoList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

/// <p>ListFileShareOutput</p>
public struct ListFileSharesOutputResponse: Equatable {
    /// <p>An array of information about the file gateway's file shares.</p>
    public let fileShareInfoList: [FileShareInfo]?
    /// <p>If the request includes <code>Marker</code>, the response returns that value in this
    ///          field.</p>
    public let marker: String?
    /// <p>If a value is present, there are more file shares to return. In a subsequent request,
    ///          use <code>NextMarker</code> as the value for <code>Marker</code> to retrieve the next set
    ///          of file shares.</p>
    public let nextMarker: String?

    public init (
        fileShareInfoList: [FileShareInfo]? = nil,
        marker: String? = nil,
        nextMarker: String? = nil
    )
    {
        self.fileShareInfoList = fileShareInfoList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSharesOutputResponseBody: Equatable {
    public let marker: String?
    public let nextMarker: String?
    public let fileShareInfoList: [FileShareInfo]?
}

extension ListFileSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareInfoList = "FileShareInfoList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileShareInfoListContainer = try containerValues.decodeIfPresent([FileShareInfo?].self, forKey: .fileShareInfoList)
        var fileShareInfoListDecoded0:[FileShareInfo]? = nil
        if let fileShareInfoListContainer = fileShareInfoListContainer {
            fileShareInfoListDecoded0 = [FileShareInfo]()
            for structure0 in fileShareInfoListContainer {
                if let structure0 = structure0 {
                    fileShareInfoListDecoded0?.append(structure0)
                }
            }
        }
        fileShareInfoList = fileShareInfoListDecoded0
    }
}

public struct ListFileSystemAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "ListFileSystemAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSystemAssociationsOutputError>
}

extension ListFileSystemAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFileSystemAssociationsInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListFileSystemAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListFileSystemAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFileSystemAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSystemAssociationsOutputError>
}

public struct ListFileSystemAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFileSystemAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFileSystemAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFileSystemAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFileSystemAssociationsInput>
    public typealias MOutput = OperationOutput<ListFileSystemAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFileSystemAssociationsOutputError>
}

public struct ListFileSystemAssociationsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The maximum number of file system associations to return in the response. If present, <code>Limit</code> must be an integer with a value greater than zero. Optional.</p>
    public let limit: Int?
    /// <p>Opaque pagination token returned from a previous <code>ListFileSystemAssociations</code> operation. If present, <code>Marker</code> specifies where to continue the list from after a previous call to <code>ListFileSystemAssociations</code>. Optional.</p>
    public let marker: String?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListFileSystemAssociationsInputBody: Equatable {
    public let gatewayARN: String?
    public let limit: Int?
    public let marker: String?
}

extension ListFileSystemAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListFileSystemAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFileSystemAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFileSystemAssociationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFileSystemAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFileSystemAssociationsOutputResponse(fileSystemAssociationSummaryList: \(String(describing: fileSystemAssociationSummaryList)), marker: \(String(describing: marker)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListFileSystemAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFileSystemAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemAssociationSummaryList = output.fileSystemAssociationSummaryList
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystemAssociationSummaryList = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFileSystemAssociationsOutputResponse: Equatable {
    /// <p>An array of information about the Amazon FSx gateway's file system associations.</p>
    public let fileSystemAssociationSummaryList: [FileSystemAssociationSummary]?
    /// <p>If the request includes <code>Marker</code>, the response returns that value in this field.</p>
    public let marker: String?
    /// <p>If a value is present, there are more file system associations to return.
    ///          In a subsequent request, use <code>NextMarker</code> as the value for <code>Marker</code> to retrieve the next set of file system associations.</p>
    public let nextMarker: String?

    public init (
        fileSystemAssociationSummaryList: [FileSystemAssociationSummary]? = nil,
        marker: String? = nil,
        nextMarker: String? = nil
    )
    {
        self.fileSystemAssociationSummaryList = fileSystemAssociationSummaryList
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct ListFileSystemAssociationsOutputResponseBody: Equatable {
    public let marker: String?
    public let nextMarker: String?
    public let fileSystemAssociationSummaryList: [FileSystemAssociationSummary]?
}

extension ListFileSystemAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationSummaryList = "FileSystemAssociationSummaryList"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let fileSystemAssociationSummaryListContainer = try containerValues.decodeIfPresent([FileSystemAssociationSummary?].self, forKey: .fileSystemAssociationSummaryList)
        var fileSystemAssociationSummaryListDecoded0:[FileSystemAssociationSummary]? = nil
        if let fileSystemAssociationSummaryListContainer = fileSystemAssociationSummaryListContainer {
            fileSystemAssociationSummaryListDecoded0 = [FileSystemAssociationSummary]()
            for structure0 in fileSystemAssociationSummaryListContainer {
                if let structure0 = structure0 {
                    fileSystemAssociationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fileSystemAssociationSummaryList = fileSystemAssociationSummaryListDecoded0
    }
}

public struct ListGatewaysInputBodyMiddleware: Middleware {
    public let id: String = "ListGatewaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

extension ListGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListGatewaysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

/// <p>A JSON object containing zero or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ListGatewaysInput$Limit</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListGatewaysInput$Marker</a>
///                </p>
///             </li>
///          </ul>
public struct ListGatewaysInput: Equatable {
    /// <p>Specifies that the list of gateways returned be limited to the specified number of
    ///          items.</p>
    public let limit: Int?
    /// <p>An opaque string that indicates the position at which to begin the returned list of
    ///          gateways.</p>
    public let marker: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
    }
}

struct ListGatewaysInputBody: Equatable {
    public let marker: String?
    public let limit: Int?
}

extension ListGatewaysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysOutputResponse(gateways: \(String(describing: gateways)), marker: \(String(describing: marker)))"}
}

extension ListGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gateways = output.gateways
            self.marker = output.marker
        } else {
            self.gateways = nil
            self.marker = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Equatable {
    /// <p>An array of <a>GatewayInfo</a> objects.</p>
    public let gateways: [GatewayInfo]?
    /// <p>Use the marker in your next request to fetch the next set of gateways in the list. If
    ///          there are no more gateways to list, this field does not appear in the response.</p>
    public let marker: String?

    public init (
        gateways: [GatewayInfo]? = nil,
        marker: String? = nil
    )
    {
        self.gateways = gateways
        self.marker = marker
    }
}

struct ListGatewaysOutputResponseBody: Equatable {
    public let gateways: [GatewayInfo]?
    public let marker: String?
}

extension ListGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gateways = "Gateways"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([GatewayInfo?].self, forKey: .gateways)
        var gatewaysDecoded0:[GatewayInfo]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [GatewayInfo]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListLocalDisksInputBodyMiddleware: Middleware {
    public let id: String = "ListLocalDisksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocalDisksOutputError>
}

extension ListLocalDisksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLocalDisksInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ListLocalDisksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListLocalDisksInputHeadersMiddleware: Middleware {
    public let id: String = "ListLocalDisksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocalDisksOutputError>
}

public struct ListLocalDisksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLocalDisksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLocalDisksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLocalDisksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLocalDisksInput>
    public typealias MOutput = OperationOutput<ListLocalDisksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLocalDisksOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway.</p>
public struct ListLocalDisksInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksInputBody: Equatable {
    public let gatewayARN: String?
}

extension ListLocalDisksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListLocalDisksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLocalDisksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLocalDisksOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLocalDisksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLocalDisksOutputResponse(disks: \(String(describing: disks)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ListLocalDisksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLocalDisksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disks = output.disks
            self.gatewayARN = output.gatewayARN
        } else {
            self.disks = nil
            self.gatewayARN = nil
        }
    }
}

public struct ListLocalDisksOutputResponse: Equatable {
    /// <p>A JSON object containing the following fields:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListLocalDisksOutput$Disks</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let disks: [Disk]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        disks: [Disk]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.disks = disks
        self.gatewayARN = gatewayARN
    }
}

struct ListLocalDisksOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let disks: [Disk]?
}

extension ListLocalDisksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disks = "Disks"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let disksContainer = try containerValues.decodeIfPresent([Disk?].self, forKey: .disks)
        var disksDecoded0:[Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p>ListTagsForResourceInput</p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>Specifies that the list of tags returned be limited to the specified number of
    ///          items.</p>
    public let limit: Int?
    /// <p>An opaque string that indicates the position at which to begin returning the list of
    ///          tags.</p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of the resource for which you want to list tags.</p>
    public let resourceARN: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
    public let marker: String?
    public let limit: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(marker: \(String(describing: marker)), resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.resourceARN = output.resourceARN
            self.tags = output.tags
        } else {
            self.marker = nil
            self.resourceARN = nil
            self.tags = nil
        }
    }
}

/// <p>ListTagsForResourceOutput</p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An opaque string that indicates the position at which to stop returning the list of
    ///          tags.</p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of the resource for which you want to list tags.</p>
    public let resourceARN: String?
    /// <p>An array that contains the tags for the specified resource.</p>
    public let tags: [Tag]?

    public init (
        marker: String? = nil,
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.marker = marker
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let resourceARN: String?
    public let marker: String?
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTapePoolsInputBodyMiddleware: Middleware {
    public let id: String = "ListTapePoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapePoolsOutputError>
}

extension ListTapePoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTapePoolsInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), poolARNs: \(String(describing: poolARNs)))"}
}

extension ListTapePoolsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let poolARNs = poolARNs {
            var poolARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .poolARNs)
            for poolarns0 in poolARNs {
                try poolARNsContainer.encode(poolarns0)
            }
        }
    }
}

public struct ListTapePoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTapePoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapePoolsOutputError>
}

public struct ListTapePoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTapePoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapePoolsInput>
    public typealias MOutput = OperationOutput<ListTapePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapePoolsOutputError>
}

public struct ListTapePoolsInput: Equatable {
    /// <p>An optional number limit for the tape pools in the list returned by this call.</p>
    public let limit: Int?
    /// <p>A string that indicates the position at which to begin the returned list of tape
    ///          pools.</p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you
    ///          don't specify a custom tape pool ARN, the response lists all custom tape pools. </p>
    public let poolARNs: [String]?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        poolARNs: [String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.poolARNs = poolARNs
    }
}

struct ListTapePoolsInputBody: Equatable {
    public let poolARNs: [String]?
    public let marker: String?
    public let limit: Int?
}

extension ListTapePoolsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case poolARNs = "PoolARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .poolARNs)
        var poolARNsDecoded0:[String]? = nil
        if let poolARNsContainer = poolARNsContainer {
            poolARNsDecoded0 = [String]()
            for string0 in poolARNsContainer {
                if let string0 = string0 {
                    poolARNsDecoded0?.append(string0)
                }
            }
        }
        poolARNs = poolARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapePoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapePoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTapePoolsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapePoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTapePoolsOutputResponse(marker: \(String(describing: marker)), poolInfos: \(String(describing: poolInfos)))"}
}

extension ListTapePoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTapePoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.poolInfos = output.poolInfos
        } else {
            self.marker = nil
            self.poolInfos = nil
        }
    }
}

public struct ListTapePoolsOutputResponse: Equatable {
    /// <p>A string that indicates the position at which to begin the returned list of tape pools.
    ///          Use the marker in your next request to continue pagination of tape pools. If there are no
    ///          more tape pools to list, this element does not appear in the response body. </p>
    public let marker: String?
    /// <p>An array of <code>PoolInfo</code> objects, where each object describes a single custom
    ///          tape pool. If there are no custom tape pools, the <code>PoolInfos</code> is an empty array.
    ///       </p>
    public let poolInfos: [PoolInfo]?

    public init (
        marker: String? = nil,
        poolInfos: [PoolInfo]? = nil
    )
    {
        self.marker = marker
        self.poolInfos = poolInfos
    }
}

struct ListTapePoolsOutputResponseBody: Equatable {
    public let poolInfos: [PoolInfo]?
    public let marker: String?
}

extension ListTapePoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case poolInfos = "PoolInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolInfosContainer = try containerValues.decodeIfPresent([PoolInfo?].self, forKey: .poolInfos)
        var poolInfosDecoded0:[PoolInfo]? = nil
        if let poolInfosContainer = poolInfosContainer {
            poolInfosDecoded0 = [PoolInfo]()
            for structure0 in poolInfosContainer {
                if let structure0 = structure0 {
                    poolInfosDecoded0?.append(structure0)
                }
            }
        }
        poolInfos = poolInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListTapesInputBodyMiddleware: Middleware {
    public let id: String = "ListTapesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapesInput>
    public typealias MOutput = OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapesOutputError>
}

extension ListTapesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTapesInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), tapeARNs: \(String(describing: tapeARNs)))"}
}

extension ListTapesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let tapeARNs = tapeARNs {
            var tapeARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tapeARNs)
            for tapearns0 in tapeARNs {
                try tapeARNsContainer.encode(tapearns0)
            }
        }
    }
}

public struct ListTapesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTapesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapesInput>
    public typealias MOutput = OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapesOutputError>
}

public struct ListTapesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTapesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTapesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTapesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTapesInput>
    public typealias MOutput = OperationOutput<ListTapesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTapesOutputError>
}

/// <p>A JSON object that contains one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ListTapesInput$Limit</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListTapesInput$Marker</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListTapesInput$TapeARNs</a>
///                </p>
///             </li>
///          </ul>
public struct ListTapesInput: Equatable {
    /// <p>An optional number limit for the tapes in the list returned by this call.</p>
    public let limit: Int?
    /// <p>A string that indicates the position at which to begin the returned list of
    ///          tapes.</p>
    public let marker: String?
    /// <p>The Amazon Resource Name (ARN) of each of the tapes you want to list. If you don't
    ///          specify a tape ARN, the response lists all tapes in both your VTL and VTS.</p>
    public let tapeARNs: [String]?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        tapeARNs: [String]? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.tapeARNs = tapeARNs
    }
}

struct ListTapesInputBody: Equatable {
    public let tapeARNs: [String]?
    public let marker: String?
    public let limit: Int?
}

extension ListTapesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case marker = "Marker"
        case tapeARNs = "TapeARNs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tapeARNs)
        var tapeARNsDecoded0:[String]? = nil
        if let tapeARNsContainer = tapeARNsContainer {
            tapeARNsDecoded0 = [String]()
            for string0 in tapeARNsContainer {
                if let string0 = string0 {
                    tapeARNsDecoded0?.append(string0)
                }
            }
        }
        tapeARNs = tapeARNsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTapesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTapesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTapesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTapesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTapesOutputResponse(marker: \(String(describing: marker)), tapeInfos: \(String(describing: tapeInfos)))"}
}

extension ListTapesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTapesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.tapeInfos = output.tapeInfos
        } else {
            self.marker = nil
            self.tapeInfos = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ListTapesOutput$Marker</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListTapesOutput$VolumeInfos</a>
///                </p>
///             </li>
///          </ul>
public struct ListTapesOutputResponse: Equatable {
    /// <p>A string that indicates the position at which to begin returning the next list of tapes.
    ///          Use the marker in your next request to continue pagination of tapes. If there are no more
    ///          tapes to list, this element does not appear in the response body.</p>
    public let marker: String?
    /// <p>An array of <a>TapeInfo</a> objects, where each object describes a single
    ///          tape. If there are no tapes in the tape library or VTS, then the <code>TapeInfos</code> is
    ///          an empty array.</p>
    public let tapeInfos: [TapeInfo]?

    public init (
        marker: String? = nil,
        tapeInfos: [TapeInfo]? = nil
    )
    {
        self.marker = marker
        self.tapeInfos = tapeInfos
    }
}

struct ListTapesOutputResponseBody: Equatable {
    public let tapeInfos: [TapeInfo]?
    public let marker: String?
}

extension ListTapesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case tapeInfos = "TapeInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeInfosContainer = try containerValues.decodeIfPresent([TapeInfo?].self, forKey: .tapeInfos)
        var tapeInfosDecoded0:[TapeInfo]? = nil
        if let tapeInfosContainer = tapeInfosContainer {
            tapeInfosDecoded0 = [TapeInfo]()
            for structure0 in tapeInfosContainer {
                if let structure0 = structure0 {
                    tapeInfosDecoded0?.append(structure0)
                }
            }
        }
        tapeInfos = tapeInfosDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct ListVolumeInitiatorsInputBodyMiddleware: Middleware {
    public let id: String = "ListVolumeInitiatorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeInitiatorsOutputError>
}

extension ListVolumeInitiatorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumeInitiatorsInput(volumeARN: \(String(describing: volumeARN)))"}
}

extension ListVolumeInitiatorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct ListVolumeInitiatorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListVolumeInitiatorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeInitiatorsOutputError>
}

public struct ListVolumeInitiatorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVolumeInitiatorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeInitiatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeInitiatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeInitiatorsInput>
    public typealias MOutput = OperationOutput<ListVolumeInitiatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeInitiatorsOutputError>
}

/// <p>ListVolumeInitiatorsInput</p>
public struct ListVolumeInitiatorsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes for the gateway.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct ListVolumeInitiatorsInputBody: Equatable {
    public let volumeARN: String?
}

extension ListVolumeInitiatorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

extension ListVolumeInitiatorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeInitiatorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumeInitiatorsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeInitiatorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumeInitiatorsOutputResponse(initiators: \(String(describing: initiators)))"}
}

extension ListVolumeInitiatorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVolumeInitiatorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.initiators = output.initiators
        } else {
            self.initiators = nil
        }
    }
}

/// <p>ListVolumeInitiatorsOutput</p>
public struct ListVolumeInitiatorsOutputResponse: Equatable {
    /// <p>The host names and port numbers of all iSCSI initiators that are connected to the
    ///          gateway.</p>
    public let initiators: [String]?

    public init (
        initiators: [String]? = nil
    )
    {
        self.initiators = initiators
    }
}

struct ListVolumeInitiatorsOutputResponseBody: Equatable {
    public let initiators: [String]?
}

extension ListVolumeInitiatorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initiators = "Initiators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .initiators)
        var initiatorsDecoded0:[String]? = nil
        if let initiatorsContainer = initiatorsContainer {
            initiatorsDecoded0 = [String]()
            for string0 in initiatorsContainer {
                if let string0 = string0 {
                    initiatorsDecoded0?.append(string0)
                }
            }
        }
        initiators = initiatorsDecoded0
    }
}

public struct ListVolumeRecoveryPointsInputBodyMiddleware: Middleware {
    public let id: String = "ListVolumeRecoveryPointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeRecoveryPointsOutputError>
}

extension ListVolumeRecoveryPointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumeRecoveryPointsInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ListVolumeRecoveryPointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ListVolumeRecoveryPointsInputHeadersMiddleware: Middleware {
    public let id: String = "ListVolumeRecoveryPointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeRecoveryPointsOutputError>
}

public struct ListVolumeRecoveryPointsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVolumeRecoveryPointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumeRecoveryPointsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumeRecoveryPointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumeRecoveryPointsInput>
    public typealias MOutput = OperationOutput<ListVolumeRecoveryPointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumeRecoveryPointsOutputError>
}

public struct ListVolumeRecoveryPointsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ListVolumeRecoveryPointsInputBody: Equatable {
    public let gatewayARN: String?
}

extension ListVolumeRecoveryPointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ListVolumeRecoveryPointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumeRecoveryPointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumeRecoveryPointsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumeRecoveryPointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumeRecoveryPointsOutputResponse(gatewayARN: \(String(describing: gatewayARN)), volumeRecoveryPointInfos: \(String(describing: volumeRecoveryPointInfos)))"}
}

extension ListVolumeRecoveryPointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVolumeRecoveryPointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.volumeRecoveryPointInfos = output.volumeRecoveryPointInfos
        } else {
            self.gatewayARN = nil
            self.volumeRecoveryPointInfos = nil
        }
    }
}

public struct ListVolumeRecoveryPointsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>An array of <a>VolumeRecoveryPointInfo</a> objects.</p>
    public let volumeRecoveryPointInfos: [VolumeRecoveryPointInfo]?

    public init (
        gatewayARN: String? = nil,
        volumeRecoveryPointInfos: [VolumeRecoveryPointInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.volumeRecoveryPointInfos = volumeRecoveryPointInfos
    }
}

struct ListVolumeRecoveryPointsOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let volumeRecoveryPointInfos: [VolumeRecoveryPointInfo]?
}

extension ListVolumeRecoveryPointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case volumeRecoveryPointInfos = "VolumeRecoveryPointInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let volumeRecoveryPointInfosContainer = try containerValues.decodeIfPresent([VolumeRecoveryPointInfo?].self, forKey: .volumeRecoveryPointInfos)
        var volumeRecoveryPointInfosDecoded0:[VolumeRecoveryPointInfo]? = nil
        if let volumeRecoveryPointInfosContainer = volumeRecoveryPointInfosContainer {
            volumeRecoveryPointInfosDecoded0 = [VolumeRecoveryPointInfo]()
            for structure0 in volumeRecoveryPointInfosContainer {
                if let structure0 = structure0 {
                    volumeRecoveryPointInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeRecoveryPointInfos = volumeRecoveryPointInfosDecoded0
    }
}

public struct ListVolumesInputBodyMiddleware: Middleware {
    public let id: String = "ListVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumesInput>
    public typealias MOutput = OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumesOutputError>
}

extension ListVolumesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumesInput(gatewayARN: \(String(describing: gatewayARN)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListVolumesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListVolumesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumesInput>
    public typealias MOutput = OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumesOutputError>
}

public struct ListVolumesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVolumesInput>
    public typealias MOutput = OperationOutput<ListVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVolumesOutputError>
}

/// <p>A JSON object that contains one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ListVolumesInput$Limit</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListVolumesInput$Marker</a>
///                </p>
///             </li>
///          </ul>
public struct ListVolumesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Specifies that the list of volumes returned be limited to the specified number of
    ///          items.</p>
    public let limit: Int?
    /// <p>A string that indicates the position at which to begin the returned list of volumes.
    ///          Obtain the marker from the response of a previous List iSCSI Volumes request.</p>
    public let marker: String?

    public init (
        gatewayARN: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.limit = limit
        self.marker = marker
    }
}

struct ListVolumesInputBody: Equatable {
    public let gatewayARN: String?
    public let marker: String?
    public let limit: Int?
}

extension ListVolumesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case limit = "Limit"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListVolumesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVolumesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVolumesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVolumesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVolumesOutputResponse(gatewayARN: \(String(describing: gatewayARN)), marker: \(String(describing: marker)), volumeInfos: \(String(describing: volumeInfos)))"}
}

extension ListVolumesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVolumesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.marker = output.marker
            self.volumeInfos = output.volumeInfos
        } else {
            self.gatewayARN = nil
            self.marker = nil
            self.volumeInfos = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>ListVolumesOutput$Marker</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>ListVolumesOutput$VolumeInfos</a>
///                </p>
///             </li>
///          </ul>
public struct ListVolumesOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Use the marker in your next request to continue pagination of iSCSI volumes. If there
    ///          are no more volumes to list, this field does not appear in the response body.</p>
    public let marker: String?
    /// <p>An array of <a>VolumeInfo</a> objects, where each object describes an iSCSI
    ///          volume. If no volumes are defined for the gateway, then <code>VolumeInfos</code> is an
    ///          empty array "[]".</p>
    public let volumeInfos: [VolumeInfo]?

    public init (
        gatewayARN: String? = nil,
        marker: String? = nil,
        volumeInfos: [VolumeInfo]? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.marker = marker
        self.volumeInfos = volumeInfos
    }
}

struct ListVolumesOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let marker: String?
    public let volumeInfos: [VolumeInfo]?
}

extension ListVolumesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case marker = "Marker"
        case volumeInfos = "VolumeInfos"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let volumeInfosContainer = try containerValues.decodeIfPresent([VolumeInfo?].self, forKey: .volumeInfos)
        var volumeInfosDecoded0:[VolumeInfo]? = nil
        if let volumeInfosContainer = volumeInfosContainer {
            volumeInfosDecoded0 = [VolumeInfo]()
            for structure0 in volumeInfosContainer {
                if let structure0 = structure0 {
                    volumeInfosDecoded0?.append(structure0)
                }
            }
        }
        volumeInfos = volumeInfosDecoded0
    }
}

extension NFSFileShareDefaults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryMode = "DirectoryMode"
        case fileMode = "FileMode"
        case groupId = "GroupId"
        case ownerId = "OwnerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryMode = directoryMode {
            try encodeContainer.encode(directoryMode, forKey: .directoryMode)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode, forKey: .fileMode)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let directoryModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryMode)
        directoryMode = directoryModeDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .groupId)
        groupId = groupIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
    }
}

extension NFSFileShareDefaults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NFSFileShareDefaults(directoryMode: \(String(describing: directoryMode)), fileMode: \(String(describing: fileMode)), groupId: \(String(describing: groupId)), ownerId: \(String(describing: ownerId)))"}
}

/// <p>Describes Network File System (NFS) file share default values. Files and folders stored
///          as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions
///          assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that
///          represent files and folders are assigned these default Unix permissions. This operation is
///          only supported for file gateways.</p>
public struct NFSFileShareDefaults: Equatable {
    /// <p>The Unix directory mode in the form "nnnn". For example, <code>0666</code> represents
    ///          the default access mode for all directories inside the file share. The default value is
    ///             <code>0777</code>.</p>
    public let directoryMode: String?
    /// <p>The Unix file mode in the form "nnnn". For example, <code>0666</code> represents the
    ///          default file mode inside the file share. The default value is <code>0666</code>.</p>
    public let fileMode: String?
    /// <p>The default group ID for the file share (unless the files have another group ID
    ///          specified). The default value is <code>nfsnobody</code>.</p>
    public let groupId: Int?
    /// <p>The default owner ID for files in the file share (unless the files have another owner ID
    ///          specified). The default value is <code>nfsnobody</code>.</p>
    public let ownerId: Int?

    public init (
        directoryMode: String? = nil,
        fileMode: String? = nil,
        groupId: Int? = nil,
        ownerId: Int? = nil
    )
    {
        self.directoryMode = directoryMode
        self.fileMode = fileMode
        self.groupId = groupId
        self.ownerId = ownerId
    }
}

extension NFSFileShareInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case squash = "Squash"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if kMSEncrypted != false {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clientList)
        var clientListDecoded0:[String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension NFSFileShareInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NFSFileShareInfo(cacheAttributes: \(String(describing: cacheAttributes)), clientList: \(String(describing: clientList)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareARN: \(String(describing: fileShareARN)), fileShareId: \(String(describing: fileShareId)), fileShareName: \(String(describing: fileShareName)), fileShareStatus: \(String(describing: fileShareStatus)), gatewayARN: \(String(describing: gatewayARN)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), locationARN: \(String(describing: locationARN)), nFSFileShareDefaults: \(String(describing: nFSFileShareDefaults)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), path: \(String(describing: path)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), role: \(String(describing: role)), squash: \(String(describing: squash)), tags: \(String(describing: tags)))"}
}

/// <p>The Unix file permissions and ownership information assigned, by default, to native S3
///          objects when file gateway discovers them in S3 buckets. This operation is only supported in
///          file gateways.</p>
public struct NFSFileShareInfo: Equatable {
    /// <p>Refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The list of clients that are allowed to access the file gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.</p>
    public let clientList: [String]?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?
    /// <p>The ID of the file share.</p>
    public let fileShareId: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>The status of the file share.</p>
    ///
    ///          <p>Valid Values: <code>CREATING</code> | <code>UPDATING</code> | <code>AVAILABLE</code> |
    ///             <code>DELETING</code>
    ///          </p>
    public let fileShareStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".</p>
    public let locationARN: String?
    /// <p>Describes Network File System (NFS) file share default values. Files and folders stored
    ///          as Amazon S3 objects in S3 buckets don't, by default, have Unix file permissions
    ///          assigned to them. Upon discovery in an S3 bucket by Storage Gateway, the S3 objects that
    ///          represent files and folders are assigned these default Unix permissions. This operation is
    ///          only supported for file gateways.</p>
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>The file share path used by the NFS client to identify the mount point.</p>
    public let path: String?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The ARN of the IAM role that file gateway assumes when it accesses the underlying
    ///          storage.</p>
    public let role: String?
    /// <p>The user mapped to anonymous user. Valid options are the following:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NoSquash</code>: No one is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
    ///             </li>
    ///          </ul>
    public let squash: String?
    /// <p>A list of up to 50 tags assigned to the NFS file share, sorted alphabetically by key
    ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
    ///          view all tags using the <code>ListTagsForResource</code> API operation.</p>
    public let tags: [Tag]?

    public init (
        cacheAttributes: CacheAttributes? = nil,
        clientList: [String]? = nil,
        defaultStorageClass: String? = nil,
        fileShareARN: String? = nil,
        fileShareId: String? = nil,
        fileShareName: String? = nil,
        fileShareStatus: String? = nil,
        gatewayARN: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        kMSEncrypted: Bool = false,
        kMSKey: String? = nil,
        locationARN: String? = nil,
        nFSFileShareDefaults: NFSFileShareDefaults? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        path: String? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        role: String? = nil,
        squash: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareId = fileShareId
        self.fileShareName = fileShareName
        self.fileShareStatus = fileShareStatus
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.path = path
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipv4Address = "Ipv4Address"
        case ipv6Address = "Ipv6Address"
        case macAddress = "MacAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv4Address = ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let ipv6Address = ipv6Address {
            try encodeContainer.encode(ipv6Address, forKey: .ipv6Address)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipv6AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipv6Address)
        ipv6Address = ipv6AddressDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(ipv4Address: \(String(describing: ipv4Address)), ipv6Address: \(String(describing: ipv6Address)), macAddress: \(String(describing: macAddress)))"}
}

/// <p>Describes a gateway's network interface.</p>
public struct NetworkInterface: Equatable {
    /// <p>The Internet Protocol version 4 (IPv4) address of the interface.</p>
    public let ipv4Address: String?
    /// <p>The Internet Protocol version 6 (IPv6) address of the interface. <i>Currently not
    ///             supported</i>.</p>
    public let ipv6Address: String?
    /// <p>The Media Access Control (MAC) address of the interface.</p>
    ///
    ///          <note>
    ///             <p>This is currently unsupported and will not be returned in output.</p>
    ///          </note>
    public let macAddress: String?

    public init (
        ipv4Address: String? = nil,
        ipv6Address: String? = nil,
        macAddress: String? = nil
    )
    {
        self.ipv4Address = ipv4Address
        self.ipv6Address = ipv6Address
        self.macAddress = macAddress
    }
}

public struct NotifyWhenUploadedInputBodyMiddleware: Middleware {
    public let id: String = "NotifyWhenUploadedInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWhenUploadedOutputError>
}

extension NotifyWhenUploadedInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyWhenUploadedInput(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension NotifyWhenUploadedInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
    }
}

public struct NotifyWhenUploadedInputHeadersMiddleware: Middleware {
    public let id: String = "NotifyWhenUploadedInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWhenUploadedOutputError>
}

public struct NotifyWhenUploadedInputQueryItemMiddleware: Middleware {
    public let id: String = "NotifyWhenUploadedInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyWhenUploadedInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyWhenUploadedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyWhenUploadedInput>
    public typealias MOutput = OperationOutput<NotifyWhenUploadedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyWhenUploadedOutputError>
}

public struct NotifyWhenUploadedInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct NotifyWhenUploadedInputBody: Equatable {
    public let fileShareARN: String?
}

extension NotifyWhenUploadedInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

extension NotifyWhenUploadedOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyWhenUploadedOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyWhenUploadedOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyWhenUploadedOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyWhenUploadedOutputResponse(fileShareARN: \(String(describing: fileShareARN)), notificationId: \(String(describing: notificationId)))"}
}

extension NotifyWhenUploadedOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotifyWhenUploadedOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

public struct NotifyWhenUploadedOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?
    /// <p>The randomly generated ID of the notification that was sent. This ID is in UUID
    ///          format.</p>
    public let notificationId: String?

    public init (
        fileShareARN: String? = nil,
        notificationId: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct NotifyWhenUploadedOutputResponseBody: Equatable {
    public let fileShareARN: String?
    public let notificationId: String?
}

extension NotifyWhenUploadedOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

/// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
public enum ObjectACL {
    case authenticatedRead
    case awsExecRead
    case bucketOwnerFullControl
    case bucketOwnerRead
    case `private`
    case publicRead
    case publicReadWrite
    case sdkUnknown(String)
}

extension ObjectACL : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectACL] {
        return [
            .authenticatedRead,
            .awsExecRead,
            .bucketOwnerFullControl,
            .bucketOwnerRead,
            .private,
            .publicRead,
            .publicReadWrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRead: return "authenticated-read"
        case .awsExecRead: return "aws-exec-read"
        case .bucketOwnerFullControl: return "bucket-owner-full-control"
        case .bucketOwnerRead: return "bucket-owner-read"
        case .private: return "private"
        case .publicRead: return "public-read"
        case .publicReadWrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectACL(rawValue: rawValue) ?? ObjectACL.sdkUnknown(rawValue)
    }
}

extension PoolInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case poolARN = "PoolARN"
        case poolName = "PoolName"
        case poolStatus = "PoolStatus"
        case retentionLockTimeInDays = "RetentionLockTimeInDays"
        case retentionLockType = "RetentionLockType"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolARN = poolARN {
            try encodeContainer.encode(poolARN, forKey: .poolARN)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let poolStatus = poolStatus {
            try encodeContainer.encode(poolStatus.rawValue, forKey: .poolStatus)
        }
        if let retentionLockTimeInDays = retentionLockTimeInDays {
            try encodeContainer.encode(retentionLockTimeInDays, forKey: .retentionLockTimeInDays)
        }
        if let retentionLockType = retentionLockType {
            try encodeContainer.encode(retentionLockType.rawValue, forKey: .retentionLockType)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolARN)
        poolARN = poolARNDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(TapeStorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionLockTypeDecoded = try containerValues.decodeIfPresent(RetentionLockType.self, forKey: .retentionLockType)
        retentionLockType = retentionLockTypeDecoded
        let retentionLockTimeInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionLockTimeInDays)
        retentionLockTimeInDays = retentionLockTimeInDaysDecoded
        let poolStatusDecoded = try containerValues.decodeIfPresent(PoolStatus.self, forKey: .poolStatus)
        poolStatus = poolStatusDecoded
    }
}

extension PoolInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PoolInfo(poolARN: \(String(describing: poolARN)), poolName: \(String(describing: poolName)), poolStatus: \(String(describing: poolStatus)), retentionLockTimeInDays: \(String(describing: retentionLockTimeInDays)), retentionLockType: \(String(describing: retentionLockType)), storageClass: \(String(describing: storageClass)))"}
}

/// <p>Describes a custom tape pool.</p>
public struct PoolInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom tape pool. Use the <a>ListTapePools</a> operation to return a list of custom tape pools for your
    ///          account and AWS Region.</p>
    public let poolARN: String?
    /// <p>The name of the custom tape pool. <code>PoolName</code> can use all ASCII characters,
    ///          except '/' and '\'.</p>
    public let poolName: String?
    /// <p>Status of the custom tape pool. Pool can be <code>ACTIVE</code> or
    ///          <code>DELETED</code>.</p>
    public let poolStatus: PoolStatus?
    /// <p>Tape retention lock time is set in days. Tape retention lock can be enabled for up to
    ///          100 years (36,500 days).</p>
    public let retentionLockTimeInDays: Int?
    /// <p>Tape retention lock type, which can be configured in two modes. When configured in
    ///          governance mode, AWS accounts with specific IAM permissions are authorized to remove the
    ///          tape retention lock from archived virtual tapes. When configured in compliance mode, the
    ///          tape retention lock cannot be removed by any user, including the root AWS account.</p>
    public let retentionLockType: RetentionLockType?
    /// <p>The storage class that is associated with the custom pool. When you use your backup
    ///          application to eject the tape, the tape is archived directly into the storage class (S3
    ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    public let storageClass: TapeStorageClass?

    public init (
        poolARN: String? = nil,
        poolName: String? = nil,
        poolStatus: PoolStatus? = nil,
        retentionLockTimeInDays: Int? = nil,
        retentionLockType: RetentionLockType? = nil,
        storageClass: TapeStorageClass? = nil
    )
    {
        self.poolARN = poolARN
        self.poolName = poolName
        self.poolStatus = poolStatus
        self.retentionLockTimeInDays = retentionLockTimeInDays
        self.retentionLockType = retentionLockType
        self.storageClass = storageClass
    }
}

public enum PoolStatus {
    case active
    case deleted
    case sdkUnknown(String)
}

extension PoolStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PoolStatus] {
        return [
            .active,
            .deleted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PoolStatus(rawValue: rawValue) ?? PoolStatus.sdkUnknown(rawValue)
    }
}

public struct RefreshCacheInputBodyMiddleware: Middleware {
    public let id: String = "RefreshCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshCacheOutputError>
}

extension RefreshCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshCacheInput(fileShareARN: \(String(describing: fileShareARN)), folderList: \(String(describing: folderList)), recursive: \(String(describing: recursive)))"}
}

extension RefreshCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let folderList = folderList {
            var folderListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderList)
            for folderlist0 in folderList {
                try folderListContainer.encode(folderlist0)
            }
        }
        if let recursive = recursive {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
    }
}

public struct RefreshCacheInputHeadersMiddleware: Middleware {
    public let id: String = "RefreshCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshCacheOutputError>
}

public struct RefreshCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "RefreshCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshCacheInput>
    public typealias MOutput = OperationOutput<RefreshCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshCacheOutputError>
}

/// <p>RefreshCacheInput</p>
public struct RefreshCacheInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share you want to refresh.</p>
    public let fileShareARN: String?
    /// <p>A comma-separated list of the paths of folders to refresh in the cache. The default is
    ///             [<code>"/"</code>]. The default refreshes objects and folders at the root of the Amazon
    ///          S3 bucket. If <code>Recursive</code> is set to <code>true</code>, the entire S3 bucket that
    ///          the file share has access to is refreshed.</p>
    public let folderList: [String]?
    /// <p>A value that specifies whether to recursively refresh folders in the cache. The refresh
    ///          includes folders that were in the cache the last time the gateway listed the folder's
    ///          contents. If this value set to <code>true</code>, each folder that is listed in
    ///             <code>FolderList</code> is recursively updated. Otherwise, subfolders listed in
    ///             <code>FolderList</code> are not refreshed. Only objects that are in folders listed
    ///          directly under <code>FolderList</code> are found and used for the update. The default is
    ///             <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let recursive: Bool?

    public init (
        fileShareARN: String? = nil,
        folderList: [String]? = nil,
        recursive: Bool? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.folderList = folderList
        self.recursive = recursive
    }
}

struct RefreshCacheInputBody: Equatable {
    public let fileShareARN: String?
    public let folderList: [String]?
    public let recursive: Bool?
}

extension RefreshCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case folderList = "FolderList"
        case recursive = "Recursive"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let folderListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .folderList)
        var folderListDecoded0:[String]? = nil
        if let folderListContainer = folderListContainer {
            folderListDecoded0 = [String]()
            for string0 in folderListContainer {
                if let string0 = string0 {
                    folderListDecoded0?.append(string0)
                }
            }
        }
        folderList = folderListDecoded0
        let recursiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
    }
}

extension RefreshCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshCacheOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshCacheOutputResponse(fileShareARN: \(String(describing: fileShareARN)), notificationId: \(String(describing: notificationId)))"}
}

extension RefreshCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RefreshCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
            self.notificationId = output.notificationId
        } else {
            self.fileShareARN = nil
            self.notificationId = nil
        }
    }
}

/// <p>RefreshCacheOutput</p>
public struct RefreshCacheOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?
    /// <p>The randomly generated ID of the notification that was sent. This ID is in UUID
    ///          format.</p>
    public let notificationId: String?

    public init (
        fileShareARN: String? = nil,
        notificationId: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
        self.notificationId = notificationId
    }
}

struct RefreshCacheOutputResponseBody: Equatable {
    public let fileShareARN: String?
    public let notificationId: String?
}

extension RefreshCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
        case notificationId = "NotificationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let notificationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationId)
        notificationId = notificationIdDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

/// <p>RemoveTagsFromResourceInput</p>
public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource you want to remove the tags from.</p>
    public let resourceARN: String?
    /// <p>The keys of the tags you want to remove from the specified resource. A tag is composed
    ///          of a key-value pair.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension RemoveTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse(resourceARN: \(String(describing: resourceARN)))"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceARN = output.resourceARN
        } else {
            self.resourceARN = nil
        }
    }
}

/// <p>RemoveTagsFromResourceOutput</p>
public struct RemoveTagsFromResourceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that the tags were removed from.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
    public let resourceARN: String?
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

public struct ResetCacheInputBodyMiddleware: Middleware {
    public let id: String = "ResetCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetCacheInput>
    public typealias MOutput = OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetCacheOutputError>
}

extension ResetCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetCacheInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ResetCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ResetCacheInputHeadersMiddleware: Middleware {
    public let id: String = "ResetCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetCacheInput>
    public typealias MOutput = OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetCacheOutputError>
}

public struct ResetCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetCacheInput>
    public typealias MOutput = OperationOutput<ResetCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetCacheOutputError>
}

public struct ResetCacheInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheInputBody: Equatable {
    public let gatewayARN: String?
}

extension ResetCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ResetCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetCacheOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetCacheOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ResetCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct ResetCacheOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ResetCacheOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension ResetCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public enum RetentionLockType {
    case compliance
    case governance
    case `none`
    case sdkUnknown(String)
}

extension RetentionLockType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RetentionLockType] {
        return [
            .compliance,
            .governance,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliance: return "COMPLIANCE"
        case .governance: return "GOVERNANCE"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RetentionLockType(rawValue: rawValue) ?? RetentionLockType.sdkUnknown(rawValue)
    }
}

public struct RetrieveTapeArchiveInputBodyMiddleware: Middleware {
    public let id: String = "RetrieveTapeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeArchiveOutputError>
}

extension RetrieveTapeArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveTapeArchiveInput(gatewayARN: \(String(describing: gatewayARN)), tapeARN: \(String(describing: tapeARN)))"}
}

extension RetrieveTapeArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct RetrieveTapeArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "RetrieveTapeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeArchiveOutputError>
}

public struct RetrieveTapeArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "RetrieveTapeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeArchiveInput>
    public typealias MOutput = OperationOutput<RetrieveTapeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeArchiveOutputError>
}

/// <p>RetrieveTapeArchiveInput</p>
public struct RetrieveTapeArchiveInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to.
    ///          Use the <a>ListGateways</a> operation to return a list of gateways for your
    ///          account and AWS Region.</p>
    ///
    ///          <p>You retrieve archived virtual tapes to only one gateway and the gateway must be a tape
    ///          gateway.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual
    ///          tape shelf (VTS).</p>
    public let tapeARN: String?

    public init (
        gatewayARN: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveInputBody: Equatable {
    public let tapeARN: String?
    public let gatewayARN: String?
}

extension RetrieveTapeArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveTapeArchiveOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveTapeArchiveOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension RetrieveTapeArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetrieveTapeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>RetrieveTapeArchiveOutput</p>
public struct RetrieveTapeArchiveOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the retrieved virtual tape.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeArchiveOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension RetrieveTapeArchiveOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

public struct RetrieveTapeRecoveryPointInputBodyMiddleware: Middleware {
    public let id: String = "RetrieveTapeRecoveryPointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeRecoveryPointOutputError>
}

extension RetrieveTapeRecoveryPointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveTapeRecoveryPointInput(gatewayARN: \(String(describing: gatewayARN)), tapeARN: \(String(describing: tapeARN)))"}
}

extension RetrieveTapeRecoveryPointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
    }
}

public struct RetrieveTapeRecoveryPointInputHeadersMiddleware: Middleware {
    public let id: String = "RetrieveTapeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeRecoveryPointOutputError>
}

public struct RetrieveTapeRecoveryPointInputQueryItemMiddleware: Middleware {
    public let id: String = "RetrieveTapeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetrieveTapeRecoveryPointInput>,
                  next: H) -> Swift.Result<OperationOutput<RetrieveTapeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetrieveTapeRecoveryPointInput>
    public typealias MOutput = OperationOutput<RetrieveTapeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetrieveTapeRecoveryPointOutputError>
}

/// <p>RetrieveTapeRecoveryPointInput</p>
public struct RetrieveTapeRecoveryPointInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the
    ///          recovery point.</p>
    public let tapeARN: String?

    public init (
        gatewayARN: String? = nil,
        tapeARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointInputBody: Equatable {
    public let tapeARN: String?
    public let gatewayARN: String?
}

extension RetrieveTapeRecoveryPointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension RetrieveTapeRecoveryPointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetrieveTapeRecoveryPointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetrieveTapeRecoveryPointOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetrieveTapeRecoveryPointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetrieveTapeRecoveryPointOutputResponse(tapeARN: \(String(describing: tapeARN)))"}
}

extension RetrieveTapeRecoveryPointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetrieveTapeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tapeARN = output.tapeARN
        } else {
            self.tapeARN = nil
        }
    }
}

/// <p>RetrieveTapeRecoveryPointOutput</p>
public struct RetrieveTapeRecoveryPointOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the virtual tape for which the recovery point was
    ///          retrieved.</p>
    public let tapeARN: String?

    public init (
        tapeARN: String? = nil
    )
    {
        self.tapeARN = tapeARN
    }
}

struct RetrieveTapeRecoveryPointOutputResponseBody: Equatable {
    public let tapeARN: String?
}

extension RetrieveTapeRecoveryPointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
    }
}

extension SMBFileShareInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case authentication = "Authentication"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareId = "FileShareId"
        case fileShareName = "FileShareName"
        case fileShareStatus = "FileShareStatus"
        case gatewayARN = "GatewayARN"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case locationARN = "LocationARN"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case path = "Path"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case role = "Role"
        case sMBACLEnabled = "SMBACLEnabled"
        case tags = "Tags"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let authentication = authentication {
            try encodeContainer.encode(authentication, forKey: .authentication)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareId = fileShareId {
            try encodeContainer.encode(fileShareId, forKey: .fileShareId)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let fileShareStatus = fileShareStatus {
            try encodeContainer.encode(fileShareStatus, forKey: .fileShareStatus)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if kMSEncrypted != false {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let locationARN = locationARN {
            try encodeContainer.encode(locationARN, forKey: .locationARN)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let fileShareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareId)
        fileShareId = fileShareIdDecoded
        let fileShareStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareStatus)
        fileShareStatus = fileShareStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let kMSEncryptedDecoded = try containerValues.decode(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let locationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationARN)
        locationARN = locationARNDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validUserList)
        var validUserListDecoded0:[String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let authenticationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authentication)
        authentication = authenticationDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension SMBFileShareInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMBFileShareInfo(accessBasedEnumeration: \(String(describing: accessBasedEnumeration)), adminUserList: \(String(describing: adminUserList)), auditDestinationARN: \(String(describing: auditDestinationARN)), authentication: \(String(describing: authentication)), cacheAttributes: \(String(describing: cacheAttributes)), caseSensitivity: \(String(describing: caseSensitivity)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareARN: \(String(describing: fileShareARN)), fileShareId: \(String(describing: fileShareId)), fileShareName: \(String(describing: fileShareName)), fileShareStatus: \(String(describing: fileShareStatus)), gatewayARN: \(String(describing: gatewayARN)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), invalidUserList: \(String(describing: invalidUserList)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), locationARN: \(String(describing: locationARN)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), path: \(String(describing: path)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), role: \(String(describing: role)), sMBACLEnabled: \(String(describing: sMBACLEnabled)), tags: \(String(describing: tags)), validUserList: \(String(describing: validUserList)))"}
}

/// <p>The Windows file permissions and ownership information assigned, by default, to native
///          S3 objects when file gateway discovers them in S3 buckets. This operation is only supported
///          for file gateways.</p>
public struct SMBFileShareInfo: Equatable {
    /// <p>Indicates whether <code>AccessBasedEnumeration</code> is enabled.</p>
    public let accessBasedEnumeration: Bool?
    /// <p>A list of users or groups in the Active Directory that have administrator rights to the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let adminUserList: [String]?
    /// <p>The Amazon Resource Name (ARN) of the storage used for audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>The authentication method of the file share. The default is
    ///          <code>ActiveDirectory</code>.</p>
    ///
    ///          <p>Valid Values: <code>ActiveDirectory</code> | <code>GuestAccess</code>
    ///          </p>
    public let authentication: String?
    /// <p>Refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The case of an object name in an Amazon S3 bucket. For <code>ClientSpecified</code>, the
    ///          client determines the case sensitivity. For <code>CaseSensitive</code>, the gateway
    ///          determines the case sensitivity. The default value is <code>ClientSpecified</code>.</p>
    public let caseSensitivity: CaseSensitivity?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    public let fileShareARN: String?
    /// <p>The ID of the file share.</p>
    public let fileShareId: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>The status of the file share.</p>
    ///
    ///          <p>Valid Values: <code>CREATING</code> | <code>UPDATING</code> | <code>AVAILABLE</code> |
    ///             <code>DELETING</code>
    ///          </p>
    public let fileShareStatus: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>A list of users or groups in the Active Directory that are not allowed to access the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let invalidUserList: [String]?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".</p>
    public let locationARN: String?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>The file share path used by the SMB client to identify the mount point.</p>
    public let path: String?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The ARN of the IAM role that file gateway assumes when it accesses the underlying
    ///          storage.</p>
    public let role: String?
    /// <p>If this value is set to <code>true</code>, it indicates that access control list (ACL)
    ///          is enabled on the SMB file share. If it is set to <code>false</code>, it indicates that
    ///          file and directory permissions are mapped to the POSIX permission.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
    ///             control access to an SMB file share</a> in the <i>AWS Storage Gateway User
    ///             Guide</i>.</p>
    public let sMBACLEnabled: Bool?
    /// <p>A list of up to 50 tags assigned to the SMB file share, sorted alphabetically by key
    ///          name. Each tag is a key-value pair. For a gateway with more than 10 tags assigned, you can
    ///          view all tags using the <code>ListTagsForResource</code> API operation.</p>
    public let tags: [Tag]?
    /// <p>A list of users or groups in the Active Directory that are allowed to access the file
    ///          share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let validUserList: [String]?

    public init (
        accessBasedEnumeration: Bool? = nil,
        adminUserList: [String]? = nil,
        auditDestinationARN: String? = nil,
        authentication: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        caseSensitivity: CaseSensitivity? = nil,
        defaultStorageClass: String? = nil,
        fileShareARN: String? = nil,
        fileShareId: String? = nil,
        fileShareName: String? = nil,
        fileShareStatus: String? = nil,
        gatewayARN: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        invalidUserList: [String]? = nil,
        kMSEncrypted: Bool = false,
        kMSKey: String? = nil,
        locationARN: String? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        path: String? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        role: String? = nil,
        sMBACLEnabled: Bool? = nil,
        tags: [Tag]? = nil,
        validUserList: [String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.authentication = authentication
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareId = fileShareId
        self.fileShareName = fileShareName
        self.fileShareStatus = fileShareStatus
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.path = path
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.sMBACLEnabled = sMBACLEnabled
        self.tags = tags
        self.validUserList = validUserList
    }
}

public enum SMBSecurityStrategy {
    case clientspecified
    case mandatoryencryption
    case mandatorysigning
    case sdkUnknown(String)
}

extension SMBSecurityStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SMBSecurityStrategy] {
        return [
            .clientspecified,
            .mandatoryencryption,
            .mandatorysigning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clientspecified: return "ClientSpecified"
        case .mandatoryencryption: return "MandatoryEncryption"
        case .mandatorysigning: return "MandatorySigning"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SMBSecurityStrategy(rawValue: rawValue) ?? SMBSecurityStrategy.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableError(error: \(String(describing: error)), message: \(String(describing: message)))"}
}

extension ServiceUnavailableError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.error = output.error
            self.message = output.message
        } else {
            self.error = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error has occurred because the service is unavailable. For more
///          information, see the error and message fields.</p>
public struct ServiceUnavailableError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
    ///          of the error.</p>
    public var error: StorageGatewayError?
    /// <p>A human-readable message describing the error that occurred.</p>
    public var message: String?

    public init (
        error: StorageGatewayError? = nil,
        message: String? = nil
    )
    {
        self.error = error
        self.message = message
    }
}

struct ServiceUnavailableErrorBody: Equatable {
    public let message: String?
    public let error: StorageGatewayError?
}

extension ServiceUnavailableErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case error
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(StorageGatewayError.self, forKey: .error)
        error = errorDecoded
    }
}

public struct SetLocalConsolePasswordInputBodyMiddleware: Middleware {
    public let id: String = "SetLocalConsolePasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLocalConsolePasswordOutputError>
}

extension SetLocalConsolePasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLocalConsolePasswordInput(gatewayARN: \(String(describing: gatewayARN)), localConsolePassword: \(String(describing: localConsolePassword)))"}
}

extension SetLocalConsolePasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let localConsolePassword = localConsolePassword {
            try encodeContainer.encode(localConsolePassword, forKey: .localConsolePassword)
        }
    }
}

public struct SetLocalConsolePasswordInputHeadersMiddleware: Middleware {
    public let id: String = "SetLocalConsolePasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLocalConsolePasswordOutputError>
}

public struct SetLocalConsolePasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLocalConsolePasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLocalConsolePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLocalConsolePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLocalConsolePasswordInput>
    public typealias MOutput = OperationOutput<SetLocalConsolePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLocalConsolePasswordOutputError>
}

/// <p>SetLocalConsolePasswordInput</p>
public struct SetLocalConsolePasswordInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The password you want to set for your VM local console.</p>
    public let localConsolePassword: String?

    public init (
        gatewayARN: String? = nil,
        localConsolePassword: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.localConsolePassword = localConsolePassword
    }
}

struct SetLocalConsolePasswordInputBody: Equatable {
    public let gatewayARN: String?
    public let localConsolePassword: String?
}

extension SetLocalConsolePasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case localConsolePassword = "LocalConsolePassword"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let localConsolePasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localConsolePassword)
        localConsolePassword = localConsolePasswordDecoded
    }
}

extension SetLocalConsolePasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLocalConsolePasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLocalConsolePasswordOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLocalConsolePasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLocalConsolePasswordOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension SetLocalConsolePasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetLocalConsolePasswordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetLocalConsolePasswordOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetLocalConsolePasswordOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension SetLocalConsolePasswordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct SetSMBGuestPasswordInputBodyMiddleware: Middleware {
    public let id: String = "SetSMBGuestPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMBGuestPasswordOutputError>
}

extension SetSMBGuestPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSMBGuestPasswordInput(gatewayARN: \(String(describing: gatewayARN)), password: \(String(describing: password)))"}
}

extension SetSMBGuestPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct SetSMBGuestPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "SetSMBGuestPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMBGuestPasswordOutputError>
}

public struct SetSMBGuestPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSMBGuestPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSMBGuestPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSMBGuestPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSMBGuestPasswordInput>
    public typealias MOutput = OperationOutput<SetSMBGuestPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSMBGuestPasswordOutputError>
}

/// <p>SetSMBGuestPasswordInput</p>
public struct SetSMBGuestPasswordInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the file gateway the SMB file share is associated
    ///          with.</p>
    public let gatewayARN: String?
    /// <p>The password that you want to set for your SMB server.</p>
    public let password: String?

    public init (
        gatewayARN: String? = nil,
        password: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.password = password
    }
}

struct SetSMBGuestPasswordInputBody: Equatable {
    public let gatewayARN: String?
    public let password: String?
}

extension SetSMBGuestPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case password = "Password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension SetSMBGuestPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetSMBGuestPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSMBGuestPasswordOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSMBGuestPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSMBGuestPasswordOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension SetSMBGuestPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetSMBGuestPasswordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct SetSMBGuestPasswordOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct SetSMBGuestPasswordOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension SetSMBGuestPasswordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct ShutdownGatewayInputBodyMiddleware: Middleware {
    public let id: String = "ShutdownGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShutdownGatewayOutputError>
}

extension ShutdownGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShutdownGatewayInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ShutdownGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct ShutdownGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "ShutdownGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShutdownGatewayOutputError>
}

public struct ShutdownGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "ShutdownGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ShutdownGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<ShutdownGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ShutdownGatewayInput>
    public typealias MOutput = OperationOutput<ShutdownGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ShutdownGatewayOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway to shut
///          down.</p>
public struct ShutdownGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayInputBody: Equatable {
    public let gatewayARN: String?
}

extension ShutdownGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension ShutdownGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ShutdownGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ShutdownGatewayOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ShutdownGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShutdownGatewayOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension ShutdownGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ShutdownGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway that was shut
///          down.</p>
public struct ShutdownGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct ShutdownGatewayOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension ShutdownGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct StartAvailabilityMonitorTestInputBodyMiddleware: Middleware {
    public let id: String = "StartAvailabilityMonitorTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAvailabilityMonitorTestOutputError>
}

extension StartAvailabilityMonitorTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAvailabilityMonitorTestInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension StartAvailabilityMonitorTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct StartAvailabilityMonitorTestInputHeadersMiddleware: Middleware {
    public let id: String = "StartAvailabilityMonitorTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAvailabilityMonitorTestOutputError>
}

public struct StartAvailabilityMonitorTestInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAvailabilityMonitorTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAvailabilityMonitorTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAvailabilityMonitorTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAvailabilityMonitorTestInput>
    public typealias MOutput = OperationOutput<StartAvailabilityMonitorTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAvailabilityMonitorTestOutputError>
}

public struct StartAvailabilityMonitorTestInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestInputBody: Equatable {
    public let gatewayARN: String?
}

extension StartAvailabilityMonitorTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartAvailabilityMonitorTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAvailabilityMonitorTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAvailabilityMonitorTestOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAvailabilityMonitorTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAvailabilityMonitorTestOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension StartAvailabilityMonitorTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartAvailabilityMonitorTestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct StartAvailabilityMonitorTestOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartAvailabilityMonitorTestOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension StartAvailabilityMonitorTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct StartGatewayInputBodyMiddleware: Middleware {
    public let id: String = "StartGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartGatewayInput>
    public typealias MOutput = OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartGatewayOutputError>
}

extension StartGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartGatewayInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension StartGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct StartGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "StartGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartGatewayInput>
    public typealias MOutput = OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartGatewayOutputError>
}

public struct StartGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "StartGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartGatewayInput>
    public typealias MOutput = OperationOutput<StartGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartGatewayOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway to start.</p>
public struct StartGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayInputBody: Equatable {
    public let gatewayARN: String?
}

extension StartGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StartGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartGatewayOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartGatewayOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension StartGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          restarted.</p>
public struct StartGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct StartGatewayOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension StartGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension StorageGatewayError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .errorDetails)
            for (dictKey0, errordetails0) in errorDetails {
                try errorDetailsContainer.encode(errordetails0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .errorDetails)
        var errorDetailsDecoded0: [String:String]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [String:String]()
            for (key0, string0) in errorDetailsContainer {
                if let string0 = string0 {
                    errorDetailsDecoded0?[key0] = string0
                }
            }
        }
        errorDetails = errorDetailsDecoded0
    }
}

extension StorageGatewayError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageGatewayError(errorCode: \(String(describing: errorCode)), errorDetails: \(String(describing: errorDetails)))"}
}

/// <p>Provides additional information about an error that was returned by the service. See the
///             <code>errorCode</code> and <code>errorDetails</code> members for more information about
///          the error.</p>
public struct StorageGatewayError: Equatable {
    /// <p>Additional information about the error.</p>
    public let errorCode: ErrorCode?
    /// <p>Human-readable text that provides detail about the error that occurred.</p>
    public let errorDetails: [String:String]?

    public init (
        errorCode: ErrorCode? = nil,
        errorDetails: [String:String]? = nil
    )
    {
        self.errorCode = errorCode
        self.errorDetails = errorDetails
    }
}

extension StorediSCSIVolume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case kMSKey = "KMSKey"
        case preservedExistingData = "PreservedExistingData"
        case sourceSnapshotId = "SourceSnapshotId"
        case targetName = "TargetName"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeDiskId = "VolumeDiskId"
        case volumeId = "VolumeId"
        case volumeProgress = "VolumeProgress"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeStatus = "VolumeStatus"
        case volumeType = "VolumeType"
        case volumeUsedInBytes = "VolumeUsedInBytes"
        case volumeiSCSIAttributes = "VolumeiSCSIAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if preservedExistingData != false {
            try encodeContainer.encode(preservedExistingData, forKey: .preservedExistingData)
        }
        if let sourceSnapshotId = sourceSnapshotId {
            try encodeContainer.encode(sourceSnapshotId, forKey: .sourceSnapshotId)
        }
        if let targetName = targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeDiskId = volumeDiskId {
            try encodeContainer.encode(volumeDiskId, forKey: .volumeDiskId)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeProgress = volumeProgress {
            try encodeContainer.encode(volumeProgress, forKey: .volumeProgress)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeStatus = volumeStatus {
            try encodeContainer.encode(volumeStatus, forKey: .volumeStatus)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
        if let volumeUsedInBytes = volumeUsedInBytes {
            try encodeContainer.encode(volumeUsedInBytes, forKey: .volumeUsedInBytes)
        }
        if let volumeiSCSIAttributes = volumeiSCSIAttributes {
            try encodeContainer.encode(volumeiSCSIAttributes, forKey: .volumeiSCSIAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeStatus)
        volumeStatus = volumeStatusDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeProgressDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .volumeProgress)
        volumeProgress = volumeProgressDecoded
        let volumeDiskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeDiskId)
        volumeDiskId = volumeDiskIdDecoded
        let sourceSnapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceSnapshotId)
        sourceSnapshotId = sourceSnapshotIdDecoded
        let preservedExistingDataDecoded = try containerValues.decode(Bool.self, forKey: .preservedExistingData)
        preservedExistingData = preservedExistingDataDecoded
        let volumeiSCSIAttributesDecoded = try containerValues.decodeIfPresent(VolumeiSCSIAttributes.self, forKey: .volumeiSCSIAttributes)
        volumeiSCSIAttributes = volumeiSCSIAttributesDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let volumeUsedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeUsedInBytes)
        volumeUsedInBytes = volumeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension StorediSCSIVolume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorediSCSIVolume(createdDate: \(String(describing: createdDate)), kMSKey: \(String(describing: kMSKey)), preservedExistingData: \(String(describing: preservedExistingData)), sourceSnapshotId: \(String(describing: sourceSnapshotId)), targetName: \(String(describing: targetName)), volumeARN: \(String(describing: volumeARN)), volumeAttachmentStatus: \(String(describing: volumeAttachmentStatus)), volumeDiskId: \(String(describing: volumeDiskId)), volumeId: \(String(describing: volumeId)), volumeProgress: \(String(describing: volumeProgress)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)), volumeStatus: \(String(describing: volumeStatus)), volumeType: \(String(describing: volumeType)), volumeUsedInBytes: \(String(describing: volumeUsedInBytes)), volumeiSCSIAttributes: \(String(describing: volumeiSCSIAttributes)))"}
}

/// <p>Describes an iSCSI stored volume.</p>
public struct StorediSCSIVolume: Equatable {
    /// <p>The date the volume was created. Volumes created prior to March 28, 2017 don’t have this
    ///          timestamp.</p>
    public let createdDate: Date?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>Indicates if when the stored volume was created, existing data on the underlying local
    ///          disk was preserved.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let preservedExistingData: Bool
    /// <p>If the stored volume was created from a snapshot, this field contains the snapshot ID
    ///          used, e.g. snap-78e22663. Otherwise, this field is not included.</p>
    public let sourceSnapshotId: String?
    /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
    ///          suffix for the target ARN. For example, specifying <code>TargetName</code> as
    ///             <i>myvolume</i> results in the target ARN of
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
    ///          The target name must be unique across all volumes on a gateway.</p>
    ///
    ///          <p>If you don't specify a value, Storage Gateway uses the value that was previously
    ///          used for this volume as the new target name.</p>
    public let targetName: String?
    /// <p>The Amazon Resource Name (ARN) of the storage volume.</p>
    public let volumeARN: String?
    /// <p>A value that indicates whether a storage volume is attached to, detached from, or is in
    ///          the process of detaching from a gateway. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#attach-detach-volume">Moving
    ///             your volumes to a different gateway</a>.</p>
    public let volumeAttachmentStatus: String?
    /// <p>The ID of the local disk that was specified in the <a>CreateStorediSCSIVolume</a> operation.</p>
    public let volumeDiskId: String?
    /// <p>The unique identifier of the volume, e.g., vol-AE4B946D.</p>
    public let volumeId: String?
    /// <p>Represents the percentage complete if the volume is restoring or bootstrapping that
    ///          represents the percent of data transferred. This field does not appear in the response if
    ///          the stored volume is not restoring or bootstrapping.</p>
    public let volumeProgress: Double?
    /// <p>The size of the volume in bytes.</p>
    public let volumeSizeInBytes: Int
    /// <p>One of the VolumeStatus values that indicates the state of the storage volume.</p>
    public let volumeStatus: String?
    /// <p>One of the VolumeType enumeration values describing the type of the volume.</p>
    public let volumeType: String?
    /// <p>The size of the data stored on the volume in bytes. This value is calculated based on
    ///          the number of blocks that are touched, instead of the actual amount of data written. This
    ///          value can be useful for sequential write patterns but less accurate for random write
    ///          patterns. <code>VolumeUsedInBytes</code> is different from the compressed size of the
    ///          volume, which is the value that is used to calculate your bill.</p>
    ///
    ///          <note>
    ///             <p>This value is not available for volumes created prior to May 13, 2015, until you
    ///             store data on the volume.</p>
    ///          </note>
    public let volumeUsedInBytes: Int?
    /// <p>An <a>VolumeiSCSIAttributes</a> object that represents a collection of iSCSI
    ///          attributes for one stored volume.</p>
    public let volumeiSCSIAttributes: VolumeiSCSIAttributes?

    public init (
        createdDate: Date? = nil,
        kMSKey: String? = nil,
        preservedExistingData: Bool = false,
        sourceSnapshotId: String? = nil,
        targetName: String? = nil,
        volumeARN: String? = nil,
        volumeAttachmentStatus: String? = nil,
        volumeDiskId: String? = nil,
        volumeId: String? = nil,
        volumeProgress: Double? = nil,
        volumeSizeInBytes: Int = 0,
        volumeStatus: String? = nil,
        volumeType: String? = nil,
        volumeUsedInBytes: Int? = nil,
        volumeiSCSIAttributes: VolumeiSCSIAttributes? = nil
    )
    {
        self.createdDate = createdDate
        self.kMSKey = kMSKey
        self.preservedExistingData = preservedExistingData
        self.sourceSnapshotId = sourceSnapshotId
        self.targetName = targetName
        self.volumeARN = volumeARN
        self.volumeAttachmentStatus = volumeAttachmentStatus
        self.volumeDiskId = volumeDiskId
        self.volumeId = volumeId
        self.volumeProgress = volumeProgress
        self.volumeSizeInBytes = volumeSizeInBytes
        self.volumeStatus = volumeStatus
        self.volumeType = volumeType
        self.volumeUsedInBytes = volumeUsedInBytes
        self.volumeiSCSIAttributes = volumeiSCSIAttributes
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair that helps you manage, filter, and search for your resource. Allowed
///          characters: letters, white space, and numbers, representable in UTF-8, and the following
///          characters: + - = . _ : /.</p>
public struct Tag: Equatable {
    /// <p>Tag key. The key can't start with aws:.</p>
    public let key: String?
    /// <p>Value of the tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension Tape: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kMSKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case progress = "Progress"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case vTLDevice = "VTLDevice"
        case worm = "Worm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let progress = progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = tapeCreatedDate {
            try encodeContainer.encode(tapeCreatedDate.timeIntervalSince1970, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if let vTLDevice = vTLDevice {
            try encodeContainer.encode(vTLDevice, forKey: .vTLDevice)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let vTLDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDevice)
        vTLDevice = vTLDeviceDecoded
        let progressDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .progress)
        progress = progressDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Bool.self, forKey: .worm)
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension Tape: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tape(kMSKey: \(String(describing: kMSKey)), poolEntryDate: \(String(describing: poolEntryDate)), poolId: \(String(describing: poolId)), progress: \(String(describing: progress)), retentionStartDate: \(String(describing: retentionStartDate)), tapeARN: \(String(describing: tapeARN)), tapeBarcode: \(String(describing: tapeBarcode)), tapeCreatedDate: \(String(describing: tapeCreatedDate)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), tapeStatus: \(String(describing: tapeStatus)), tapeUsedInBytes: \(String(describing: tapeUsedInBytes)), vTLDevice: \(String(describing: vTLDevice)), worm: \(String(describing: worm)))"}
}

/// <p>Describes a virtual tape object.</p>
public struct Tape: Equatable {
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The date that the tape enters a custom tape pool.</p>
    public let poolEntryDate: Date?
    /// <p>The ID of the pool that contains tapes that will be archived. The tapes in this pool are
    ///          archived in the S3 storage class that is associated with the pool. When you use your backup
    ///          application to eject the tape, the tape is archived directly into the storage class (S3
    ///          Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>For archiving virtual tapes, indicates how much data remains to be uploaded before
    ///          archiving is complete.</p>
    ///
    ///          <p>Range: 0 (not started) to 100 (complete).</p>
    public let progress: Double?
    /// <p>The date that the tape is first archived with tape retention lock enabled.</p>
    public let retentionStartDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the virtual tape.</p>
    public let tapeARN: String?
    /// <p>The barcode that identifies a specific virtual tape.</p>
    public let tapeBarcode: String?
    /// <p>The date the virtual tape was created.</p>
    public let tapeCreatedDate: Date?
    /// <p>The size, in bytes, of the virtual tape capacity.</p>
    public let tapeSizeInBytes: Int?
    /// <p>The current state of the virtual tape.</p>
    public let tapeStatus: String?
    /// <p>The size, in bytes, of data stored on the virtual tape.</p>
    ///
    ///          <note>
    ///             <p>This value is not available for tapes created prior to May 13, 2015.</p>
    ///          </note>
    public let tapeUsedInBytes: Int?
    /// <p>The virtual tape library (VTL) device that the virtual tape is associated with.</p>
    public let vTLDevice: String?
    /// <p>If the tape is archived as write-once-read-many (WORM), this value is
    ///          <code>true</code>.</p>
    public let worm: Bool

    public init (
        kMSKey: String? = nil,
        poolEntryDate: Date? = nil,
        poolId: String? = nil,
        progress: Double? = nil,
        retentionStartDate: Date? = nil,
        tapeARN: String? = nil,
        tapeBarcode: String? = nil,
        tapeCreatedDate: Date? = nil,
        tapeSizeInBytes: Int? = nil,
        tapeStatus: String? = nil,
        tapeUsedInBytes: Int? = nil,
        vTLDevice: String? = nil,
        worm: Bool = false
    )
    {
        self.kMSKey = kMSKey
        self.poolEntryDate = poolEntryDate
        self.poolId = poolId
        self.progress = progress
        self.retentionStartDate = retentionStartDate
        self.tapeARN = tapeARN
        self.tapeBarcode = tapeBarcode
        self.tapeCreatedDate = tapeCreatedDate
        self.tapeSizeInBytes = tapeSizeInBytes
        self.tapeStatus = tapeStatus
        self.tapeUsedInBytes = tapeUsedInBytes
        self.vTLDevice = vTLDevice
        self.worm = worm
    }
}

extension TapeArchive: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionTime = "CompletionTime"
        case kMSKey = "KMSKey"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case retrievedTo = "RetrievedTo"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeCreatedDate = "TapeCreatedDate"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
        case tapeUsedInBytes = "TapeUsedInBytes"
        case worm = "Worm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let retrievedTo = retrievedTo {
            try encodeContainer.encode(retrievedTo, forKey: .retrievedTo)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeCreatedDate = tapeCreatedDate {
            try encodeContainer.encode(tapeCreatedDate.timeIntervalSince1970, forKey: .tapeCreatedDate)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
        if let tapeUsedInBytes = tapeUsedInBytes {
            try encodeContainer.encode(tapeUsedInBytes, forKey: .tapeUsedInBytes)
        }
        if worm != false {
            try encodeContainer.encode(worm, forKey: .worm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeCreatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .tapeCreatedDate)
        tapeCreatedDate = tapeCreatedDateDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let retrievedToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievedTo)
        retrievedTo = retrievedToDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let tapeUsedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeUsedInBytes)
        tapeUsedInBytes = tapeUsedInBytesDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let wormDecoded = try containerValues.decode(Bool.self, forKey: .worm)
        worm = wormDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension TapeArchive: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TapeArchive(completionTime: \(String(describing: completionTime)), kMSKey: \(String(describing: kMSKey)), poolEntryDate: \(String(describing: poolEntryDate)), poolId: \(String(describing: poolId)), retentionStartDate: \(String(describing: retentionStartDate)), retrievedTo: \(String(describing: retrievedTo)), tapeARN: \(String(describing: tapeARN)), tapeBarcode: \(String(describing: tapeBarcode)), tapeCreatedDate: \(String(describing: tapeCreatedDate)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), tapeStatus: \(String(describing: tapeStatus)), tapeUsedInBytes: \(String(describing: tapeUsedInBytes)), worm: \(String(describing: worm)))"}
}

/// <p>Represents a virtual tape that is archived in the virtual tape shelf (VTS).</p>
public struct TapeArchive: Equatable {
    /// <p>The time that the archiving of the virtual tape was completed.</p>
    ///
    ///          <p>The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z'
    ///          format.</p>
    public let completionTime: Date?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The time that the tape entered the custom tape pool.</p>
    ///
    ///          <p>The default timestamp format is in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z'
    ///          format.</p>
    public let poolEntryDate: Date?
    /// <p>The ID of the pool that was used to archive the tape. The tapes in this pool are
    ///          archived in the S3 storage class that is associated with the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>If the archived tape is subject to tape retention lock, the date that the archived tape
    ///          started being retained.</p>
    public let retentionStartDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the tape gateway that the virtual tape is being
    ///          retrieved to.</p>
    ///
    ///          <p>The virtual tape is retrieved from the virtual tape shelf (VTS).</p>
    public let retrievedTo: String?
    /// <p>The Amazon Resource Name (ARN) of an archived virtual tape.</p>
    public let tapeARN: String?
    /// <p>The barcode that identifies the archived virtual tape.</p>
    public let tapeBarcode: String?
    /// <p>The date the virtual tape was created.</p>
    public let tapeCreatedDate: Date?
    /// <p>The size, in bytes, of the archived virtual tape.</p>
    public let tapeSizeInBytes: Int?
    /// <p>The current state of the archived virtual tape.</p>
    public let tapeStatus: String?
    /// <p>The size, in bytes, of data stored on the virtual tape.</p>
    ///
    ///          <note>
    ///             <p>This value is not available for tapes created prior to May 13, 2015.</p>
    ///          </note>
    public let tapeUsedInBytes: Int?
    /// <p>Set to <code>true</code> if the archived tape is stored as write-once-read-many
    ///          (WORM).</p>
    public let worm: Bool

    public init (
        completionTime: Date? = nil,
        kMSKey: String? = nil,
        poolEntryDate: Date? = nil,
        poolId: String? = nil,
        retentionStartDate: Date? = nil,
        retrievedTo: String? = nil,
        tapeARN: String? = nil,
        tapeBarcode: String? = nil,
        tapeCreatedDate: Date? = nil,
        tapeSizeInBytes: Int? = nil,
        tapeStatus: String? = nil,
        tapeUsedInBytes: Int? = nil,
        worm: Bool = false
    )
    {
        self.completionTime = completionTime
        self.kMSKey = kMSKey
        self.poolEntryDate = poolEntryDate
        self.poolId = poolId
        self.retentionStartDate = retentionStartDate
        self.retrievedTo = retrievedTo
        self.tapeARN = tapeARN
        self.tapeBarcode = tapeBarcode
        self.tapeCreatedDate = tapeCreatedDate
        self.tapeSizeInBytes = tapeSizeInBytes
        self.tapeStatus = tapeStatus
        self.tapeUsedInBytes = tapeUsedInBytes
        self.worm = worm
    }
}

extension TapeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case poolEntryDate = "PoolEntryDate"
        case poolId = "PoolId"
        case retentionStartDate = "RetentionStartDate"
        case tapeARN = "TapeARN"
        case tapeBarcode = "TapeBarcode"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let poolEntryDate = poolEntryDate {
            try encodeContainer.encode(poolEntryDate.timeIntervalSince1970, forKey: .poolEntryDate)
        }
        if let poolId = poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let retentionStartDate = retentionStartDate {
            try encodeContainer.encode(retentionStartDate.timeIntervalSince1970, forKey: .retentionStartDate)
        }
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeBarcode = tapeBarcode {
            try encodeContainer.encode(tapeBarcode, forKey: .tapeBarcode)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeBarcodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeBarcode)
        tapeBarcode = tapeBarcodeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let retentionStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .retentionStartDate)
        retentionStartDate = retentionStartDateDecoded
        let poolEntryDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .poolEntryDate)
        poolEntryDate = poolEntryDateDecoded
    }
}

extension TapeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TapeInfo(gatewayARN: \(String(describing: gatewayARN)), poolEntryDate: \(String(describing: poolEntryDate)), poolId: \(String(describing: poolId)), retentionStartDate: \(String(describing: retentionStartDate)), tapeARN: \(String(describing: tapeARN)), tapeBarcode: \(String(describing: tapeBarcode)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), tapeStatus: \(String(describing: tapeStatus)))"}
}

/// <p>Describes a virtual tape.</p>
public struct TapeInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The date that the tape entered the custom tape pool with tape retention lock
    ///          enabled.</p>
    public let poolEntryDate: Date?
    /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
    ///          pool is archived in the S3 storage class that is associated with the pool. When you use
    ///          your backup application to eject the tape, the tape is archived directly into the storage
    ///          class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public let poolId: String?
    /// <p>The date that the tape became subject to tape retention lock.</p>
    public let retentionStartDate: Date?
    /// <p>The Amazon Resource Name (ARN) of a virtual tape.</p>
    public let tapeARN: String?
    /// <p>The barcode that identifies a specific virtual tape.</p>
    public let tapeBarcode: String?
    /// <p>The size, in bytes, of a virtual tape.</p>
    public let tapeSizeInBytes: Int?
    /// <p>The status of the tape.</p>
    public let tapeStatus: String?

    public init (
        gatewayARN: String? = nil,
        poolEntryDate: Date? = nil,
        poolId: String? = nil,
        retentionStartDate: Date? = nil,
        tapeARN: String? = nil,
        tapeBarcode: String? = nil,
        tapeSizeInBytes: Int? = nil,
        tapeStatus: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.poolEntryDate = poolEntryDate
        self.poolId = poolId
        self.retentionStartDate = retentionStartDate
        self.tapeARN = tapeARN
        self.tapeBarcode = tapeBarcode
        self.tapeSizeInBytes = tapeSizeInBytes
        self.tapeStatus = tapeStatus
    }
}

extension TapeRecoveryPointInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tapeARN = "TapeARN"
        case tapeRecoveryPointTime = "TapeRecoveryPointTime"
        case tapeSizeInBytes = "TapeSizeInBytes"
        case tapeStatus = "TapeStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tapeARN = tapeARN {
            try encodeContainer.encode(tapeARN, forKey: .tapeARN)
        }
        if let tapeRecoveryPointTime = tapeRecoveryPointTime {
            try encodeContainer.encode(tapeRecoveryPointTime.timeIntervalSince1970, forKey: .tapeRecoveryPointTime)
        }
        if let tapeSizeInBytes = tapeSizeInBytes {
            try encodeContainer.encode(tapeSizeInBytes, forKey: .tapeSizeInBytes)
        }
        if let tapeStatus = tapeStatus {
            try encodeContainer.encode(tapeStatus, forKey: .tapeStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tapeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeARN)
        tapeARN = tapeARNDecoded
        let tapeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .tapeRecoveryPointTime)
        tapeRecoveryPointTime = tapeRecoveryPointTimeDecoded
        let tapeSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tapeSizeInBytes)
        tapeSizeInBytes = tapeSizeInBytesDecoded
        let tapeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tapeStatus)
        tapeStatus = tapeStatusDecoded
    }
}

extension TapeRecoveryPointInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TapeRecoveryPointInfo(tapeARN: \(String(describing: tapeARN)), tapeRecoveryPointTime: \(String(describing: tapeRecoveryPointTime)), tapeSizeInBytes: \(String(describing: tapeSizeInBytes)), tapeStatus: \(String(describing: tapeStatus)))"}
}

/// <p>Describes a recovery point.</p>
public struct TapeRecoveryPointInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the virtual tape.</p>
    public let tapeARN: String?
    /// <p>The time when the point-in-time view of the virtual tape was replicated for later
    ///          recovery.</p>
    ///
    ///          <p>The default timestamp format of the tape recovery point time is in the ISO8601 extended
    ///          YYYY-MM-DD'T'HH:MM:SS'Z' format.</p>
    public let tapeRecoveryPointTime: Date?
    /// <p>The size, in bytes, of the virtual tapes to recover.</p>
    public let tapeSizeInBytes: Int?
    /// <p>The status of the virtual tapes.</p>
    public let tapeStatus: String?

    public init (
        tapeARN: String? = nil,
        tapeRecoveryPointTime: Date? = nil,
        tapeSizeInBytes: Int? = nil,
        tapeStatus: String? = nil
    )
    {
        self.tapeARN = tapeARN
        self.tapeRecoveryPointTime = tapeRecoveryPointTime
        self.tapeSizeInBytes = tapeSizeInBytes
        self.tapeStatus = tapeStatus
    }
}

public enum TapeStorageClass {
    case deepArchive
    case glacier
    case sdkUnknown(String)
}

extension TapeStorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TapeStorageClass] {
        return [
            .deepArchive,
            .glacier,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TapeStorageClass(rawValue: rawValue) ?? TapeStorageClass.sdkUnknown(rawValue)
    }
}

public struct UpdateAutomaticTapeCreationPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAutomaticTapeCreationPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

extension UpdateAutomaticTapeCreationPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAutomaticTapeCreationPolicyInput(automaticTapeCreationRules: \(String(describing: automaticTapeCreationRules)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateAutomaticTapeCreationPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTapeCreationRules = automaticTapeCreationRules {
            var automaticTapeCreationRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automaticTapeCreationRules)
            for automatictapecreationrules0 in automaticTapeCreationRules {
                try automaticTapeCreationRulesContainer.encode(automatictapecreationrules0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAutomaticTapeCreationPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

public struct UpdateAutomaticTapeCreationPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAutomaticTapeCreationPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAutomaticTapeCreationPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAutomaticTapeCreationPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAutomaticTapeCreationPolicyOutputError>
}

public struct UpdateAutomaticTapeCreationPolicyInput: Equatable {
    /// <p>An automatic tape creation policy consists of a list of automatic tape creation rules.
    ///          The rules determine when and how to automatically create new tapes.</p>
    public let automaticTapeCreationRules: [AutomaticTapeCreationRule]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        automaticTapeCreationRules: [AutomaticTapeCreationRule]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.automaticTapeCreationRules = automaticTapeCreationRules
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyInputBody: Equatable {
    public let automaticTapeCreationRules: [AutomaticTapeCreationRule]?
    public let gatewayARN: String?
}

extension UpdateAutomaticTapeCreationPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automaticTapeCreationRules = "AutomaticTapeCreationRules"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticTapeCreationRulesContainer = try containerValues.decodeIfPresent([AutomaticTapeCreationRule?].self, forKey: .automaticTapeCreationRules)
        var automaticTapeCreationRulesDecoded0:[AutomaticTapeCreationRule]? = nil
        if let automaticTapeCreationRulesContainer = automaticTapeCreationRulesContainer {
            automaticTapeCreationRulesDecoded0 = [AutomaticTapeCreationRule]()
            for structure0 in automaticTapeCreationRulesContainer {
                if let structure0 = structure0 {
                    automaticTapeCreationRulesDecoded0?.append(structure0)
                }
            }
        }
        automaticTapeCreationRules = automaticTapeCreationRulesDecoded0
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAutomaticTapeCreationPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAutomaticTapeCreationPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAutomaticTapeCreationPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAutomaticTapeCreationPolicyOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateAutomaticTapeCreationPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAutomaticTapeCreationPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateAutomaticTapeCreationPolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateAutomaticTapeCreationPolicyOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateAutomaticTapeCreationPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateBandwidthRateLimitInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitOutputError>
}

extension UpdateBandwidthRateLimitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBandwidthRateLimitInput(averageDownloadRateLimitInBitsPerSec: \(String(describing: averageDownloadRateLimitInBitsPerSec)), averageUploadRateLimitInBitsPerSec: \(String(describing: averageUploadRateLimitInBitsPerSec)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageDownloadRateLimitInBitsPerSec, forKey: .averageDownloadRateLimitInBitsPerSec)
        }
        if let averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec {
            try encodeContainer.encode(averageUploadRateLimitInBitsPerSec, forKey: .averageUploadRateLimitInBitsPerSec)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateBandwidthRateLimitInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitOutputError>
}

public struct UpdateBandwidthRateLimitInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>UpdateBandwidthRateLimitInput$AverageDownloadRateLimitInBitsPerSec</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateBandwidthRateLimitInput$AverageUploadRateLimitInBitsPerSec</a>
///                </p>
///             </li>
///          </ul>
public struct UpdateBandwidthRateLimitInput: Equatable {
    /// <p>The average download bandwidth rate limit in bits per second.</p>
    public let averageDownloadRateLimitInBitsPerSec: Int?
    /// <p>The average upload bandwidth rate limit in bits per second.</p>
    public let averageUploadRateLimitInBitsPerSec: Int?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        averageDownloadRateLimitInBitsPerSec: Int? = nil,
        averageUploadRateLimitInBitsPerSec: Int? = nil,
        gatewayARN: String? = nil
    )
    {
        self.averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSec
        self.averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSec
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitInputBody: Equatable {
    public let gatewayARN: String?
    public let averageUploadRateLimitInBitsPerSec: Int?
    public let averageDownloadRateLimitInBitsPerSec: Int?
}

extension UpdateBandwidthRateLimitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case averageDownloadRateLimitInBitsPerSec = "AverageDownloadRateLimitInBitsPerSec"
        case averageUploadRateLimitInBitsPerSec = "AverageUploadRateLimitInBitsPerSec"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let averageUploadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageUploadRateLimitInBitsPerSec)
        averageUploadRateLimitInBitsPerSec = averageUploadRateLimitInBitsPerSecDecoded
        let averageDownloadRateLimitInBitsPerSecDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .averageDownloadRateLimitInBitsPerSec)
        averageDownloadRateLimitInBitsPerSec = averageDownloadRateLimitInBitsPerSecDecoded
    }
}

extension UpdateBandwidthRateLimitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBandwidthRateLimitOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBandwidthRateLimitOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBandwidthRateLimitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway whose throttle
///          information was updated.</p>
public struct UpdateBandwidthRateLimitOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateBandwidthRateLimitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateBandwidthRateLimitScheduleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

extension UpdateBandwidthRateLimitScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBandwidthRateLimitScheduleInput(bandwidthRateLimitIntervals: \(String(describing: bandwidthRateLimitIntervals)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthRateLimitIntervals = bandwidthRateLimitIntervals {
            var bandwidthRateLimitIntervalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bandwidthRateLimitIntervals)
            for bandwidthratelimitintervals0 in bandwidthRateLimitIntervals {
                try bandwidthRateLimitIntervalsContainer.encode(bandwidthratelimitintervals0)
            }
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateBandwidthRateLimitScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

public struct UpdateBandwidthRateLimitScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBandwidthRateLimitScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBandwidthRateLimitScheduleInput>
    public typealias MOutput = OperationOutput<UpdateBandwidthRateLimitScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBandwidthRateLimitScheduleOutputError>
}

public struct UpdateBandwidthRateLimitScheduleInput: Equatable {
    /// <p>
    ///          An array containing bandwidth rate limit schedule intervals for a gateway.
    ///          When no bandwidth rate limit intervals have been scheduled, the array is empty.
    ///       </p>
    public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]? = nil,
        gatewayARN: String? = nil
    )
    {
        self.bandwidthRateLimitIntervals = bandwidthRateLimitIntervals
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleInputBody: Equatable {
    public let gatewayARN: String?
    public let bandwidthRateLimitIntervals: [BandwidthRateLimitInterval]?
}

extension UpdateBandwidthRateLimitScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidthRateLimitIntervals = "BandwidthRateLimitIntervals"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let bandwidthRateLimitIntervalsContainer = try containerValues.decodeIfPresent([BandwidthRateLimitInterval?].self, forKey: .bandwidthRateLimitIntervals)
        var bandwidthRateLimitIntervalsDecoded0:[BandwidthRateLimitInterval]? = nil
        if let bandwidthRateLimitIntervalsContainer = bandwidthRateLimitIntervalsContainer {
            bandwidthRateLimitIntervalsDecoded0 = [BandwidthRateLimitInterval]()
            for structure0 in bandwidthRateLimitIntervalsContainer {
                if let structure0 = structure0 {
                    bandwidthRateLimitIntervalsDecoded0?.append(structure0)
                }
            }
        }
        bandwidthRateLimitIntervals = bandwidthRateLimitIntervalsDecoded0
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBandwidthRateLimitScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBandwidthRateLimitScheduleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBandwidthRateLimitScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBandwidthRateLimitScheduleOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateBandwidthRateLimitScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBandwidthRateLimitScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateBandwidthRateLimitScheduleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateBandwidthRateLimitScheduleOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateBandwidthRateLimitScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateChapCredentialsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateChapCredentialsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChapCredentialsOutputError>
}

extension UpdateChapCredentialsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChapCredentialsInput(initiatorName: \(String(describing: initiatorName)), secretToAuthenticateInitiator: \(String(describing: secretToAuthenticateInitiator)), secretToAuthenticateTarget: \(String(describing: secretToAuthenticateTarget)), targetARN: \(String(describing: targetARN)))"}
}

extension UpdateChapCredentialsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiatorName = initiatorName {
            try encodeContainer.encode(initiatorName, forKey: .initiatorName)
        }
        if let secretToAuthenticateInitiator = secretToAuthenticateInitiator {
            try encodeContainer.encode(secretToAuthenticateInitiator, forKey: .secretToAuthenticateInitiator)
        }
        if let secretToAuthenticateTarget = secretToAuthenticateTarget {
            try encodeContainer.encode(secretToAuthenticateTarget, forKey: .secretToAuthenticateTarget)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }
}

public struct UpdateChapCredentialsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateChapCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChapCredentialsOutputError>
}

public struct UpdateChapCredentialsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateChapCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChapCredentialsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChapCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChapCredentialsInput>
    public typealias MOutput = OperationOutput<UpdateChapCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChapCredentialsOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>UpdateChapCredentialsInput$InitiatorName</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateChapCredentialsInput$SecretToAuthenticateInitiator</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateChapCredentialsInput$SecretToAuthenticateTarget</a>
///                </p>
///
///             </li>
///             <li>
///                <p>
///                   <a>UpdateChapCredentialsInput$TargetARN</a>
///                </p>
///             </li>
///          </ul>
public struct UpdateChapCredentialsInput: Equatable {
    /// <p>The iSCSI initiator that connects to the target.</p>
    public let initiatorName: String?
    /// <p>The secret key that the initiator (for example, the Windows client) must provide to
    ///          participate in mutual CHAP with the target.</p>
    ///
    ///          <note>
    ///             <p>The secret key must be between 12 and 16 bytes when encoded in UTF-8.</p>
    ///          </note>
    public let secretToAuthenticateInitiator: String?
    /// <p>The secret key that the target must provide to participate in mutual CHAP with the
    ///          initiator (e.g. Windows client).</p>
    ///
    ///          <p>Byte constraints: Minimum bytes of 12. Maximum bytes of 16.</p>
    ///
    ///          <note>
    ///             <p>The secret key must be between 12 and 16 bytes when encoded in UTF-8.</p>
    ///          </note>
    public let secretToAuthenticateTarget: String?
    /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return the TargetARN for specified
    ///          VolumeARN.</p>
    public let targetARN: String?

    public init (
        initiatorName: String? = nil,
        secretToAuthenticateInitiator: String? = nil,
        secretToAuthenticateTarget: String? = nil,
        targetARN: String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.secretToAuthenticateInitiator = secretToAuthenticateInitiator
        self.secretToAuthenticateTarget = secretToAuthenticateTarget
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsInputBody: Equatable {
    public let targetARN: String?
    public let secretToAuthenticateInitiator: String?
    public let initiatorName: String?
    public let secretToAuthenticateTarget: String?
}

extension UpdateChapCredentialsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case secretToAuthenticateInitiator = "SecretToAuthenticateInitiator"
        case secretToAuthenticateTarget = "SecretToAuthenticateTarget"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let secretToAuthenticateInitiatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretToAuthenticateInitiator)
        secretToAuthenticateInitiator = secretToAuthenticateInitiatorDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
        let secretToAuthenticateTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretToAuthenticateTarget)
        secretToAuthenticateTarget = secretToAuthenticateTargetDecoded
    }
}

extension UpdateChapCredentialsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChapCredentialsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChapCredentialsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChapCredentialsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChapCredentialsOutputResponse(initiatorName: \(String(describing: initiatorName)), targetARN: \(String(describing: targetARN)))"}
}

extension UpdateChapCredentialsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateChapCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.initiatorName = output.initiatorName
            self.targetARN = output.targetARN
        } else {
            self.initiatorName = nil
            self.targetARN = nil
        }
    }
}

/// <p>A JSON object containing the following fields:</p>
public struct UpdateChapCredentialsOutputResponse: Equatable {
    /// <p>The iSCSI initiator that connects to the target. This is the same initiator name
    ///          specified in the request.</p>
    public let initiatorName: String?
    /// <p>The Amazon Resource Name (ARN) of the target. This is the same target specified in the
    ///          request.</p>
    public let targetARN: String?

    public init (
        initiatorName: String? = nil,
        targetARN: String? = nil
    )
    {
        self.initiatorName = initiatorName
        self.targetARN = targetARN
    }
}

struct UpdateChapCredentialsOutputResponseBody: Equatable {
    public let targetARN: String?
    public let initiatorName: String?
}

extension UpdateChapCredentialsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case initiatorName = "InitiatorName"
        case targetARN = "TargetARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let initiatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initiatorName)
        initiatorName = initiatorNameDecoded
    }
}

public struct UpdateFileSystemAssociationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFileSystemAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemAssociationOutputError>
}

extension UpdateFileSystemAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemAssociationInput(auditDestinationARN: \(String(describing: auditDestinationARN)), cacheAttributes: \(String(describing: cacheAttributes)), fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)), password: \(String(describing: password)), userName: \(String(describing: userName)))"}
}

extension UpdateFileSystemAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let fileSystemAssociationARN = fileSystemAssociationARN {
            try encodeContainer.encode(fileSystemAssociationARN, forKey: .fileSystemAssociationARN)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct UpdateFileSystemAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFileSystemAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemAssociationOutputError>
}

public struct UpdateFileSystemAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFileSystemAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFileSystemAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFileSystemAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFileSystemAssociationInput>
    public typealias MOutput = OperationOutput<UpdateFileSystemAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFileSystemAssociationOutputError>
}

public struct UpdateFileSystemAssociationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the storage used for the audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>The refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The Amazon Resource Name (ARN) of the file system association that you want to update.</p>
    public let fileSystemAssociationARN: String?
    /// <p>The password of the user credential.</p>
    public let password: String?
    /// <p>The user name of the user credential that has permission to access the root share D$ of
    ///          the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
    ///          user group.</p>
    public let userName: String?

    public init (
        auditDestinationARN: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        fileSystemAssociationARN: String? = nil,
        password: String? = nil,
        userName: String? = nil
    )
    {
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.fileSystemAssociationARN = fileSystemAssociationARN
        self.password = password
        self.userName = userName
    }
}

struct UpdateFileSystemAssociationInputBody: Equatable {
    public let fileSystemAssociationARN: String?
    public let userName: String?
    public let password: String?
    public let auditDestinationARN: String?
    public let cacheAttributes: CacheAttributes?
}

extension UpdateFileSystemAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case fileSystemAssociationARN = "FileSystemAssociationARN"
        case password = "Password"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
    }
}

extension UpdateFileSystemAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemAssociationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFileSystemAssociationOutputResponse(fileSystemAssociationARN: \(String(describing: fileSystemAssociationARN)))"}
}

extension UpdateFileSystemAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFileSystemAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileSystemAssociationARN = output.fileSystemAssociationARN
        } else {
            self.fileSystemAssociationARN = nil
        }
    }
}

public struct UpdateFileSystemAssociationOutputResponse: Equatable {
    /// <p>The ARN of the updated file system association.</p>
    public let fileSystemAssociationARN: String?

    public init (
        fileSystemAssociationARN: String? = nil
    )
    {
        self.fileSystemAssociationARN = fileSystemAssociationARN
    }
}

struct UpdateFileSystemAssociationOutputResponseBody: Equatable {
    public let fileSystemAssociationARN: String?
}

extension UpdateFileSystemAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSystemAssociationARN = "FileSystemAssociationARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemAssociationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileSystemAssociationARN)
        fileSystemAssociationARN = fileSystemAssociationARNDecoded
    }
}

public struct UpdateGatewayInformationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayInformationOutputError>
}

extension UpdateGatewayInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayInformationInput(cloudWatchLogGroupARN: \(String(describing: cloudWatchLogGroupARN)), gatewayARN: \(String(describing: gatewayARN)), gatewayName: \(String(describing: gatewayName)), gatewayTimezone: \(String(describing: gatewayTimezone)))"}
}

extension UpdateGatewayInformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupARN = cloudWatchLogGroupARN {
            try encodeContainer.encode(cloudWatchLogGroupARN, forKey: .cloudWatchLogGroupARN)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayTimezone = gatewayTimezone {
            try encodeContainer.encode(gatewayTimezone, forKey: .gatewayTimezone)
        }
    }
}

public struct UpdateGatewayInformationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayInformationOutputError>
}

public struct UpdateGatewayInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInformationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayInformationOutputError>
}

public struct UpdateGatewayInformationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use
    ///          to monitor and log events in the gateway.</p>
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html">What is Amazon CloudWatch
    ///             Logs?</a>
    ///          </p>
    public let cloudWatchLogGroupARN: String?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The name you configured for your gateway.</p>
    public let gatewayName: String?
    /// <p>A value that indicates the time zone of the gateway.</p>
    public let gatewayTimezone: String?

    public init (
        cloudWatchLogGroupARN: String? = nil,
        gatewayARN: String? = nil,
        gatewayName: String? = nil,
        gatewayTimezone: String? = nil
    )
    {
        self.cloudWatchLogGroupARN = cloudWatchLogGroupARN
        self.gatewayARN = gatewayARN
        self.gatewayName = gatewayName
        self.gatewayTimezone = gatewayTimezone
    }
}

struct UpdateGatewayInformationInputBody: Equatable {
    public let gatewayARN: String?
    public let gatewayName: String?
    public let gatewayTimezone: String?
    public let cloudWatchLogGroupARN: String?
}

extension UpdateGatewayInformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupARN = "CloudWatchLogGroupARN"
        case gatewayARN = "GatewayARN"
        case gatewayName = "GatewayName"
        case gatewayTimezone = "GatewayTimezone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayTimezone)
        gatewayTimezone = gatewayTimezoneDecoded
        let cloudWatchLogGroupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupARN)
        cloudWatchLogGroupARN = cloudWatchLogGroupARNDecoded
    }
}

extension UpdateGatewayInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayInformationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayInformationOutputResponse(gatewayARN: \(String(describing: gatewayARN)), gatewayName: \(String(describing: gatewayName)))"}
}

extension UpdateGatewayInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGatewayInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
            self.gatewayName = output.gatewayName
        } else {
            self.gatewayARN = nil
            self.gatewayName = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          updated.</p>
public struct UpdateGatewayInformationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The name you configured for your gateway.</p>
    public let gatewayName: String?

    public init (
        gatewayARN: String? = nil,
        gatewayName: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInformationOutputResponseBody: Equatable {
    public let gatewayARN: String?
    public let gatewayName: String?
}

extension UpdateGatewayInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayName = "GatewayName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

public struct UpdateGatewaySoftwareNowInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewaySoftwareNowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewaySoftwareNowOutputError>
}

extension UpdateGatewaySoftwareNowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewaySoftwareNowInput(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateGatewaySoftwareNowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateGatewaySoftwareNowInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewaySoftwareNowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewaySoftwareNowOutputError>
}

public struct UpdateGatewaySoftwareNowInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewaySoftwareNowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewaySoftwareNowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewaySoftwareNowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewaySoftwareNowInput>
    public typealias MOutput = OperationOutput<UpdateGatewaySoftwareNowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewaySoftwareNowOutputError>
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway to update.</p>
public struct UpdateGatewaySoftwareNowInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowInputBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateGatewaySoftwareNowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

extension UpdateGatewaySoftwareNowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewaySoftwareNowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewaySoftwareNowOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewaySoftwareNowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewaySoftwareNowOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateGatewaySoftwareNowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGatewaySoftwareNowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway that was
///          updated.</p>
public struct UpdateGatewaySoftwareNowOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateGatewaySoftwareNowOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateGatewaySoftwareNowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateMaintenanceStartTimeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceStartTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceStartTimeOutputError>
}

extension UpdateMaintenanceStartTimeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceStartTimeInput(dayOfMonth: \(String(describing: dayOfMonth)), dayOfWeek: \(String(describing: dayOfWeek)), gatewayARN: \(String(describing: gatewayARN)), hourOfDay: \(String(describing: hourOfDay)), minuteOfHour: \(String(describing: minuteOfHour)))"}
}

extension UpdateMaintenanceStartTimeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek, forKey: .dayOfWeek)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let hourOfDay = hourOfDay {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if let minuteOfHour = minuteOfHour {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }
}

public struct UpdateMaintenanceStartTimeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceStartTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceStartTimeOutputError>
}

public struct UpdateMaintenanceStartTimeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceStartTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceStartTimeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceStartTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceStartTimeInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceStartTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceStartTimeOutputError>
}

/// <p>A JSON object containing the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>UpdateMaintenanceStartTimeInput$DayOfMonth</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateMaintenanceStartTimeInput$DayOfWeek</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateMaintenanceStartTimeInput$HourOfDay</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateMaintenanceStartTimeInput$MinuteOfHour</a>
///                </p>
///             </li>
///          </ul>
public struct UpdateMaintenanceStartTimeInput: Equatable {
    /// <p>The day of the month component of the maintenance start time represented as an ordinal
    ///          number from 1 to 28, where 1 represents the first day of the month and 28 represents the
    ///          last day of the month.</p>
    public let dayOfMonth: Int?
    /// <p>The day of the week component of the maintenance start time week represented as an
    ///          ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.</p>
    public let dayOfWeek: Int?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The hour component of the maintenance start time represented as <i>hh</i>,
    ///          where <i>hh</i> is the hour (00 to 23). The hour of the day is in the time
    ///          zone of the gateway.</p>
    public let hourOfDay: Int?
    /// <p>The minute component of the maintenance start time represented as
    ///             <i>mm</i>, where <i>mm</i> is the minute (00 to 59). The
    ///          minute of the hour is in the time zone of the gateway.</p>
    public let minuteOfHour: Int?

    public init (
        dayOfMonth: Int? = nil,
        dayOfWeek: Int? = nil,
        gatewayARN: String? = nil,
        hourOfDay: Int? = nil,
        minuteOfHour: Int? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.gatewayARN = gatewayARN
        self.hourOfDay = hourOfDay
        self.minuteOfHour = minuteOfHour
    }
}

struct UpdateMaintenanceStartTimeInputBody: Equatable {
    public let gatewayARN: String?
    public let hourOfDay: Int?
    public let minuteOfHour: Int?
    public let dayOfWeek: Int?
    public let dayOfMonth: Int?
}

extension UpdateMaintenanceStartTimeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth = "DayOfMonth"
        case dayOfWeek = "DayOfWeek"
        case gatewayARN = "GatewayARN"
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hourOfDay)
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minuteOfHour)
        minuteOfHour = minuteOfHourDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension UpdateMaintenanceStartTimeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceStartTimeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceStartTimeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceStartTimeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceStartTimeOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateMaintenanceStartTimeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMaintenanceStartTimeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the gateway whose maintenance
///          start time is updated.</p>
public struct UpdateMaintenanceStartTimeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateMaintenanceStartTimeOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateMaintenanceStartTimeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateNFSFileShareInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNFSFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNFSFileShareOutputError>
}

extension UpdateNFSFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNFSFileShareInput(cacheAttributes: \(String(describing: cacheAttributes)), clientList: \(String(describing: clientList)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareARN: \(String(describing: fileShareARN)), fileShareName: \(String(describing: fileShareName)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), nFSFileShareDefaults: \(String(describing: nFSFileShareDefaults)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), squash: \(String(describing: squash)))"}
}

extension UpdateNFSFileShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let clientList = clientList {
            var clientListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientList)
            for fileshareclientlist0 in clientList {
                try clientListContainer.encode(fileshareclientlist0)
            }
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let nFSFileShareDefaults = nFSFileShareDefaults {
            try encodeContainer.encode(nFSFileShareDefaults, forKey: .nFSFileShareDefaults)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let squash = squash {
            try encodeContainer.encode(squash, forKey: .squash)
        }
    }
}

public struct UpdateNFSFileShareInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNFSFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNFSFileShareOutputError>
}

public struct UpdateNFSFileShareInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNFSFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNFSFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNFSFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNFSFileShareInput>
    public typealias MOutput = OperationOutput<UpdateNFSFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNFSFileShareOutputError>
}

/// <p>UpdateNFSFileShareInput</p>
public struct UpdateNFSFileShareInput: Equatable {
    /// <p>specifies refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The list of clients that are allowed to access the file gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.</p>
    public let clientList: [String]?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The Amazon Resource Name (ARN) of the file share to be updated.</p>
    public let fileShareARN: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The default values for the file share. Optional.</p>
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The user mapped to anonymous user.</p>
    ///
    ///          <p>Valid values are the following:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NoSquash</code>: No one is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
    ///             </li>
    ///          </ul>
    public let squash: String?

    public init (
        cacheAttributes: CacheAttributes? = nil,
        clientList: [String]? = nil,
        defaultStorageClass: String? = nil,
        fileShareARN: String? = nil,
        fileShareName: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        nFSFileShareDefaults: NFSFileShareDefaults? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        squash: String? = nil
    )
    {
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.squash = squash
    }
}

struct UpdateNFSFileShareInputBody: Equatable {
    public let fileShareARN: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    public let defaultStorageClass: String?
    public let objectACL: ObjectACL?
    public let clientList: [String]?
    public let squash: String?
    public let readOnly: Bool?
    public let guessMIMETypeEnabled: Bool?
    public let requesterPays: Bool?
    public let fileShareName: String?
    public let cacheAttributes: CacheAttributes?
    public let notificationPolicy: String?
}

extension UpdateNFSFileShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cacheAttributes = "CacheAttributes"
        case clientList = "ClientList"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case nFSFileShareDefaults = "NFSFileShareDefaults"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case squash = "Squash"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let nFSFileShareDefaultsDecoded = try containerValues.decodeIfPresent(NFSFileShareDefaults.self, forKey: .nFSFileShareDefaults)
        nFSFileShareDefaults = nFSFileShareDefaultsDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let clientListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clientList)
        var clientListDecoded0:[String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let squashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .squash)
        squash = squashDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension UpdateNFSFileShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNFSFileShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNFSFileShareOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNFSFileShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNFSFileShareOutputResponse(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension UpdateNFSFileShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateNFSFileShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// <p>UpdateNFSFileShareOutput</p>
public struct UpdateNFSFileShareOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the updated file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateNFSFileShareOutputResponseBody: Equatable {
    public let fileShareARN: String?
}

extension UpdateNFSFileShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct UpdateSMBFileShareInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareOutputError>
}

extension UpdateSMBFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBFileShareInput(accessBasedEnumeration: \(String(describing: accessBasedEnumeration)), adminUserList: \(String(describing: adminUserList)), auditDestinationARN: \(String(describing: auditDestinationARN)), cacheAttributes: \(String(describing: cacheAttributes)), caseSensitivity: \(String(describing: caseSensitivity)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareARN: \(String(describing: fileShareARN)), fileShareName: \(String(describing: fileShareName)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), invalidUserList: \(String(describing: invalidUserList)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), sMBACLEnabled: \(String(describing: sMBACLEnabled)), validUserList: \(String(describing: validUserList)))"}
}

extension UpdateSMBFileShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case sMBACLEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessBasedEnumeration = accessBasedEnumeration {
            try encodeContainer.encode(accessBasedEnumeration, forKey: .accessBasedEnumeration)
        }
        if let adminUserList = adminUserList {
            var adminUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminUserList)
            for userlist0 in adminUserList {
                try adminUserListContainer.encode(userlist0)
            }
        }
        if let auditDestinationARN = auditDestinationARN {
            try encodeContainer.encode(auditDestinationARN, forKey: .auditDestinationARN)
        }
        if let cacheAttributes = cacheAttributes {
            try encodeContainer.encode(cacheAttributes, forKey: .cacheAttributes)
        }
        if let caseSensitivity = caseSensitivity {
            try encodeContainer.encode(caseSensitivity.rawValue, forKey: .caseSensitivity)
        }
        if let defaultStorageClass = defaultStorageClass {
            try encodeContainer.encode(defaultStorageClass, forKey: .defaultStorageClass)
        }
        if let fileShareARN = fileShareARN {
            try encodeContainer.encode(fileShareARN, forKey: .fileShareARN)
        }
        if let fileShareName = fileShareName {
            try encodeContainer.encode(fileShareName, forKey: .fileShareName)
        }
        if let guessMIMETypeEnabled = guessMIMETypeEnabled {
            try encodeContainer.encode(guessMIMETypeEnabled, forKey: .guessMIMETypeEnabled)
        }
        if let invalidUserList = invalidUserList {
            var invalidUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invalidUserList)
            for userlist0 in invalidUserList {
                try invalidUserListContainer.encode(userlist0)
            }
        }
        if let kMSEncrypted = kMSEncrypted {
            try encodeContainer.encode(kMSEncrypted, forKey: .kMSEncrypted)
        }
        if let kMSKey = kMSKey {
            try encodeContainer.encode(kMSKey, forKey: .kMSKey)
        }
        if let notificationPolicy = notificationPolicy {
            try encodeContainer.encode(notificationPolicy, forKey: .notificationPolicy)
        }
        if let objectACL = objectACL {
            try encodeContainer.encode(objectACL.rawValue, forKey: .objectACL)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let requesterPays = requesterPays {
            try encodeContainer.encode(requesterPays, forKey: .requesterPays)
        }
        if let sMBACLEnabled = sMBACLEnabled {
            try encodeContainer.encode(sMBACLEnabled, forKey: .sMBACLEnabled)
        }
        if let validUserList = validUserList {
            var validUserListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validUserList)
            for userlist0 in validUserList {
                try validUserListContainer.encode(userlist0)
            }
        }
    }
}

public struct UpdateSMBFileShareInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareOutputError>
}

public struct UpdateSMBFileShareInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareOutputError>
}

/// <p>UpdateSMBFileShareInput</p>
public struct UpdateSMBFileShareInput: Equatable {
    /// <p>The files and folders on this share will only be visible to users with read
    ///          access.</p>
    public let accessBasedEnumeration: Bool?
    /// <p>A list of users or groups in the Active Directory that have administrator rights to the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let adminUserList: [String]?
    /// <p>The Amazon Resource Name (ARN) of the storage used for audit logs.</p>
    public let auditDestinationARN: String?
    /// <p>Specifies refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The case of an object name in an Amazon S3 bucket. For <code>ClientSpecified</code>, the
    ///          client determines the case sensitivity. For <code>CaseSensitive</code>, the gateway
    ///          determines the case sensitivity. The default value is <code>ClientSpecified</code>.</p>
    public let caseSensitivity: CaseSensitivity?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The Amazon Resource Name (ARN) of the SMB file share that you want to update.</p>
    public let fileShareARN: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>A list of users or groups in the Active Directory that are not allowed to access the
    ///          file share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let invalidUserList: [String]?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>Set this value to <code>true</code> to enable access control list (ACL) on the SMB file
    ///          share. Set it to <code>false</code> to map file and directory permissions to the POSIX
    ///          permissions.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
    ///             control access to an SMB file share</a> in the <i>AWS Storage Gateway User
    ///             Guide</i>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let sMBACLEnabled: Bool?
    /// <p>A list of users or groups in the Active Directory that are allowed to access the file
    ///          share. A group must be prefixed with the @ character. Acceptable formats include:
    ///             <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
    ///             <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
    ///             <code>ActiveDirectory</code>.</p>
    public let validUserList: [String]?

    public init (
        accessBasedEnumeration: Bool? = nil,
        adminUserList: [String]? = nil,
        auditDestinationARN: String? = nil,
        cacheAttributes: CacheAttributes? = nil,
        caseSensitivity: CaseSensitivity? = nil,
        defaultStorageClass: String? = nil,
        fileShareARN: String? = nil,
        fileShareName: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        invalidUserList: [String]? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        sMBACLEnabled: Bool? = nil,
        validUserList: [String]? = nil
    )
    {
        self.accessBasedEnumeration = accessBasedEnumeration
        self.adminUserList = adminUserList
        self.auditDestinationARN = auditDestinationARN
        self.cacheAttributes = cacheAttributes
        self.caseSensitivity = caseSensitivity
        self.defaultStorageClass = defaultStorageClass
        self.fileShareARN = fileShareARN
        self.fileShareName = fileShareName
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.invalidUserList = invalidUserList
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.sMBACLEnabled = sMBACLEnabled
        self.validUserList = validUserList
    }
}

struct UpdateSMBFileShareInputBody: Equatable {
    public let fileShareARN: String?
    public let kMSEncrypted: Bool?
    public let kMSKey: String?
    public let defaultStorageClass: String?
    public let objectACL: ObjectACL?
    public let readOnly: Bool?
    public let guessMIMETypeEnabled: Bool?
    public let requesterPays: Bool?
    public let sMBACLEnabled: Bool?
    public let accessBasedEnumeration: Bool?
    public let adminUserList: [String]?
    public let validUserList: [String]?
    public let invalidUserList: [String]?
    public let auditDestinationARN: String?
    public let caseSensitivity: CaseSensitivity?
    public let fileShareName: String?
    public let cacheAttributes: CacheAttributes?
    public let notificationPolicy: String?
}

extension UpdateSMBFileShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessBasedEnumeration = "AccessBasedEnumeration"
        case adminUserList = "AdminUserList"
        case auditDestinationARN = "AuditDestinationARN"
        case cacheAttributes = "CacheAttributes"
        case caseSensitivity = "CaseSensitivity"
        case defaultStorageClass = "DefaultStorageClass"
        case fileShareARN = "FileShareARN"
        case fileShareName = "FileShareName"
        case guessMIMETypeEnabled = "GuessMIMETypeEnabled"
        case invalidUserList = "InvalidUserList"
        case kMSEncrypted = "KMSEncrypted"
        case kMSKey = "KMSKey"
        case notificationPolicy = "NotificationPolicy"
        case objectACL = "ObjectACL"
        case readOnly = "ReadOnly"
        case requesterPays = "RequesterPays"
        case sMBACLEnabled = "SMBACLEnabled"
        case validUserList = "ValidUserList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
        let kMSEncryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .kMSEncrypted)
        kMSEncrypted = kMSEncryptedDecoded
        let kMSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKey)
        kMSKey = kMSKeyDecoded
        let defaultStorageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultStorageClass)
        defaultStorageClass = defaultStorageClassDecoded
        let objectACLDecoded = try containerValues.decodeIfPresent(ObjectACL.self, forKey: .objectACL)
        objectACL = objectACLDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let guessMIMETypeEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .guessMIMETypeEnabled)
        guessMIMETypeEnabled = guessMIMETypeEnabledDecoded
        let requesterPaysDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let sMBACLEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sMBACLEnabled)
        sMBACLEnabled = sMBACLEnabledDecoded
        let accessBasedEnumerationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accessBasedEnumeration)
        accessBasedEnumeration = accessBasedEnumerationDecoded
        let adminUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .adminUserList)
        var adminUserListDecoded0:[String]? = nil
        if let adminUserListContainer = adminUserListContainer {
            adminUserListDecoded0 = [String]()
            for string0 in adminUserListContainer {
                if let string0 = string0 {
                    adminUserListDecoded0?.append(string0)
                }
            }
        }
        adminUserList = adminUserListDecoded0
        let validUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validUserList)
        var validUserListDecoded0:[String]? = nil
        if let validUserListContainer = validUserListContainer {
            validUserListDecoded0 = [String]()
            for string0 in validUserListContainer {
                if let string0 = string0 {
                    validUserListDecoded0?.append(string0)
                }
            }
        }
        validUserList = validUserListDecoded0
        let invalidUserListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidUserList)
        var invalidUserListDecoded0:[String]? = nil
        if let invalidUserListContainer = invalidUserListContainer {
            invalidUserListDecoded0 = [String]()
            for string0 in invalidUserListContainer {
                if let string0 = string0 {
                    invalidUserListDecoded0?.append(string0)
                }
            }
        }
        invalidUserList = invalidUserListDecoded0
        let auditDestinationARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditDestinationARN)
        auditDestinationARN = auditDestinationARNDecoded
        let caseSensitivityDecoded = try containerValues.decodeIfPresent(CaseSensitivity.self, forKey: .caseSensitivity)
        caseSensitivity = caseSensitivityDecoded
        let fileShareNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareName)
        fileShareName = fileShareNameDecoded
        let cacheAttributesDecoded = try containerValues.decodeIfPresent(CacheAttributes.self, forKey: .cacheAttributes)
        cacheAttributes = cacheAttributesDecoded
        let notificationPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationPolicy)
        notificationPolicy = notificationPolicyDecoded
    }
}

extension UpdateSMBFileShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBFileShareOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBFileShareOutputResponse(fileShareARN: \(String(describing: fileShareARN)))"}
}

extension UpdateSMBFileShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSMBFileShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileShareARN = output.fileShareARN
        } else {
            self.fileShareARN = nil
        }
    }
}

/// <p>UpdateSMBFileShareOutput</p>
public struct UpdateSMBFileShareOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the updated SMB file share.</p>
    public let fileShareARN: String?

    public init (
        fileShareARN: String? = nil
    )
    {
        self.fileShareARN = fileShareARN
    }
}

struct UpdateSMBFileShareOutputResponseBody: Equatable {
    public let fileShareARN: String?
}

extension UpdateSMBFileShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileShareARN = "FileShareARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileShareARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileShareARN)
        fileShareARN = fileShareARNDecoded
    }
}

public struct UpdateSMBFileShareVisibilityInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareVisibilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareVisibilityOutputError>
}

extension UpdateSMBFileShareVisibilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBFileShareVisibilityInput(fileSharesVisible: \(String(describing: fileSharesVisible)), gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateSMBFileShareVisibilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSharesVisible = fileSharesVisible {
            try encodeContainer.encode(fileSharesVisible, forKey: .fileSharesVisible)
        }
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
    }
}

public struct UpdateSMBFileShareVisibilityInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareVisibilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareVisibilityOutputError>
}

public struct UpdateSMBFileShareVisibilityInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSMBFileShareVisibilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBFileShareVisibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBFileShareVisibilityInput>
    public typealias MOutput = OperationOutput<UpdateSMBFileShareVisibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBFileShareVisibilityOutputError>
}

public struct UpdateSMBFileShareVisibilityInput: Equatable {
    /// <p>The shares on this gateway appear when listing shares.</p>
    public let fileSharesVisible: Bool?
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        fileSharesVisible: Bool? = nil,
        gatewayARN: String? = nil
    )
    {
        self.fileSharesVisible = fileSharesVisible
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityInputBody: Equatable {
    public let gatewayARN: String?
    public let fileSharesVisible: Bool?
}

extension UpdateSMBFileShareVisibilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileSharesVisible = "FileSharesVisible"
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let fileSharesVisibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .fileSharesVisible)
        fileSharesVisible = fileSharesVisibleDecoded
    }
}

extension UpdateSMBFileShareVisibilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBFileShareVisibilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBFileShareVisibilityOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBFileShareVisibilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBFileShareVisibilityOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateSMBFileShareVisibilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSMBFileShareVisibilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBFileShareVisibilityOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBFileShareVisibilityOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateSMBFileShareVisibilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateSMBSecurityStrategyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSMBSecurityStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBSecurityStrategyOutputError>
}

extension UpdateSMBSecurityStrategyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBSecurityStrategyInput(gatewayARN: \(String(describing: gatewayARN)), sMBSecurityStrategy: \(String(describing: sMBSecurityStrategy)))"}
}

extension UpdateSMBSecurityStrategyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let sMBSecurityStrategy = sMBSecurityStrategy {
            try encodeContainer.encode(sMBSecurityStrategy.rawValue, forKey: .sMBSecurityStrategy)
        }
    }
}

public struct UpdateSMBSecurityStrategyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSMBSecurityStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBSecurityStrategyOutputError>
}

public struct UpdateSMBSecurityStrategyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSMBSecurityStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSMBSecurityStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSMBSecurityStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSMBSecurityStrategyInput>
    public typealias MOutput = OperationOutput<UpdateSMBSecurityStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSMBSecurityStrategyOutputError>
}

public struct UpdateSMBSecurityStrategyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>Specifies the type of security strategy.</p>
    ///
    ///          <p>ClientSpecified: if you use this option, requests are established based on what is
    ///          negotiated by the client. This option is recommended when you want to maximize
    ///          compatibility across different clients in your environment.</p>
    ///
    ///          <p>MandatorySigning: if you use this option, file gateway only allows connections from
    ///          SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on
    ///          Microsoft Windows Vista, Windows Server 2008 or newer.</p>
    ///
    ///          <p>MandatoryEncryption: if you use this option, file gateway only allows connections from
    ///          SMBv3 clients that have encryption enabled. This option is highly recommended for
    ///          environments that handle sensitive data. This option works with SMB clients on Microsoft
    ///          Windows 8, Windows Server 2012 or newer.</p>
    public let sMBSecurityStrategy: SMBSecurityStrategy?

    public init (
        gatewayARN: String? = nil,
        sMBSecurityStrategy: SMBSecurityStrategy? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.sMBSecurityStrategy = sMBSecurityStrategy
    }
}

struct UpdateSMBSecurityStrategyInputBody: Equatable {
    public let gatewayARN: String?
    public let sMBSecurityStrategy: SMBSecurityStrategy?
}

extension UpdateSMBSecurityStrategyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case sMBSecurityStrategy = "SMBSecurityStrategy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let sMBSecurityStrategyDecoded = try containerValues.decodeIfPresent(SMBSecurityStrategy.self, forKey: .sMBSecurityStrategy)
        sMBSecurityStrategy = sMBSecurityStrategyDecoded
    }
}

extension UpdateSMBSecurityStrategyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSMBSecurityStrategyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSMBSecurityStrategyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSMBSecurityStrategyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSMBSecurityStrategyOutputResponse(gatewayARN: \(String(describing: gatewayARN)))"}
}

extension UpdateSMBSecurityStrategyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSMBSecurityStrategyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayARN = output.gatewayARN
        } else {
            self.gatewayARN = nil
        }
    }
}

public struct UpdateSMBSecurityStrategyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?

    public init (
        gatewayARN: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
    }
}

struct UpdateSMBSecurityStrategyOutputResponseBody: Equatable {
    public let gatewayARN: String?
}

extension UpdateSMBSecurityStrategyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
    }
}

public struct UpdateSnapshotScheduleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSnapshotScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSnapshotScheduleOutputError>
}

extension UpdateSnapshotScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSnapshotScheduleInput(description: \(String(describing: description)), recurrenceInHours: \(String(describing: recurrenceInHours)), startAt: \(String(describing: startAt)), tags: \(String(describing: tags)), volumeARN: \(String(describing: volumeARN)))"}
}

extension UpdateSnapshotScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recurrenceInHours = recurrenceInHours {
            try encodeContainer.encode(recurrenceInHours, forKey: .recurrenceInHours)
        }
        if let startAt = startAt {
            try encodeContainer.encode(startAt, forKey: .startAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
    }
}

public struct UpdateSnapshotScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSnapshotScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSnapshotScheduleOutputError>
}

public struct UpdateSnapshotScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSnapshotScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSnapshotScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSnapshotScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSnapshotScheduleInput>
    public typealias MOutput = OperationOutput<UpdateSnapshotScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSnapshotScheduleOutputError>
}

/// <p>A JSON object containing one or more of the following fields:</p>
///
///          <ul>
///             <li>
///                <p>
///                   <a>UpdateSnapshotScheduleInput$Description</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateSnapshotScheduleInput$RecurrenceInHours</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateSnapshotScheduleInput$StartAt</a>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <a>UpdateSnapshotScheduleInput$VolumeARN</a>
///                </p>
///             </li>
///          </ul>
public struct UpdateSnapshotScheduleInput: Equatable {
    /// <p>Optional description of the snapshot that overwrites the existing description.</p>
    public let description: String?
    /// <p>Frequency of snapshots. Specify the number of hours between snapshots.</p>
    public let recurrenceInHours: Int?
    /// <p>The hour of the day at which the snapshot schedule begins represented as
    ///             <i>hh</i>, where <i>hh</i> is the hour (0 to 23). The hour
    ///          of the day is in the time zone of the gateway.</p>
    public let startAt: Int?
    /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
    ///          pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes.</p>
    public let volumeARN: String?

    public init (
        description: String? = nil,
        recurrenceInHours: Int? = nil,
        startAt: Int? = nil,
        tags: [Tag]? = nil,
        volumeARN: String? = nil
    )
    {
        self.description = description
        self.recurrenceInHours = recurrenceInHours
        self.startAt = startAt
        self.tags = tags
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleInputBody: Equatable {
    public let volumeARN: String?
    public let startAt: Int?
    public let recurrenceInHours: Int?
    public let description: String?
    public let tags: [Tag]?
}

extension UpdateSnapshotScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case recurrenceInHours = "RecurrenceInHours"
        case startAt = "StartAt"
        case tags = "Tags"
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let startAtDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startAt)
        startAt = startAtDecoded
        let recurrenceInHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .recurrenceInHours)
        recurrenceInHours = recurrenceInHoursDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSnapshotScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSnapshotScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSnapshotScheduleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSnapshotScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSnapshotScheduleOutputResponse(volumeARN: \(String(describing: volumeARN)))"}
}

extension UpdateSnapshotScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSnapshotScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumeARN = output.volumeARN
        } else {
            self.volumeARN = nil
        }
    }
}

/// <p>A JSON object containing the Amazon Resource Name (ARN) of the updated storage
///          volume.</p>
public struct UpdateSnapshotScheduleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
    ///          operation to return a list of gateway volumes.</p>
    public let volumeARN: String?

    public init (
        volumeARN: String? = nil
    )
    {
        self.volumeARN = volumeARN
    }
}

struct UpdateSnapshotScheduleOutputResponseBody: Equatable {
    public let volumeARN: String?
}

extension UpdateSnapshotScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
    }
}

public struct UpdateVTLDeviceTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVTLDeviceTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVTLDeviceTypeOutputError>
}

extension UpdateVTLDeviceTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVTLDeviceTypeInput(deviceType: \(String(describing: deviceType)), vTLDeviceARN: \(String(describing: vTLDeviceARN)))"}
}

extension UpdateVTLDeviceTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceType = "DeviceType"
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let vTLDeviceARN = vTLDeviceARN {
            try encodeContainer.encode(vTLDeviceARN, forKey: .vTLDeviceARN)
        }
    }
}

public struct UpdateVTLDeviceTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVTLDeviceTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVTLDeviceTypeOutputError>
}

public struct UpdateVTLDeviceTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVTLDeviceTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVTLDeviceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVTLDeviceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVTLDeviceTypeInput>
    public typealias MOutput = OperationOutput<UpdateVTLDeviceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVTLDeviceTypeOutputError>
}

public struct UpdateVTLDeviceTypeInput: Equatable {
    /// <p>The type of medium changer you want to select.</p>
    ///
    ///          <p>Valid Values: <code>STK-L700</code> | <code>AWS-Gateway-VTL</code> |
    ///             <code>IBM-03584L32-0402</code>
    ///          </p>
    public let deviceType: String?
    /// <p>The Amazon Resource Name (ARN) of the medium changer you want to select.</p>
    public let vTLDeviceARN: String?

    public init (
        deviceType: String? = nil,
        vTLDeviceARN: String? = nil
    )
    {
        self.deviceType = deviceType
        self.vTLDeviceARN = vTLDeviceARN
    }
}

struct UpdateVTLDeviceTypeInputBody: Equatable {
    public let vTLDeviceARN: String?
    public let deviceType: String?
}

extension UpdateVTLDeviceTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceType = "DeviceType"
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
    }
}

extension UpdateVTLDeviceTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVTLDeviceTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGatewayRequestException" : self = .invalidGatewayRequestException(try InvalidGatewayRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVTLDeviceTypeOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidGatewayRequestException(InvalidGatewayRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVTLDeviceTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVTLDeviceTypeOutputResponse(vTLDeviceARN: \(String(describing: vTLDeviceARN)))"}
}

extension UpdateVTLDeviceTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateVTLDeviceTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.vTLDeviceARN = output.vTLDeviceARN
        } else {
            self.vTLDeviceARN = nil
        }
    }
}

/// <p>UpdateVTLDeviceTypeOutput</p>
public struct UpdateVTLDeviceTypeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the medium changer you have selected.</p>
    public let vTLDeviceARN: String?

    public init (
        vTLDeviceARN: String? = nil
    )
    {
        self.vTLDeviceARN = vTLDeviceARN
    }
}

struct UpdateVTLDeviceTypeOutputResponseBody: Equatable {
    public let vTLDeviceARN: String?
}

extension UpdateVTLDeviceTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vTLDeviceARN = "VTLDeviceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
    }
}

extension VTLDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceiSCSIAttributes = "DeviceiSCSIAttributes"
        case vTLDeviceARN = "VTLDeviceARN"
        case vTLDeviceProductIdentifier = "VTLDeviceProductIdentifier"
        case vTLDeviceType = "VTLDeviceType"
        case vTLDeviceVendor = "VTLDeviceVendor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceiSCSIAttributes = deviceiSCSIAttributes {
            try encodeContainer.encode(deviceiSCSIAttributes, forKey: .deviceiSCSIAttributes)
        }
        if let vTLDeviceARN = vTLDeviceARN {
            try encodeContainer.encode(vTLDeviceARN, forKey: .vTLDeviceARN)
        }
        if let vTLDeviceProductIdentifier = vTLDeviceProductIdentifier {
            try encodeContainer.encode(vTLDeviceProductIdentifier, forKey: .vTLDeviceProductIdentifier)
        }
        if let vTLDeviceType = vTLDeviceType {
            try encodeContainer.encode(vTLDeviceType, forKey: .vTLDeviceType)
        }
        if let vTLDeviceVendor = vTLDeviceVendor {
            try encodeContainer.encode(vTLDeviceVendor, forKey: .vTLDeviceVendor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vTLDeviceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceARN)
        vTLDeviceARN = vTLDeviceARNDecoded
        let vTLDeviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceType)
        vTLDeviceType = vTLDeviceTypeDecoded
        let vTLDeviceVendorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceVendor)
        vTLDeviceVendor = vTLDeviceVendorDecoded
        let vTLDeviceProductIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vTLDeviceProductIdentifier)
        vTLDeviceProductIdentifier = vTLDeviceProductIdentifierDecoded
        let deviceiSCSIAttributesDecoded = try containerValues.decodeIfPresent(DeviceiSCSIAttributes.self, forKey: .deviceiSCSIAttributes)
        deviceiSCSIAttributes = deviceiSCSIAttributesDecoded
    }
}

extension VTLDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VTLDevice(deviceiSCSIAttributes: \(String(describing: deviceiSCSIAttributes)), vTLDeviceARN: \(String(describing: vTLDeviceARN)), vTLDeviceProductIdentifier: \(String(describing: vTLDeviceProductIdentifier)), vTLDeviceType: \(String(describing: vTLDeviceType)), vTLDeviceVendor: \(String(describing: vTLDeviceVendor)))"}
}

/// <p>Represents a device object associated with a tape gateway.</p>
public struct VTLDevice: Equatable {
    /// <p>A list of iSCSI information about a VTL device.</p>
    public let deviceiSCSIAttributes: DeviceiSCSIAttributes?
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the device (tape drive or media
    ///          changer).</p>
    public let vTLDeviceARN: String?
    /// <p>Specifies the model number of device that the VTL device emulates.</p>
    public let vTLDeviceProductIdentifier: String?
    /// <p>Specifies the type of device that the VTL device emulates.</p>
    public let vTLDeviceType: String?
    /// <p>Specifies the vendor of the device that the VTL device object emulates.</p>
    public let vTLDeviceVendor: String?

    public init (
        deviceiSCSIAttributes: DeviceiSCSIAttributes? = nil,
        vTLDeviceARN: String? = nil,
        vTLDeviceProductIdentifier: String? = nil,
        vTLDeviceType: String? = nil,
        vTLDeviceVendor: String? = nil
    )
    {
        self.deviceiSCSIAttributes = deviceiSCSIAttributes
        self.vTLDeviceARN = vTLDeviceARN
        self.vTLDeviceProductIdentifier = vTLDeviceProductIdentifier
        self.vTLDeviceType = vTLDeviceType
        self.vTLDeviceVendor = vTLDeviceVendor
    }
}

extension VolumeInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayARN = "GatewayARN"
        case gatewayId = "GatewayId"
        case volumeARN = "VolumeARN"
        case volumeAttachmentStatus = "VolumeAttachmentStatus"
        case volumeId = "VolumeId"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayARN = gatewayARN {
            try encodeContainer.encode(gatewayARN, forKey: .gatewayARN)
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeAttachmentStatus = volumeAttachmentStatus {
            try encodeContainer.encode(volumeAttachmentStatus, forKey: .volumeAttachmentStatus)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let gatewayARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayARN)
        gatewayARN = gatewayARNDecoded
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeAttachmentStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeAttachmentStatus)
        volumeAttachmentStatus = volumeAttachmentStatusDecoded
    }
}

extension VolumeInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeInfo(gatewayARN: \(String(describing: gatewayARN)), gatewayId: \(String(describing: gatewayId)), volumeARN: \(String(describing: volumeARN)), volumeAttachmentStatus: \(String(describing: volumeAttachmentStatus)), volumeId: \(String(describing: volumeId)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes a storage volume object.</p>
public struct VolumeInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
    ///          operation to return a list of gateways for your account and AWS Region.</p>
    public let gatewayARN: String?
    /// <p>The unique identifier assigned to your gateway during activation. This ID becomes part
    ///          of the gateway Amazon Resource Name (ARN), which you use as input for other
    ///          operations.</p>
    ///
    ///          <p>Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).</p>
    public let gatewayId: String?
    /// <p>The Amazon Resource Name (ARN) for the storage volume. For example, the following is a
    ///          valid ARN:</p>
    ///
    ///          <p>
    ///             <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/volume/vol-1122AABB</code>
    ///          </p>
    ///
    ///          <p>Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).</p>
    public let volumeARN: String?
    /// <p>One of the VolumeStatus values that indicates the state of the storage volume.</p>
    public let volumeAttachmentStatus: String?
    /// <p>The unique identifier assigned to the volume. This ID becomes part of the volume Amazon
    ///          Resource Name (ARN), which you use as input for other operations.</p>
    ///
    ///          <p>Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).</p>
    public let volumeId: String?
    /// <p>The size of the volume in bytes.</p>
    ///
    ///          <p>Valid Values: 50 to 500 lowercase letters, numbers, periods (.), and hyphens (-).</p>
    public let volumeSizeInBytes: Int
    /// <p>One of the VolumeType enumeration values describing the type of the volume.</p>
    public let volumeType: String?

    public init (
        gatewayARN: String? = nil,
        gatewayId: String? = nil,
        volumeARN: String? = nil,
        volumeAttachmentStatus: String? = nil,
        volumeId: String? = nil,
        volumeSizeInBytes: Int = 0,
        volumeType: String? = nil
    )
    {
        self.gatewayARN = gatewayARN
        self.gatewayId = gatewayId
        self.volumeARN = volumeARN
        self.volumeAttachmentStatus = volumeAttachmentStatus
        self.volumeId = volumeId
        self.volumeSizeInBytes = volumeSizeInBytes
        self.volumeType = volumeType
    }
}

extension VolumeRecoveryPointInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeARN = "VolumeARN"
        case volumeRecoveryPointTime = "VolumeRecoveryPointTime"
        case volumeSizeInBytes = "VolumeSizeInBytes"
        case volumeUsageInBytes = "VolumeUsageInBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeARN = volumeARN {
            try encodeContainer.encode(volumeARN, forKey: .volumeARN)
        }
        if let volumeRecoveryPointTime = volumeRecoveryPointTime {
            try encodeContainer.encode(volumeRecoveryPointTime, forKey: .volumeRecoveryPointTime)
        }
        if volumeSizeInBytes != 0 {
            try encodeContainer.encode(volumeSizeInBytes, forKey: .volumeSizeInBytes)
        }
        if volumeUsageInBytes != 0 {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeARN)
        volumeARN = volumeARNDecoded
        let volumeSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInBytes)
        volumeSizeInBytes = volumeSizeInBytesDecoded
        let volumeUsageInBytesDecoded = try containerValues.decode(Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeRecoveryPointTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeRecoveryPointTime)
        volumeRecoveryPointTime = volumeRecoveryPointTimeDecoded
    }
}

extension VolumeRecoveryPointInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeRecoveryPointInfo(volumeARN: \(String(describing: volumeARN)), volumeRecoveryPointTime: \(String(describing: volumeRecoveryPointTime)), volumeSizeInBytes: \(String(describing: volumeSizeInBytes)), volumeUsageInBytes: \(String(describing: volumeUsageInBytes)))"}
}

/// <p>Describes a storage volume recovery point object.</p>
public struct VolumeRecoveryPointInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the volume target.</p>
    public let volumeARN: String?
    /// <p>The time the recovery point was taken.</p>
    public let volumeRecoveryPointTime: String?
    /// <p>The size of the volume in bytes.</p>
    public let volumeSizeInBytes: Int
    /// <p>The size of the data stored on the volume in bytes.</p>
    ///
    ///          <note>
    ///             <p>This value is not available for volumes created prior to May 13, 2015, until you
    ///             store data on the volume.</p>
    ///          </note>
    public let volumeUsageInBytes: Int

    public init (
        volumeARN: String? = nil,
        volumeRecoveryPointTime: String? = nil,
        volumeSizeInBytes: Int = 0,
        volumeUsageInBytes: Int = 0
    )
    {
        self.volumeARN = volumeARN
        self.volumeRecoveryPointTime = volumeRecoveryPointTime
        self.volumeSizeInBytes = volumeSizeInBytes
        self.volumeUsageInBytes = volumeUsageInBytes
    }
}

extension VolumeiSCSIAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case chapEnabled = "ChapEnabled"
        case lunNumber = "LunNumber"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfacePort = "NetworkInterfacePort"
        case targetARN = "TargetARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if chapEnabled != false {
            try encodeContainer.encode(chapEnabled, forKey: .chapEnabled)
        }
        if let lunNumber = lunNumber {
            try encodeContainer.encode(lunNumber, forKey: .lunNumber)
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if networkInterfacePort != 0 {
            try encodeContainer.encode(networkInterfacePort, forKey: .networkInterfacePort)
        }
        if let targetARN = targetARN {
            try encodeContainer.encode(targetARN, forKey: .targetARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetARN)
        targetARN = targetARNDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfacePortDecoded = try containerValues.decode(Int.self, forKey: .networkInterfacePort)
        networkInterfacePort = networkInterfacePortDecoded
        let lunNumberDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lunNumber)
        lunNumber = lunNumberDecoded
        let chapEnabledDecoded = try containerValues.decode(Bool.self, forKey: .chapEnabled)
        chapEnabled = chapEnabledDecoded
    }
}

extension VolumeiSCSIAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeiSCSIAttributes(chapEnabled: \(String(describing: chapEnabled)), lunNumber: \(String(describing: lunNumber)), networkInterfaceId: \(String(describing: networkInterfaceId)), networkInterfacePort: \(String(describing: networkInterfacePort)), targetARN: \(String(describing: targetARN)))"}
}

/// <p>Lists iSCSI information about a volume.</p>
public struct VolumeiSCSIAttributes: Equatable {
    /// <p>Indicates whether mutual CHAP is enabled for the iSCSI target.</p>
    public let chapEnabled: Bool
    /// <p>The logical disk number.</p>
    public let lunNumber: Int?
    /// <p>The network interface identifier.</p>
    public let networkInterfaceId: String?
    /// <p>The port used to communicate with iSCSI targets.</p>
    public let networkInterfacePort: Int
    /// <p>The Amazon Resource Name (ARN) of the volume target.</p>
    public let targetARN: String?

    public init (
        chapEnabled: Bool = false,
        lunNumber: Int? = nil,
        networkInterfaceId: String? = nil,
        networkInterfacePort: Int = 0,
        targetARN: String? = nil
    )
    {
        self.chapEnabled = chapEnabled
        self.lunNumber = lunNumber
        self.networkInterfaceId = networkInterfaceId
        self.networkInterfacePort = networkInterfacePort
        self.targetARN = targetARN
    }
}
