// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>CreateNFSFileShareInput</p>
public struct CreateNFSFileShareInput: Equatable {
    /// <p>Specifies refresh cache information for the file share.</p>
    public let cacheAttributes: CacheAttributes?
    /// <p>The list of clients that are allowed to access the file gateway. The list must contain
    ///          either valid IP addresses or valid CIDR blocks.</p>
    public let clientList: [String]?
    /// <p>A unique string value that you supply that is used by file gateway to ensure idempotent
    ///          file share creation.</p>
    public let clientToken: String?
    /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
    ///          The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
    ///
    ///          <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
    ///             <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
    ///          </p>
    public let defaultStorageClass: String?
    /// <p>The name of the file share. Optional.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>FileShareName</code> must be set if an S3 prefix name is set in
    ///                <code>LocationARN</code>.</p>
    ///          </note>
    public let fileShareName: String?
    /// <p>The Amazon Resource Name (ARN) of the file gateway on which you want to create a file
    ///          share.</p>
    public let gatewayARN: String?
    /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
    ///          extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
    ///          to <code>false</code>. The default value is <code>true</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let guessMIMETypeEnabled: Bool?
    /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
    ///          key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let kMSEncrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
    ///          S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
    ///          only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
    public let kMSKey: String?
    /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
    ///          the S3 bucket name. It must end with a "/".</p>
    public let locationARN: String?
    /// <p>File share default values. Optional.</p>
    public let nFSFileShareDefaults: NFSFileShareDefaults?
    /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
    ///          the number of seconds to wait after the last point in time a client wrote to a file before
    ///          generating an <code>ObjectUploaded</code> notification. Because clients can make many small
    ///          writes to files, it's best to set this parameter for as long as possible to avoid
    ///          generating multiple notifications for the same file in a small time period.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
    ///             uploading to Amazon S3, only the timing of the notification.</p>
    ///          </note>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> on with
    ///             <code>SettlingTimeInSeconds</code> set to 60.</p>
    ///
    ///          <p>
    ///             <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
    ///          </p>
    ///
    ///          <p>The following example sets <code>NotificationPolicy</code> off.</p>
    ///
    ///          <p>
    ///             <code>{}</code>
    ///          </p>
    public let notificationPolicy: String?
    /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
    ///          that a file gateway puts objects into. The default value is <code>private</code>.</p>
    public let objectACL: ObjectACL?
    /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
    ///          to set the write status to read-only, otherwise set to <code>false</code>.</p>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let readOnly: Bool?
    /// <p>A value that sets who pays the cost of the request and the cost associated with data
    ///          download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
    ///          the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
    ///          the cost of storing data.</p>
    ///
    ///          <note>
    ///             <p>
    ///                <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
    ///             share, so make sure that the configuration on the file share is the same as the S3
    ///             bucket configuration.</p>
    ///          </note>
    ///
    ///          <p>Valid Values: <code>true</code> | <code>false</code>
    ///          </p>
    public let requesterPays: Bool?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that a file gateway assumes
    ///          when it accesses the underlying storage.</p>
    public let role: String?
    /// <p>A value that maps a user to anonymous user.</p>
    ///
    ///          <p>Valid values are the following:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NoSquash</code>: No one is mapped to anonymous user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
    ///             </li>
    ///          </ul>
    public let squash: String?
    /// <p>A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
    ///          key-value pair.</p>
    ///
    ///          <note>
    ///             <p>Valid characters for key and value are letters, spaces, and numbers representable in
    ///             UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
    ///             of a tag's key is 128 characters, and the maximum length for a tag's value is
    ///             256.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        cacheAttributes: CacheAttributes? = nil,
        clientList: [String]? = nil,
        clientToken: String? = nil,
        defaultStorageClass: String? = nil,
        fileShareName: String? = nil,
        gatewayARN: String? = nil,
        guessMIMETypeEnabled: Bool? = nil,
        kMSEncrypted: Bool? = nil,
        kMSKey: String? = nil,
        locationARN: String? = nil,
        nFSFileShareDefaults: NFSFileShareDefaults? = nil,
        notificationPolicy: String? = nil,
        objectACL: ObjectACL? = nil,
        readOnly: Bool? = nil,
        requesterPays: Bool? = nil,
        role: String? = nil,
        squash: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.cacheAttributes = cacheAttributes
        self.clientList = clientList
        self.clientToken = clientToken
        self.defaultStorageClass = defaultStorageClass
        self.fileShareName = fileShareName
        self.gatewayARN = gatewayARN
        self.guessMIMETypeEnabled = guessMIMETypeEnabled
        self.kMSEncrypted = kMSEncrypted
        self.kMSKey = kMSKey
        self.locationARN = locationARN
        self.nFSFileShareDefaults = nFSFileShareDefaults
        self.notificationPolicy = notificationPolicy
        self.objectACL = objectACL
        self.readOnly = readOnly
        self.requesterPays = requesterPays
        self.role = role
        self.squash = squash
        self.tags = tags
    }
}

extension CreateNFSFileShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNFSFileShareInput(cacheAttributes: \(String(describing: cacheAttributes)), clientList: \(String(describing: clientList)), clientToken: \(String(describing: clientToken)), defaultStorageClass: \(String(describing: defaultStorageClass)), fileShareName: \(String(describing: fileShareName)), gatewayARN: \(String(describing: gatewayARN)), guessMIMETypeEnabled: \(String(describing: guessMIMETypeEnabled)), kMSEncrypted: \(String(describing: kMSEncrypted)), kMSKey: \(String(describing: kMSKey)), locationARN: \(String(describing: locationARN)), nFSFileShareDefaults: \(String(describing: nFSFileShareDefaults)), notificationPolicy: \(String(describing: notificationPolicy)), objectACL: \(String(describing: objectACL)), readOnly: \(String(describing: readOnly)), requesterPays: \(String(describing: requesterPays)), role: \(String(describing: role)), squash: \(String(describing: squash)), tags: \(String(describing: tags)))"}
}
