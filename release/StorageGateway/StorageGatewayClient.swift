// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class StorageGatewayClient {
    let client: SdkHttpClient
    let config: StorageGatewayClientConfiguration
    let serviceName = "Storage Gateway"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: StorageGatewayClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    deinit {
        client.close()
    }

    public class StorageGatewayClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public let clientLogMode: ClientLogMode
        public let logger: LogAgent

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String,
            clientLogMode: ClientLogMode = .request,
            logger: LogAgent? = nil
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
            self.clientLogMode = clientLogMode
            self.logger = logger ?? SwiftLogger(label: "StorageGatewayClient")
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> StorageGatewayClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try StorageGatewayClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

public struct StorageGatewayClientLogHandlerFactory: SDKLogHandlerFactory {
    public var label = "StorageGatewayClient"
    let logLevel: SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension StorageGatewayClient: StorageGatewayClientProtocol {
    /// <p>Activates the gateway you previously deployed on your host. In the activation process,
    ///          you specify information such as the AWS Region that you want to use for storing snapshots
    ///          or tapes, the time zone for scheduled snapshots the gateway snapshot schedule window, an
    ///          activation key, and a name for your gateway. The activation process also associates your
    ///          gateway with your account. For more information, see <a>UpdateGatewayInformation</a>.</p>
    ///          <note>
    ///             <p>You must turn on the gateway VM before you can activate your gateway.</p>
    ///          </note>
    public func activateGateway(input: ActivateGatewayInput, completion: @escaping (SdkResult<ActivateGatewayOutputResponse, ActivateGatewayOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "activateGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ActivateGatewayInput, ActivateGatewayOutputResponse, ActivateGatewayOutputError>(id: "activateGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ActivateGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ActivateGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ActivateGatewayInput, ActivateGatewayOutputResponse, ActivateGatewayOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ActivateGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ActivateGatewayInput, ActivateGatewayOutputResponse, ActivateGatewayOutputError>(xAmzTarget: "StorageGateway_20130630.ActivateGateway"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configures one or more gateway local disks as cache for a gateway. This operation is
    ///          only supported in the cached volume, tape, and file gateway type (see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/StorageGatewayConcepts.html">How AWS Storage Gateway works (architecture)</a>.</p>
    ///
    ///          <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
    ///          add cache, and one or more disk IDs that you want to configure as cache.</p>
    public func addCache(input: AddCacheInput, completion: @escaping (SdkResult<AddCacheOutputResponse, AddCacheOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddCacheInput, AddCacheOutputResponse, AddCacheOutputError>(id: "addCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddCacheInput, AddCacheOutputResponse, AddCacheOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AddCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AddCacheInput, AddCacheOutputResponse, AddCacheOutputError>(xAmzTarget: "StorageGateway_20130630.AddCache"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds one or more tags to the specified resource. You use tags to add metadata to
    ///          resources, which you can use to categorize these resources. For example, you can categorize
    ///          resources by purpose, owner, environment, or team. Each tag consists of a key and a value,
    ///          which you define. You can add tags to the following AWS Storage Gateway resources:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Storage gateways of all types</p>
    ///             </li>
    ///             <li>
    ///                <p>Storage volumes</p>
    ///             </li>
    ///             <li>
    ///                <p>Virtual tapes</p>
    ///             </li>
    ///             <li>
    ///                <p>NFS and SMB file shares</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>You can create a maximum of 50 tags for each resource. Virtual tapes and storage volumes
    ///          that are recovered to a new gateway maintain their tags.</p>
    public func addTagsToResource(input: AddTagsToResourceInput, completion: @escaping (SdkResult<AddTagsToResourceOutputResponse, AddTagsToResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addTagsToResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddTagsToResourceInput, AddTagsToResourceOutputResponse, AddTagsToResourceOutputError>(id: "addTagsToResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddTagsToResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddTagsToResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddTagsToResourceInput, AddTagsToResourceOutputResponse, AddTagsToResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AddTagsToResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AddTagsToResourceInput, AddTagsToResourceOutputResponse, AddTagsToResourceOutputError>(xAmzTarget: "StorageGateway_20130630.AddTagsToResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configures one or more gateway local disks as upload buffer for a specified gateway.
    ///          This operation is supported for the stored volume, cached volume, and tape gateway
    ///          types.</p>
    ///
    ///          <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
    ///          add upload buffer, and one or more disk IDs that you want to configure as upload
    ///          buffer.</p>
    public func addUploadBuffer(input: AddUploadBufferInput, completion: @escaping (SdkResult<AddUploadBufferOutputResponse, AddUploadBufferOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addUploadBuffer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddUploadBufferInput, AddUploadBufferOutputResponse, AddUploadBufferOutputError>(id: "addUploadBuffer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddUploadBufferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddUploadBufferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddUploadBufferInput, AddUploadBufferOutputResponse, AddUploadBufferOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AddUploadBufferInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AddUploadBufferInput, AddUploadBufferOutputResponse, AddUploadBufferOutputError>(xAmzTarget: "StorageGateway_20130630.AddUploadBuffer"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configures one or more gateway local disks as working storage for a gateway. This
    ///          operation is only supported in the stored volume gateway type. This operation is deprecated
    ///          in cached volume API version 20120630. Use <a>AddUploadBuffer</a>
    ///          instead.</p>
    ///
    ///          <note>
    ///             <p>Working storage is also referred to as upload buffer. You can also use the <a>AddUploadBuffer</a> operation to add upload buffer to a stored volume
    ///             gateway.</p>
    ///          </note>
    ///
    ///          <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
    ///          add working storage, and one or more disk IDs that you want to configure as working
    ///          storage.</p>
    public func addWorkingStorage(input: AddWorkingStorageInput, completion: @escaping (SdkResult<AddWorkingStorageOutputResponse, AddWorkingStorageOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addWorkingStorage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddWorkingStorageInput, AddWorkingStorageOutputResponse, AddWorkingStorageOutputError>(id: "addWorkingStorage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddWorkingStorageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddWorkingStorageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddWorkingStorageInput, AddWorkingStorageOutputResponse, AddWorkingStorageOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AddWorkingStorageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AddWorkingStorageInput, AddWorkingStorageOutputResponse, AddWorkingStorageOutputError>(xAmzTarget: "StorageGateway_20130630.AddWorkingStorage"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Assigns a tape to a tape pool for archiving. The tape assigned to a pool is archived in
    ///          the S3 storage class that is associated with the pool. When you use your backup application
    ///          to eject the tape, the tape is archived directly into the S3 storage class (S3 Glacier or
    ///          S3 Glacier Deep Archive) that corresponds to the pool.</p>
    ///
    ///          <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
    ///          </p>
    public func assignTapePool(input: AssignTapePoolInput, completion: @escaping (SdkResult<AssignTapePoolOutputResponse, AssignTapePoolOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "assignTapePool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssignTapePoolInput, AssignTapePoolOutputResponse, AssignTapePoolOutputError>(id: "assignTapePool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssignTapePoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssignTapePoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssignTapePoolInput, AssignTapePoolOutputResponse, AssignTapePoolOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AssignTapePoolInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AssignTapePoolInput, AssignTapePoolOutputResponse, AssignTapePoolOutputError>(xAmzTarget: "StorageGateway_20130630.AssignTapePool"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associate an Amazon FSx file system with the Amazon FSx file gateway. After the
    ///          association process is complete, the file shares on the Amazon FSx file system are
    ///          available for access through the gateway. This operation only supports the Amazon FSx file
    ///          gateway type.</p>
    public func associateFileSystem(input: AssociateFileSystemInput, completion: @escaping (SdkResult<AssociateFileSystemOutputResponse, AssociateFileSystemOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AssociateFileSystemInput, AssociateFileSystemOutputResponse, AssociateFileSystemOutputError>(id: "associateFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AssociateFileSystemInput, AssociateFileSystemOutputResponse, AssociateFileSystemOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AssociateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AssociateFileSystemInput, AssociateFileSystemOutputResponse, AssociateFileSystemOutputError>(xAmzTarget: "StorageGateway_20130630.AssociateFileSystem"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Connects a volume to an iSCSI connection and then attaches the volume to the specified
    ///          gateway. Detaching and attaching a volume enables you to recover your data from one gateway
    ///          to a different gateway without creating a snapshot. It also makes it easier to move your
    ///          volumes from an on-premises gateway to a gateway hosted on an Amazon EC2 instance.</p>
    public func attachVolume(input: AttachVolumeInput, completion: @escaping (SdkResult<AttachVolumeOutputResponse, AttachVolumeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "attachVolume")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AttachVolumeInput, AttachVolumeOutputResponse, AttachVolumeOutputError>(id: "attachVolume")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AttachVolumeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AttachVolumeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AttachVolumeInput, AttachVolumeOutputResponse, AttachVolumeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: AttachVolumeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<AttachVolumeInput, AttachVolumeOutputResponse, AttachVolumeOutputError>(xAmzTarget: "StorageGateway_20130630.AttachVolume"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels archiving of a virtual tape to the virtual tape shelf (VTS) after the archiving
    ///          process is initiated. This operation is only supported in the tape gateway type.</p>
    public func cancelArchival(input: CancelArchivalInput, completion: @escaping (SdkResult<CancelArchivalOutputResponse, CancelArchivalOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelArchival")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelArchivalInput, CancelArchivalOutputResponse, CancelArchivalOutputError>(id: "cancelArchival")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelArchivalInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelArchivalInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelArchivalInput, CancelArchivalOutputResponse, CancelArchivalOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelArchivalInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelArchivalInput, CancelArchivalOutputResponse, CancelArchivalOutputError>(xAmzTarget: "StorageGateway_20130630.CancelArchival"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels retrieval of a virtual tape from the virtual tape shelf (VTS) to a gateway after
    ///          the retrieval process is initiated. The virtual tape is returned to the VTS. This operation
    ///          is only supported in the tape gateway type.</p>
    public func cancelRetrieval(input: CancelRetrievalInput, completion: @escaping (SdkResult<CancelRetrievalOutputResponse, CancelRetrievalOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelRetrieval")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelRetrievalInput, CancelRetrievalOutputResponse, CancelRetrievalOutputError>(id: "cancelRetrieval")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelRetrievalInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelRetrievalInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelRetrievalInput, CancelRetrievalOutputResponse, CancelRetrievalOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelRetrievalInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelRetrievalInput, CancelRetrievalOutputResponse, CancelRetrievalOutputError>(xAmzTarget: "StorageGateway_20130630.CancelRetrieval"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a cached volume on a specified cached volume gateway. This operation is only
    ///          supported in the cached volume gateway type.</p>
    ///
    ///          <note>
    ///             <p>Cache storage must be allocated to the gateway before you can create a cached volume.
    ///             Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
    ///          </note>
    ///
    ///          <p>In the request, you must specify the gateway, size of the volume in bytes, the iSCSI
    ///          target name, an IP address on which to expose the target, and a unique client token. In
    ///          response, the gateway creates the volume and returns information about it. This information
    ///          includes the volume Amazon Resource Name (ARN), its size, and the iSCSI target ARN that
    ///          initiators can use to connect to the volume target.</p>
    ///
    ///          <p>Optionally, you can provide the ARN for an existing volume as the
    ///             <code>SourceVolumeARN</code> for this cached volume, which creates an exact copy of the
    ///          existing volumeâ€™s latest recovery point. The <code>VolumeSizeInBytes</code> value must be
    ///          equal to or larger than the size of the copied volume, in bytes.</p>
    public func createCachediSCSIVolume(input: CreateCachediSCSIVolumeInput, completion: @escaping (SdkResult<CreateCachediSCSIVolumeOutputResponse, CreateCachediSCSIVolumeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCachediSCSIVolume")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCachediSCSIVolumeInput, CreateCachediSCSIVolumeOutputResponse, CreateCachediSCSIVolumeOutputError>(id: "createCachediSCSIVolume")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCachediSCSIVolumeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCachediSCSIVolumeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCachediSCSIVolumeInput, CreateCachediSCSIVolumeOutputResponse, CreateCachediSCSIVolumeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCachediSCSIVolumeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateCachediSCSIVolumeInput, CreateCachediSCSIVolumeOutputResponse, CreateCachediSCSIVolumeOutputError>(xAmzTarget: "StorageGateway_20130630.CreateCachediSCSIVolume"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a Network File System (NFS) file share on an existing file gateway. In Storage
    ///          Gateway, a file share is a file system mount point backed by Amazon S3 cloud storage.
    ///          Storage Gateway exposes file shares using an NFS interface. This operation is only
    ///          supported for file gateways.</p>
    ///
    ///          <important>
    ///             <p>File gateway requires AWS Security Token Service (AWS STS) to be activated to enable
    ///             you to create a file share. Make sure AWS STS is activated in the AWS Region you are
    ///             creating your file gateway in. If AWS STS is not activated in the AWS Region, activate
    ///             it. For information about how to activate AWS STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    ///                deactivating AWS STS in an AWS Region</a> in the <i>AWS Identity and
    ///                Access Management User Guide</i>.</p>
    ///
    ///             <p>File gateway does not support creating hard or symbolic links on a file share.</p>
    ///          </important>
    public func createNFSFileShare(input: CreateNFSFileShareInput, completion: @escaping (SdkResult<CreateNFSFileShareOutputResponse, CreateNFSFileShareOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createNFSFileShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateNFSFileShareInput, CreateNFSFileShareOutputResponse, CreateNFSFileShareOutputError>(id: "createNFSFileShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateNFSFileShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateNFSFileShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateNFSFileShareInput, CreateNFSFileShareOutputResponse, CreateNFSFileShareOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateNFSFileShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateNFSFileShareInput, CreateNFSFileShareOutputResponse, CreateNFSFileShareOutputError>(xAmzTarget: "StorageGateway_20130630.CreateNFSFileShare"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a Server Message Block (SMB) file share on an existing file gateway. In Storage
    ///          Gateway, a file share is a file system mount point backed by Amazon S3 cloud storage.
    ///          Storage Gateway exposes file shares using an SMB interface. This operation is only
    ///          supported for file gateways.</p>
    ///
    ///          <important>
    ///             <p>File gateways require AWS Security Token Service (AWS STS) to be activated to enable
    ///             you to create a file share. Make sure that AWS STS is activated in the AWS Region you
    ///             are creating your file gateway in. If AWS STS is not activated in this AWS Region,
    ///             activate it. For information about how to activate AWS STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    ///                deactivating AWS STS in an AWS Region</a> in the <i>AWS Identity and
    ///                Access Management User Guide</i>.</p>
    ///
    ///             <p>File gateways don't support creating hard or symbolic links on a file
    ///             share.</p>
    ///          </important>
    public func createSMBFileShare(input: CreateSMBFileShareInput, completion: @escaping (SdkResult<CreateSMBFileShareOutputResponse, CreateSMBFileShareOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSMBFileShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSMBFileShareInput, CreateSMBFileShareOutputResponse, CreateSMBFileShareOutputError>(id: "createSMBFileShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSMBFileShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSMBFileShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSMBFileShareInput, CreateSMBFileShareOutputResponse, CreateSMBFileShareOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSMBFileShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateSMBFileShareInput, CreateSMBFileShareOutputResponse, CreateSMBFileShareOutputError>(xAmzTarget: "StorageGateway_20130630.CreateSMBFileShare"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a snapshot of a volume.</p>
    ///
    ///          <p>AWS Storage Gateway provides the ability to back up point-in-time snapshots of your data
    ///          to Amazon Simple Storage (Amazon S3) for durable off-site recovery, and also import the
    ///          data to an Amazon Elastic Block Store (EBS) volume in Amazon Elastic Compute Cloud (EC2).
    ///          You can take snapshots of your gateway volume on a scheduled or ad hoc basis. This API
    ///          enables you to take an ad hoc snapshot. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#SchedulingSnapshot">Editing a
    ///             snapshot schedule</a>.</p>
    ///
    ///          <p>In the <code>CreateSnapshot</code> request, you identify the volume by providing its
    ///          Amazon Resource Name (ARN). You must also provide description for the snapshot. When AWS
    ///          Storage Gateway takes the snapshot of specified volume, the snapshot and description
    ///          appears in the AWS Storage Gateway console. In response, AWS Storage Gateway returns you a
    ///          snapshot ID. You can use this snapshot ID to check the snapshot progress or later use it
    ///          when you want to create a volume from a snapshot. This operation is only supported in
    ///          stored and cached volume gateway type.</p>
    ///
    ///          <note>
    ///             <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
    ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
    ///             or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteSnapshot.html">DeleteSnapshot</a> in the <i>Amazon Elastic Compute Cloud API
    ///                Reference</i>.</p>
    ///          </note>
    ///
    ///          <important>
    ///             <p>Volume and snapshot IDs are changing to a longer length ID format. For more
    ///             information, see the important note on the <a href="https://docs.aws.amazon.com/storagegateway/latest/APIReference/Welcome.html">Welcome</a> page.</p>
    ///          </important>
    public func createSnapshot(input: CreateSnapshotInput, completion: @escaping (SdkResult<CreateSnapshotOutputResponse, CreateSnapshotOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSnapshot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSnapshotInput, CreateSnapshotOutputResponse, CreateSnapshotOutputError>(id: "createSnapshot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSnapshotInput, CreateSnapshotOutputResponse, CreateSnapshotOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateSnapshotInput, CreateSnapshotOutputResponse, CreateSnapshotOutputError>(xAmzTarget: "StorageGateway_20130630.CreateSnapshot"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Initiates a snapshot of a gateway from a volume recovery point. This operation is only
    ///          supported in the cached volume gateway type.</p>
    ///
    ///          <p>A volume recovery point is a point in time at which all data of the volume is consistent
    ///          and from which you can create a snapshot. To get a list of volume recovery point for cached
    ///          volume gateway, use <a>ListVolumeRecoveryPoints</a>.</p>
    ///
    ///          <p>In the <code>CreateSnapshotFromVolumeRecoveryPoint</code> request, you identify the
    ///          volume by providing its Amazon Resource Name (ARN). You must also provide a description for
    ///          the snapshot. When the gateway takes a snapshot of the specified volume, the snapshot and
    ///          its description appear in the AWS Storage Gateway console.
    ///           In response, the gateway returns
    ///          you a snapshot ID. You can use this snapshot ID to check the snapshot progress or later use
    ///          it when you want to create a volume from a snapshot.</p>
    ///
    ///          <note>
    ///             <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
    ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
    ///             or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteSnapshot.html">DeleteSnapshot</a> in the <i>Amazon Elastic Compute Cloud API
    ///                Reference</i>.</p>
    ///          </note>
    public func createSnapshotFromVolumeRecoveryPoint(input: CreateSnapshotFromVolumeRecoveryPointInput, completion: @escaping (SdkResult<CreateSnapshotFromVolumeRecoveryPointOutputResponse, CreateSnapshotFromVolumeRecoveryPointOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSnapshotFromVolumeRecoveryPoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSnapshotFromVolumeRecoveryPointInput, CreateSnapshotFromVolumeRecoveryPointOutputResponse, CreateSnapshotFromVolumeRecoveryPointOutputError>(id: "createSnapshotFromVolumeRecoveryPoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotFromVolumeRecoveryPointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotFromVolumeRecoveryPointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSnapshotFromVolumeRecoveryPointInput, CreateSnapshotFromVolumeRecoveryPointOutputResponse, CreateSnapshotFromVolumeRecoveryPointOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSnapshotFromVolumeRecoveryPointInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateSnapshotFromVolumeRecoveryPointInput, CreateSnapshotFromVolumeRecoveryPointOutputResponse, CreateSnapshotFromVolumeRecoveryPointOutputError>(xAmzTarget: "StorageGateway_20130630.CreateSnapshotFromVolumeRecoveryPoint"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a volume on a specified gateway. This operation is only supported in the stored
    ///          volume gateway type.</p>
    ///
    ///          <p>The size of the volume to create is inferred from the disk size. You can choose to
    ///          preserve existing data on the disk, create volume from an existing snapshot, or create an
    ///          empty volume. If you choose to create an empty gateway volume, then any existing data on
    ///          the disk is erased.</p>
    ///
    ///          <p>In the request, you must specify the gateway and the disk information on which you are
    ///          creating the volume. In response, the gateway creates the volume and returns volume
    ///          information such as the volume Amazon Resource Name (ARN), its size, and the iSCSI target
    ///          ARN that initiators can use to connect to the volume target.</p>
    public func createStorediSCSIVolume(input: CreateStorediSCSIVolumeInput, completion: @escaping (SdkResult<CreateStorediSCSIVolumeOutputResponse, CreateStorediSCSIVolumeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createStorediSCSIVolume")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateStorediSCSIVolumeInput, CreateStorediSCSIVolumeOutputResponse, CreateStorediSCSIVolumeOutputError>(id: "createStorediSCSIVolume")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateStorediSCSIVolumeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateStorediSCSIVolumeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateStorediSCSIVolumeInput, CreateStorediSCSIVolumeOutputResponse, CreateStorediSCSIVolumeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateStorediSCSIVolumeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateStorediSCSIVolumeInput, CreateStorediSCSIVolumeOutputResponse, CreateStorediSCSIVolumeOutputError>(xAmzTarget: "StorageGateway_20130630.CreateStorediSCSIVolume"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new custom tape pool. You can use custom tape pool to enable tape retention
    ///          lock on tapes that are archived in the custom pool.</p>
    public func createTapePool(input: CreateTapePoolInput, completion: @escaping (SdkResult<CreateTapePoolOutputResponse, CreateTapePoolOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTapePool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTapePoolInput, CreateTapePoolOutputResponse, CreateTapePoolOutputError>(id: "createTapePool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTapePoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTapePoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTapePoolInput, CreateTapePoolOutputResponse, CreateTapePoolOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTapePoolInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateTapePoolInput, CreateTapePoolOutputResponse, CreateTapePoolOutputError>(xAmzTarget: "StorageGateway_20130630.CreateTapePool"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a virtual tape by using your own barcode. You write data to the virtual tape and
    ///          then archive the tape. A barcode is unique and cannot be reused if it has already been used
    ///          on a tape. This applies to barcodes used on deleted tapes. This operation is only supported
    ///          in the tape gateway type.</p>
    ///
    ///          <note>
    ///             <p>Cache storage must be allocated to the gateway before you can create a virtual tape.
    ///             Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
    ///          </note>
    public func createTapeWithBarcode(input: CreateTapeWithBarcodeInput, completion: @escaping (SdkResult<CreateTapeWithBarcodeOutputResponse, CreateTapeWithBarcodeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTapeWithBarcode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTapeWithBarcodeInput, CreateTapeWithBarcodeOutputResponse, CreateTapeWithBarcodeOutputError>(id: "createTapeWithBarcode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTapeWithBarcodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTapeWithBarcodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTapeWithBarcodeInput, CreateTapeWithBarcodeOutputResponse, CreateTapeWithBarcodeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTapeWithBarcodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateTapeWithBarcodeInput, CreateTapeWithBarcodeOutputResponse, CreateTapeWithBarcodeOutputError>(xAmzTarget: "StorageGateway_20130630.CreateTapeWithBarcode"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates one or more virtual tapes. You write data to the virtual tapes and then archive
    ///          the tapes. This operation is only supported in the tape gateway type.</p>
    ///
    ///          <note>
    ///             <p>Cache storage must be allocated to the gateway before you can create virtual tapes.
    ///             Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
    ///          </note>
    public func createTapes(input: CreateTapesInput, completion: @escaping (SdkResult<CreateTapesOutputResponse, CreateTapesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTapes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTapesInput, CreateTapesOutputResponse, CreateTapesOutputError>(id: "createTapes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTapesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTapesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTapesInput, CreateTapesOutputResponse, CreateTapesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTapesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateTapesInput, CreateTapesOutputResponse, CreateTapesOutputError>(xAmzTarget: "StorageGateway_20130630.CreateTapes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the automatic tape creation policy of a gateway. If you delete this policy, new
    ///          virtual tapes must be created manually. Use the Amazon Resource Name (ARN) of the gateway
    ///          in your request to remove the policy.</p>
    public func deleteAutomaticTapeCreationPolicy(input: DeleteAutomaticTapeCreationPolicyInput, completion: @escaping (SdkResult<DeleteAutomaticTapeCreationPolicyOutputResponse, DeleteAutomaticTapeCreationPolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAutomaticTapeCreationPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAutomaticTapeCreationPolicyInput, DeleteAutomaticTapeCreationPolicyOutputResponse, DeleteAutomaticTapeCreationPolicyOutputError>(id: "deleteAutomaticTapeCreationPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAutomaticTapeCreationPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAutomaticTapeCreationPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAutomaticTapeCreationPolicyInput, DeleteAutomaticTapeCreationPolicyOutputResponse, DeleteAutomaticTapeCreationPolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteAutomaticTapeCreationPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteAutomaticTapeCreationPolicyInput, DeleteAutomaticTapeCreationPolicyOutputResponse, DeleteAutomaticTapeCreationPolicyOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteAutomaticTapeCreationPolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the bandwidth rate limits of a gateway. You can delete either the upload and
    ///          download bandwidth rate limit, or you can delete both. If you delete only one of the
    ///          limits, the other limit remains unchanged. To specify which gateway to work with, use the
    ///          Amazon Resource Name (ARN) of the gateway in your request. This operation is supported for
    ///          the stored volume, cached volume and tape gateway types.</p>
    public func deleteBandwidthRateLimit(input: DeleteBandwidthRateLimitInput, completion: @escaping (SdkResult<DeleteBandwidthRateLimitOutputResponse, DeleteBandwidthRateLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBandwidthRateLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBandwidthRateLimitInput, DeleteBandwidthRateLimitOutputResponse, DeleteBandwidthRateLimitOutputError>(id: "deleteBandwidthRateLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBandwidthRateLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBandwidthRateLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBandwidthRateLimitInput, DeleteBandwidthRateLimitOutputResponse, DeleteBandwidthRateLimitOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteBandwidthRateLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteBandwidthRateLimitInput, DeleteBandwidthRateLimitOutputResponse, DeleteBandwidthRateLimitOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteBandwidthRateLimit"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes Challenge-Handshake Authentication Protocol (CHAP) credentials for a specified
    ///          iSCSI target and initiator pair. This operation is supported in volume and tape gateway
    ///          types.</p>
    public func deleteChapCredentials(input: DeleteChapCredentialsInput, completion: @escaping (SdkResult<DeleteChapCredentialsOutputResponse, DeleteChapCredentialsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteChapCredentials")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteChapCredentialsInput, DeleteChapCredentialsOutputResponse, DeleteChapCredentialsOutputError>(id: "deleteChapCredentials")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteChapCredentialsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteChapCredentialsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteChapCredentialsInput, DeleteChapCredentialsOutputResponse, DeleteChapCredentialsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteChapCredentialsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteChapCredentialsInput, DeleteChapCredentialsOutputResponse, DeleteChapCredentialsOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteChapCredentials"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a file share from a file gateway. This operation is only supported for file
    ///          gateways.</p>
    public func deleteFileShare(input: DeleteFileShareInput, completion: @escaping (SdkResult<DeleteFileShareOutputResponse, DeleteFileShareOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFileShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFileShareInput, DeleteFileShareOutputResponse, DeleteFileShareOutputError>(id: "deleteFileShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFileShareInput, DeleteFileShareOutputResponse, DeleteFileShareOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteFileShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteFileShareInput, DeleteFileShareOutputResponse, DeleteFileShareOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteFileShare"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a gateway. To specify which gateway to delete, use the Amazon Resource Name
    ///          (ARN) of the gateway in your request. The operation deletes the gateway; however, it does
    ///          not delete the gateway virtual machine (VM) from your host computer.</p>
    ///
    ///          <p>After you delete a gateway, you cannot reactivate it. Completed snapshots of the gateway
    ///          volumes are not deleted upon deleting the gateway, however, pending snapshots will not
    ///          complete. After you delete a gateway, your next step is to remove it from your
    ///          environment.</p>
    ///
    ///          <important>
    ///             <p>You no longer pay software charges after the gateway is deleted; however, your
    ///             existing Amazon EBS snapshots persist and you will continue to be billed for these
    ///             snapshots.Â You can choose to remove all remaining Amazon EBS snapshots by canceling your
    ///             Amazon EC2 subscription.Â  If you prefer not to cancel your Amazon EC2 subscription, you
    ///             can delete your snapshots using the Amazon EC2 console. For more information, see the
    ///                <a href="http://aws.amazon.com/storagegateway">AWS Storage Gateway detail
    ///             page</a>.</p>
    ///          </important>
    public func deleteGateway(input: DeleteGatewayInput, completion: @escaping (SdkResult<DeleteGatewayOutputResponse, DeleteGatewayOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGatewayInput, DeleteGatewayOutputResponse, DeleteGatewayOutputError>(id: "deleteGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteGatewayInput, DeleteGatewayOutputResponse, DeleteGatewayOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteGatewayInput, DeleteGatewayOutputResponse, DeleteGatewayOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteGateway"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a snapshot of a volume.</p>
    ///
    ///          <p>You can take snapshots of your gateway volumes on a scheduled or ad hoc basis. This API
    ///          action enables you to delete a snapshot schedule for a volume. For more information, see
    ///             <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/backing-up-volumes.html">Backing up your
    ///             volumes</a>. In the <code>DeleteSnapshotSchedule</code> request, you identify the
    ///          volume by providing its Amazon Resource Name (ARN). This operation is only supported in
    ///          stored and cached volume gateway types.</p>
    ///
    ///          <note>
    ///
    ///             <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
    ///             go to <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
    ///             in the <i>Amazon Elastic Compute Cloud API Reference</i>.</p>
    ///          </note>
    public func deleteSnapshotSchedule(input: DeleteSnapshotScheduleInput, completion: @escaping (SdkResult<DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSnapshotScheduleInput, DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>(id: "deleteSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSnapshotScheduleInput, DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteSnapshotScheduleInput, DeleteSnapshotScheduleOutputResponse, DeleteSnapshotScheduleOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteSnapshotSchedule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified virtual tape. This operation is only supported in the tape gateway
    ///          type.</p>
    public func deleteTape(input: DeleteTapeInput, completion: @escaping (SdkResult<DeleteTapeOutputResponse, DeleteTapeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTape")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTapeInput, DeleteTapeOutputResponse, DeleteTapeOutputError>(id: "deleteTape")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTapeInput, DeleteTapeOutputResponse, DeleteTapeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteTapeInput, DeleteTapeOutputResponse, DeleteTapeOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteTape"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified virtual tape from the virtual tape shelf (VTS). This operation is
    ///          only supported in the tape gateway type.</p>
    public func deleteTapeArchive(input: DeleteTapeArchiveInput, completion: @escaping (SdkResult<DeleteTapeArchiveOutputResponse, DeleteTapeArchiveOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTapeArchive")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTapeArchiveInput, DeleteTapeArchiveOutputResponse, DeleteTapeArchiveOutputError>(id: "deleteTapeArchive")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeArchiveInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeArchiveInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTapeArchiveInput, DeleteTapeArchiveOutputResponse, DeleteTapeArchiveOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapeArchiveInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteTapeArchiveInput, DeleteTapeArchiveOutputResponse, DeleteTapeArchiveOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteTapeArchive"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete a custom tape pool. A custom tape pool can only be deleted if there are no tapes
    ///          in the pool and if there are no automatic tape creation policies that reference the custom
    ///          tape pool.</p>
    public func deleteTapePool(input: DeleteTapePoolInput, completion: @escaping (SdkResult<DeleteTapePoolOutputResponse, DeleteTapePoolOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTapePool")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTapePoolInput, DeleteTapePoolOutputResponse, DeleteTapePoolOutputError>(id: "deleteTapePool")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapePoolInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapePoolInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTapePoolInput, DeleteTapePoolOutputResponse, DeleteTapePoolOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteTapePoolInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteTapePoolInput, DeleteTapePoolOutputResponse, DeleteTapePoolOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteTapePool"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified storage volume that you previously created using the <a>CreateCachediSCSIVolume</a> or <a>CreateStorediSCSIVolume</a> API.
    ///          This operation is only supported in the cached volume and stored volume types. For stored
    ///          volume gateways, the local disk that was configured as the storage volume is not deleted.
    ///          You can reuse the local disk to create another storage volume.</p>
    ///
    ///          <p>Before you delete a volume, make sure there are no iSCSI connections to the volume you
    ///          are deleting. You should also make sure there is no snapshot in progress. You can use the
    ///          Amazon Elastic Compute Cloud (Amazon EC2) API to query snapshots on the volume you are
    ///          deleting and check the snapshot status. For more information, go to <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
    ///             Reference</i>.</p>
    ///
    ///          <p>In the request, you must provide the Amazon Resource Name (ARN) of the storage volume
    ///          you want to delete.</p>
    public func deleteVolume(input: DeleteVolumeInput, completion: @escaping (SdkResult<DeleteVolumeOutputResponse, DeleteVolumeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVolume")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVolumeInput, DeleteVolumeOutputResponse, DeleteVolumeOutputError>(id: "deleteVolume")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVolumeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVolumeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVolumeInput, DeleteVolumeOutputResponse, DeleteVolumeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteVolumeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DeleteVolumeInput, DeleteVolumeOutputResponse, DeleteVolumeOutputError>(xAmzTarget: "StorageGateway_20130630.DeleteVolume"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the most recent high availability monitoring test that was
    ///          performed on the host in a cluster. If a test isn't performed, the status and start
    ///          time in the response would be null.</p>
    public func describeAvailabilityMonitorTest(input: DescribeAvailabilityMonitorTestInput, completion: @escaping (SdkResult<DescribeAvailabilityMonitorTestOutputResponse, DescribeAvailabilityMonitorTestOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAvailabilityMonitorTest")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAvailabilityMonitorTestInput, DescribeAvailabilityMonitorTestOutputResponse, DescribeAvailabilityMonitorTestOutputError>(id: "describeAvailabilityMonitorTest")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAvailabilityMonitorTestInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAvailabilityMonitorTestInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAvailabilityMonitorTestInput, DescribeAvailabilityMonitorTestOutputResponse, DescribeAvailabilityMonitorTestOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAvailabilityMonitorTestInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAvailabilityMonitorTestInput, DescribeAvailabilityMonitorTestOutputResponse, DescribeAvailabilityMonitorTestOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeAvailabilityMonitorTest"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the bandwidth rate limits of a gateway. By default, these limits are not set,
    ///          which means no bandwidth rate limiting is in effect. This operation is supported for the
    ///          stored volume, cached volume, and tape gateway types.</p>
    ///
    ///          <p>This operation only returns a value for a bandwidth rate limit only if the limit is set.
    ///          If no limits are set for the gateway, then this operation returns only the gateway ARN in
    ///          the response body. To specify which gateway to describe, use the Amazon Resource Name (ARN)
    ///          of the gateway in your request.</p>
    public func describeBandwidthRateLimit(input: DescribeBandwidthRateLimitInput, completion: @escaping (SdkResult<DescribeBandwidthRateLimitOutputResponse, DescribeBandwidthRateLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBandwidthRateLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBandwidthRateLimitInput, DescribeBandwidthRateLimitOutputResponse, DescribeBandwidthRateLimitOutputError>(id: "describeBandwidthRateLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBandwidthRateLimitInput, DescribeBandwidthRateLimitOutputResponse, DescribeBandwidthRateLimitOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeBandwidthRateLimitInput, DescribeBandwidthRateLimitOutputResponse, DescribeBandwidthRateLimitOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeBandwidthRateLimit"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Returns information about the bandwidth rate limit schedule of a gateway. By default, gateways do
    ///          not have bandwidth rate limit schedules, which means no bandwidth rate limiting is in effect. This
    ///          operation is supported only in the volume and tape gateway types.
    ///       </p>
    ///
    ///          <p>This operation returns information about a gateway's bandwidth rate limit schedule. A bandwidth
    ///          rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit
    ///          interval defines a period of time on one or more days of the week, during which bandwidth rate
    ///          limits are specified for uploading, downloading, or both.
    ///       </p>
    ///
    ///          <p>
    ///          A bandwidth rate limit interval consists of one or more days of the week, a start hour and minute,
    ///          an ending hour and minute, and bandwidth rate limits for uploading and downloading
    ///       </p>
    ///
    ///          <p>
    ///          If no bandwidth rate limit schedule intervals are set for the gateway, this operation returns an
    ///          empty response. To specify which gateway to describe, use the Amazon Resource Name (ARN)
    ///          of the gateway in your request.</p>
    public func describeBandwidthRateLimitSchedule(input: DescribeBandwidthRateLimitScheduleInput, completion: @escaping (SdkResult<DescribeBandwidthRateLimitScheduleOutputResponse, DescribeBandwidthRateLimitScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeBandwidthRateLimitSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeBandwidthRateLimitScheduleInput, DescribeBandwidthRateLimitScheduleOutputResponse, DescribeBandwidthRateLimitScheduleOutputError>(id: "describeBandwidthRateLimitSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeBandwidthRateLimitScheduleInput, DescribeBandwidthRateLimitScheduleOutputResponse, DescribeBandwidthRateLimitScheduleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeBandwidthRateLimitScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeBandwidthRateLimitScheduleInput, DescribeBandwidthRateLimitScheduleOutputResponse, DescribeBandwidthRateLimitScheduleOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeBandwidthRateLimitSchedule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the cache of a gateway. This operation is only supported in
    ///          the cached volume, tape, and file gateway types.</p>
    ///
    ///          <p>The response includes disk IDs that are configured as cache, and it includes the amount
    ///          of cache allocated and used.</p>
    public func describeCache(input: DescribeCacheInput, completion: @escaping (SdkResult<DescribeCacheOutputResponse, DescribeCacheOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCacheInput, DescribeCacheOutputResponse, DescribeCacheOutputError>(id: "describeCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCacheInput, DescribeCacheOutputResponse, DescribeCacheOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeCacheInput, DescribeCacheOutputResponse, DescribeCacheOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeCache"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a description of the gateway volumes specified in the request. This operation is
    ///          only supported in the cached volume gateway types.</p>
    ///
    ///          <p>The list of gateway volumes in the request must be from one gateway. In the response,
    ///          AWS Storage Gateway returns volume information sorted by volume Amazon Resource Name
    ///          (ARN).</p>
    public func describeCachediSCSIVolumes(input: DescribeCachediSCSIVolumesInput, completion: @escaping (SdkResult<DescribeCachediSCSIVolumesOutputResponse, DescribeCachediSCSIVolumesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCachediSCSIVolumes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCachediSCSIVolumesInput, DescribeCachediSCSIVolumesOutputResponse, DescribeCachediSCSIVolumesOutputError>(id: "describeCachediSCSIVolumes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCachediSCSIVolumesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCachediSCSIVolumesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCachediSCSIVolumesInput, DescribeCachediSCSIVolumesOutputResponse, DescribeCachediSCSIVolumesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeCachediSCSIVolumesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeCachediSCSIVolumesInput, DescribeCachediSCSIVolumesOutputResponse, DescribeCachediSCSIVolumesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeCachediSCSIVolumes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of Challenge-Handshake Authentication Protocol (CHAP) credentials
    ///          information for a specified iSCSI target, one for each target-initiator pair. This
    ///          operation is supported in the volume and tape gateway types.</p>
    public func describeChapCredentials(input: DescribeChapCredentialsInput, completion: @escaping (SdkResult<DescribeChapCredentialsOutputResponse, DescribeChapCredentialsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeChapCredentials")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeChapCredentialsInput, DescribeChapCredentialsOutputResponse, DescribeChapCredentialsOutputError>(id: "describeChapCredentials")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeChapCredentialsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeChapCredentialsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeChapCredentialsInput, DescribeChapCredentialsOutputResponse, DescribeChapCredentialsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeChapCredentialsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeChapCredentialsInput, DescribeChapCredentialsOutputResponse, DescribeChapCredentialsOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeChapCredentials"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the file system association information. This operation is only supported for
    ///          Amazon FSx file gateways.</p>
    public func describeFileSystemAssociations(input: DescribeFileSystemAssociationsInput, completion: @escaping (SdkResult<DescribeFileSystemAssociationsOutputResponse, DescribeFileSystemAssociationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFileSystemAssociations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFileSystemAssociationsInput, DescribeFileSystemAssociationsOutputResponse, DescribeFileSystemAssociationsOutputError>(id: "describeFileSystemAssociations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAssociationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAssociationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFileSystemAssociationsInput, DescribeFileSystemAssociationsOutputResponse, DescribeFileSystemAssociationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeFileSystemAssociationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeFileSystemAssociationsInput, DescribeFileSystemAssociationsOutputResponse, DescribeFileSystemAssociationsOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeFileSystemAssociations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns metadata about a gateway such as its name, network interfaces, configured time
    ///          zone, and the state (whether the gateway is running or not). To specify which gateway to
    ///          describe, use the Amazon Resource Name (ARN) of the gateway in your request.</p>
    public func describeGatewayInformation(input: DescribeGatewayInformationInput, completion: @escaping (SdkResult<DescribeGatewayInformationOutputResponse, DescribeGatewayInformationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeGatewayInformation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeGatewayInformationInput, DescribeGatewayInformationOutputResponse, DescribeGatewayInformationOutputError>(id: "describeGatewayInformation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayInformationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayInformationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeGatewayInformationInput, DescribeGatewayInformationOutputResponse, DescribeGatewayInformationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayInformationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeGatewayInformationInput, DescribeGatewayInformationOutputResponse, DescribeGatewayInformationOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeGatewayInformation"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns your gateway's weekly maintenance start time including the day and time of
    ///          the week. Note that values are in terms of the gateway's time zone.</p>
    public func describeMaintenanceStartTime(input: DescribeMaintenanceStartTimeInput, completion: @escaping (SdkResult<DescribeMaintenanceStartTimeOutputResponse, DescribeMaintenanceStartTimeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMaintenanceStartTime")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMaintenanceStartTimeInput, DescribeMaintenanceStartTimeOutputResponse, DescribeMaintenanceStartTimeOutputError>(id: "describeMaintenanceStartTime")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMaintenanceStartTimeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMaintenanceStartTimeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMaintenanceStartTimeInput, DescribeMaintenanceStartTimeOutputResponse, DescribeMaintenanceStartTimeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeMaintenanceStartTimeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeMaintenanceStartTimeInput, DescribeMaintenanceStartTimeOutputResponse, DescribeMaintenanceStartTimeOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeMaintenanceStartTime"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a description for one or more Network File System (NFS) file shares from a file
    ///          gateway. This operation is only supported for file gateways.</p>
    public func describeNFSFileShares(input: DescribeNFSFileSharesInput, completion: @escaping (SdkResult<DescribeNFSFileSharesOutputResponse, DescribeNFSFileSharesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeNFSFileShares")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeNFSFileSharesInput, DescribeNFSFileSharesOutputResponse, DescribeNFSFileSharesOutputError>(id: "describeNFSFileShares")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeNFSFileSharesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeNFSFileSharesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeNFSFileSharesInput, DescribeNFSFileSharesOutputResponse, DescribeNFSFileSharesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeNFSFileSharesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeNFSFileSharesInput, DescribeNFSFileSharesOutputResponse, DescribeNFSFileSharesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeNFSFileShares"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a description for one or more Server Message Block (SMB) file shares from a file
    ///          gateway. This operation is only supported for file gateways.</p>
    public func describeSMBFileShares(input: DescribeSMBFileSharesInput, completion: @escaping (SdkResult<DescribeSMBFileSharesOutputResponse, DescribeSMBFileSharesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSMBFileShares")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSMBFileSharesInput, DescribeSMBFileSharesOutputResponse, DescribeSMBFileSharesOutputError>(id: "describeSMBFileShares")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBFileSharesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBFileSharesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSMBFileSharesInput, DescribeSMBFileSharesOutputResponse, DescribeSMBFileSharesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBFileSharesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeSMBFileSharesInput, DescribeSMBFileSharesOutputResponse, DescribeSMBFileSharesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeSMBFileShares"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a description of a Server Message Block (SMB) file share settings from a file
    ///          gateway. This operation is only supported for file gateways.</p>
    public func describeSMBSettings(input: DescribeSMBSettingsInput, completion: @escaping (SdkResult<DescribeSMBSettingsOutputResponse, DescribeSMBSettingsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSMBSettings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSMBSettingsInput, DescribeSMBSettingsOutputResponse, DescribeSMBSettingsOutputError>(id: "describeSMBSettings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBSettingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBSettingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSMBSettingsInput, DescribeSMBSettingsOutputResponse, DescribeSMBSettingsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSMBSettingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeSMBSettingsInput, DescribeSMBSettingsOutputResponse, DescribeSMBSettingsOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeSMBSettings"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the snapshot schedule for the specified gateway volume. The snapshot schedule
    ///          information includes intervals at which snapshots are automatically initiated on the
    ///          volume. This operation is only supported in the cached volume and stored volume
    ///          types.</p>
    public func describeSnapshotSchedule(input: DescribeSnapshotScheduleInput, completion: @escaping (SdkResult<DescribeSnapshotScheduleOutputResponse, DescribeSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeSnapshotScheduleInput, DescribeSnapshotScheduleOutputResponse, DescribeSnapshotScheduleOutputError>(id: "describeSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeSnapshotScheduleInput, DescribeSnapshotScheduleOutputResponse, DescribeSnapshotScheduleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeSnapshotScheduleInput, DescribeSnapshotScheduleOutputResponse, DescribeSnapshotScheduleOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeSnapshotSchedule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the description of the gateway volumes specified in the request. The list of
    ///          gateway volumes in the request must be from one gateway. In the response, AWS Storage
    ///          Gateway returns volume information sorted by volume ARNs. This operation is only supported
    ///          in stored volume gateway type.</p>
    public func describeStorediSCSIVolumes(input: DescribeStorediSCSIVolumesInput, completion: @escaping (SdkResult<DescribeStorediSCSIVolumesOutputResponse, DescribeStorediSCSIVolumesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeStorediSCSIVolumes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeStorediSCSIVolumesInput, DescribeStorediSCSIVolumesOutputResponse, DescribeStorediSCSIVolumesOutputError>(id: "describeStorediSCSIVolumes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeStorediSCSIVolumesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeStorediSCSIVolumesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeStorediSCSIVolumesInput, DescribeStorediSCSIVolumesOutputResponse, DescribeStorediSCSIVolumesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeStorediSCSIVolumesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeStorediSCSIVolumesInput, DescribeStorediSCSIVolumesOutputResponse, DescribeStorediSCSIVolumesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeStorediSCSIVolumes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a description of specified virtual tapes in the virtual tape shelf (VTS). This
    ///          operation is only supported in the tape gateway type.</p>
    ///
    ///          <p>If a specific <code>TapeARN</code> is not specified, AWS Storage Gateway returns a
    ///          description of all virtual tapes found in the VTS associated with your account.</p>
    public func describeTapeArchives(input: DescribeTapeArchivesInput, completion: @escaping (SdkResult<DescribeTapeArchivesOutputResponse, DescribeTapeArchivesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTapeArchives")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTapeArchivesInput, DescribeTapeArchivesOutputResponse, DescribeTapeArchivesOutputError>(id: "describeTapeArchives")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeArchivesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeArchivesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTapeArchivesInput, DescribeTapeArchivesOutputResponse, DescribeTapeArchivesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeArchivesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTapeArchivesInput, DescribeTapeArchivesOutputResponse, DescribeTapeArchivesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeTapeArchives"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of virtual tape recovery points that are available for the specified tape
    ///          gateway.</p>
    ///
    ///          <p>A recovery point is a point-in-time view of a virtual tape at which all the data on the
    ///          virtual tape is consistent. If your gateway crashes, virtual tapes that have recovery
    ///          points can be recovered to a new gateway. This operation is only supported in the tape
    ///          gateway type.</p>
    public func describeTapeRecoveryPoints(input: DescribeTapeRecoveryPointsInput, completion: @escaping (SdkResult<DescribeTapeRecoveryPointsOutputResponse, DescribeTapeRecoveryPointsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTapeRecoveryPoints")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTapeRecoveryPointsInput, DescribeTapeRecoveryPointsOutputResponse, DescribeTapeRecoveryPointsOutputError>(id: "describeTapeRecoveryPoints")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeRecoveryPointsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeRecoveryPointsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTapeRecoveryPointsInput, DescribeTapeRecoveryPointsOutputResponse, DescribeTapeRecoveryPointsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapeRecoveryPointsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTapeRecoveryPointsInput, DescribeTapeRecoveryPointsOutputResponse, DescribeTapeRecoveryPointsOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeTapeRecoveryPoints"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a description of the specified Amazon Resource Name (ARN) of virtual tapes. If a
    ///             <code>TapeARN</code> is not specified, returns a description of all virtual tapes
    ///          associated with the specified gateway. This operation is only supported in the tape gateway
    ///          type.</p>
    public func describeTapes(input: DescribeTapesInput, completion: @escaping (SdkResult<DescribeTapesOutputResponse, DescribeTapesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeTapes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeTapesInput, DescribeTapesOutputResponse, DescribeTapesOutputError>(id: "describeTapes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeTapesInput, DescribeTapesOutputResponse, DescribeTapesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeTapesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeTapesInput, DescribeTapesOutputResponse, DescribeTapesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeTapes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the upload buffer of a gateway. This operation is supported
    ///          for the stored volume, cached volume, and tape gateway types.</p>
    ///
    ///          <p>The response includes disk IDs that are configured as upload buffer space, and it
    ///          includes the amount of upload buffer space allocated and used.</p>
    public func describeUploadBuffer(input: DescribeUploadBufferInput, completion: @escaping (SdkResult<DescribeUploadBufferOutputResponse, DescribeUploadBufferOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUploadBuffer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUploadBufferInput, DescribeUploadBufferOutputResponse, DescribeUploadBufferOutputError>(id: "describeUploadBuffer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUploadBufferInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUploadBufferInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUploadBufferInput, DescribeUploadBufferOutputResponse, DescribeUploadBufferOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeUploadBufferInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeUploadBufferInput, DescribeUploadBufferOutputResponse, DescribeUploadBufferOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeUploadBuffer"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a description of virtual tape library (VTL) devices for the specified tape
    ///          gateway. In the response, AWS Storage Gateway returns VTL device information.</p>
    ///
    ///          <p>This operation is only supported in the tape gateway type.</p>
    public func describeVTLDevices(input: DescribeVTLDevicesInput, completion: @escaping (SdkResult<DescribeVTLDevicesOutputResponse, DescribeVTLDevicesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVTLDevices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVTLDevicesInput, DescribeVTLDevicesOutputResponse, DescribeVTLDevicesOutputError>(id: "describeVTLDevices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVTLDevicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVTLDevicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeVTLDevicesInput, DescribeVTLDevicesOutputResponse, DescribeVTLDevicesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeVTLDevicesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeVTLDevicesInput, DescribeVTLDevicesOutputResponse, DescribeVTLDevicesOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeVTLDevices"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the working storage of a gateway. This operation is only
    ///          supported in the stored volumes gateway type. This operation is deprecated in cached
    ///          volumes API version (20120630). Use DescribeUploadBuffer instead.</p>
    ///
    ///          <note>
    ///             <p>Working storage is also referred to as upload buffer. You can also use the
    ///             DescribeUploadBuffer operation to add upload buffer to a stored volume gateway.</p>
    ///          </note>
    ///
    ///          <p>The response includes disk IDs that are configured as working storage, and it includes
    ///          the amount of working storage allocated and used.</p>
    public func describeWorkingStorage(input: DescribeWorkingStorageInput, completion: @escaping (SdkResult<DescribeWorkingStorageOutputResponse, DescribeWorkingStorageOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeWorkingStorage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeWorkingStorageInput, DescribeWorkingStorageOutputResponse, DescribeWorkingStorageOutputError>(id: "describeWorkingStorage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeWorkingStorageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeWorkingStorageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeWorkingStorageInput, DescribeWorkingStorageOutputResponse, DescribeWorkingStorageOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeWorkingStorageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeWorkingStorageInput, DescribeWorkingStorageOutputResponse, DescribeWorkingStorageOutputError>(xAmzTarget: "StorageGateway_20130630.DescribeWorkingStorage"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disconnects a volume from an iSCSI connection and then detaches the volume from the
    ///          specified gateway. Detaching and attaching a volume enables you to recover your data from
    ///          one gateway to a different gateway without creating a snapshot. It also makes it easier to
    ///          move your volumes from an on-premises gateway to a gateway hosted on an Amazon EC2
    ///          instance. This operation is only supported in the volume gateway type.</p>
    public func detachVolume(input: DetachVolumeInput, completion: @escaping (SdkResult<DetachVolumeOutputResponse, DetachVolumeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "detachVolume")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DetachVolumeInput, DetachVolumeOutputResponse, DetachVolumeOutputError>(id: "detachVolume")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DetachVolumeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DetachVolumeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DetachVolumeInput, DetachVolumeOutputResponse, DetachVolumeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DetachVolumeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DetachVolumeInput, DetachVolumeOutputResponse, DetachVolumeOutputError>(xAmzTarget: "StorageGateway_20130630.DetachVolume"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables a tape gateway when the gateway is no longer functioning. For example, if your
    ///          gateway VM is damaged, you can disable the gateway so you can recover virtual tapes.</p>
    ///
    ///          <p>Use this operation for a tape gateway that is not reachable or not functioning. This
    ///          operation is only supported in the tape gateway type.</p>
    ///
    ///          <important>
    ///             <p>After a gateway is disabled, it cannot be enabled.</p>
    ///          </important>
    public func disableGateway(input: DisableGatewayInput, completion: @escaping (SdkResult<DisableGatewayOutputResponse, DisableGatewayOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisableGatewayInput, DisableGatewayOutputResponse, DisableGatewayOutputError>(id: "disableGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisableGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisableGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisableGatewayInput, DisableGatewayOutputResponse, DisableGatewayOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DisableGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DisableGatewayInput, DisableGatewayOutputResponse, DisableGatewayOutputError>(xAmzTarget: "StorageGateway_20130630.DisableGateway"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disassociates an Amazon FSx file system from the specified gateway. After the
    ///          disassociation process finishes, the gateway can no longer access the Amazon FSx file
    ///          system. This operation is only supported in the Amazon FSx file gateway type.</p>
    public func disassociateFileSystem(input: DisassociateFileSystemInput, completion: @escaping (SdkResult<DisassociateFileSystemOutputResponse, DisassociateFileSystemOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateFileSystem")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DisassociateFileSystemInput, DisassociateFileSystemOutputResponse, DisassociateFileSystemOutputError>(id: "disassociateFileSystem")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DisassociateFileSystemInput, DisassociateFileSystemOutputResponse, DisassociateFileSystemOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DisassociateFileSystemInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DisassociateFileSystemInput, DisassociateFileSystemOutputResponse, DisassociateFileSystemOutputError>(xAmzTarget: "StorageGateway_20130630.DisassociateFileSystem"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a file gateway to an Active Directory domain. This operation is only supported for
    ///          file gateways that support the SMB file protocol.</p>
    public func joinDomain(input: JoinDomainInput, completion: @escaping (SdkResult<JoinDomainOutputResponse, JoinDomainOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "joinDomain")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<JoinDomainInput, JoinDomainOutputResponse, JoinDomainOutputError>(id: "joinDomain")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: JoinDomainInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: JoinDomainInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<JoinDomainInput, JoinDomainOutputResponse, JoinDomainOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: JoinDomainInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<JoinDomainInput, JoinDomainOutputResponse, JoinDomainOutputError>(xAmzTarget: "StorageGateway_20130630.JoinDomain"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the automatic tape creation policies for a gateway. If there are no automatic tape
    ///          creation policies for the gateway, it returns an empty list.</p>
    ///
    ///          <p>This operation is only supported for tape gateways.</p>
    public func listAutomaticTapeCreationPolicies(input: ListAutomaticTapeCreationPoliciesInput, completion: @escaping (SdkResult<ListAutomaticTapeCreationPoliciesOutputResponse, ListAutomaticTapeCreationPoliciesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAutomaticTapeCreationPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAutomaticTapeCreationPoliciesInput, ListAutomaticTapeCreationPoliciesOutputResponse, ListAutomaticTapeCreationPoliciesOutputError>(id: "listAutomaticTapeCreationPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAutomaticTapeCreationPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAutomaticTapeCreationPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAutomaticTapeCreationPoliciesInput, ListAutomaticTapeCreationPoliciesOutputResponse, ListAutomaticTapeCreationPoliciesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListAutomaticTapeCreationPoliciesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListAutomaticTapeCreationPoliciesInput, ListAutomaticTapeCreationPoliciesOutputResponse, ListAutomaticTapeCreationPoliciesOutputError>(xAmzTarget: "StorageGateway_20130630.ListAutomaticTapeCreationPolicies"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of the file shares for a specific file gateway, or the list of file shares
    ///          that belong to the calling user account. This operation is only supported for file
    ///          gateways.</p>
    public func listFileShares(input: ListFileSharesInput, completion: @escaping (SdkResult<ListFileSharesOutputResponse, ListFileSharesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFileShares")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFileSharesInput, ListFileSharesOutputResponse, ListFileSharesOutputError>(id: "listFileShares")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFileSharesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFileSharesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFileSharesInput, ListFileSharesOutputResponse, ListFileSharesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListFileSharesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListFileSharesInput, ListFileSharesOutputResponse, ListFileSharesOutputError>(xAmzTarget: "StorageGateway_20130630.ListFileShares"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of <code>FileSystemAssociationSummary</code> objects. Each object contains a
    ///          summary of a file system association. This operation is only supported for Amazon FSx file
    ///          gateways.</p>
    public func listFileSystemAssociations(input: ListFileSystemAssociationsInput, completion: @escaping (SdkResult<ListFileSystemAssociationsOutputResponse, ListFileSystemAssociationsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFileSystemAssociations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFileSystemAssociationsInput, ListFileSystemAssociationsOutputResponse, ListFileSystemAssociationsOutputError>(id: "listFileSystemAssociations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFileSystemAssociationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFileSystemAssociationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFileSystemAssociationsInput, ListFileSystemAssociationsOutputResponse, ListFileSystemAssociationsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListFileSystemAssociationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListFileSystemAssociationsInput, ListFileSystemAssociationsOutputResponse, ListFileSystemAssociationsOutputError>(xAmzTarget: "StorageGateway_20130630.ListFileSystemAssociations"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists gateways owned by an AWS account in an AWS Region specified in the request. The
    ///          returned list is ordered by gateway Amazon Resource Name (ARN).</p>
    ///
    ///          <p>By default, the operation returns a maximum of 100 gateways. This operation supports
    ///          pagination that allows you to optionally reduce the number of gateways returned in a
    ///          response.</p>
    ///
    ///          <p>If you have more gateways than are returned in a response (that is, the response returns
    ///          only a truncated list of your gateways), the response contains a marker that you can
    ///          specify in your next request to fetch the next page of gateways.</p>
    public func listGateways(input: ListGatewaysInput, completion: @escaping (SdkResult<ListGatewaysOutputResponse, ListGatewaysOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGateways")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGatewaysInput, ListGatewaysOutputResponse, ListGatewaysOutputError>(id: "listGateways")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGatewaysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGatewaysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGatewaysInput, ListGatewaysOutputResponse, ListGatewaysOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListGatewaysInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListGatewaysInput, ListGatewaysOutputResponse, ListGatewaysOutputError>(xAmzTarget: "StorageGateway_20130630.ListGateways"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of the gateway's local disks. To specify which gateway to describe,
    ///          you use the Amazon Resource Name (ARN) of the gateway in the body of the request.</p>
    ///
    ///          <p>The request returns a list of all disks, specifying which are configured as working
    ///          storage, cache storage, or stored volume or not configured at all. The response includes a
    ///             <code>DiskStatus</code> field. This field can have a value of present (the disk is
    ///          available to use), missing (the disk is no longer connected to the gateway), or mismatch
    ///          (the disk node is occupied by a disk that has incorrect metadata or the disk content is
    ///          corrupted).</p>
    public func listLocalDisks(input: ListLocalDisksInput, completion: @escaping (SdkResult<ListLocalDisksOutputResponse, ListLocalDisksOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLocalDisks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLocalDisksInput, ListLocalDisksOutputResponse, ListLocalDisksOutputError>(id: "listLocalDisks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLocalDisksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLocalDisksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLocalDisksInput, ListLocalDisksOutputResponse, ListLocalDisksOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListLocalDisksInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListLocalDisksInput, ListLocalDisksOutputResponse, ListLocalDisksOutputError>(xAmzTarget: "StorageGateway_20130630.ListLocalDisks"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags that have been added to the specified resource. This operation is
    ///          supported in storage gateways of all types.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(xAmzTarget: "StorageGateway_20130630.ListTagsForResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists custom tape pools. You specify custom tape pools to list by specifying one or more
    ///          custom tape pool Amazon Resource Names (ARNs). If you don't specify a custom tape pool ARN,
    ///          the operation lists all custom tape pools.</p>
    ///
    ///          <p>This operation supports pagination. You can optionally specify the <code>Limit</code>
    ///          parameter in the body to limit the number of tape pools in the response. If the number of
    ///          tape pools returned in the response is truncated, the response includes a
    ///             <code>Marker</code> element that you can use in your subsequent request to retrieve the
    ///          next set of tape pools.</p>
    public func listTapePools(input: ListTapePoolsInput, completion: @escaping (SdkResult<ListTapePoolsOutputResponse, ListTapePoolsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTapePools")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTapePoolsInput, ListTapePoolsOutputResponse, ListTapePoolsOutputError>(id: "listTapePools")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTapePoolsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTapePoolsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTapePoolsInput, ListTapePoolsOutputResponse, ListTapePoolsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTapePoolsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTapePoolsInput, ListTapePoolsOutputResponse, ListTapePoolsOutputError>(xAmzTarget: "StorageGateway_20130630.ListTapePools"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists virtual tapes in your virtual tape library (VTL) and your virtual tape shelf
    ///          (VTS). You specify the tapes to list by specifying one or more tape Amazon Resource Names
    ///          (ARNs). If you don't specify a tape ARN, the operation lists all virtual tapes in both
    ///          your VTL and VTS.</p>
    ///
    ///          <p>This operation supports pagination. By default, the operation returns a maximum of up to
    ///          100 tapes. You can optionally specify the <code>Limit</code> parameter in the body to limit
    ///          the number of tapes in the response. If the number of tapes returned in the response is
    ///          truncated, the response includes a <code>Marker</code> element that you can use in your
    ///          subsequent request to retrieve the next set of tapes. This operation is only supported in
    ///          the tape gateway type.</p>
    public func listTapes(input: ListTapesInput, completion: @escaping (SdkResult<ListTapesOutputResponse, ListTapesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTapes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTapesInput, ListTapesOutputResponse, ListTapesOutputError>(id: "listTapes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTapesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTapesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTapesInput, ListTapesOutputResponse, ListTapesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListTapesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListTapesInput, ListTapesOutputResponse, ListTapesOutputError>(xAmzTarget: "StorageGateway_20130630.ListTapes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists iSCSI initiators that are connected to a volume. You can use this operation to
    ///          determine whether a volume is being used or not. This operation is only supported in the
    ///          cached volume and stored volume gateway types.</p>
    public func listVolumeInitiators(input: ListVolumeInitiatorsInput, completion: @escaping (SdkResult<ListVolumeInitiatorsOutputResponse, ListVolumeInitiatorsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVolumeInitiators")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVolumeInitiatorsInput, ListVolumeInitiatorsOutputResponse, ListVolumeInitiatorsOutputError>(id: "listVolumeInitiators")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeInitiatorsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeInitiatorsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVolumeInitiatorsInput, ListVolumeInitiatorsOutputResponse, ListVolumeInitiatorsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeInitiatorsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListVolumeInitiatorsInput, ListVolumeInitiatorsOutputResponse, ListVolumeInitiatorsOutputError>(xAmzTarget: "StorageGateway_20130630.ListVolumeInitiators"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the recovery points for a specified gateway. This operation is only supported in
    ///          the cached volume gateway type.</p>
    ///
    ///          <p>Each cache volume has one recovery point. A volume recovery point is a point in time at
    ///          which all data of the volume is consistent and from which you can create a snapshot or
    ///          clone a new cached volume from a source volume. To create a snapshot from a volume recovery
    ///          point use the <a>CreateSnapshotFromVolumeRecoveryPoint</a> operation.</p>
    public func listVolumeRecoveryPoints(input: ListVolumeRecoveryPointsInput, completion: @escaping (SdkResult<ListVolumeRecoveryPointsOutputResponse, ListVolumeRecoveryPointsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVolumeRecoveryPoints")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVolumeRecoveryPointsInput, ListVolumeRecoveryPointsOutputResponse, ListVolumeRecoveryPointsOutputError>(id: "listVolumeRecoveryPoints")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeRecoveryPointsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeRecoveryPointsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVolumeRecoveryPointsInput, ListVolumeRecoveryPointsOutputResponse, ListVolumeRecoveryPointsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListVolumeRecoveryPointsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListVolumeRecoveryPointsInput, ListVolumeRecoveryPointsOutputResponse, ListVolumeRecoveryPointsOutputError>(xAmzTarget: "StorageGateway_20130630.ListVolumeRecoveryPoints"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the iSCSI stored volumes of a gateway. Results are sorted by volume ARN. The
    ///          response includes only the volume ARNs. If you want additional volume information, use the
    ///             <a>DescribeStorediSCSIVolumes</a> or the <a>DescribeCachediSCSIVolumes</a> API.</p>
    ///
    ///          <p>The operation supports pagination. By default, the operation returns a maximum of up to
    ///          100 volumes. You can optionally specify the <code>Limit</code> field in the body to limit
    ///          the number of volumes in the response. If the number of volumes returned in the response is
    ///          truncated, the response includes a Marker field. You can use this Marker value in your
    ///          subsequent request to retrieve the next set of volumes. This operation is only supported in
    ///          the cached volume and stored volume gateway types.</p>
    public func listVolumes(input: ListVolumesInput, completion: @escaping (SdkResult<ListVolumesOutputResponse, ListVolumesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVolumes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVolumesInput, ListVolumesOutputResponse, ListVolumesOutputError>(id: "listVolumes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVolumesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVolumesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVolumesInput, ListVolumesOutputResponse, ListVolumesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListVolumesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListVolumesInput, ListVolumesOutputResponse, ListVolumesOutputError>(xAmzTarget: "StorageGateway_20130630.ListVolumes"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sends you notification through CloudWatch Events when all files written to your file
    ///          share have been uploaded to Amazon S3.</p>
    ///
    ///          <p>AWS Storage Gateway can send a notification through Amazon CloudWatch Events when all
    ///          files written to your file share up to that point in time have been uploaded to Amazon S3.
    ///          These files include files written to the file share up to the time that you make a request
    ///          for notification. When the upload is done, Storage Gateway sends you notification through
    ///          an Amazon CloudWatch Event. You can configure CloudWatch Events to send the notification
    ///          through event targets such as Amazon SNS or AWS Lambda function. This operation is only
    ///          supported for file gateways.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-upload-notification">Getting file upload notification</a> in the <i>AWS Storage Gateway User
    ///             Guide</i>.</p>
    public func notifyWhenUploaded(input: NotifyWhenUploadedInput, completion: @escaping (SdkResult<NotifyWhenUploadedOutputResponse, NotifyWhenUploadedOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "notifyWhenUploaded")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<NotifyWhenUploadedInput, NotifyWhenUploadedOutputResponse, NotifyWhenUploadedOutputError>(id: "notifyWhenUploaded")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: NotifyWhenUploadedInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: NotifyWhenUploadedInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<NotifyWhenUploadedInput, NotifyWhenUploadedOutputResponse, NotifyWhenUploadedOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: NotifyWhenUploadedInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<NotifyWhenUploadedInput, NotifyWhenUploadedOutputResponse, NotifyWhenUploadedOutputError>(xAmzTarget: "StorageGateway_20130630.NotifyWhenUploaded"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Refreshes the cached inventory of objects for the specified file share. This operation
    ///          finds objects in the Amazon S3 bucket that were added, removed, or replaced since the
    ///          gateway last listed the bucket's contents and cached the results. This operation does
    ///          not import files into the file gateway cache storage. It only updates the cached inventory
    ///          to reflect changes in the inventory of the objects in the S3 bucket. This operation is only
    ///          supported in the file gateway type. You can subscribe to be notified through an Amazon
    ///          CloudWatch event when your <code>RefreshCache</code> operation completes. For more
    ///          information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>AWS Storage Gateway
    ///             User Guide</i>.</p>
    ///
    ///          <p>When this API is called, it only initiates the refresh operation. When the API call
    ///          completes and returns a success code, it doesn't necessarily mean that the file
    ///          refresh has completed. You should use the refresh-complete notification to determine that
    ///          the operation has completed before you check for new files on the gateway file share. You
    ///          can subscribe to be notified through a CloudWatch event when your <code>RefreshCache</code>
    ///          operation completes.</p>
    ///
    ///          <p>Throttle limit: This API is asynchronous, so the gateway will accept no more than two
    ///          refreshes at any time. We recommend using the refresh-complete CloudWatch event
    ///          notification before issuing additional requests. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>AWS Storage Gateway
    ///             User Guide</i>.</p>
    ///
    ///          <p>If you invoke the RefreshCache API when two requests are already being processed, any
    ///          new request will cause an <code>InvalidGatewayRequestException</code> error because too
    ///          many requests were sent to the server.</p>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>AWS Storage Gateway
    ///             User Guide</i>.</p>
    public func refreshCache(input: RefreshCacheInput, completion: @escaping (SdkResult<RefreshCacheOutputResponse, RefreshCacheOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "refreshCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RefreshCacheInput, RefreshCacheOutputResponse, RefreshCacheOutputError>(id: "refreshCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RefreshCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RefreshCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RefreshCacheInput, RefreshCacheOutputResponse, RefreshCacheOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RefreshCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RefreshCacheInput, RefreshCacheOutputResponse, RefreshCacheOutputError>(xAmzTarget: "StorageGateway_20130630.RefreshCache"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes one or more tags from the specified resource. This operation is supported in
    ///          storage gateways of all types.</p>
    public func removeTagsFromResource(input: RemoveTagsFromResourceInput, completion: @escaping (SdkResult<RemoveTagsFromResourceOutputResponse, RemoveTagsFromResourceOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeTagsFromResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveTagsFromResourceInput, RemoveTagsFromResourceOutputResponse, RemoveTagsFromResourceOutputError>(id: "removeTagsFromResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsFromResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsFromResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveTagsFromResourceInput, RemoveTagsFromResourceOutputResponse, RemoveTagsFromResourceOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RemoveTagsFromResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RemoveTagsFromResourceInput, RemoveTagsFromResourceOutputResponse, RemoveTagsFromResourceOutputError>(xAmzTarget: "StorageGateway_20130630.RemoveTagsFromResource"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Resets all cache disks that have encountered an error and makes the disks available for
    ///          reconfiguration as cache storage. If your cache disk encounters an error, the gateway
    ///          prevents read and write operations on virtual tapes in the gateway. For example, an error
    ///          can occur when a disk is corrupted or removed from the gateway. When a cache is reset, the
    ///          gateway loses its cache storage. At this point, you can reconfigure the disks as cache
    ///          disks. This operation is only supported in the cached volume and tape types.</p>
    ///
    ///          <important>
    ///             <p>If the cache disk you are resetting contains data that has not been uploaded to
    ///             Amazon S3 yet, that data can be lost. After you reset cache disks, there will be no
    ///             configured cache disks left in the gateway, so you must configure at least one new cache
    ///             disk for your gateway to function properly.</p>
    ///          </important>
    public func resetCache(input: ResetCacheInput, completion: @escaping (SdkResult<ResetCacheOutputResponse, ResetCacheOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "resetCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ResetCacheInput, ResetCacheOutputResponse, ResetCacheOutputError>(id: "resetCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ResetCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ResetCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ResetCacheInput, ResetCacheOutputResponse, ResetCacheOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ResetCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ResetCacheInput, ResetCacheOutputResponse, ResetCacheOutputError>(xAmzTarget: "StorageGateway_20130630.ResetCache"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves an archived virtual tape from the virtual tape shelf (VTS) to a tape gateway.
    ///          Virtual tapes archived in the VTS are not associated with any gateway. However after a tape
    ///          is retrieved, it is associated with a gateway, even though it is also listed in the VTS,
    ///          that is, archive. This operation is only supported in the tape gateway type.</p>
    ///
    ///          <p>Once a tape is successfully retrieved to a gateway, it cannot be retrieved again to
    ///          another gateway. You must archive the tape again before you can retrieve it to another
    ///          gateway. This operation is only supported in the tape gateway type.</p>
    public func retrieveTapeArchive(input: RetrieveTapeArchiveInput, completion: @escaping (SdkResult<RetrieveTapeArchiveOutputResponse, RetrieveTapeArchiveOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "retrieveTapeArchive")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RetrieveTapeArchiveInput, RetrieveTapeArchiveOutputResponse, RetrieveTapeArchiveOutputError>(id: "retrieveTapeArchive")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeArchiveInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeArchiveInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RetrieveTapeArchiveInput, RetrieveTapeArchiveOutputResponse, RetrieveTapeArchiveOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeArchiveInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RetrieveTapeArchiveInput, RetrieveTapeArchiveOutputResponse, RetrieveTapeArchiveOutputError>(xAmzTarget: "StorageGateway_20130630.RetrieveTapeArchive"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the recovery point for the specified virtual tape. This operation is only
    ///          supported in the tape gateway type.</p>
    ///
    ///          <p>A recovery point is a point in time view of a virtual tape at which all the data on the
    ///          tape is consistent. If your gateway crashes, virtual tapes that have recovery points can be
    ///          recovered to a new gateway.</p>
    ///
    ///          <note>
    ///             <p>The virtual tape can be retrieved to only one gateway. The retrieved tape is
    ///             read-only. The virtual tape can be retrieved to only a tape gateway. There is no charge
    ///             for retrieving recovery points.</p>
    ///          </note>
    public func retrieveTapeRecoveryPoint(input: RetrieveTapeRecoveryPointInput, completion: @escaping (SdkResult<RetrieveTapeRecoveryPointOutputResponse, RetrieveTapeRecoveryPointOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "retrieveTapeRecoveryPoint")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RetrieveTapeRecoveryPointInput, RetrieveTapeRecoveryPointOutputResponse, RetrieveTapeRecoveryPointOutputError>(id: "retrieveTapeRecoveryPoint")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeRecoveryPointInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeRecoveryPointInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RetrieveTapeRecoveryPointInput, RetrieveTapeRecoveryPointOutputResponse, RetrieveTapeRecoveryPointOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: RetrieveTapeRecoveryPointInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<RetrieveTapeRecoveryPointInput, RetrieveTapeRecoveryPointOutputResponse, RetrieveTapeRecoveryPointOutputError>(xAmzTarget: "StorageGateway_20130630.RetrieveTapeRecoveryPoint"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the password for your VM local console. When you log in to the local console for
    ///          the first time, you log in to the VM with the default credentials. We recommend that you
    ///          set a new password. You don't need to know the default password to set a new
    ///          password.</p>
    public func setLocalConsolePassword(input: SetLocalConsolePasswordInput, completion: @escaping (SdkResult<SetLocalConsolePasswordOutputResponse, SetLocalConsolePasswordOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setLocalConsolePassword")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetLocalConsolePasswordInput, SetLocalConsolePasswordOutputResponse, SetLocalConsolePasswordOutputError>(id: "setLocalConsolePassword")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetLocalConsolePasswordInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetLocalConsolePasswordInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetLocalConsolePasswordInput, SetLocalConsolePasswordOutputResponse, SetLocalConsolePasswordOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SetLocalConsolePasswordInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SetLocalConsolePasswordInput, SetLocalConsolePasswordOutputResponse, SetLocalConsolePasswordOutputError>(xAmzTarget: "StorageGateway_20130630.SetLocalConsolePassword"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Sets the password for the guest user <code>smbguest</code>. The <code>smbguest</code>
    ///          user is the user when the authentication method for the file share is set to
    ///             <code>GuestAccess</code>.</p>
    public func setSMBGuestPassword(input: SetSMBGuestPasswordInput, completion: @escaping (SdkResult<SetSMBGuestPasswordOutputResponse, SetSMBGuestPasswordOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setSMBGuestPassword")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SetSMBGuestPasswordInput, SetSMBGuestPasswordOutputResponse, SetSMBGuestPasswordOutputError>(id: "setSMBGuestPassword")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SetSMBGuestPasswordInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SetSMBGuestPasswordInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SetSMBGuestPasswordInput, SetSMBGuestPasswordOutputResponse, SetSMBGuestPasswordOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: SetSMBGuestPasswordInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<SetSMBGuestPasswordInput, SetSMBGuestPasswordOutputResponse, SetSMBGuestPasswordOutputError>(xAmzTarget: "StorageGateway_20130630.SetSMBGuestPassword"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Shuts down a gateway. To specify which gateway to shut down, use the Amazon Resource
    ///          Name (ARN) of the gateway in the body of your request.</p>
    ///
    ///          <p>The operation shuts down the gateway service component running in the gateway's
    ///          virtual machine (VM) and not the host VM.</p>
    ///
    ///          <note>
    ///             <p>If you want to shut down the VM, it is recommended that you first shut down the
    ///             gateway component in the VM to avoid unpredictable conditions.</p>
    ///          </note>
    ///
    ///          <p>After the gateway is shutdown, you cannot call any other API except <a>StartGateway</a>, <a>DescribeGatewayInformation</a>, and <a>ListGateways</a>. For more information, see <a>ActivateGateway</a>.
    ///          Your applications cannot read from or write to the gateway's storage volumes, and
    ///          there are no snapshots taken.</p>
    ///
    ///          <note>
    ///             <p>When you make a shutdown request, you will get a <code>200 OK</code> success response
    ///             immediately. However, it might take some time for the gateway to shut down. You can call
    ///             the <a>DescribeGatewayInformation</a> API to check the status. For more
    ///             information, see <a>ActivateGateway</a>.</p>
    ///          </note>
    ///
    ///          <p>If do not intend to use the gateway again, you must delete the gateway (using <a>DeleteGateway</a>) to no longer pay software charges associated with the
    ///          gateway.</p>
    public func shutdownGateway(input: ShutdownGatewayInput, completion: @escaping (SdkResult<ShutdownGatewayOutputResponse, ShutdownGatewayOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "shutdownGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ShutdownGatewayInput, ShutdownGatewayOutputResponse, ShutdownGatewayOutputError>(id: "shutdownGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ShutdownGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ShutdownGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ShutdownGatewayInput, ShutdownGatewayOutputResponse, ShutdownGatewayOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ShutdownGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ShutdownGatewayInput, ShutdownGatewayOutputResponse, ShutdownGatewayOutputError>(xAmzTarget: "StorageGateway_20130630.ShutdownGateway"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Start a test that verifies that the specified gateway is configured for High
    ///          Availability monitoring in your host environment. This request only initiates the test and
    ///          that a successful response only indicates that the test was started. It doesn't
    ///          indicate that the test passed. For the status of the test, invoke the
    ///             <code>DescribeAvailabilityMonitorTest</code> API.</p>
    ///          <note>
    ///             <p>Starting this test will cause your gateway to go offline for a brief period.</p>
    ///          </note>
    public func startAvailabilityMonitorTest(input: StartAvailabilityMonitorTestInput, completion: @escaping (SdkResult<StartAvailabilityMonitorTestOutputResponse, StartAvailabilityMonitorTestOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startAvailabilityMonitorTest")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartAvailabilityMonitorTestInput, StartAvailabilityMonitorTestOutputResponse, StartAvailabilityMonitorTestOutputError>(id: "startAvailabilityMonitorTest")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartAvailabilityMonitorTestInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartAvailabilityMonitorTestInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartAvailabilityMonitorTestInput, StartAvailabilityMonitorTestOutputResponse, StartAvailabilityMonitorTestOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartAvailabilityMonitorTestInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartAvailabilityMonitorTestInput, StartAvailabilityMonitorTestOutputResponse, StartAvailabilityMonitorTestOutputError>(xAmzTarget: "StorageGateway_20130630.StartAvailabilityMonitorTest"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts a gateway that you previously shut down (see <a>ShutdownGateway</a>).
    ///          After the gateway starts, you can then make other API calls, your applications can read
    ///          from or write to the gateway's storage volumes and you will be able to take snapshot
    ///          backups.</p>
    ///
    ///          <note>
    ///             <p>When you make a request, you will get a 200 OK success response immediately. However,
    ///             it might take some time for the gateway to be ready. You should call <a>DescribeGatewayInformation</a> and check the status before making any
    ///             additional API calls. For more information, see <a>ActivateGateway</a>.</p>
    ///          </note>
    ///
    ///          <p>To specify which gateway to start, use the Amazon Resource Name (ARN) of the gateway in
    ///          your request.</p>
    public func startGateway(input: StartGatewayInput, completion: @escaping (SdkResult<StartGatewayOutputResponse, StartGatewayOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartGatewayInput, StartGatewayOutputResponse, StartGatewayOutputError>(id: "startGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartGatewayInput, StartGatewayOutputResponse, StartGatewayOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: StartGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<StartGatewayInput, StartGatewayOutputResponse, StartGatewayOutputError>(xAmzTarget: "StorageGateway_20130630.StartGateway"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the automatic tape creation policy of a gateway. Use this to update the policy
    ///          with a new set of automatic tape creation rules. This is only supported for tape
    ///          gateways.</p>
    ///
    ///          <p>By default, there is no automatic tape creation policy.</p>
    ///
    ///          <note>
    ///             <p>A gateway can have only one automatic tape creation policy.</p>
    ///          </note>
    public func updateAutomaticTapeCreationPolicy(input: UpdateAutomaticTapeCreationPolicyInput, completion: @escaping (SdkResult<UpdateAutomaticTapeCreationPolicyOutputResponse, UpdateAutomaticTapeCreationPolicyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAutomaticTapeCreationPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAutomaticTapeCreationPolicyInput, UpdateAutomaticTapeCreationPolicyOutputResponse, UpdateAutomaticTapeCreationPolicyOutputError>(id: "updateAutomaticTapeCreationPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAutomaticTapeCreationPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAutomaticTapeCreationPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateAutomaticTapeCreationPolicyInput, UpdateAutomaticTapeCreationPolicyOutputResponse, UpdateAutomaticTapeCreationPolicyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAutomaticTapeCreationPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateAutomaticTapeCreationPolicyInput, UpdateAutomaticTapeCreationPolicyOutputResponse, UpdateAutomaticTapeCreationPolicyOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateAutomaticTapeCreationPolicy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the bandwidth rate limits of a gateway. You can update both the upload and
    ///          download bandwidth rate limit or specify only one of the two. If you don't set a
    ///          bandwidth rate limit, the existing rate limit remains. This operation is supported for the
    ///          stored volume, cached volume, and tape gateway types.</p>
    ///
    ///          <p>By default, a gateway's bandwidth rate limits are not set. If you don't set
    ///          any limit, the gateway does not have any limitations on its bandwidth usage and could
    ///          potentially use the maximum available bandwidth.</p>
    ///
    ///          <p>To specify which gateway to update, use the Amazon Resource Name (ARN) of the gateway in
    ///          your request.</p>
    public func updateBandwidthRateLimit(input: UpdateBandwidthRateLimitInput, completion: @escaping (SdkResult<UpdateBandwidthRateLimitOutputResponse, UpdateBandwidthRateLimitOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBandwidthRateLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBandwidthRateLimitInput, UpdateBandwidthRateLimitOutputResponse, UpdateBandwidthRateLimitOutputError>(id: "updateBandwidthRateLimit")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBandwidthRateLimitInput, UpdateBandwidthRateLimitOutputResponse, UpdateBandwidthRateLimitOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateBandwidthRateLimitInput, UpdateBandwidthRateLimitOutputResponse, UpdateBandwidthRateLimitOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateBandwidthRateLimit"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>
    ///          Updates the bandwidth rate limit schedule for a specified gateway. By default, gateways do
    ///          not have bandwidth rate limit schedules, which means no bandwidth rate limiting is in effect.
    ///          Use this to initiate or update a gateway's bandwidth rate limit schedule.
    ///          This operation is supported in the volume and tape gateway types.
    ///       </p>
    public func updateBandwidthRateLimitSchedule(input: UpdateBandwidthRateLimitScheduleInput, completion: @escaping (SdkResult<UpdateBandwidthRateLimitScheduleOutputResponse, UpdateBandwidthRateLimitScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBandwidthRateLimitSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBandwidthRateLimitScheduleInput, UpdateBandwidthRateLimitScheduleOutputResponse, UpdateBandwidthRateLimitScheduleOutputError>(id: "updateBandwidthRateLimitSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateBandwidthRateLimitScheduleInput, UpdateBandwidthRateLimitScheduleOutputResponse, UpdateBandwidthRateLimitScheduleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBandwidthRateLimitScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateBandwidthRateLimitScheduleInput, UpdateBandwidthRateLimitScheduleOutputResponse, UpdateBandwidthRateLimitScheduleOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateBandwidthRateLimitSchedule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the Challenge-Handshake Authentication Protocol (CHAP) credentials for a
    ///          specified iSCSI target. By default, a gateway does not have CHAP enabled; however, for
    ///          added security, you might use it. This operation is supported in the volume and tape
    ///          gateway types.</p>
    ///
    ///          <important>
    ///             <p>When you update CHAP credentials, all existing connections on the target are closed
    ///             and initiators must reconnect with the new credentials.</p>
    ///          </important>
    public func updateChapCredentials(input: UpdateChapCredentialsInput, completion: @escaping (SdkResult<UpdateChapCredentialsOutputResponse, UpdateChapCredentialsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateChapCredentials")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateChapCredentialsInput, UpdateChapCredentialsOutputResponse, UpdateChapCredentialsOutputError>(id: "updateChapCredentials")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateChapCredentialsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateChapCredentialsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateChapCredentialsInput, UpdateChapCredentialsOutputResponse, UpdateChapCredentialsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateChapCredentialsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateChapCredentialsInput, UpdateChapCredentialsOutputResponse, UpdateChapCredentialsOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateChapCredentials"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a file system association. This operation is only supported in the Amazon FSx
    ///          file gateway type.</p>
    public func updateFileSystemAssociation(input: UpdateFileSystemAssociationInput, completion: @escaping (SdkResult<UpdateFileSystemAssociationOutputResponse, UpdateFileSystemAssociationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFileSystemAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFileSystemAssociationInput, UpdateFileSystemAssociationOutputResponse, UpdateFileSystemAssociationOutputError>(id: "updateFileSystemAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFileSystemAssociationInput, UpdateFileSystemAssociationOutputResponse, UpdateFileSystemAssociationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFileSystemAssociationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateFileSystemAssociationInput, UpdateFileSystemAssociationOutputResponse, UpdateFileSystemAssociationOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateFileSystemAssociation"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a gateway's metadata, which includes the gateway's name and time zone.
    ///          To specify which gateway to update, use the Amazon Resource Name (ARN) of the gateway in
    ///          your request.</p>
    ///
    ///          <note>
    ///             <p>For gateways activated after September 2, 2015, the gateway's ARN contains the
    ///             gateway ID rather than the gateway name. However, changing the name of the gateway has
    ///             no effect on the gateway's ARN.</p>
    ///          </note>
    public func updateGatewayInformation(input: UpdateGatewayInformationInput, completion: @escaping (SdkResult<UpdateGatewayInformationOutputResponse, UpdateGatewayInformationOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGatewayInformation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGatewayInformationInput, UpdateGatewayInformationOutputResponse, UpdateGatewayInformationOutputError>(id: "updateGatewayInformation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayInformationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayInformationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGatewayInformationInput, UpdateGatewayInformationOutputResponse, UpdateGatewayInformationOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayInformationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateGatewayInformationInput, UpdateGatewayInformationOutputResponse, UpdateGatewayInformationOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateGatewayInformation"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the gateway virtual machine (VM) software. The request immediately triggers the
    ///          software update.</p>
    ///
    ///          <note>
    ///             <p>When you make this request, you get a <code>200 OK</code> success response
    ///             immediately. However, it might take some time for the update to complete. You can call
    ///                <a>DescribeGatewayInformation</a> to verify the gateway is in the
    ///                <code>STATE_RUNNING</code> state.</p>
    ///          </note>
    ///
    ///          <important>
    ///             <p>A software update forces a system restart of your gateway. You can minimize the
    ///             chance of any disruption to your applications by increasing your iSCSI Initiators'
    ///             timeouts. For more information about increasing iSCSI Initiator timeouts for Windows and
    ///             Linux, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/ConfiguringiSCSIClientInitiatorWindowsClient.html#CustomizeWindowsiSCSISettings">Customizing your Windows iSCSI settings</a> and <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/ConfiguringiSCSIClientInitiatorRedHatClient.html#CustomizeLinuxiSCSISettings">Customizing your Linux iSCSI settings</a>, respectively.</p>
    ///          </important>
    public func updateGatewaySoftwareNow(input: UpdateGatewaySoftwareNowInput, completion: @escaping (SdkResult<UpdateGatewaySoftwareNowOutputResponse, UpdateGatewaySoftwareNowOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGatewaySoftwareNow")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGatewaySoftwareNowInput, UpdateGatewaySoftwareNowOutputResponse, UpdateGatewaySoftwareNowOutputError>(id: "updateGatewaySoftwareNow")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewaySoftwareNowInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewaySoftwareNowInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGatewaySoftwareNowInput, UpdateGatewaySoftwareNowOutputResponse, UpdateGatewaySoftwareNowOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewaySoftwareNowInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateGatewaySoftwareNowInput, UpdateGatewaySoftwareNowOutputResponse, UpdateGatewaySoftwareNowOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateGatewaySoftwareNow"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a gateway's weekly maintenance start time information, including day and
    ///          time of the week. The maintenance time is the time in your gateway's time zone.</p>
    public func updateMaintenanceStartTime(input: UpdateMaintenanceStartTimeInput, completion: @escaping (SdkResult<UpdateMaintenanceStartTimeOutputResponse, UpdateMaintenanceStartTimeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMaintenanceStartTime")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMaintenanceStartTimeInput, UpdateMaintenanceStartTimeOutputResponse, UpdateMaintenanceStartTimeOutputError>(id: "updateMaintenanceStartTime")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMaintenanceStartTimeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMaintenanceStartTimeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateMaintenanceStartTimeInput, UpdateMaintenanceStartTimeOutputResponse, UpdateMaintenanceStartTimeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMaintenanceStartTimeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateMaintenanceStartTimeInput, UpdateMaintenanceStartTimeOutputResponse, UpdateMaintenanceStartTimeOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateMaintenanceStartTime"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a Network File System (NFS) file share. This operation is only supported in the
    ///          file gateway type.</p>
    ///
    ///          <note>
    ///             <p>To leave a file share field unchanged, set the corresponding input field to
    ///             null.</p>
    ///          </note>
    ///
    ///          <p>Updates the following file share settings:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Default storage class for your S3 bucket</p>
    ///             </li>
    ///             <li>
    ///                <p>Metadata defaults for your S3 bucket</p>
    ///             </li>
    ///             <li>
    ///                <p>Allowed NFS clients for your file share</p>
    ///             </li>
    ///             <li>
    ///                <p>Squash settings</p>
    ///             </li>
    ///             <li>
    ///                <p>Write status of your file share</p>
    ///             </li>
    ///          </ul>
    public func updateNFSFileShare(input: UpdateNFSFileShareInput, completion: @escaping (SdkResult<UpdateNFSFileShareOutputResponse, UpdateNFSFileShareOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateNFSFileShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateNFSFileShareInput, UpdateNFSFileShareOutputResponse, UpdateNFSFileShareOutputError>(id: "updateNFSFileShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateNFSFileShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateNFSFileShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateNFSFileShareInput, UpdateNFSFileShareOutputResponse, UpdateNFSFileShareOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateNFSFileShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateNFSFileShareInput, UpdateNFSFileShareOutputResponse, UpdateNFSFileShareOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateNFSFileShare"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a Server Message Block (SMB) file share. This operation is only supported for
    ///          file gateways.</p>
    ///
    ///          <note>
    ///             <p>To leave a file share field unchanged, set the corresponding input field to
    ///             null.</p>
    ///          </note>
    ///
    ///          <important>
    ///             <p>File gateways require AWS Security Token Service (AWS STS) to be activated to enable
    ///             you to create a file share. Make sure that AWS STS is activated in the AWS Region you
    ///             are creating your file gateway in. If AWS STS is not activated in this AWS Region,
    ///             activate it. For information about how to activate AWS STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
    ///                deactivating AWS STS in an AWS Region</a> in the <i>AWS Identity and
    ///                Access Management User Guide</i>.</p>
    ///
    ///             <p>File gateways don't support creating hard or symbolic links on a file
    ///             share.</p>
    ///          </important>
    public func updateSMBFileShare(input: UpdateSMBFileShareInput, completion: @escaping (SdkResult<UpdateSMBFileShareOutputResponse, UpdateSMBFileShareOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSMBFileShare")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSMBFileShareInput, UpdateSMBFileShareOutputResponse, UpdateSMBFileShareOutputError>(id: "updateSMBFileShare")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSMBFileShareInput, UpdateSMBFileShareOutputResponse, UpdateSMBFileShareOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSMBFileShareInput, UpdateSMBFileShareOutputResponse, UpdateSMBFileShareOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateSMBFileShare"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Controls whether the shares on a gateway are visible in a net view or browse
    ///          list.</p>
    public func updateSMBFileShareVisibility(input: UpdateSMBFileShareVisibilityInput, completion: @escaping (SdkResult<UpdateSMBFileShareVisibilityOutputResponse, UpdateSMBFileShareVisibilityOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSMBFileShareVisibility")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSMBFileShareVisibilityInput, UpdateSMBFileShareVisibilityOutputResponse, UpdateSMBFileShareVisibilityOutputError>(id: "updateSMBFileShareVisibility")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareVisibilityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareVisibilityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSMBFileShareVisibilityInput, UpdateSMBFileShareVisibilityOutputResponse, UpdateSMBFileShareVisibilityOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBFileShareVisibilityInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSMBFileShareVisibilityInput, UpdateSMBFileShareVisibilityOutputResponse, UpdateSMBFileShareVisibilityOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateSMBFileShareVisibility"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the SMB security strategy on a file gateway. This action is only supported in
    ///          file gateways.</p>
    ///
    ///          <note>
    ///             <p>This API is called Security level in the User Guide.</p>
    ///
    ///             <p>A higher security level can affect performance of the gateway.</p>
    ///          </note>
    public func updateSMBSecurityStrategy(input: UpdateSMBSecurityStrategyInput, completion: @escaping (SdkResult<UpdateSMBSecurityStrategyOutputResponse, UpdateSMBSecurityStrategyOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSMBSecurityStrategy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSMBSecurityStrategyInput, UpdateSMBSecurityStrategyOutputResponse, UpdateSMBSecurityStrategyOutputError>(id: "updateSMBSecurityStrategy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBSecurityStrategyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBSecurityStrategyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSMBSecurityStrategyInput, UpdateSMBSecurityStrategyOutputResponse, UpdateSMBSecurityStrategyOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSMBSecurityStrategyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSMBSecurityStrategyInput, UpdateSMBSecurityStrategyOutputResponse, UpdateSMBSecurityStrategyOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateSMBSecurityStrategy"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a snapshot schedule configured for a gateway volume. This operation is only
    ///          supported in the cached volume and stored volume gateway types.</p>
    ///
    ///          <p>The default snapshot schedule for volume is once every 24 hours, starting at the
    ///          creation time of the volume. You can use this API to change the snapshot schedule
    ///          configured for the volume.</p>
    ///
    ///          <p>In the request you must identify the gateway volume whose snapshot schedule you want to
    ///          update, and the schedule information, including when you want the snapshot to begin on a
    ///          day and the frequency (in hours) of snapshots.</p>
    public func updateSnapshotSchedule(input: UpdateSnapshotScheduleInput, completion: @escaping (SdkResult<UpdateSnapshotScheduleOutputResponse, UpdateSnapshotScheduleOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateSnapshotSchedule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateSnapshotScheduleInput, UpdateSnapshotScheduleOutputResponse, UpdateSnapshotScheduleOutputError>(id: "updateSnapshotSchedule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateSnapshotScheduleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateSnapshotScheduleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateSnapshotScheduleInput, UpdateSnapshotScheduleOutputResponse, UpdateSnapshotScheduleOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateSnapshotScheduleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateSnapshotScheduleInput, UpdateSnapshotScheduleOutputResponse, UpdateSnapshotScheduleOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateSnapshotSchedule"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the type of medium changer in a tape gateway. When you activate a tape gateway,
    ///          you select a medium changer type for the tape gateway. This operation enables you to select
    ///          a different type of medium changer after a tape gateway is activated. This operation is
    ///          only supported in the tape gateway type.</p>
    public func updateVTLDeviceType(input: UpdateVTLDeviceTypeInput, completion: @escaping (SdkResult<UpdateVTLDeviceTypeOutputResponse, UpdateVTLDeviceTypeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVTLDeviceType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "storagegateway.\(config.region).amazonaws.com")
                      .withSigningName(value: "storagegateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVTLDeviceTypeInput, UpdateVTLDeviceTypeOutputResponse, UpdateVTLDeviceTypeOutputError>(id: "updateVTLDeviceType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateVTLDeviceTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVTLDeviceTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateVTLDeviceTypeInput, UpdateVTLDeviceTypeOutputResponse, UpdateVTLDeviceTypeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVTLDeviceTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateVTLDeviceTypeInput, UpdateVTLDeviceTypeOutputResponse, UpdateVTLDeviceTypeOutputError>(xAmzTarget: "StorageGateway_20130630.UpdateVTLDeviceType"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
