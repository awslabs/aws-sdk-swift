// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied. Your account is not authorized to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum CmkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aoCmk
        case cmCmk
        case sdkUnknown(Swift.String)

        public static var allCases: [CmkType] {
            return [
                .aoCmk,
                .cmCmk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aoCmk: return "AWS_OWNED_KMS_KEY"
            case .cmCmk: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmkType(rawValue: rawValue) ?? CmkType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Data Store is in a transition state and the user requested action can not be performed.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreTypeVersion = self.datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = self.preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = self.sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFHIRDatastoreInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    public var clientToken: Swift.String?
    /// The user generated name for the Data Store.
    public var datastoreName: Swift.String?
    /// The FHIR version of the Data Store. The only supported version is R4.
    /// This member is required.
    public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// Optional parameter to preload data upon creation of the Data Store. Currently, the only supported preloaded data is synthetic data generated from Synthea.
    public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    /// The server-side encryption key configuration for a customer provided encryption key specified for creating a Data Store.
    public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    /// Resource tags that are applied to a Data Store when it is created.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
        sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.preloadDataConfig = preloadDataConfig
        self.sseConfiguration = sseConfiguration
        self.tags = tags
    }
}

struct CreateFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreName: Swift.String?
    let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    let sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    let clientToken: Swift.String?
    let tags: [HealthLakeClientTypes.Tag]?
}

extension CreateFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The datastore ARN is generated during the creation of the Data Store and can be found in the output from the initial Data Store creation call.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the created Data Store. For preview, only US-east-1 endpoints are supported.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated Data Store id. This id is in the output from the initial Data Store creation call.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the FHIR Data Store. Possible statuses are ‘CREATING’, ‘ACTIVE’, ‘DELETING’, ‘DELETED’.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreArn: Swift.String?
    let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    let datastoreEndpoint: Swift.String?
}

extension CreateFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .epochSeconds, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .epochSeconds, forKey: .createdBefore)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
    }
}

extension HealthLakeClientTypes {
    /// The filters applied to Data Store query.
    public struct DatastoreFilter: Swift.Equatable {
        /// A filter that allows the user to set cutoff dates for records. All Data Stores created after the specified date will be included in the results.
        public var createdAfter: ClientRuntime.Date?
        /// A filter that allows the user to set cutoff dates for records. All Data Stores created before the specified date will be included in the results.
        public var createdBefore: ClientRuntime.Date?
        /// Allows the user to filter Data Store results by name.
        public var datastoreName: Swift.String?
        /// Allows the user to filter Data Store results by status.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }

}

extension HealthLakeClientTypes.DatastoreProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let datastoreArn = self.datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreEndpoint = self.datastoreEndpoint {
            try encodeContainer.encode(datastoreEndpoint, forKey: .datastoreEndpoint)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = self.datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = self.datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let datastoreTypeVersion = self.datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = self.preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = self.sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
    }
}

extension HealthLakeClientTypes {
    /// Displays the properties of the Data Store, including the ID, Arn, name, and the status of the Data Store.
    public struct DatastoreProperties: Swift.Equatable {
        /// The time that a Data Store was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name used in the creation of the Data Store.
        /// This member is required.
        public var datastoreArn: Swift.String?
        /// The AWS endpoint for the Data Store. Each Data Store will have it's own endpoint with Data Store ID in the endpoint URL.
        /// This member is required.
        public var datastoreEndpoint: Swift.String?
        /// The AWS-generated ID number for the Data Store.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The user-generated name for the Data Store.
        public var datastoreName: Swift.String?
        /// The status of the Data Store. Possible statuses are 'CREATING', 'ACTIVE', 'DELETING', or 'DELETED'.
        /// This member is required.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// The FHIR version. Only R4 version data is supported.
        /// This member is required.
        public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.
        public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
        /// The server-side encryption key configuration for a customer provided encryption key (CMK).
        public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
            sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }
    }

}

extension HealthLakeClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

extension DeleteFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFHIRDatastoreInput: Swift.Equatable {
    /// The AWS-generated ID for the Data Store to be deleted.
    public var datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
}

extension DeleteFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DeleteFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the Data Store the user has requested to be deleted.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated ID for the Data Store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the Data Store that the user has requested to be deleted.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let datastoreArn: Swift.String?
    let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    let datastoreEndpoint: Swift.String?
}

extension DeleteFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension DescribeFHIRDatastoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

extension DescribeFHIRDatastoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRDatastoreInput: Swift.Equatable {
    /// The AWS-generated Data Store id. This is part of the ‘CreateFHIRDatastore’ output.
    public var datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DescribeFHIRDatastoreInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
}

extension DescribeFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DescribeFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct DescribeFHIRDatastoreOutputResponse: Swift.Equatable {
    /// All properties associated with a Data Store, including the Data Store ID, Data Store ARN, Data Store name, Data Store status, created at, Data Store type version, and Data Store endpoint.
    /// This member is required.
    public var datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init (
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct DescribeFHIRDatastoreOutputResponseBody: Swift.Equatable {
    let datastoreProperties: HealthLakeClientTypes.DatastoreProperties?
}

extension DescribeFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreProperties = "DatastoreProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

extension DescribeFHIRExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFHIRExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRExportJobInput: Swift.Equatable {
    /// The AWS generated ID for the Data Store from which files are being exported from for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRExportJobInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobProperties = output.exportJobProperties
        } else {
            self.exportJobProperties = nil
        }
    }
}

public struct DescribeFHIRExportJobOutputResponse: Swift.Equatable {
    /// Displays the properties of the export job, including the ID, Arn, Name, and the status of the job.
    /// This member is required.
    public var exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init (
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

struct DescribeFHIRExportJobOutputResponseBody: Swift.Equatable {
    let exportJobProperties: HealthLakeClientTypes.ExportJobProperties?
}

extension DescribeFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobProperties = "ExportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ExportJobProperties.self, forKey: .exportJobProperties)
        exportJobProperties = exportJobPropertiesDecoded
    }
}

extension DescribeFHIRImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFHIRImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFHIRImportJobInput: Swift.Equatable {
    /// The AWS-generated ID of the Data Store.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRImportJobInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobProperties = output.importJobProperties
        } else {
            self.importJobProperties = nil
        }
    }
}

public struct DescribeFHIRImportJobOutputResponse: Swift.Equatable {
    /// The properties of the Import job request, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init (
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

struct DescribeFHIRImportJobOutputResponseBody: Swift.Equatable {
    let importJobProperties: HealthLakeClientTypes.ImportJobProperties?
}

extension DescribeFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobProperties = "ImportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ImportJobProperties.self, forKey: .importJobProperties)
        importJobProperties = importJobPropertiesDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    /// The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.
    public struct ExportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name used during the initiation of the job.
        public var dataAccessRoleArn: Swift.String?
        /// The AWS generated ID for the Data Store from which files are being exported for an export job.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time an export job completed.
        public var endTime: ClientRuntime.Date?
        /// The AWS generated ID for an export job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user generated name for an export job.
        public var jobName: Swift.String?
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the export job.
        public var message: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        /// This member is required.
        public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The time an export job was initiated.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes {
    public enum FHIRVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FHIRVersion(rawValue: rawValue) ?? FHIRVersion.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.ImportJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
        case jobStatus = "JobStatus"
        case message = "Message"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = self.jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    /// Displays the properties of the import job, including the ID, Arn, Name, and the status of the Data Store.
    public struct ImportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The datastore id used when the Import job was created.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time that the Import job was completed.
        public var endTime: ClientRuntime.Date?
        /// The input data configuration that was supplied when the Import job was created.
        /// This member is required.
        public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// The AWS-generated id number for the Import job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user-generated name for an Import job.
        public var jobName: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the FHIR import job.
        public var message: Swift.String?
        /// The time that the Import job was submitted for processing.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// The input properties for an import job.
    public enum InputDataConfig: Swift.Equatable, Swift.Hashable {
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unknown error occurs in the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkType = "CmkType"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkType = self.cmkType {
            try encodeContainer.encode(cmkType.rawValue, forKey: .cmkType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cmkTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.CmkType.self, forKey: .cmkType)
        cmkType = cmkTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes {
    /// The customer-managed-key(CMK) used when creating a Data Store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
    public struct KmsEncryptionConfig: Swift.Equatable {
        /// The type of customer-managed-key(CMK) used for encyrption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
        /// This member is required.
        public var cmkType: HealthLakeClientTypes.CmkType?
        /// The KMS encryption key id/alias used to encrypt the Data Store contents at rest.
        public var kmsKeyId: Swift.String?

        public init (
            cmkType: HealthLakeClientTypes.CmkType? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ListFHIRDatastoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFHIRDatastoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRDatastoresInput: Swift.Equatable {
    /// Lists all filters associated with a FHIR Data Store request.
    public var filter: HealthLakeClientTypes.DatastoreFilter?
    /// The maximum number of Data Stores returned in a single page of a ListFHIRDatastoresRequest call.
    public var maxResults: Swift.Int?
    /// Fetches the next page of Data Stores when results are paginated.
    public var nextToken: Swift.String?

    public init (
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresInputBody: Swift.Equatable {
    let filter: HealthLakeClientTypes.DatastoreFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFHIRDatastoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFHIRDatastoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRDatastoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFHIRDatastoresOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRDatastoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFHIRDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastorePropertiesList = output.datastorePropertiesList
            self.nextToken = output.nextToken
        } else {
            self.datastorePropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRDatastoresOutputResponse: Swift.Equatable {
    /// All properties associated with the listed Data Stores.
    /// This member is required.
    public var datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// Pagination token that can be used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresOutputResponseBody: Swift.Equatable {
    let datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRDatastoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastorePropertiesList = "DatastorePropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.DatastoreProperties?].self, forKey: .datastorePropertiesList)
        var datastorePropertiesListDecoded0:[HealthLakeClientTypes.DatastoreProperties]? = nil
        if let datastorePropertiesListContainer = datastorePropertiesListContainer {
            datastorePropertiesListDecoded0 = [HealthLakeClientTypes.DatastoreProperties]()
            for structure0 in datastorePropertiesListContainer {
                if let structure0 = structure0 {
                    datastorePropertiesListDecoded0?.append(structure0)
                }
            }
        }
        datastorePropertiesList = datastorePropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFHIRExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = self.submittedAfter {
            try encodeContainer.encodeTimestamp(submittedAfter, format: .epochSeconds, forKey: .submittedAfter)
        }
        if let submittedBefore = self.submittedBefore {
            try encodeContainer.encodeTimestamp(submittedBefore, format: .epochSeconds, forKey: .submittedBefore)
        }
    }
}

extension ListFHIRExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRExportJobsInput: Swift.Equatable {
    /// This parameter limits the response to the export job with the specified Data Store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the export job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the export jobs with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR export jobs submitted after a user specified date.
    public var submittedAfter: ClientRuntime.Date?
    /// This parameter limits the response to FHIR export jobs submitted before a user specified date.
    public var submittedBefore: ClientRuntime.Date?

    public init (
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRExportJobsInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let jobName: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let submittedBefore: ClientRuntime.Date?
    let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

extension ListFHIRExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFHIRExportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFHIRExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobPropertiesList = output.exportJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.exportJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRExportJobsOutputResponse: Swift.Equatable {
    /// The properties of listed FHIR export jobs, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    public var nextToken: Swift.String?

    public init (
        exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobPropertiesList = exportJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRExportJobsOutputResponseBody: Swift.Equatable {
    let exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobPropertiesList = "ExportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ExportJobProperties?].self, forKey: .exportJobPropertiesList)
        var exportJobPropertiesListDecoded0:[HealthLakeClientTypes.ExportJobProperties]? = nil
        if let exportJobPropertiesListContainer = exportJobPropertiesListContainer {
            exportJobPropertiesListDecoded0 = [HealthLakeClientTypes.ExportJobProperties]()
            for structure0 in exportJobPropertiesListContainer {
                if let structure0 = structure0 {
                    exportJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        exportJobPropertiesList = exportJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFHIRImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = self.submittedAfter {
            try encodeContainer.encodeTimestamp(submittedAfter, format: .epochSeconds, forKey: .submittedAfter)
        }
        if let submittedBefore = self.submittedBefore {
            try encodeContainer.encodeTimestamp(submittedBefore, format: .epochSeconds, forKey: .submittedBefore)
        }
    }
}

extension ListFHIRImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFHIRImportJobsInput: Swift.Equatable {
    /// This parameter limits the response to the import job with the specified Data Store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// This parameter limits the response to the import job with the specified job name.
    public var jobName: Swift.String?
    /// This parameter limits the response to the import job with the specified job status.
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    /// This parameter limits the number of results returned for a ListFHIRImportJobs to a maximum quantity specified by the user.
    public var maxResults: Swift.Int?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?
    /// This parameter limits the response to FHIR import jobs submitted after a user specified date.
    public var submittedAfter: ClientRuntime.Date?
    /// This parameter limits the response to FHIR import jobs submitted before a user specified date.
    public var submittedBefore: ClientRuntime.Date?

    public init (
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRImportJobsInputBody: Swift.Equatable {
    let datastoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let jobName: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let submittedBefore: ClientRuntime.Date?
    let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

extension ListFHIRImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFHIRImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFHIRImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobPropertiesList = output.importJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.importJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRImportJobsOutputResponse: Swift.Equatable {
    /// The properties of a listed FHIR import jobs, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    /// A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    public var nextToken: Swift.String?

    public init (
        importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobPropertiesList = importJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRImportJobsOutputResponseBody: Swift.Equatable {
    let importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    let nextToken: Swift.String?
}

extension ListFHIRImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobPropertiesList = "ImportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ImportJobProperties?].self, forKey: .importJobPropertiesList)
        var importJobPropertiesListDecoded0:[HealthLakeClientTypes.ImportJobProperties]? = nil
        if let importJobPropertiesListContainer = importJobPropertiesListContainer {
            importJobPropertiesListDecoded0 = [HealthLakeClientTypes.ImportJobProperties]()
            for structure0 in importJobPropertiesListContainer {
                if let structure0 = structure0 {
                    importJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        importJobPropertiesList = importJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN) of the Data Store for which tags are being added.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Returns a list of tags associated with a Data Store.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [HealthLakeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HealthLakeClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3configuration = "S3Configuration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3configuration(s3configuration):
                try container.encode(s3configuration, forKey: .s3configuration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3configurationDecoded = try values.decodeIfPresent(HealthLakeClientTypes.S3Configuration.self, forKey: .s3configuration)
        if let s3configuration = s3configurationDecoded {
            self = .s3configuration(s3configuration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// The output data configuration that was supplied when the export job was created.
    public enum OutputDataConfig: Swift.Equatable {
        /// The output data configuration that was supplied when the export job was created.
        case s3configuration(HealthLakeClientTypes.S3Configuration)
        case sdkUnknown(Swift.String)
    }

}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preloadDataType = "PreloadDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preloadDataType = self.preloadDataType {
            try encodeContainer.encode(preloadDataType.rawValue, forKey: .preloadDataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preloadDataTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataType.self, forKey: .preloadDataType)
        preloadDataType = preloadDataTypeDecoded
    }
}

extension HealthLakeClientTypes {
    /// The input properties for the preloaded Data Store. Only data preloaded from Synthea is supported.
    public struct PreloadDataConfig: Swift.Equatable {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        /// This member is required.
        public var preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init (
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        )
        {
            self.preloadDataType = preloadDataType
        }
    }

}

extension HealthLakeClientTypes {
    public enum PreloadDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreloadDataType(rawValue: rawValue) ?? PreloadDataType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested Data Store was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes {
    /// The configuration of the S3 bucket for either an import or export job. This includes assigning permissions for access.
    public struct S3Configuration: Swift.Equatable {
        /// The KMS key ID used to access the S3 bucket.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension HealthLakeClientTypes.SseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionConfig = "KmsEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionConfig = self.kmsEncryptionConfig {
            try encodeContainer.encode(kmsEncryptionConfig, forKey: .kmsEncryptionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.KmsEncryptionConfig.self, forKey: .kmsEncryptionConfig)
        kmsEncryptionConfig = kmsEncryptionConfigDecoded
    }
}

extension HealthLakeClientTypes {
    /// The server-side encryption key configuration for a customer provided encryption key.
    public struct SseConfiguration: Swift.Equatable {
        /// The KMS encryption configuration used to provide details for data encryption.
        /// This member is required.
        public var kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig?

        public init (
            kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig? = nil
        )
        {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }
    }

}

extension StartFHIRExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartFHIRExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFHIRExportJobInput: Swift.Equatable {
    /// An optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name used during the initiation of the job.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS generated ID for the Data Store from which files are being exported for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The user generated name for an export job.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartFHIRExportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    let datastoreId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRExportJobOutputResponse: Swift.Equatable {
    /// The AWS generated ID for the Data Store from which files are being exported for an export job.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRExportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let datastoreId: Swift.String?
}

extension StartFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension StartFHIRImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = self.datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = self.jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
    }
}

extension StartFHIRImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFHIRImportJobInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS-generated Data Store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input properties of the FHIR Import job in the StartFHIRImport job request.
    /// This member is required.
    public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// The name of the FHIR Import job in the StartFHIRImport job request.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.jobOutputDataConfig = jobOutputDataConfig
    }
}

struct StartFHIRImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    let jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    let datastoreId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRImportJobOutputResponse: Swift.Equatable {
    /// The AWS-generated Data Store ID.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of an import job.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobStatus: HealthLakeClientTypes.JobStatus?
    let datastoreId: Swift.String?
}

extension StartFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension HealthLakeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HealthLakeClientTypes {
    /// A tag is a label consisting of a user-defined key and value. The form for tags is {"Key", "Value"}
    public struct Tag: Swift.Equatable {
        /// The key portion of a tag. Tag keys are case sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value portion of tag. Tag values are case sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN)that gives Amazon HealthLake access to the Data Store which tags are being added to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The user specified key and value pair tags being added to a Data Store.
    /// This member is required.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [HealthLakeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user has exceeded their maximum number of allowed calls to the given API.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// "The Amazon Resource Name(ARN) of the Data Store for which tags are being removed
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys for the tags to be removed from the Healthlake Data Store.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user input parameter was invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
