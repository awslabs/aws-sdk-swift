// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.ActiveContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextAttributes
        case name
        case timeToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextAttributes = contextAttributes {
            var contextAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .contextAttributes)
            for (dictKey0, activeContextParametersMap0) in contextAttributes {
                try contextAttributesContainer.encode(activeContextParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ActiveContextTimeToLive.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .contextAttributes)
        var contextAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let contextAttributesContainer = contextAttributesContainer {
            contextAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, text0) in contextAttributesContainer {
                if let text0 = text0 {
                    contextAttributesDecoded0?[key0] = text0
                }
            }
        }
        contextAttributes = contextAttributesDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// Contains information about the contexts that a user is using in a session. You can configure Amazon Lex V2 to set a context when an intent is fulfilled, or you can set a context using the , , or operations. Use a context to indicate to Amazon Lex V2 intents that should be used as follow-up intents. For example, if the active context is order-fulfilled, only intents that have order-fulfilled configured as a trigger are considered for follow up.
    public struct ActiveContext: Swift.Equatable {
        /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request. If you don't specify a list of contexts, Amazon Lex V2 will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
        /// This member is required.
        public var contextAttributes: [Swift.String:Swift.String]?
        /// The name of the context.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the number of turns or seconds that the context is active. Once the time to live expires, the context is no longer returned in a response.
        /// This member is required.
        public var timeToLive: LexRuntimeV2ClientTypes.ActiveContextTimeToLive?

        public init (
            contextAttributes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            timeToLive: LexRuntimeV2ClientTypes.ActiveContextTimeToLive? = nil
        )
        {
            self.contextAttributes = contextAttributes
            self.name = name
            self.timeToLive = timeToLive
        }
    }

}

extension LexRuntimeV2ClientTypes.ActiveContextTimeToLive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLiveInSeconds = self.timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = self.turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The time that a context is active. You can specify the time to live in seconds or in conversation turns.
    public struct ActiveContextTimeToLive: Swift.Equatable {
        /// The number of seconds that the context is active. You can specify between 5 and 86400 seconds (24 hours).
        /// This member is required.
        public var timeToLiveInSeconds: Swift.Int?
        /// The number of turns that the context is active. You can specify up to 20 turns. Each request and response from the bot is a turn.
        /// This member is required.
        public var turnsToLive: Swift.Int?

        public init (
            timeToLiveInSeconds: Swift.Int? = nil,
            turnsToLive: Swift.Int? = nil
        )
        {
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }
    }

}

extension LexRuntimeV2ClientTypes.AudioInputEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChunk
        case clientTimestampMillis
        case contentType
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = self.audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Represents a chunk of audio sent from the client application to Amazon Lex V2. The audio is all or part of an utterance from the user. Amazon Lex V2 accumulates audio chunks until it recognizes a natural pause in speech before processing the input.
    public struct AudioInputEvent: Swift.Equatable {
        /// An encoded stream of audio.
        public var audioChunk: ClientRuntime.Data?
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// The encoding used for the audio chunk. You must use 8 KHz PCM 16-bit mono-channel little-endian format. The value of the field should be: audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
        /// This member is required.
        public var contentType: Swift.String?
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?

        public init (
            audioChunk: ClientRuntime.Data? = nil,
            clientTimestampMillis: Swift.Int = 0,
            contentType: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.audioChunk = audioChunk
            self.clientTimestampMillis = clientTimestampMillis
            self.contentType = contentType
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.AudioResponseEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChunk
        case contentType
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = self.audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// An event sent from Amazon Lex V2 to your client application containing audio to play to the user.
    public struct AudioResponseEvent: Swift.Equatable {
        /// A chunk of the audio to play.
        public var audioChunk: ClientRuntime.Data?
        /// The encoding of the audio chunk. This is the same as the encoding configure in the contentType field of the ConfigurationEvent.
        public var contentType: Swift.String?
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?

        public init (
            audioChunk: ClientRuntime.Data? = nil,
            contentType: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.audioChunk = audioChunk
            self.contentType = contentType
            self.eventId = eventId
        }
    }

}

extension BadGatewayException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadGatewayException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct BadGatewayException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadGatewayExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadGatewayExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Button: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// A button that appears on a response card show to the user.
    public struct Button: Swift.Equatable {
        /// The text that is displayed on the button.
        /// This member is required.
        public var text: Swift.String?
        /// The value returned to Amazon Lex V2 when a user chooses the button.
        /// This member is required.
        public var value: Swift.String?

        public init (
            text: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.text = text
            self.value = value
        }
    }

}

extension LexRuntimeV2ClientTypes.ConfidenceScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Provides a score that indicates the confidence that Amazon Lex V2 has that an intent is the one that satisfies the user's intent.
    public struct ConfidenceScore: Swift.Equatable {
        /// A score that indicates how confident Amazon Lex V2 is that an intent satisfies the user's intent. Ranges between 0.00 and 1.00. Higher scores indicate higher confidence.
        public var score: Swift.Double

        public init (
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension LexRuntimeV2ClientTypes.ConfigurationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case disablePlayback
        case eventId
        case requestAttributes
        case responseContentType
        case sessionState
        case welcomeMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if disablePlayback != false {
            try encodeContainer.encode(disablePlayback, forKey: .disablePlayback)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseContentType = self.responseContentType {
            try encodeContainer.encode(responseContentType, forKey: .responseContentType)
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let welcomeMessages = welcomeMessages {
            var welcomeMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .welcomeMessages)
            for message0 in welcomeMessages {
                try welcomeMessagesContainer.encode(message0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let responseContentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseContentType)
        responseContentType = responseContentTypeDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let welcomeMessagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .welcomeMessages)
        var welcomeMessagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let welcomeMessagesContainer = welcomeMessagesContainer {
            welcomeMessagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in welcomeMessagesContainer {
                if let structure0 = structure0 {
                    welcomeMessagesDecoded0?.append(structure0)
                }
            }
        }
        welcomeMessages = welcomeMessagesDecoded0
        let disablePlaybackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disablePlayback) ?? false
        disablePlayback = disablePlaybackDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The initial event sent from the application to Amazon Lex V2 to configure the conversation, including session and request attributes and the response content type.
    public struct ConfigurationEvent: Swift.Equatable {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// Determines whether Amazon Lex V2 should send audio responses to the client application. Set this field to false when the client is operating in a playback mode where audio responses are played to the user. If the client isn't operating in playback mode, such as a text chat application, set this to true so that Amazon Lex V2 doesn't wait for the prompt to finish playing on the client.
        public var disablePlayback: Swift.Bool
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?
        /// Request-specific information passed between the client application and Amazon Lex V2. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes for prefix x-amz-lex:.
        public var requestAttributes: [Swift.String:Swift.String]?
        /// The message that Amazon Lex V2 returns in the response can be either text or speech based on the responseContentType value.
        ///
        /// * If the value is text/plain;charset=utf-8, Amazon Lex V2 returns text in the response.
        ///
        /// * If the value begins with audio/, Amazon Lex V2 returns speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech using the configuration that you specified in the requestContentType parameter. For example, if you specify audio/mpeg as the value, Amazon Lex V2 returns speech in the MPEG format.
        ///
        /// * If the value is audio/pcm, the speech returned is audio/pcm in 16-bit, little-endian format.
        ///
        /// * The following are the accepted values:
        ///
        /// * audio/mpeg
        ///
        /// * audio/ogg
        ///
        /// * audio/pcm
        ///
        /// * audio/* (defaults to mpeg)
        ///
        /// * text/plain; charset=utf-8
        /// This member is required.
        public var responseContentType: Swift.String?
        /// The state of the user's session with Amazon Lex V2.
        public var sessionState: LexRuntimeV2ClientTypes.SessionState?
        /// A list of messages to send to the user. If you set the welcomeMessage field, you must also set the [DialogAction](https://docs.aws.amazon.com/lexv2/latest/dg/API_runtime_DialogAction.html) structure's [type](https://docs.aws.amazon.com/lexv2/latest/dg/API_runtime_DialogAction.html#lexv2-Type-runtime_DialogAction-type) field.
        public var welcomeMessages: [LexRuntimeV2ClientTypes.Message]?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            disablePlayback: Swift.Bool = false,
            eventId: Swift.String? = nil,
            requestAttributes: [Swift.String:Swift.String]? = nil,
            responseContentType: Swift.String? = nil,
            sessionState: LexRuntimeV2ClientTypes.SessionState? = nil,
            welcomeMessages: [LexRuntimeV2ClientTypes.Message]? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.disablePlayback = disablePlayback
            self.eventId = eventId
            self.requestAttributes = requestAttributes
            self.responseContentType = responseContentType
            self.sessionState = sessionState
            self.welcomeMessages = welcomeMessages
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum ConfirmationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmed
        case denied
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationState] {
            return [
                .confirmed,
                .denied,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "Confirmed"
            case .denied: return "Denied"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfirmationState(rawValue: rawValue) ?? ConfirmationState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    public enum ConversationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audio
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationMode] {
            return [
                .audio,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConversationMode(rawValue: rawValue) ?? ConversationMode.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.DTMFInputEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
        case inputCharacter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputCharacter = self.inputCharacter {
            try encodeContainer.encode(inputCharacter, forKey: .inputCharacter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputCharacter)
        inputCharacter = inputCharacterDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.DTMFInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DTMFInputEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)), inputCharacter: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeV2ClientTypes {
    /// A DTMF character sent from the client application. DTMF characters are typically sent from a phone keypad to represent numbers. For example, you can have Amazon Lex V2 process a credit card number input from a phone.
    public struct DTMFInputEvent: Swift.Equatable {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?
        /// The DTMF character that the user pressed. The allowed characters are A - D, 0 - 9, # and *.
        /// This member is required.
        public var inputCharacter: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil,
            inputCharacter: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.inputCharacter = inputCharacter
        }
    }

}

extension DeleteSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct DeleteSessionInput: Swift.Equatable {
    /// The alias identifier in use for the bot that contains the session data.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that contains the session data.
    /// This member is required.
    public var botId: Swift.String?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// The identifier of the session to delete.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionInputBody: Swift.Equatable {
}

extension DeleteSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasId = output.botAliasId
            self.botId = output.botId
            self.localeId = output.localeId
            self.sessionId = output.sessionId
        } else {
            self.botAliasId = nil
            self.botId = nil
            self.localeId = nil
            self.sessionId = nil
        }
    }
}

public struct DeleteSessionOutputResponse: Swift.Equatable {
    /// The alias identifier in use for the bot that contained the session data.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that contained the session data.
    public var botId: Swift.String?
    /// The locale where the session was used.
    public var localeId: Swift.String?
    /// The identifier of the deleted session.
    public var sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionOutputResponseBody: Swift.Equatable {
    let botId: Swift.String?
    let botAliasId: Swift.String?
    let localeId: Swift.String?
    let sessionId: Swift.String?
}

extension DeleteSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botId
        case localeId
        case sessionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension DependencyFailedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DependencyFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct DependencyFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.DialogAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotElicitationStyle
        case slotToElicit
        case subSlotToElicit
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotElicitationStyle = self.slotElicitationStyle {
            try encodeContainer.encode(slotElicitationStyle.rawValue, forKey: .slotElicitationStyle)
        }
        if let slotToElicit = self.slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let subSlotToElicit = self.subSlotToElicit {
            try encodeContainer.encode(subSlotToElicit, forKey: .subSlotToElicit)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.DialogActionType.self, forKey: .type)
        type = typeDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let slotElicitationStyleDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.StyleType.self, forKey: .slotElicitationStyle)
        slotElicitationStyle = slotElicitationStyleDecoded
        let subSlotToElicitDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ElicitSubSlot.self, forKey: .subSlotToElicit)
        subSlotToElicit = subSlotToElicitDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The next action that Amazon Lex V2 should take.
    public struct DialogAction: Swift.Equatable {
        /// Configures the slot to use spell-by-letter or spell-by-word style. When you use a style on a slot, users can spell out their input to make it clear to your bot.
        ///
        /// * Spell by letter - "b" "o" "b"
        ///
        /// * Spell by word - "b as in boy" "o as in oscar" "b as in boy"
        ///
        ///
        /// For more information, see [ Using spelling to enter slot values ](https://docs.aws.amazon.com/lexv2/latest/dg/using-spelling.html).
        public var slotElicitationStyle: LexRuntimeV2ClientTypes.StyleType?
        /// The name of the slot that should be elicited from the user.
        public var slotToElicit: Swift.String?
        /// The name of the constituent sub slot of the composite slot specified in slotToElicit that should be elicited from the user.
        public var subSlotToElicit: LexRuntimeV2ClientTypes.ElicitSubSlot?
        /// The next action that the bot should take in its interaction with the user. The possible values are:
        ///
        /// * Close - Indicates that there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.
        ///
        /// * ConfirmIntent - The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"
        ///
        /// * Delegate - The next action is determined by Amazon Lex V2.
        ///
        /// * ElicitIntent - The next action is to elicit an intent from the user.
        ///
        /// * ElicitSlot - The next action is to elicit a slot value from the user.
        /// This member is required.
        public var type: LexRuntimeV2ClientTypes.DialogActionType?

        public init (
            slotElicitationStyle: LexRuntimeV2ClientTypes.StyleType? = nil,
            slotToElicit: Swift.String? = nil,
            subSlotToElicit: LexRuntimeV2ClientTypes.ElicitSubSlot? = nil,
            type: LexRuntimeV2ClientTypes.DialogActionType? = nil
        )
        {
            self.slotElicitationStyle = slotElicitationStyle
            self.slotToElicit = slotToElicit
            self.subSlotToElicit = subSlotToElicit
            self.type = type
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum DialogActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case close
        case confirmIntent
        case delegate
        case elicitIntent
        case elicitSlot
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogActionType] {
            return [
                .close,
                .confirmIntent,
                .delegate,
                .elicitIntent,
                .elicitSlot,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .close: return "Close"
            case .confirmIntent: return "ConfirmIntent"
            case .delegate: return "Delegate"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.DisconnectionEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// A notification from the client that it is disconnecting from Amazon Lex V2. Sending a DisconnectionEvent event is optional, but can help identify a conversation in logs.
    public struct DisconnectionEvent: Swift.Equatable {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.ElicitSubSlot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case subSlotToElicit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subSlotToElicit = self.subSlotToElicit {
            try encodeContainer.encode(subSlotToElicit.value, forKey: .subSlotToElicit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subSlotToElicitDecoded = try containerValues.decodeIfPresent(Box<LexRuntimeV2ClientTypes.ElicitSubSlot>.self, forKey: .subSlotToElicit)
        subSlotToElicit = subSlotToElicitDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The specific constituent sub slot of the composite slot to elicit in dialog action.
    public struct ElicitSubSlot: Swift.Equatable {
        /// The name of the slot that should be elicited from the user.
        /// This member is required.
        public var name: Swift.String?
        /// The field is not supported.
        public var subSlotToElicit: Box<LexRuntimeV2ClientTypes.ElicitSubSlot>?

        public init (
            name: Swift.String? = nil,
            subSlotToElicit: Box<LexRuntimeV2ClientTypes.ElicitSubSlot>? = nil
        )
        {
            self.name = name
            self.subSlotToElicit = subSlotToElicit
        }
    }

}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The alias identifier in use for the bot that contains the session data.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that contains the session data.
    /// This member is required.
    public var botId: Swift.String?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// The identifier of the session to return.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
    public var interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    /// A list of messages that were last sent to the user. The messages are ordered based on the order that your returned the messages from your Lambda function or the order that messages are defined in the bot.
    public var messages: [LexRuntimeV2ClientTypes.Message]?
    /// The identifier of the returned session.
    public var sessionId: Swift.String?
    /// Represents the current state of the dialog between the user and the bot. You can use this to determine the progress of the conversation and what the next action might be.
    public var sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    let sessionId: Swift.String?
    let messages: [LexRuntimeV2ClientTypes.Message]?
    let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    let sessionState: LexRuntimeV2ClientTypes.SessionState?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretations
        case messages
        case sessionId
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
    }
}

extension LexRuntimeV2ClientTypes.HeartbeatEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Event that Amazon Lex V2 sends to indicate that the stream is still open between the client application and Amazon Lex V2
    public struct HeartbeatEvent: Swift.Equatable {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?

        public init (
            eventId: Swift.String? = nil
        )
        {
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.ImageResponseCard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buttons
        case imageUrl
        case subtitle
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for button0 in buttons {
                try buttonsContainer.encode(button0)
            }
        }
        if let imageUrl = self.imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Button?].self, forKey: .buttons)
        var buttonsDecoded0:[LexRuntimeV2ClientTypes.Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [LexRuntimeV2ClientTypes.Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// A card that is shown to the user by a messaging platform. You define the contents of the card, the card is displayed by the platform. When you use a response card, the response from the user is constrained to the text associated with a button on the card.
    public struct ImageResponseCard: Swift.Equatable {
        /// A list of buttons that should be displayed on the response card. The arrangement of the buttons is determined by the platform that displays the button.
        public var buttons: [LexRuntimeV2ClientTypes.Button]?
        /// The URL of an image to display on the response card. The image URL must be publicly available so that the platform displaying the response card has access to the image.
        public var imageUrl: Swift.String?
        /// The subtitle to display on the response card. The format of the subtitle is determined by the platform displaying the response card.
        public var subtitle: Swift.String?
        /// The title to display on the response card. The format of the title is determined by the platform displaying the response card.
        /// This member is required.
        public var title: Swift.String?

        public init (
            buttons: [LexRuntimeV2ClientTypes.Button]? = nil,
            imageUrl: Swift.String? = nil,
            subtitle: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum InputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dtmf
        case speech
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [InputMode] {
            return [
                .dtmf,
                .speech,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dtmf: return "DTMF"
            case .speech: return "Speech"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputMode(rawValue: rawValue) ?? InputMode.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.Intent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationState
        case name
        case slots
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationState = self.confirmationState {
            try encodeContainer.encode(confirmationState.rawValue, forKey: .confirmationState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, slots0) in slots {
                try slotsContainer.encode(slots0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: LexRuntimeV2ClientTypes.Slot?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:LexRuntimeV2ClientTypes.Slot]()
            for (key0, slot0) in slotsContainer {
                if let slot0 = slot0 {
                    slotsDecoded0?[key0] = slot0
                }
            }
        }
        slots = slotsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.IntentState.self, forKey: .state)
        state = stateDecoded
        let confirmationStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ConfirmationState.self, forKey: .confirmationState)
        confirmationState = confirmationStateDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The current intent that Amazon Lex V2 is attempting to fulfill.
    public struct Intent: Swift.Equatable {
        /// Contains information about whether fulfillment of the intent has been confirmed.
        public var confirmationState: LexRuntimeV2ClientTypes.ConfirmationState?
        /// The name of the intent.
        /// This member is required.
        public var name: Swift.String?
        /// A map of all of the slots for the intent. The name of the slot maps to the value of the slot. If a slot has not been filled, the value is null.
        public var slots: [Swift.String:LexRuntimeV2ClientTypes.Slot]?
        /// Contains fulfillment information for the intent.
        public var state: LexRuntimeV2ClientTypes.IntentState?

        public init (
            confirmationState: LexRuntimeV2ClientTypes.ConfirmationState? = nil,
            name: Swift.String? = nil,
            slots: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil,
            state: LexRuntimeV2ClientTypes.IntentState? = nil
        )
        {
            self.confirmationState = confirmationState
            self.name = name
            self.slots = slots
            self.state = state
        }
    }

}

extension LexRuntimeV2ClientTypes.IntentResultEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case inputMode
        case interpretations
        case requestAttributes
        case sessionId
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputMode = self.inputMode {
            try encodeContainer.encode(inputMode.rawValue, forKey: .inputMode)
        }
        if let interpretations = interpretations {
            var interpretationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .interpretations)
            for interpretation0 in interpretations {
                try interpretationsContainer.encode(interpretation0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputModeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.InputMode.self, forKey: .inputMode)
        inputMode = inputModeDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Contains the current state of the conversation between the client application and Amazon Lex V2.
    public struct IntentResultEvent: Swift.Equatable {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?
        /// Indicates whether the input to the operation was text or speech.
        public var inputMode: LexRuntimeV2ClientTypes.InputMode?
        /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
        public var interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
        /// The attributes sent in the request.
        public var requestAttributes: [Swift.String:Swift.String]?
        /// The identifier of the session in use.
        public var sessionId: Swift.String?
        /// The state of the user's session with Amazon Lex V2.
        public var sessionState: LexRuntimeV2ClientTypes.SessionState?

        public init (
            eventId: Swift.String? = nil,
            inputMode: LexRuntimeV2ClientTypes.InputMode? = nil,
            interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
            requestAttributes: [Swift.String:Swift.String]? = nil,
            sessionId: Swift.String? = nil,
            sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
        )
        {
            self.eventId = eventId
            self.inputMode = inputMode
            self.interpretations = interpretations
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum IntentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case fulfilled
        case fulfillmentInProgress
        case inProgress
        case readyForFulfillment
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentState] {
            return [
                .failed,
                .fulfilled,
                .fulfillmentInProgress,
                .inProgress,
                .readyForFulfillment,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .fulfillmentInProgress: return "FulfillmentInProgress"
            case .inProgress: return "InProgress"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentState(rawValue: rawValue) ?? IntentState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Interpretation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intent
        case nluConfidence
        case sentimentResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intent = self.intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let nluConfidence = self.nluConfidence {
            try encodeContainer.encode(nluConfidence, forKey: .nluConfidence)
        }
        if let sentimentResponse = self.sentimentResponse {
            try encodeContainer.encode(sentimentResponse, forKey: .sentimentResponse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nluConfidenceDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ConfidenceScore.self, forKey: .nluConfidence)
        nluConfidence = nluConfidenceDecoded
        let sentimentResponseDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentResponse.self, forKey: .sentimentResponse)
        sentimentResponse = sentimentResponseDecoded
        let intentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// An intent that Amazon Lex V2 determined might satisfy the user's utterance. The intents are ordered by the confidence score.
    public struct Interpretation: Swift.Equatable {
        /// A list of intents that might satisfy the user's utterance. The intents are ordered by the confidence score.
        public var intent: LexRuntimeV2ClientTypes.Intent?
        /// Determines the threshold where Amazon Lex V2 will insert the AMAZON.FallbackIntent, AMAZON.KendraSearchIntent, or both when returning alternative intents in a response. AMAZON.FallbackIntent and AMAZON.KendraSearchIntent are only inserted if they are configured for the bot.
        public var nluConfidence: LexRuntimeV2ClientTypes.ConfidenceScore?
        /// The sentiment expressed in an utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
        public var sentimentResponse: LexRuntimeV2ClientTypes.SentimentResponse?

        public init (
            intent: LexRuntimeV2ClientTypes.Intent? = nil,
            nluConfidence: LexRuntimeV2ClientTypes.ConfidenceScore? = nil,
            sentimentResponse: LexRuntimeV2ClientTypes.SentimentResponse? = nil
        )
        {
            self.intent = intent
            self.nluConfidence = nluConfidence
            self.sentimentResponse = sentimentResponse
        }
    }

}

extension LexRuntimeV2ClientTypes.Message: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case contentType
        case imageResponseCard
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let imageResponseCard = self.imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.MessageContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension LexRuntimeV2ClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(contentType: \(Swift.String(describing: contentType)), imageResponseCard: \(Swift.String(describing: imageResponseCard)), content: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeV2ClientTypes {
    /// Container for text that is returned to the customer..
    public struct Message: Swift.Equatable {
        /// The text of the message.
        public var content: Swift.String?
        /// Indicates the type of response.
        /// This member is required.
        public var contentType: LexRuntimeV2ClientTypes.MessageContentType?
        /// A card that is shown to the user by a messaging platform. You define the contents of the card, the card is displayed by the platform. When you use a response card, the response from the user is constrained to the text associated with a button on the card.
        public var imageResponseCard: LexRuntimeV2ClientTypes.ImageResponseCard?

        public init (
            content: Swift.String? = nil,
            contentType: LexRuntimeV2ClientTypes.MessageContentType? = nil,
            imageResponseCard: LexRuntimeV2ClientTypes.ImageResponseCard? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.imageResponseCard = imageResponseCard
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum MessageContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customPayload
        case imageResponseCard
        case plainText
        case ssml
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageContentType] {
            return [
                .customPayload,
                .imageResponseCard,
                .plainText,
                .ssml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customPayload: return "CustomPayload"
            case .imageResponseCard: return "ImageResponseCard"
            case .plainText: return "PlainText"
            case .ssml: return "SSML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageContentType(rawValue: rawValue) ?? MessageContentType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.PlaybackCompletionEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Event sent from the client application to Amazon Lex V2 to indicate that playback of audio is complete and that Amazon Lex V2 should start processing the user's input.
    public struct PlaybackCompletionEvent: Swift.Equatable {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.PlaybackInterruptionEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causedByEventId
        case eventId
        case eventReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causedByEventId = self.causedByEventId {
            try encodeContainer.encode(causedByEventId, forKey: .causedByEventId)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReason = self.eventReason {
            try encodeContainer.encode(eventReason.rawValue, forKey: .eventReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventReasonDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackInterruptionReason.self, forKey: .eventReason)
        eventReason = eventReasonDecoded
        let causedByEventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causedByEventId)
        causedByEventId = causedByEventIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Event sent from Amazon Lex V2 to indicate to the client application should stop playback of audio. For example, if the client is playing a prompt that asks for the user's telephone number, the user might start to say the phone number before the prompt is complete. Amazon Lex V2 sends this event to the client application to indicate that the user is responding and that Amazon Lex V2 is processing their input.
    public struct PlaybackInterruptionEvent: Swift.Equatable {
        /// The identifier of the event that contained the audio, DTMF, or text that caused the interruption.
        public var causedByEventId: Swift.String?
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?
        /// Indicates the type of user input that Amazon Lex V2 detected.
        public var eventReason: LexRuntimeV2ClientTypes.PlaybackInterruptionReason?

        public init (
            causedByEventId: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventReason: LexRuntimeV2ClientTypes.PlaybackInterruptionReason? = nil
        )
        {
            self.causedByEventId = causedByEventId
            self.eventId = eventId
            self.eventReason = eventReason
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum PlaybackInterruptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dtmfStartDetected
        case textDetected
        case voiceStartDetected
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaybackInterruptionReason] {
            return [
                .dtmfStartDetected,
                .textDetected,
                .voiceStartDetected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dtmfStartDetected: return "DTMF_START_DETECTED"
            case .textDetected: return "TEXT_DETECTED"
            case .voiceStartDetected: return "VOICE_START_DETECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaybackInterruptionReason(rawValue: rawValue) ?? PlaybackInterruptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PutSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for message0 in messages {
                try messagesContainer.encode(message0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }
}

extension PutSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let responseContentType = responseContentType {
            items.add(Header(name: "ResponseContentType", value: Swift.String(responseContentType)))
        }
        return items
    }
}

extension PutSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct PutSessionInput: Swift.Equatable {
    /// The alias identifier of the bot that receives the session data.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that receives the session data.
    /// This member is required.
    public var botId: Swift.String?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// A list of messages to send to the user. Messages are sent in the order that they are defined in the list.
    public var messages: [LexRuntimeV2ClientTypes.Message]?
    /// Request-specific information passed between Amazon Lex V2 and the client application. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:.
    public var requestAttributes: [Swift.String:Swift.String]?
    /// The message that Amazon Lex V2 returns in the response can be either text or speech depending on the value of this parameter.
    ///
    /// * If the value is text/plain; charset=utf-8, Amazon Lex V2 returns text in the response.
    public var responseContentType: Swift.String?
    /// The identifier of the session that receives the session data.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Sets the state of the session with the user. You can use this to set the current intent, attributes, context, and dialog action. Use the dialog action to determine the next step that Amazon Lex V2 should use in the conversation with the user.
    /// This member is required.
    public var sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        responseContentType: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionInputBody: Swift.Equatable {
    let messages: [LexRuntimeV2ClientTypes.Message]?
    let sessionState: LexRuntimeV2ClientTypes.SessionState?
    let requestAttributes: [Swift.String:Swift.String]?
}

extension PutSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension PutSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.audioStream = ByteStream.from(data: data)
        } else {
            self.audioStream = nil
        }
    }
}

public struct PutSessionOutputResponse: Swift.Equatable {
    /// If the requested content type was audio, the audio version of the message to convey to the user.
    public var audioStream: ClientRuntime.ByteStream?
    /// The type of response. Same as the type specified in the responseContentType field in the request.
    public var contentType: Swift.String?
    /// A list of messages that were last sent to the user. The messages are ordered based on how you return the messages from you Lambda function or the order that the messages are defined in the bot.
    public var messages: Swift.String?
    /// Request-specific information passed between the client application and Amazon Lex V2. These are the same as the requestAttribute parameter in the call to the PutSession operation.
    public var requestAttributes: Swift.String?
    /// The identifier of the session that received the data.
    public var sessionId: Swift.String?
    /// Represents the current state of the dialog between the user and the bot. Use this to determine the progress of the conversation and what the next action may be.
    public var sessionState: Swift.String?

    public init (
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        messages: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionOutputResponseBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension PutSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension RecognizeTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeTextInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), text: \"CONTENT_REDACTED\")"}
}

extension RecognizeTextInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension RecognizeTextInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/text"
    }
}

public struct RecognizeTextInput: Swift.Equatable {
    /// The alias identifier in use for the bot that processes the request.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that processes the request.
    /// This member is required.
    public var botId: Swift.String?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// Request-specific information passed between the client application and Amazon Lex V2 The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:.
    public var requestAttributes: [Swift.String:Swift.String]?
    /// The identifier of the user session that is having the conversation.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The current state of the dialog between the user and the bot.
    public var sessionState: LexRuntimeV2ClientTypes.SessionState?
    /// The text that the user entered. Amazon Lex V2 interprets this text.
    /// This member is required.
    public var text: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil,
        text: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
        self.text = text
    }
}

struct RecognizeTextInputBody: Swift.Equatable {
    let text: Swift.String?
    let sessionState: LexRuntimeV2ClientTypes.SessionState?
    let requestAttributes: [Swift.String:Swift.String]?
}

extension RecognizeTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension RecognizeTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RecognizeTextOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RecognizeTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.requestAttributes = output.requestAttributes
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.requestAttributes = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct RecognizeTextOutputResponse: Swift.Equatable {
    /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates now confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance.
    public var interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    /// A list of messages last sent to the user. The messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot.
    public var messages: [LexRuntimeV2ClientTypes.Message]?
    /// The attributes sent in the request.
    public var requestAttributes: [Swift.String:Swift.String]?
    /// The identifier of the session in use.
    public var sessionId: Swift.String?
    /// Represents the current state of the dialog between the user and the bot. Use this to determine the progress of the conversation and what the next action may be.
    public var sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeTextOutputResponseBody: Swift.Equatable {
    let messages: [LexRuntimeV2ClientTypes.Message]?
    let sessionState: LexRuntimeV2ClientTypes.SessionState?
    let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    let requestAttributes: [Swift.String:Swift.String]?
    let sessionId: Swift.String?
}

extension RecognizeTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretations
        case messages
        case requestAttributes
        case sessionId
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

public struct RecognizeUtteranceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeUtteranceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let inputStream = input.operationInput.inputStream {
            let inputStreamdata = inputStream
            let inputStreambody = ClientRuntime.HttpBody.stream(inputStreamdata)
            input.builder.withBody(inputStreambody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension RecognizeUtteranceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeUtteranceInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), inputStream: \(Swift.String(describing: inputStream)), localeId: \(Swift.String(describing: localeId)), requestContentType: \(Swift.String(describing: requestContentType)), responseContentType: \(Swift.String(describing: responseContentType)), sessionId: \(Swift.String(describing: sessionId)), requestAttributes: \"CONTENT_REDACTED\", sessionState: \"CONTENT_REDACTED\")"}
}

extension RecognizeUtteranceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStream = self.inputStream {
            try encodeContainer.encode(inputStream.toBytes().getData(), forKey: .inputStream)
        }
    }
}

extension RecognizeUtteranceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let requestAttributes = requestAttributes {
            items.add(Header(name: "x-amz-lex-request-attributes", value: Swift.String(requestAttributes)))
        }
        if let requestContentType = requestContentType {
            items.add(Header(name: "Content-Type", value: Swift.String(requestContentType)))
        }
        if let responseContentType = responseContentType {
            items.add(Header(name: "Response-Content-Type", value: Swift.String(responseContentType)))
        }
        if let sessionState = sessionState {
            items.add(Header(name: "x-amz-lex-session-state", value: Swift.String(sessionState)))
        }
        return items
    }
}

extension RecognizeUtteranceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/utterance"
    }
}

public struct RecognizeUtteranceInput: Swift.Equatable {
    /// The alias identifier in use for the bot that should receive the request.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot that should receive the request.
    /// This member is required.
    public var botId: Swift.String?
    /// User input in PCM or Opus audio format or text format as described in the requestContentType parameter.
    public var inputStream: ClientRuntime.ByteStream?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// Request-specific information passed between the client application and Amazon Lex V2 The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes for prefix x-amz-lex:. The requestAttributes field must be compressed using gzip and then base64 encoded before sending to Amazon Lex V2.
    public var requestAttributes: Swift.String?
    /// Indicates the format for audio input or that the content is text. The header must start with one of the following prefixes:
    ///
    /// * PCM format, audio data must be in little-endian byte order.
    ///
    /// * audio/l16; rate=16000; channels=1
    ///
    /// * audio/x-l16; sample-rate=16000; channel-count=1
    ///
    /// * audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
    ///
    ///
    ///
    ///
    /// * Opus format
    ///
    /// * audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4
    ///
    ///
    ///
    ///
    /// * Text format
    ///
    /// * text/plain; charset=utf-8
    /// This member is required.
    public var requestContentType: Swift.String?
    /// The message that Amazon Lex V2 returns in the response can be either text or speech based on the responseContentType value.
    ///
    /// * If the value is text/plain;charset=utf-8, Amazon Lex V2 returns text in the response.
    ///
    /// * If the value begins with audio/, Amazon Lex V2 returns speech in the response. Amazon Lex V2 uses Amazon Polly to generate the speech using the configuration that you specified in the requestContentType parameter. For example, if you specify audio/mpeg as the value, Amazon Lex V2 returns speech in the MPEG format.
    ///
    /// * If the value is audio/pcm, the speech returned is audio/pcm at 16 KHz in 16-bit, little-endian format.
    ///
    /// * The following are the accepted values:
    ///
    /// * audio/mpeg
    ///
    /// * audio/ogg
    ///
    /// * audio/pcm (16 KHz)
    ///
    /// * audio/* (defaults to mpeg)
    ///
    /// * text/plain; charset=utf-8
    public var responseContentType: Swift.String?
    /// The identifier of the session in use.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Sets the state of the session with the user. You can use this to set the current intent, attributes, context, and dialog action. Use the dialog action to determine the next step that Amazon Lex V2 should use in the conversation with the user. The sessionState field must be compressed using gzip and then base64 encoded before sending to Amazon Lex V2.
    public var sessionState: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        inputStream: ClientRuntime.ByteStream? = nil,
        localeId: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        requestContentType: Swift.String? = nil,
        responseContentType: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.inputStream = inputStream
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.requestContentType = requestContentType
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceInputBody: Swift.Equatable {
    let inputStream: ClientRuntime.ByteStream?
}

extension RecognizeUtteranceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .inputStream)
        inputStream = inputStreamDecoded
    }
}

extension RecognizeUtteranceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeUtteranceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RecognizeUtteranceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeUtteranceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let inputModeHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-mode") {
            self.inputMode = inputModeHeaderValue
        } else {
            self.inputMode = nil
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            self.inputTranscript = inputTranscriptHeaderValue
        } else {
            self.inputTranscript = nil
        }
        if let interpretationsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-interpretations") {
            self.interpretations = interpretationsHeaderValue
        } else {
            self.interpretations = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.audioStream = ByteStream.from(data: data)
        } else {
            self.audioStream = nil
        }
    }
}

public struct RecognizeUtteranceOutputResponse: Swift.Equatable {
    /// The prompt or statement to send to the user. This is based on the bot configuration and context. For example, if Amazon Lex V2 did not understand the user intent, it sends the clarificationPrompt configured for the bot. If the intent requires confirmation before taking the fulfillment action, it sends the confirmationPrompt. Another example: Suppose that the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. Then Amazon Lex V2 sends that message in the response.
    public var audioStream: ClientRuntime.ByteStream?
    /// Content type as specified in the responseContentType in the request.
    public var contentType: Swift.String?
    /// Indicates whether the input mode to the operation was text or speech.
    public var inputMode: Swift.String?
    /// The text used to process the request. If the input was an audio stream, the inputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex V2 is correctly processing the audio that you send. The inputTranscript field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
    public var inputTranscript: Swift.String?
    /// A list of intents that Amazon Lex V2 determined might satisfy the user's utterance. Each interpretation includes the intent, a score that indicates how confident Amazon Lex V2 is that the interpretation is the correct one, and an optional sentiment response that indicates the sentiment expressed in the utterance. The interpretations field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
    public var interpretations: Swift.String?
    /// A list of messages that were last sent to the user. The messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot. The messages field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
    public var messages: Swift.String?
    /// The attributes sent in the request. The requestAttributes field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents.
    public var requestAttributes: Swift.String?
    /// The identifier of the session in use.
    public var sessionId: Swift.String?
    /// Represents the current state of the dialog between the user and the bot. Use this to determine the progress of the conversation and what the next action might be. The sessionState field is compressed with gzip and then base64 encoded. Before you can use the contents of the field, you must decode and decompress the contents. See the example for a simple function to decode and decompress the contents.
    public var sessionState: Swift.String?

    public init (
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        inputMode: Swift.String? = nil,
        inputTranscript: Swift.String? = nil,
        interpretations: Swift.String? = nil,
        messages: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.inputMode = inputMode
        self.inputTranscript = inputTranscript
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceOutputResponseBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension RecognizeUtteranceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension ResourceNotFoundException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.RuntimeHintDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeHintValues
        case subSlotHints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runtimeHintValues = runtimeHintValues {
            var runtimeHintValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeHintValues)
            for runtimehintvalue0 in runtimeHintValues {
                try runtimeHintValuesContainer.encode(runtimehintvalue0)
            }
        }
        if let subSlotHints = subSlotHints {
            var subSlotHintsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .subSlotHints)
            for (dictKey0, slotHintsSlotMap0) in subSlotHints {
                try subSlotHintsContainer.encode(slotHintsSlotMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeHintValuesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.RuntimeHintValue?].self, forKey: .runtimeHintValues)
        var runtimeHintValuesDecoded0:[LexRuntimeV2ClientTypes.RuntimeHintValue]? = nil
        if let runtimeHintValuesContainer = runtimeHintValuesContainer {
            runtimeHintValuesDecoded0 = [LexRuntimeV2ClientTypes.RuntimeHintValue]()
            for structure0 in runtimeHintValuesContainer {
                if let structure0 = structure0 {
                    runtimeHintValuesDecoded0?.append(structure0)
                }
            }
        }
        runtimeHintValues = runtimeHintValuesDecoded0
        let subSlotHintsContainer = try containerValues.decodeIfPresent([Swift.String: LexRuntimeV2ClientTypes.RuntimeHintDetails?].self, forKey: .subSlotHints)
        var subSlotHintsDecoded0: [Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]? = nil
        if let subSlotHintsContainer = subSlotHintsContainer {
            subSlotHintsDecoded0 = [Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]()
            for (key0, runtimehintdetails0) in subSlotHintsContainer {
                if let runtimehintdetails0 = runtimehintdetails0 {
                    subSlotHintsDecoded0?[key0] = runtimehintdetails0
                }
            }
        }
        subSlotHints = subSlotHintsDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// Provides an array of phrases that should be given preference when resolving values for a slot.
    public struct RuntimeHintDetails: Swift.Equatable {
        /// One or more strings that Amazon Lex V2 should look for in the input to the bot. Each phrase is given preference when deciding on slot values.
        public var runtimeHintValues: [LexRuntimeV2ClientTypes.RuntimeHintValue]?
        /// A map of constituent sub slot names inside a composite slot in the intent and the phrases that should be added for each sub slot. Inside each composite slot hints, this structure provides a mechanism to add granular sub slot phrases. Only sub slot hints are supported for composite slots. The intent name, composite slot name and the constituent sub slot names must exist.
        public var subSlotHints: [Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]?

        public init (
            runtimeHintValues: [LexRuntimeV2ClientTypes.RuntimeHintValue]? = nil,
            subSlotHints: [Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]? = nil
        )
        {
            self.runtimeHintValues = runtimeHintValues
            self.subSlotHints = subSlotHints
        }
    }

}

extension LexRuntimeV2ClientTypes.RuntimeHintValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phrase
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phrase = self.phrase {
            try encodeContainer.encode(phrase, forKey: .phrase)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phrase)
        phrase = phraseDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Provides the phrase that Amazon Lex V2 should look for in the user's input to the bot.
    public struct RuntimeHintValue: Swift.Equatable {
        /// The phrase that Amazon Lex V2 should look for in the user's input to the bot.
        /// This member is required.
        public var phrase: Swift.String?

        public init (
            phrase: Swift.String? = nil
        )
        {
            self.phrase = phrase
        }
    }

}

extension LexRuntimeV2ClientTypes.RuntimeHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotHints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotHints = slotHints {
            var slotHintsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slotHints)
            for (dictKey0, slotHintsIntentMap0) in slotHints {
                var slotHintsIntentMap0Container = slotHintsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, slotHintsSlotMap1) in slotHintsIntentMap0 {
                    try slotHintsIntentMap0Container.encode(slotHintsSlotMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let slotHintsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: LexRuntimeV2ClientTypes.RuntimeHintDetails?]?].self, forKey: .slotHints)
        var slotHintsDecoded0: [Swift.String:[Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]]? = nil
        if let slotHintsContainer = slotHintsContainer {
            slotHintsDecoded0 = [Swift.String:[Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]]()
            for (key0, slothintsslotmap0) in slotHintsContainer {
                var slothintsslotmap0Decoded0: [Swift.String: LexRuntimeV2ClientTypes.RuntimeHintDetails]? = nil
                if let slothintsslotmap0 = slothintsslotmap0 {
                    slothintsslotmap0Decoded0 = [Swift.String: LexRuntimeV2ClientTypes.RuntimeHintDetails]()
                    for (key1, runtimehintdetails1) in slothintsslotmap0 {
                        if let runtimehintdetails1 = runtimehintdetails1 {
                            slothintsslotmap0Decoded0?[key1] = runtimehintdetails1
                        }
                    }
                }
                slotHintsDecoded0?[key0] = slothintsslotmap0Decoded0
            }
        }
        slotHints = slotHintsDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// You can provide Amazon Lex V2 with hints to the phrases that a customer is likely to use for a slot. When a slot with hints is resolved, the phrases in the runtime hints are preferred in the resolution. You can provide hints for a maximum of 100 intents. You can provide a maximum of 100 slots. Before you can use runtime hints with an existing bot, you must first rebuild the bot. For more information, see [Using runtime hints to improve recognition of slot values](https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.html).
    public struct RuntimeHints: Swift.Equatable {
        /// A list of the slots in the intent that should have runtime hints added, and the phrases that should be added for each slot. The first level of the slotHints map is the name of the intent. The second level is the name of the slot within the intent. For more information, see [Using hints to improve accuracy](https://docs.aws.amazon.com/lexv2/latest/dg/using-hints.html). The intent name and slot name must exist.
        public var slotHints: [Swift.String:[Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]]?

        public init (
            slotHints: [Swift.String:[Swift.String:LexRuntimeV2ClientTypes.RuntimeHintDetails]]? = nil
        )
        {
            self.slotHints = slotHints
        }
    }

}

extension LexRuntimeV2ClientTypes.SentimentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sentiment
        case sentimentScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sentiment = self.sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
        if let sentimentScore = self.sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentType.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentScore.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Provides information about the sentiment expressed in a user's response in a conversation. Sentiments are determined using Amazon Comprehend. Sentiments are only returned if they are enabled for the bot. For more information, see [ Determine Sentiment ](https://docs.aws.amazon.com/comprehend/latest/dg/how-sentiment.html) in the Amazon Comprehend developer guide.
    public struct SentimentResponse: Swift.Equatable {
        /// The overall sentiment expressed in the user's response. This is the sentiment most likely expressed by the user based on the analysis by Amazon Comprehend.
        public var sentiment: LexRuntimeV2ClientTypes.SentimentType?
        /// The individual sentiment responses for the utterance.
        public var sentimentScore: LexRuntimeV2ClientTypes.SentimentScore?

        public init (
            sentiment: LexRuntimeV2ClientTypes.SentimentType? = nil,
            sentimentScore: LexRuntimeV2ClientTypes.SentimentScore? = nil
        )
        {
            self.sentiment = sentiment
            self.sentimentScore = sentimentScore
        }
    }

}

extension LexRuntimeV2ClientTypes.SentimentScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mixed
        case negative
        case neutral
        case positive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mixed != 0.0 {
            try encodeContainer.encode(mixed, forKey: .mixed)
        }
        if negative != 0.0 {
            try encodeContainer.encode(negative, forKey: .negative)
        }
        if neutral != 0.0 {
            try encodeContainer.encode(neutral, forKey: .neutral)
        }
        if positive != 0.0 {
            try encodeContainer.encode(positive, forKey: .positive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positiveDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .positive) ?? 0.0
        positive = positiveDecoded
        let negativeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .negative) ?? 0.0
        negative = negativeDecoded
        let neutralDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .neutral) ?? 0.0
        neutral = neutralDecoded
        let mixedDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .mixed) ?? 0.0
        mixed = mixedDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The individual sentiment responses for the utterance.
    public struct SentimentScore: Swift.Equatable {
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the MIXED sentiment.
        public var mixed: Swift.Double
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the NEGATIVE sentiment.
        public var negative: Swift.Double
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the NEUTRAL sentiment.
        public var neutral: Swift.Double
        /// The level of confidence that Amazon Comprehend has in the accuracy of its detection of the POSITIVE sentiment.
        public var positive: Swift.Double

        public init (
            mixed: Swift.Double = 0.0,
            negative: Swift.Double = 0.0,
            neutral: Swift.Double = 0.0,
            positive: Swift.Double = 0.0
        )
        {
            self.mixed = mixed
            self.negative = negative
            self.neutral = neutral
            self.positive = positive
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum SentimentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mixed
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentType] {
            return [
                .mixed,
                .negative,
                .neutral,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mixed: return "MIXED"
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SentimentType(rawValue: rawValue) ?? SentimentType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.SessionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case dialogAction
        case intent
        case originatingRequestId
        case runtimeHints
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontext0 in activeContexts {
                try activeContextsContainer.encode(activecontext0)
            }
        }
        if let dialogAction = self.dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let intent = self.intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let originatingRequestId = self.originatingRequestId {
            try encodeContainer.encode(originatingRequestId, forKey: .originatingRequestId)
        }
        if let runtimeHints = self.runtimeHints {
            try encodeContainer.encode(runtimeHints, forKey: .runtimeHints)
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialogActionDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let intentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeV2ClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeV2ClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let originatingRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originatingRequestId)
        originatingRequestId = originatingRequestIdDecoded
        let runtimeHintsDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.RuntimeHints.self, forKey: .runtimeHints)
        runtimeHints = runtimeHintsDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The state of the user's session with Amazon Lex V2.
    public struct SessionState: Swift.Equatable {
        /// One or more contexts that indicate to Amazon Lex V2 the context of a request. When a context is active, Amazon Lex V2 considers intents with the matching context as a trigger as the next intent in a session.
        public var activeContexts: [LexRuntimeV2ClientTypes.ActiveContext]?
        /// The next step that Amazon Lex V2 should take in the conversation with a user.
        public var dialogAction: LexRuntimeV2ClientTypes.DialogAction?
        /// The active intent that Amazon Lex V2 is processing.
        public var intent: LexRuntimeV2ClientTypes.Intent?
        /// A unique identifier for a specific request.
        public var originatingRequestId: Swift.String?
        /// Hints for phrases that a customer is likely to use for a slot. Amazon Lex V2 uses the hints to help determine the correct value of a slot.
        public var runtimeHints: LexRuntimeV2ClientTypes.RuntimeHints?
        /// Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex V2 and a client application.
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init (
            activeContexts: [LexRuntimeV2ClientTypes.ActiveContext]? = nil,
            dialogAction: LexRuntimeV2ClientTypes.DialogAction? = nil,
            intent: LexRuntimeV2ClientTypes.Intent? = nil,
            originatingRequestId: Swift.String? = nil,
            runtimeHints: LexRuntimeV2ClientTypes.RuntimeHints? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeContexts = activeContexts
            self.dialogAction = dialogAction
            self.intent = intent
            self.originatingRequestId = originatingRequestId
            self.runtimeHints = runtimeHints
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum Shape: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case composite
        case list
        case scalar
        case sdkUnknown(Swift.String)

        public static var allCases: [Shape] {
            return [
                .composite,
                .list,
                .scalar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .composite: return "Composite"
            case .list: return "List"
            case .scalar: return "Scalar"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Shape(rawValue: rawValue) ?? Shape.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.Slot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shape
        case subSlots
        case value
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shape = self.shape {
            try encodeContainer.encode(shape.rawValue, forKey: .shape)
        }
        if let subSlots = subSlots {
            var subSlotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .subSlots)
            for (dictKey0, slots0) in subSlots {
                try subSlotsContainer.encode(slots0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for slot0 in values {
                try valuesContainer.encode(slot0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Value.self, forKey: .value)
        value = valueDecoded
        let shapeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Shape.self, forKey: .shape)
        shape = shapeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Slot?].self, forKey: .values)
        var valuesDecoded0:[LexRuntimeV2ClientTypes.Slot]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [LexRuntimeV2ClientTypes.Slot]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let subSlotsContainer = try containerValues.decodeIfPresent([Swift.String: LexRuntimeV2ClientTypes.Slot?].self, forKey: .subSlots)
        var subSlotsDecoded0: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil
        if let subSlotsContainer = subSlotsContainer {
            subSlotsDecoded0 = [Swift.String:LexRuntimeV2ClientTypes.Slot]()
            for (key0, slot0) in subSlotsContainer {
                if let slot0 = slot0 {
                    subSlotsDecoded0?[key0] = slot0
                }
            }
        }
        subSlots = subSlotsDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// A value that Amazon Lex V2 uses to fulfill an intent.
    public struct Slot: Swift.Equatable {
        /// When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        public var shape: LexRuntimeV2ClientTypes.Shape?
        /// The constituent sub slots of a composite slot.
        public var subSlots: [Swift.String:LexRuntimeV2ClientTypes.Slot]?
        /// The current value of the slot.
        public var value: LexRuntimeV2ClientTypes.Value?
        /// A list of one or more values that the user provided for the slot. For example, if a for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        public var values: [LexRuntimeV2ClientTypes.Slot]?

        public init (
            shape: LexRuntimeV2ClientTypes.Shape? = nil,
            subSlots: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil,
            value: LexRuntimeV2ClientTypes.Value? = nil,
            values: [LexRuntimeV2ClientTypes.Slot]? = nil
        )
        {
            self.shape = shape
            self.subSlots = subSlots
            self.value = value
            self.values = values
        }
    }

}

public struct StartConversationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartConversationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartConversationInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<StartConversationOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let requestEventStream = input.operationInput.requestEventStream {
                let requestEventStreamdata = try encoder.encode(requestEventStream)
                let requestEventStreambody = ClientRuntime.HttpBody.data(requestEventStreamdata)
                input.builder.withBody(requestEventStreambody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let requestEventStreamdata = "{}".data(using: .utf8)!
                    let requestEventStreambody = ClientRuntime.HttpBody.data(requestEventStreamdata)
                    input.builder.withBody(requestEventStreambody)
                }
            }
        } catch let err {
            throw SdkError<StartConversationOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartConversationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension StartConversationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestEventStream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestEventStream = self.requestEventStream {
            try encodeContainer.encode(requestEventStream, forKey: .requestEventStream)
        }
    }
}

extension StartConversationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let conversationMode = conversationMode {
            items.add(Header(name: "x-amz-lex-conversation-mode", value: Swift.String(conversationMode.rawValue)))
        }
        return items
    }
}

extension StartConversationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botId = botId else {
            return nil
        }
        guard let botAliasId = botAliasId else {
            return nil
        }
        guard let localeId = localeId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/bots/\(botId.urlPercentEncoding())/botAliases/\(botAliasId.urlPercentEncoding())/botLocales/\(localeId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/conversation"
    }
}

public struct StartConversationInput: Swift.Equatable {
    /// The alias identifier in use for the bot that processes the request.
    /// This member is required.
    public var botAliasId: Swift.String?
    /// The identifier of the bot to process the request.
    /// This member is required.
    public var botId: Swift.String?
    /// The conversation type that you are using the Amazon Lex V2. If the conversation mode is AUDIO you can send both audio and DTMF information. If the mode is TEXT you can only send text.
    public var conversationMode: LexRuntimeV2ClientTypes.ConversationMode?
    /// The locale where the session is in use.
    /// This member is required.
    public var localeId: Swift.String?
    /// Represents the stream of events to Amazon Lex V2 from your application. The events are encoded as HTTP/2 data frames.
    /// This member is required.
    public var requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream?
    /// The identifier of the user session that is having the conversation.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        conversationMode: LexRuntimeV2ClientTypes.ConversationMode? = nil,
        localeId: Swift.String? = nil,
        requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.conversationMode = conversationMode
        self.localeId = localeId
        self.requestEventStream = requestEventStream
        self.sessionId = sessionId
    }
}

struct StartConversationInputBody: Swift.Equatable {
    let requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream?
}

extension StartConversationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestEventStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestEventStreamDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.StartConversationRequestEventStream.self, forKey: .requestEventStream)
        requestEventStream = requestEventStreamDecoded
    }
}

extension StartConversationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConversationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartConversationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConversationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: LexRuntimeV2ClientTypes.StartConversationResponseEventStream = try responseDecoder.decode(responseBody: data)
                self.responseEventStream = output
            } else {
                self.responseEventStream = nil
            }
        } else {
            self.responseEventStream = nil
        }
    }
}

public struct StartConversationOutputResponse: Swift.Equatable {
    /// Represents the stream of events from Amazon Lex V2 to your application. The events are encoded as HTTP/2 data frames.
    public var responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream?

    public init (
        responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream? = nil
    )
    {
        self.responseEventStream = responseEventStream
    }
}

struct StartConversationOutputResponseBody: Swift.Equatable {
    let responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream?
}

extension StartConversationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseEventStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseEventStreamDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.StartConversationResponseEventStream.self, forKey: .responseEventStream)
        responseEventStream = responseEventStreamDecoded
    }
}

extension LexRuntimeV2ClientTypes.StartConversationRequestEventStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioinputevent = "AudioInputEvent"
        case configurationevent = "ConfigurationEvent"
        case dtmfinputevent = "DTMFInputEvent"
        case disconnectionevent = "DisconnectionEvent"
        case playbackcompletionevent = "PlaybackCompletionEvent"
        case textinputevent = "TextInputEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .audioinputevent(audioinputevent):
                try container.encode(audioinputevent, forKey: .audioinputevent)
            case let .configurationevent(configurationevent):
                try container.encode(configurationevent, forKey: .configurationevent)
            case let .dtmfinputevent(dtmfinputevent):
                try container.encode(dtmfinputevent, forKey: .dtmfinputevent)
            case let .disconnectionevent(disconnectionevent):
                try container.encode(disconnectionevent, forKey: .disconnectionevent)
            case let .playbackcompletionevent(playbackcompletionevent):
                try container.encode(playbackcompletionevent, forKey: .playbackcompletionevent)
            case let .textinputevent(textinputevent):
                try container.encode(textinputevent, forKey: .textinputevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let configurationeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.ConfigurationEvent.self, forKey: .configurationevent)
        if let configurationevent = configurationeventDecoded {
            self = .configurationevent(configurationevent)
            return
        }
        let audioinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.AudioInputEvent.self, forKey: .audioinputevent)
        if let audioinputevent = audioinputeventDecoded {
            self = .audioinputevent(audioinputevent)
            return
        }
        let dtmfinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.DTMFInputEvent.self, forKey: .dtmfinputevent)
        if let dtmfinputevent = dtmfinputeventDecoded {
            self = .dtmfinputevent(dtmfinputevent)
            return
        }
        let textinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TextInputEvent.self, forKey: .textinputevent)
        if let textinputevent = textinputeventDecoded {
            self = .textinputevent(textinputevent)
            return
        }
        let playbackcompletioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackCompletionEvent.self, forKey: .playbackcompletionevent)
        if let playbackcompletionevent = playbackcompletioneventDecoded {
            self = .playbackcompletionevent(playbackcompletionevent)
            return
        }
        let disconnectioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.DisconnectionEvent.self, forKey: .disconnectionevent)
        if let disconnectionevent = disconnectioneventDecoded {
            self = .disconnectionevent(disconnectionevent)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LexRuntimeV2ClientTypes {
    /// Represents a stream of events between your application and Amazon Lex V2.
    public enum StartConversationRequestEventStream: Swift.Equatable {
        /// Configuration information sent from your client application to Amazon Lex V2
        case configurationevent(LexRuntimeV2ClientTypes.ConfigurationEvent)
        /// Speech audio sent from your client application to Amazon Lex V2. Audio starts accumulating when Amazon Lex V2 identifies a voice and continues until a natural pause in the speech is found before processing.
        case audioinputevent(LexRuntimeV2ClientTypes.AudioInputEvent)
        /// DTMF information sent to Amazon Lex V2 by your application. Amazon Lex V2 accumulates the DMTF information from when the user sends the first character and ends
        ///
        /// * when there's a pause longer that the value configured for the end timeout.
        ///
        /// * when there's a digit that is the configured end character.
        ///
        /// * when Amazon Lex V2 accumulates characters equal to the maximum DTMF character configuration.
        case dtmfinputevent(LexRuntimeV2ClientTypes.DTMFInputEvent)
        /// Text sent from your client application to Amazon Lex V2. Each TextInputEvent is processed individually.
        case textinputevent(LexRuntimeV2ClientTypes.TextInputEvent)
        /// Event sent from the client application to Amazon Lex V2 to indicate that it has finished playing audio and that Amazon Lex V2 should start listening for user input.
        case playbackcompletionevent(LexRuntimeV2ClientTypes.PlaybackCompletionEvent)
        /// Event sent from the client application to indicate to Amazon Lex V2 that the conversation is over.
        case disconnectionevent(LexRuntimeV2ClientTypes.DisconnectionEvent)
        case sdkUnknown(Swift.String)
    }

}

extension LexRuntimeV2ClientTypes.StartConversationResponseEventStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessdeniedexception = "AccessDeniedException"
        case audioresponseevent = "AudioResponseEvent"
        case badgatewayexception = "BadGatewayException"
        case conflictexception = "ConflictException"
        case dependencyfailedexception = "DependencyFailedException"
        case heartbeatevent = "HeartbeatEvent"
        case intentresultevent = "IntentResultEvent"
        case internalserverexception = "InternalServerException"
        case playbackinterruptionevent = "PlaybackInterruptionEvent"
        case resourcenotfoundexception = "ResourceNotFoundException"
        case textresponseevent = "TextResponseEvent"
        case throttlingexception = "ThrottlingException"
        case transcriptevent = "TranscriptEvent"
        case validationexception = "ValidationException"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accessdeniedexception(accessdeniedexception):
                try container.encode(accessdeniedexception, forKey: .accessdeniedexception)
            case let .audioresponseevent(audioresponseevent):
                try container.encode(audioresponseevent, forKey: .audioresponseevent)
            case let .badgatewayexception(badgatewayexception):
                try container.encode(badgatewayexception, forKey: .badgatewayexception)
            case let .conflictexception(conflictexception):
                try container.encode(conflictexception, forKey: .conflictexception)
            case let .dependencyfailedexception(dependencyfailedexception):
                try container.encode(dependencyfailedexception, forKey: .dependencyfailedexception)
            case let .heartbeatevent(heartbeatevent):
                try container.encode(heartbeatevent, forKey: .heartbeatevent)
            case let .intentresultevent(intentresultevent):
                try container.encode(intentresultevent, forKey: .intentresultevent)
            case let .internalserverexception(internalserverexception):
                try container.encode(internalserverexception, forKey: .internalserverexception)
            case let .playbackinterruptionevent(playbackinterruptionevent):
                try container.encode(playbackinterruptionevent, forKey: .playbackinterruptionevent)
            case let .resourcenotfoundexception(resourcenotfoundexception):
                try container.encode(resourcenotfoundexception, forKey: .resourcenotfoundexception)
            case let .textresponseevent(textresponseevent):
                try container.encode(textresponseevent, forKey: .textresponseevent)
            case let .throttlingexception(throttlingexception):
                try container.encode(throttlingexception, forKey: .throttlingexception)
            case let .transcriptevent(transcriptevent):
                try container.encode(transcriptevent, forKey: .transcriptevent)
            case let .validationexception(validationexception):
                try container.encode(validationexception, forKey: .validationexception)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let playbackinterruptioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackInterruptionEvent.self, forKey: .playbackinterruptionevent)
        if let playbackinterruptionevent = playbackinterruptioneventDecoded {
            self = .playbackinterruptionevent(playbackinterruptionevent)
            return
        }
        let transcripteventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TranscriptEvent.self, forKey: .transcriptevent)
        if let transcriptevent = transcripteventDecoded {
            self = .transcriptevent(transcriptevent)
            return
        }
        let intentresulteventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.IntentResultEvent.self, forKey: .intentresultevent)
        if let intentresultevent = intentresulteventDecoded {
            self = .intentresultevent(intentresultevent)
            return
        }
        let textresponseeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TextResponseEvent.self, forKey: .textresponseevent)
        if let textresponseevent = textresponseeventDecoded {
            self = .textresponseevent(textresponseevent)
            return
        }
        let audioresponseeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.AudioResponseEvent.self, forKey: .audioresponseevent)
        if let audioresponseevent = audioresponseeventDecoded {
            self = .audioresponseevent(audioresponseevent)
            return
        }
        let heartbeateventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.HeartbeatEvent.self, forKey: .heartbeatevent)
        if let heartbeatevent = heartbeateventDecoded {
            self = .heartbeatevent(heartbeatevent)
            return
        }
        let accessdeniedexceptionDecoded = try values.decodeIfPresent(AccessDeniedException.self, forKey: .accessdeniedexception)
        if let accessdeniedexception = accessdeniedexceptionDecoded {
            self = .accessdeniedexception(accessdeniedexception)
            return
        }
        let resourcenotfoundexceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourcenotfoundexception)
        if let resourcenotfoundexception = resourcenotfoundexceptionDecoded {
            self = .resourcenotfoundexception(resourcenotfoundexception)
            return
        }
        let validationexceptionDecoded = try values.decodeIfPresent(ValidationException.self, forKey: .validationexception)
        if let validationexception = validationexceptionDecoded {
            self = .validationexception(validationexception)
            return
        }
        let throttlingexceptionDecoded = try values.decodeIfPresent(ThrottlingException.self, forKey: .throttlingexception)
        if let throttlingexception = throttlingexceptionDecoded {
            self = .throttlingexception(throttlingexception)
            return
        }
        let internalserverexceptionDecoded = try values.decodeIfPresent(InternalServerException.self, forKey: .internalserverexception)
        if let internalserverexception = internalserverexceptionDecoded {
            self = .internalserverexception(internalserverexception)
            return
        }
        let conflictexceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictexception)
        if let conflictexception = conflictexceptionDecoded {
            self = .conflictexception(conflictexception)
            return
        }
        let dependencyfailedexceptionDecoded = try values.decodeIfPresent(DependencyFailedException.self, forKey: .dependencyfailedexception)
        if let dependencyfailedexception = dependencyfailedexceptionDecoded {
            self = .dependencyfailedexception(dependencyfailedexception)
            return
        }
        let badgatewayexceptionDecoded = try values.decodeIfPresent(BadGatewayException.self, forKey: .badgatewayexception)
        if let badgatewayexception = badgatewayexceptionDecoded {
            self = .badgatewayexception(badgatewayexception)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LexRuntimeV2ClientTypes {
    /// Represents a stream of events between Amazon Lex V2 and your application.
    public enum StartConversationResponseEventStream: Swift.Equatable {
        /// Event sent from Amazon Lex V2 to indicate to the client application should stop playback of audio. For example, if the client is playing a prompt that asks for the user's telephone number, the user might start to say the phone number before the prompt is complete. Amazon Lex V2 sends this event to the client application to indicate that the user is responding and that Amazon Lex V2 is processing their input.
        case playbackinterruptionevent(LexRuntimeV2ClientTypes.PlaybackInterruptionEvent)
        /// Event sent from Amazon Lex V2 to your client application that contains a transcript of voice audio.
        case transcriptevent(LexRuntimeV2ClientTypes.TranscriptEvent)
        /// Event sent from Amazon Lex V2 to the client application containing the current state of the conversation between the user and Amazon Lex V2.
        case intentresultevent(LexRuntimeV2ClientTypes.IntentResultEvent)
        /// The event sent from Amazon Lex V2 to your application with text to present to the user.
        case textresponseevent(LexRuntimeV2ClientTypes.TextResponseEvent)
        /// An event sent from Amazon Lex V2 to your client application containing audio to play to the user.
        case audioresponseevent(LexRuntimeV2ClientTypes.AudioResponseEvent)
        /// Event that Amazon Lex V2 sends to indicate that the stream is still open between the client application and Amazon Lex V2
        case heartbeatevent(LexRuntimeV2ClientTypes.HeartbeatEvent)
        /// Exception thrown when the credentials passed with the request are invalid or expired. Also thrown when the credentials in the request do not have permission to access the StartConversation operation.
        case accessdeniedexception(AccessDeniedException)
        /// Exception thrown if one of the input parameters points to a resource that does not exist. For example, if the bot ID specified does not exist.
        case resourcenotfoundexception(ResourceNotFoundException)
        /// Exception thrown when one or more parameters could not be validated. The message contains the name of the field that isn't valid.
        case validationexception(ValidationException)
        /// Exception thrown when your application exceeds the maximum number of concurrent requests.
        case throttlingexception(ThrottlingException)
        /// An error occurred with Amazon Lex V2.
        case internalserverexception(InternalServerException)
        /// Exception thrown when two clients are using the same AWS account, Amazon Lex V2 bot, and session ID.
        case conflictexception(ConflictException)
        ///
        case dependencyfailedexception(DependencyFailedException)
        ///
        case badgatewayexception(BadGatewayException)
        case sdkUnknown(Swift.String)
    }

}

extension LexRuntimeV2ClientTypes {
    public enum StyleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case spellByLetter
        case spellByWord
        case sdkUnknown(Swift.String)

        public static var allCases: [StyleType] {
            return [
                .default,
                .spellByLetter,
                .spellByWord,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .spellByLetter: return "SpellByLetter"
            case .spellByWord: return "SpellByWord"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StyleType(rawValue: rawValue) ?? StyleType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.TextInputEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clientTimestampMillis) ?? 0
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.TextInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextInputEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)), text: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeV2ClientTypes {
    /// The event sent from your client application to Amazon Lex V2 with text input from the user.
    public struct TextInputEvent: Swift.Equatable {
        /// A timestamp set by the client of the date and time that the event was sent to Amazon Lex V2.
        public var clientTimestampMillis: Swift.Int
        /// A unique identifier that your application assigns to the event. You can use this to identify events in logs.
        public var eventId: Swift.String?
        /// The text from the user. Amazon Lex V2 processes this as a complete statement.
        /// This member is required.
        public var text: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.text = text
        }
    }

}

extension LexRuntimeV2ClientTypes.TextResponseEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for message0 in messages {
                try messagesContainer.encode(message0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// The event sent from Amazon Lex V2 to your application with text to present to the user.
    public struct TextResponseEvent: Swift.Equatable {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?
        /// A list of messages to send to the user. Messages are ordered based on the order that you returned the messages from your Lambda function or the order that the messages are defined in the bot.
        public var messages: [LexRuntimeV2ClientTypes.Message]?

        public init (
            eventId: Swift.String? = nil,
            messages: [LexRuntimeV2ClientTypes.Message]? = nil
        )
        {
            self.eventId = eventId
            self.messages = messages
        }
    }

}

extension ThrottlingException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.TranscriptEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case transcript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let transcript = self.transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    /// Event sent from Amazon Lex V2 to your client application that contains a transcript of voice audio.
    public struct TranscriptEvent: Swift.Equatable {
        /// A unique identifier of the event sent by Amazon Lex V2. The identifier is in the form RESPONSE-N, where N is a number starting with one and incremented for each event sent by Amazon Lex V2 in the current session.
        public var eventId: Swift.String?
        /// The transcript of the voice audio from the user.
        public var transcript: Swift.String?

        public init (
            eventId: Swift.String? = nil,
            transcript: Swift.String? = nil
        )
        {
            self.eventId = eventId
            self.transcript = transcript
        }
    }

}

extension ValidationException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Value: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretedValue
        case originalValue
        case resolvedValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpretedValue = self.interpretedValue {
            try encodeContainer.encode(interpretedValue, forKey: .interpretedValue)
        }
        if let originalValue = self.originalValue {
            try encodeContainer.encode(originalValue, forKey: .originalValue)
        }
        if let resolvedValues = resolvedValues {
            var resolvedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resolvedValues)
            for nonemptystring0 in resolvedValues {
                try resolvedValuesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originalValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalValue)
        originalValue = originalValueDecoded
        let interpretedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interpretedValue)
        interpretedValue = interpretedValueDecoded
        let resolvedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resolvedValues)
        var resolvedValuesDecoded0:[Swift.String]? = nil
        if let resolvedValuesContainer = resolvedValuesContainer {
            resolvedValuesDecoded0 = [Swift.String]()
            for string0 in resolvedValuesContainer {
                if let string0 = string0 {
                    resolvedValuesDecoded0?.append(string0)
                }
            }
        }
        resolvedValues = resolvedValuesDecoded0
    }
}

extension LexRuntimeV2ClientTypes {
    /// The value of a slot.
    public struct Value: Swift.Equatable {
        /// The value that Amazon Lex V2 determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex V2 choose the first value in the resolvedValues list.
        /// This member is required.
        public var interpretedValue: Swift.String?
        /// The text of the utterance from the user that was entered for the slot.
        public var originalValue: Swift.String?
        /// A list of additional values that have been recognized for the slot.
        public var resolvedValues: [Swift.String]?

        public init (
            interpretedValue: Swift.String? = nil,
            originalValue: Swift.String? = nil,
            resolvedValues: [Swift.String]? = nil
        )
        {
            self.interpretedValue = interpretedValue
            self.originalValue = originalValue
            self.resolvedValues = resolvedValues
        }
    }

}
