// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class WorkDocsClient {
    let client: SdkHttpClient
    let config: WorkDocsClientConfiguration
    let serviceName = "WorkDocs"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: WorkDocsClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class WorkDocsClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> WorkDocsClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try WorkDocsClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension WorkDocsClient: WorkDocsClientProtocol {
    /// <p>Aborts the upload of the specified document version that was previously initiated
    ///             by <a>InitiateDocumentVersionUpload</a>. The client should make this call
    ///             only when it no longer intends to upload the document version, or fails to do
    ///             so.</p>
    public func abortDocumentVersionUpload(input: AbortDocumentVersionUploadInput, completion: @escaping (SdkResult<AbortDocumentVersionUploadOutputResponse, AbortDocumentVersionUploadOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "abortDocumentVersionUpload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AbortDocumentVersionUploadInput, AbortDocumentVersionUploadOutputResponse, AbortDocumentVersionUploadOutputError>(id: "abortDocumentVersionUpload")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AbortDocumentVersionUploadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AbortDocumentVersionUploadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AbortDocumentVersionUploadInput, AbortDocumentVersionUploadOutputResponse, AbortDocumentVersionUploadOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Activates the specified user. Only active users can access Amazon
    ///             WorkDocs.</p>
    public func activateUser(input: ActivateUserInput, completion: @escaping (SdkResult<ActivateUserOutputResponse, ActivateUserOutputError>) -> Void)
    {
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/users/\(userId)/activation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "activateUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ActivateUserInput, ActivateUserOutputResponse, ActivateUserOutputError>(id: "activateUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ActivateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ActivateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ActivateUserInput, ActivateUserOutputResponse, ActivateUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a set of permissions for the specified folder or document. The resource
    ///             permissions are overwritten if the principals already have different
    ///             permissions.</p>
    public func addResourcePermissions(input: AddResourcePermissionsInput, completion: @escaping (SdkResult<AddResourcePermissionsOutputResponse, AddResourcePermissionsOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/permissions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addResourcePermissions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<AddResourcePermissionsInput, AddResourcePermissionsOutputResponse, AddResourcePermissionsOutputError>(id: "addResourcePermissions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: AddResourcePermissionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: AddResourcePermissionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<AddResourcePermissionsInput, AddResourcePermissionsOutputResponse, AddResourcePermissionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: AddResourcePermissionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a new comment to the specified document version.</p>
    public func createComment(input: CreateCommentInput, completion: @escaping (SdkResult<CreateCommentOutputResponse, CreateCommentOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)/comment"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCommentInput, CreateCommentOutputResponse, CreateCommentOutputError>(id: "createComment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCommentInput, CreateCommentOutputResponse, CreateCommentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCommentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds one or more custom properties to the specified resource (a folder, document,
    ///             or version).</p>
    public func createCustomMetadata(input: CreateCustomMetadataInput, completion: @escaping (SdkResult<CreateCustomMetadataOutputResponse, CreateCustomMetadataOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/customMetadata"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCustomMetadata")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCustomMetadataInput, CreateCustomMetadataOutputResponse, CreateCustomMetadataOutputError>(id: "createCustomMetadata")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetadataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetadataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCustomMetadataInput, CreateCustomMetadataOutputResponse, CreateCustomMetadataOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCustomMetadataInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a folder with the specified name and parent folder.</p>
    public func createFolder(input: CreateFolderInput, completion: @escaping (SdkResult<CreateFolderOutputResponse, CreateFolderOutputError>) -> Void)
    {
        let urlPath = "/api/v1/folders"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFolder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFolderInput, CreateFolderOutputResponse, CreateFolderOutputError>(id: "createFolder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFolderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFolderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFolderInput, CreateFolderOutputResponse, CreateFolderOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFolderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds the specified list of labels to the given resource (a document or
    ///             folder)</p>
    public func createLabels(input: CreateLabelsInput, completion: @escaping (SdkResult<CreateLabelsOutputResponse, CreateLabelsOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/labels"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createLabels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateLabelsInput, CreateLabelsOutputResponse, CreateLabelsOutputError>(id: "createLabels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateLabelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateLabelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateLabelsInput, CreateLabelsOutputResponse, CreateLabelsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateLabelsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Configure Amazon WorkDocs to use Amazon SNS notifications. The endpoint receives a
    ///             confirmation message, and must confirm the subscription.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/subscribe-notifications.html">Subscribe to
    ///                 Notifications</a> in the <i>Amazon WorkDocs Developer
    ///             Guide</i>.</p>
    public func createNotificationSubscription(input: CreateNotificationSubscriptionInput, completion: @escaping (SdkResult<CreateNotificationSubscriptionOutputResponse, CreateNotificationSubscriptionOutputError>) -> Void)
    {
        guard let organizationId = input.organizationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component organizationId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/organizations/\(organizationId)/subscriptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createNotificationSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateNotificationSubscriptionInput, CreateNotificationSubscriptionOutputResponse, CreateNotificationSubscriptionOutputError>(id: "createNotificationSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateNotificationSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateNotificationSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateNotificationSubscriptionInput, CreateNotificationSubscriptionOutputResponse, CreateNotificationSubscriptionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateNotificationSubscriptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a user in a Simple AD or Microsoft AD directory. The status of a newly
    ///             created user is "ACTIVE". New users can access Amazon WorkDocs.</p>
    public func createUser(input: CreateUserInput, completion: @escaping (SdkResult<CreateUserOutputResponse, CreateUserOutputError>) -> Void)
    {
        let urlPath = "/api/v1/users"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUserInput, CreateUserOutputResponse, CreateUserOutputError>(id: "createUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateUserInput, CreateUserOutputResponse, CreateUserOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUserInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deactivates the specified user, which revokes the user's access to Amazon
    ///             WorkDocs.</p>
    public func deactivateUser(input: DeactivateUserInput, completion: @escaping (SdkResult<DeactivateUserOutputResponse, DeactivateUserOutputError>) -> Void)
    {
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/users/\(userId)/activation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deactivateUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeactivateUserInput, DeactivateUserOutputResponse, DeactivateUserOutputError>(id: "deactivateUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeactivateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeactivateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeactivateUserInput, DeactivateUserOutputResponse, DeactivateUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified comment from the document version.</p>
    public func deleteComment(input: DeleteCommentInput, completion: @escaping (SdkResult<DeleteCommentOutputResponse, DeleteCommentOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        guard let commentId = input.commentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component commentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)/comment/\(commentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCommentInput, DeleteCommentOutputResponse, DeleteCommentOutputError>(id: "deleteComment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCommentInput, DeleteCommentOutputResponse, DeleteCommentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes custom metadata from the specified resource.</p>
    public func deleteCustomMetadata(input: DeleteCustomMetadataInput, completion: @escaping (SdkResult<DeleteCustomMetadataOutputResponse, DeleteCustomMetadataOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/customMetadata"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCustomMetadata")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCustomMetadataInput, DeleteCustomMetadataOutputResponse, DeleteCustomMetadataOutputError>(id: "deleteCustomMetadata")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomMetadataInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCustomMetadataInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCustomMetadataInput, DeleteCustomMetadataOutputResponse, DeleteCustomMetadataOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Permanently deletes the specified document and its associated metadata.</p>
    public func deleteDocument(input: DeleteDocumentInput, completion: @escaping (SdkResult<DeleteDocumentOutputResponse, DeleteDocumentOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDocument")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDocumentInput, DeleteDocumentOutputResponse, DeleteDocumentOutputError>(id: "deleteDocument")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDocumentInput, DeleteDocumentOutputResponse, DeleteDocumentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Permanently deletes the specified folder and its contents.</p>
    public func deleteFolder(input: DeleteFolderInput, completion: @escaping (SdkResult<DeleteFolderOutputResponse, DeleteFolderOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFolder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFolderInput, DeleteFolderOutputResponse, DeleteFolderOutputError>(id: "deleteFolder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFolderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFolderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFolderInput, DeleteFolderOutputResponse, DeleteFolderOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the contents of the specified folder.</p>
    public func deleteFolderContents(input: DeleteFolderContentsInput, completion: @escaping (SdkResult<DeleteFolderContentsOutputResponse, DeleteFolderContentsOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)/contents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFolderContents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFolderContentsInput, DeleteFolderContentsOutputResponse, DeleteFolderContentsOutputError>(id: "deleteFolderContents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFolderContentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFolderContentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFolderContentsInput, DeleteFolderContentsOutputResponse, DeleteFolderContentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified list of labels from a resource.</p>
    public func deleteLabels(input: DeleteLabelsInput, completion: @escaping (SdkResult<DeleteLabelsOutputResponse, DeleteLabelsOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/labels"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteLabels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteLabelsInput, DeleteLabelsOutputResponse, DeleteLabelsOutputError>(id: "deleteLabels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteLabelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteLabelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteLabelsInput, DeleteLabelsOutputResponse, DeleteLabelsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified subscription from the specified organization.</p>
    public func deleteNotificationSubscription(input: DeleteNotificationSubscriptionInput, completion: @escaping (SdkResult<DeleteNotificationSubscriptionOutputResponse, DeleteNotificationSubscriptionOutputError>) -> Void)
    {
        guard let organizationId = input.organizationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component organizationId unexpectedly nil"))))
            return
        }
        guard let subscriptionId = input.subscriptionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component subscriptionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/organizations/\(organizationId)/subscriptions/\(subscriptionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteNotificationSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteNotificationSubscriptionInput, DeleteNotificationSubscriptionOutputResponse, DeleteNotificationSubscriptionOutputError>(id: "deleteNotificationSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteNotificationSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteNotificationSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteNotificationSubscriptionInput, DeleteNotificationSubscriptionOutputResponse, DeleteNotificationSubscriptionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified user from a Simple AD or Microsoft AD directory.</p>
    public func deleteUser(input: DeleteUserInput, completion: @escaping (SdkResult<DeleteUserOutputResponse, DeleteUserOutputError>) -> Void)
    {
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/users/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUserInput, DeleteUserOutputResponse, DeleteUserOutputError>(id: "deleteUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUserInput, DeleteUserOutputResponse, DeleteUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the user activities in a specified time period.</p>
    public func describeActivities(input: DescribeActivitiesInput, completion: @escaping (SdkResult<DescribeActivitiesOutputResponse, DescribeActivitiesOutputError>) -> Void)
    {
        let urlPath = "/api/v1/activities"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeActivities")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeActivitiesInput, DescribeActivitiesOutputResponse, DescribeActivitiesOutputError>(id: "describeActivities")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeActivitiesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeActivitiesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeActivitiesInput, DescribeActivitiesOutputResponse, DescribeActivitiesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all the comments for the specified document version.</p>
    public func describeComments(input: DescribeCommentsInput, completion: @escaping (SdkResult<DescribeCommentsOutputResponse, DescribeCommentsOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)/comments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeComments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeCommentsInput, DescribeCommentsOutputResponse, DescribeCommentsOutputError>(id: "describeComments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeCommentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeCommentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeCommentsInput, DescribeCommentsOutputResponse, DescribeCommentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the document versions for the specified document.</p>
    ///         <p>By default, only active versions are returned.</p>
    public func describeDocumentVersions(input: DescribeDocumentVersionsInput, completion: @escaping (SdkResult<DescribeDocumentVersionsOutputResponse, DescribeDocumentVersionsOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeDocumentVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeDocumentVersionsInput, DescribeDocumentVersionsOutputResponse, DescribeDocumentVersionsOutputError>(id: "describeDocumentVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeDocumentVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeDocumentVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeDocumentVersionsInput, DescribeDocumentVersionsOutputResponse, DescribeDocumentVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the contents of the specified folder, including its documents and
    ///             subfolders.</p>
    ///         <p>By default, Amazon WorkDocs returns the first 100 active document and folder
    ///             metadata items. If there are more results, the response includes a marker that you can
    ///             use to request the next set of results. You can also request initialized
    ///             documents.</p>
    public func describeFolderContents(input: DescribeFolderContentsInput, completion: @escaping (SdkResult<DescribeFolderContentsOutputResponse, DescribeFolderContentsOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)/contents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFolderContents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFolderContentsInput, DescribeFolderContentsOutputResponse, DescribeFolderContentsOutputError>(id: "describeFolderContents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFolderContentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFolderContentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFolderContentsInput, DescribeFolderContentsOutputResponse, DescribeFolderContentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the groups specified by the query. Groups are defined by the underlying
    ///             Active Directory.</p>
    public func describeGroups(input: DescribeGroupsInput, completion: @escaping (SdkResult<DescribeGroupsOutputResponse, DescribeGroupsOutputError>) -> Void)
    {
        let urlPath = "/api/v1/groups"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeGroupsInput, DescribeGroupsOutputResponse, DescribeGroupsOutputError>(id: "describeGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeGroupsInput, DescribeGroupsOutputResponse, DescribeGroupsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the specified notification subscriptions.</p>
    public func describeNotificationSubscriptions(input: DescribeNotificationSubscriptionsInput, completion: @escaping (SdkResult<DescribeNotificationSubscriptionsOutputResponse, DescribeNotificationSubscriptionsOutputError>) -> Void)
    {
        guard let organizationId = input.organizationId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component organizationId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/organizations/\(organizationId)/subscriptions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeNotificationSubscriptions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeNotificationSubscriptionsInput, DescribeNotificationSubscriptionsOutputResponse, DescribeNotificationSubscriptionsOutputError>(id: "describeNotificationSubscriptions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeNotificationSubscriptionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeNotificationSubscriptionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeNotificationSubscriptionsInput, DescribeNotificationSubscriptionsOutputResponse, DescribeNotificationSubscriptionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the permissions of a specified resource.</p>
    public func describeResourcePermissions(input: DescribeResourcePermissionsInput, completion: @escaping (SdkResult<DescribeResourcePermissionsOutputResponse, DescribeResourcePermissionsOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/permissions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeResourcePermissions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeResourcePermissionsInput, DescribeResourcePermissionsOutputResponse, DescribeResourcePermissionsOutputError>(id: "describeResourcePermissions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeResourcePermissionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeResourcePermissionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeResourcePermissionsInput, DescribeResourcePermissionsOutputResponse, DescribeResourcePermissionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the current user's special folders; the <code>RootFolder</code> and the
    ///                 <code>RecycleBin</code>. <code>RootFolder</code> is the root of user's files and
    ///             folders and <code>RecycleBin</code> is the root of recycled items. This is not a valid
    ///             action for SigV4 (administrative API) clients.</p>
    ///         <p>This action requires an authentication token. To get an authentication token,
    ///             register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access
    ///                 Control for User Applications</a> in the
    ///             <i>Amazon
    ///             WorkDocs Developer Guide</i>.</p>
    public func describeRootFolders(input: DescribeRootFoldersInput, completion: @escaping (SdkResult<DescribeRootFoldersOutputResponse, DescribeRootFoldersOutputError>) -> Void)
    {
        let urlPath = "/api/v1/me/root"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRootFolders")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRootFoldersInput, DescribeRootFoldersOutputResponse, DescribeRootFoldersOutputError>(id: "describeRootFolders")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRootFoldersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRootFoldersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRootFoldersInput, DescribeRootFoldersOutputResponse, DescribeRootFoldersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes the specified users. You can describe all users or filter the results
    ///             (for example, by status or organization).</p>
    ///         <p>By default, Amazon WorkDocs returns the first 24 active or pending users. If there
    ///             are more results, the response includes a marker that you can use to request the next
    ///             set of results.</p>
    public func describeUsers(input: DescribeUsersInput, completion: @escaping (SdkResult<DescribeUsersOutputResponse, DescribeUsersOutputError>) -> Void)
    {
        let urlPath = "/api/v1/users"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeUsers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeUsersInput, DescribeUsersOutputResponse, DescribeUsersOutputError>(id: "describeUsers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeUsersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeUsersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeUsersInput, DescribeUsersOutputResponse, DescribeUsersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves details of the current user for whom the authentication token was
    ///             generated. This is not a valid action for SigV4 (administrative API) clients.</p>
    ///         <p>This action requires an authentication token. To get an authentication token,
    ///             register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access
    ///                 Control for User Applications</a> in the
    ///             <i>Amazon
    ///                 WorkDocs Developer Guide</i>.</p>
    public func getCurrentUser(input: GetCurrentUserInput, completion: @escaping (SdkResult<GetCurrentUserOutputResponse, GetCurrentUserOutputError>) -> Void)
    {
        let urlPath = "/api/v1/me"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCurrentUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCurrentUserInput, GetCurrentUserOutputResponse, GetCurrentUserOutputError>(id: "getCurrentUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCurrentUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCurrentUserInput, GetCurrentUserOutputResponse, GetCurrentUserOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves details of a document.</p>
    public func getDocument(input: GetDocumentInput, completion: @escaping (SdkResult<GetDocumentOutputResponse, GetDocumentOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocument")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentInput, GetDocumentOutputResponse, GetDocumentOutputError>(id: "getDocument")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDocumentInput, GetDocumentOutputResponse, GetDocumentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the path information (the hierarchy from the root folder) for the
    ///             requested document.</p>
    ///         <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the
    ///             requested document and only includes the IDs of the parent folders in the path. You can
    ///             limit the maximum number of levels. You can also request the names of the parent
    ///             folders.</p>
    public func getDocumentPath(input: GetDocumentPathInput, completion: @escaping (SdkResult<GetDocumentPathOutputResponse, GetDocumentPathOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/path"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentPath")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentPathInput, GetDocumentPathOutputResponse, GetDocumentPathOutputError>(id: "getDocumentPath")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentPathInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentPathInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDocumentPathInput, GetDocumentPathOutputResponse, GetDocumentPathOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves version metadata for the specified document.</p>
    public func getDocumentVersion(input: GetDocumentVersionInput, completion: @escaping (SdkResult<GetDocumentVersionOutputResponse, GetDocumentVersionOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentVersionInput, GetDocumentVersionOutputResponse, GetDocumentVersionOutputError>(id: "getDocumentVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDocumentVersionInput, GetDocumentVersionOutputResponse, GetDocumentVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the metadata of the specified folder.</p>
    public func getFolder(input: GetFolderInput, completion: @escaping (SdkResult<GetFolderOutputResponse, GetFolderOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFolder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFolderInput, GetFolderOutputResponse, GetFolderOutputError>(id: "getFolder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFolderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFolderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFolderInput, GetFolderOutputResponse, GetFolderOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the path information (the hierarchy from the root folder) for the
    ///             specified folder.</p>
    ///         <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the
    ///             requested folder and only includes the IDs of the parent folders in the path. You can
    ///             limit the maximum number of levels. You can also request the parent folder
    ///             names.</p>
    public func getFolderPath(input: GetFolderPathInput, completion: @escaping (SdkResult<GetFolderPathOutputResponse, GetFolderPathOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)/path"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFolderPath")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFolderPathInput, GetFolderPathOutputResponse, GetFolderPathOutputError>(id: "getFolderPath")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFolderPathInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFolderPathInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFolderPathInput, GetFolderPathOutputResponse, GetFolderPathOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a collection of resources, including folders and documents. The only
    ///             <code>CollectionType</code> supported is <code>SHARED_WITH_ME</code>.</p>
    public func getResources(input: GetResourcesInput, completion: @escaping (SdkResult<GetResourcesOutputResponse, GetResourcesOutputError>) -> Void)
    {
        let urlPath = "/api/v1/resources"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourcesInput, GetResourcesOutputResponse, GetResourcesOutputError>(id: "getResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResourcesInput, GetResourcesOutputResponse, GetResourcesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new document object and version object.</p>
    ///         <p>The client specifies the parent folder ID and name of the document to upload. The
    ///             ID is optionally specified when creating a new version of an existing document. This is
    ///             the first step to upload a document. Next, upload the document to the URL returned from
    ///             the call, and then call <a>UpdateDocumentVersion</a>.</p>
    ///         <p>To cancel the document upload, call <a>AbortDocumentVersionUpload</a>.</p>
    public func initiateDocumentVersionUpload(input: InitiateDocumentVersionUploadInput, completion: @escaping (SdkResult<InitiateDocumentVersionUploadOutputResponse, InitiateDocumentVersionUploadOutputError>) -> Void)
    {
        let urlPath = "/api/v1/documents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "initiateDocumentVersionUpload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<InitiateDocumentVersionUploadInput, InitiateDocumentVersionUploadOutputResponse, InitiateDocumentVersionUploadOutputError>(id: "initiateDocumentVersionUpload")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: InitiateDocumentVersionUploadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: InitiateDocumentVersionUploadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<InitiateDocumentVersionUploadInput, InitiateDocumentVersionUploadOutputResponse, InitiateDocumentVersionUploadOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: InitiateDocumentVersionUploadInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes all the permissions from the specified resource.</p>
    public func removeAllResourcePermissions(input: RemoveAllResourcePermissionsInput, completion: @escaping (SdkResult<RemoveAllResourcePermissionsOutputResponse, RemoveAllResourcePermissionsOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/permissions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeAllResourcePermissions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveAllResourcePermissionsInput, RemoveAllResourcePermissionsOutputResponse, RemoveAllResourcePermissionsOutputError>(id: "removeAllResourcePermissions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveAllResourcePermissionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveAllResourcePermissionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveAllResourcePermissionsInput, RemoveAllResourcePermissionsOutputResponse, RemoveAllResourcePermissionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes the permission for the specified principal from the specified
    ///             resource.</p>
    public func removeResourcePermission(input: RemoveResourcePermissionInput, completion: @escaping (SdkResult<RemoveResourcePermissionOutputResponse, RemoveResourcePermissionOutputError>) -> Void)
    {
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let principalId = input.principalId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component principalId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/resources/\(resourceId)/permissions/\(principalId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeResourcePermission")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RemoveResourcePermissionInput, RemoveResourcePermissionOutputResponse, RemoveResourcePermissionOutputError>(id: "removeResourcePermission")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RemoveResourcePermissionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RemoveResourcePermissionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RemoveResourcePermissionInput, RemoveResourcePermissionOutputResponse, RemoveResourcePermissionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified attributes of a document. The user must have access to both
    ///             the document and its parent folder, if applicable.</p>
    public func updateDocument(input: UpdateDocumentInput, completion: @escaping (SdkResult<UpdateDocumentOutputResponse, UpdateDocumentOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDocument")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDocumentInput, UpdateDocumentOutputResponse, UpdateDocumentOutputError>(id: "updateDocument")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDocumentInput, UpdateDocumentOutputResponse, UpdateDocumentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Changes the status of the document version to ACTIVE. </p>
    ///         <p>Amazon WorkDocs also sets its document container to ACTIVE. This is the last step
    ///             in a document upload, after the client uploads the document to an S3-presigned URL
    ///             returned by <a>InitiateDocumentVersionUpload</a>. </p>
    public func updateDocumentVersion(input: UpdateDocumentVersionInput, completion: @escaping (SdkResult<UpdateDocumentVersionOutputResponse, UpdateDocumentVersionOutputError>) -> Void)
    {
        guard let documentId = input.documentId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component documentId unexpectedly nil"))))
            return
        }
        guard let versionId = input.versionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/documents/\(documentId)/versions/\(versionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDocumentVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDocumentVersionInput, UpdateDocumentVersionOutputResponse, UpdateDocumentVersionOutputError>(id: "updateDocumentVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDocumentVersionInput, UpdateDocumentVersionOutputResponse, UpdateDocumentVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified attributes of the specified folder. The user must have access
    ///             to both the folder and its parent folder, if applicable.</p>
    public func updateFolder(input: UpdateFolderInput, completion: @escaping (SdkResult<UpdateFolderOutputResponse, UpdateFolderOutputError>) -> Void)
    {
        guard let folderId = input.folderId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component folderId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/folders/\(folderId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFolder")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFolderInput, UpdateFolderOutputResponse, UpdateFolderOutputError>(id: "updateFolder")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFolderInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFolderInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFolderInput, UpdateFolderOutputResponse, UpdateFolderOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFolderInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the specified attributes of the specified user, and grants or revokes
    ///             administrative privileges to the Amazon WorkDocs site.</p>
    public func updateUser(input: UpdateUserInput, completion: @escaping (SdkResult<UpdateUserOutputResponse, UpdateUserOutputError>) -> Void)
    {
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/api/v1/users/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUser")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "workdocs.\(config.region).amazonaws.com")
                      .withSigningName(value: "workdocs")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUserInput, UpdateUserOutputResponse, UpdateUserOutputError>(id: "updateUser")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateUserInput, UpdateUserOutputResponse, UpdateUserOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUserInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
