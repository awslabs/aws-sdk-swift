// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortDocumentVersionUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortDocumentVersionUploadInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), versionId: \(String(describing: versionId)))"}
}

extension AbortDocumentVersionUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AbortDocumentVersionUploadInputHeadersMiddleware: Middleware {
    public let id: String = "AbortDocumentVersionUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortDocumentVersionUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortDocumentVersionUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortDocumentVersionUploadInput>
    public typealias MOutput = OperationOutput<AbortDocumentVersionUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortDocumentVersionUploadOutputError>
}

public struct AbortDocumentVersionUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "AbortDocumentVersionUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortDocumentVersionUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortDocumentVersionUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortDocumentVersionUploadInput>
    public typealias MOutput = OperationOutput<AbortDocumentVersionUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortDocumentVersionUploadOutputError>
}

public struct AbortDocumentVersionUploadInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>The ID of the version.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct AbortDocumentVersionUploadInputBody: Equatable {
}

extension AbortDocumentVersionUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AbortDocumentVersionUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortDocumentVersionUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortDocumentVersionUploadOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortDocumentVersionUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortDocumentVersionUploadOutputResponse()"}
}

extension AbortDocumentVersionUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AbortDocumentVersionUploadOutputResponse: Equatable {

    public init() {}
}

struct AbortDocumentVersionUploadOutputResponseBody: Equatable {
}

extension AbortDocumentVersionUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ActivateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateUserInput(authenticationToken: \(String(describing: authenticationToken)), userId: \(String(describing: userId)))"}
}

extension ActivateUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ActivateUserInputHeadersMiddleware: Middleware {
    public let id: String = "ActivateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateUserInput>
    public typealias MOutput = OperationOutput<ActivateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateUserOutputError>
}

public struct ActivateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateUserInput>
    public typealias MOutput = OperationOutput<ActivateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateUserOutputError>
}

public struct ActivateUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the user.</p>
    public let userId: String?

    public init (
        authenticationToken: String? = nil,
        userId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct ActivateUserInputBody: Equatable {
}

extension ActivateUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ActivateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateUserOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateUserOutputResponse(user: \(String(describing: user)))"}
}

extension ActivateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActivateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct ActivateUserOutputResponse: Equatable {
    /// <p>The user information.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct ActivateUserOutputResponseBody: Equatable {
    public let user: User?
}

extension ActivateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

extension Activity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentMetadata = "CommentMetadata"
        case initiator = "Initiator"
        case isIndirectActivity = "IsIndirectActivity"
        case organizationId = "OrganizationId"
        case originalParent = "OriginalParent"
        case participants = "Participants"
        case resourceMetadata = "ResourceMetadata"
        case timeStamp = "TimeStamp"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentMetadata = commentMetadata {
            try encodeContainer.encode(commentMetadata, forKey: .commentMetadata)
        }
        if let initiator = initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if isIndirectActivity != false {
            try encodeContainer.encode(isIndirectActivity, forKey: .isIndirectActivity)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let originalParent = originalParent {
            try encodeContainer.encode(originalParent, forKey: .originalParent)
        }
        if let participants = participants {
            try encodeContainer.encode(participants, forKey: .participants)
        }
        if let resourceMetadata = resourceMetadata {
            try encodeContainer.encode(resourceMetadata, forKey: .resourceMetadata)
        }
        if let timeStamp = timeStamp {
            try encodeContainer.encode(timeStamp.timeIntervalSince1970, forKey: .timeStamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ActivityType.self, forKey: .type)
        type = typeDecoded
        let timeStampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timeStamp)
        timeStamp = timeStampDecoded
        let isIndirectActivityDecoded = try containerValues.decode(Bool.self, forKey: .isIndirectActivity)
        isIndirectActivity = isIndirectActivityDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(UserMetadata.self, forKey: .initiator)
        initiator = initiatorDecoded
        let participantsDecoded = try containerValues.decodeIfPresent(Participants.self, forKey: .participants)
        participants = participantsDecoded
        let resourceMetadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .resourceMetadata)
        resourceMetadata = resourceMetadataDecoded
        let originalParentDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .originalParent)
        originalParent = originalParentDecoded
        let commentMetadataDecoded = try containerValues.decodeIfPresent(CommentMetadata.self, forKey: .commentMetadata)
        commentMetadata = commentMetadataDecoded
    }
}

extension Activity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Activity(commentMetadata: \(String(describing: commentMetadata)), initiator: \(String(describing: initiator)), isIndirectActivity: \(String(describing: isIndirectActivity)), organizationId: \(String(describing: organizationId)), originalParent: \(String(describing: originalParent)), participants: \(String(describing: participants)), resourceMetadata: \(String(describing: resourceMetadata)), timeStamp: \(String(describing: timeStamp)), type: \(String(describing: type)))"}
}

/// <p>Describes the activity information.</p>
public struct Activity: Equatable {
    /// <p>Metadata of the commenting activity. This is an optional field and is filled for
    ///             commenting activities.</p>
    public let commentMetadata: CommentMetadata?
    /// <p>The user who performed the action.</p>
    public let initiator: UserMetadata?
    /// <p>Indicates whether an activity is indirect or direct. An indirect activity results
    ///             from a direct activity performed on a parent resource. For example, sharing a parent
    ///             folder (the direct activity) shares all of the subfolders and documents within the
    ///             parent folder (the indirect activity).</p>
    public let isIndirectActivity: Bool
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>The original parent of the resource. This is an optional field and is filled for
    ///             move activities.</p>
    public let originalParent: ResourceMetadata?
    /// <p>The list of users or groups impacted by this action. This is an optional field and
    ///             is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED,
    ///             DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.</p>
    public let participants: Participants?
    /// <p>The metadata of the resource involved in the user action.</p>
    public let resourceMetadata: ResourceMetadata?
    /// <p>The timestamp when the action was performed.</p>
    public let timeStamp: Date?
    /// <p>The activity type.</p>
    public let type: ActivityType?

    public init (
        commentMetadata: CommentMetadata? = nil,
        initiator: UserMetadata? = nil,
        isIndirectActivity: Bool = false,
        organizationId: String? = nil,
        originalParent: ResourceMetadata? = nil,
        participants: Participants? = nil,
        resourceMetadata: ResourceMetadata? = nil,
        timeStamp: Date? = nil,
        type: ActivityType? = nil
    )
    {
        self.commentMetadata = commentMetadata
        self.initiator = initiator
        self.isIndirectActivity = isIndirectActivity
        self.organizationId = organizationId
        self.originalParent = originalParent
        self.participants = participants
        self.resourceMetadata = resourceMetadata
        self.timeStamp = timeStamp
        self.type = type
    }
}

public enum ActivityType {
    case documentAnnotationAdded
    case documentAnnotationDeleted
    case documentCheckedIn
    case documentCheckedOut
    case documentCommentAdded
    case documentCommentDeleted
    case documentMoved
    case documentRecycled
    case documentRenamed
    case documentRestored
    case documentReverted
    case documentShareableLinkCreated
    case documentShareableLinkPermissionChanged
    case documentShareableLinkRemoved
    case documentShared
    case documentSharePermissionChanged
    case documentUnshared
    case documentVersionDeleted
    case documentVersionDownloaded
    case documentVersionUploaded
    case documentVersionViewed
    case folderCreated
    case folderDeleted
    case folderMoved
    case folderRecycled
    case folderRenamed
    case folderRestored
    case folderShareableLinkCreated
    case folderShareableLinkPermissionChanged
    case folderShareableLinkRemoved
    case folderShared
    case folderSharePermissionChanged
    case folderUnshared
    case sdkUnknown(String)
}

extension ActivityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActivityType] {
        return [
            .documentAnnotationAdded,
            .documentAnnotationDeleted,
            .documentCheckedIn,
            .documentCheckedOut,
            .documentCommentAdded,
            .documentCommentDeleted,
            .documentMoved,
            .documentRecycled,
            .documentRenamed,
            .documentRestored,
            .documentReverted,
            .documentShareableLinkCreated,
            .documentShareableLinkPermissionChanged,
            .documentShareableLinkRemoved,
            .documentShared,
            .documentSharePermissionChanged,
            .documentUnshared,
            .documentVersionDeleted,
            .documentVersionDownloaded,
            .documentVersionUploaded,
            .documentVersionViewed,
            .folderCreated,
            .folderDeleted,
            .folderMoved,
            .folderRecycled,
            .folderRenamed,
            .folderRestored,
            .folderShareableLinkCreated,
            .folderShareableLinkPermissionChanged,
            .folderShareableLinkRemoved,
            .folderShared,
            .folderSharePermissionChanged,
            .folderUnshared,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .documentAnnotationAdded: return "DOCUMENT_ANNOTATION_ADDED"
        case .documentAnnotationDeleted: return "DOCUMENT_ANNOTATION_DELETED"
        case .documentCheckedIn: return "DOCUMENT_CHECKED_IN"
        case .documentCheckedOut: return "DOCUMENT_CHECKED_OUT"
        case .documentCommentAdded: return "DOCUMENT_COMMENT_ADDED"
        case .documentCommentDeleted: return "DOCUMENT_COMMENT_DELETED"
        case .documentMoved: return "DOCUMENT_MOVED"
        case .documentRecycled: return "DOCUMENT_RECYCLED"
        case .documentRenamed: return "DOCUMENT_RENAMED"
        case .documentRestored: return "DOCUMENT_RESTORED"
        case .documentReverted: return "DOCUMENT_REVERTED"
        case .documentShareableLinkCreated: return "DOCUMENT_SHAREABLE_LINK_CREATED"
        case .documentShareableLinkPermissionChanged: return "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
        case .documentShareableLinkRemoved: return "DOCUMENT_SHAREABLE_LINK_REMOVED"
        case .documentShared: return "DOCUMENT_SHARED"
        case .documentSharePermissionChanged: return "DOCUMENT_SHARE_PERMISSION_CHANGED"
        case .documentUnshared: return "DOCUMENT_UNSHARED"
        case .documentVersionDeleted: return "DOCUMENT_VERSION_DELETED"
        case .documentVersionDownloaded: return "DOCUMENT_VERSION_DOWNLOADED"
        case .documentVersionUploaded: return "DOCUMENT_VERSION_UPLOADED"
        case .documentVersionViewed: return "DOCUMENT_VERSION_VIEWED"
        case .folderCreated: return "FOLDER_CREATED"
        case .folderDeleted: return "FOLDER_DELETED"
        case .folderMoved: return "FOLDER_MOVED"
        case .folderRecycled: return "FOLDER_RECYCLED"
        case .folderRenamed: return "FOLDER_RENAMED"
        case .folderRestored: return "FOLDER_RESTORED"
        case .folderShareableLinkCreated: return "FOLDER_SHAREABLE_LINK_CREATED"
        case .folderShareableLinkPermissionChanged: return "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
        case .folderShareableLinkRemoved: return "FOLDER_SHAREABLE_LINK_REMOVED"
        case .folderShared: return "FOLDER_SHARED"
        case .folderSharePermissionChanged: return "FOLDER_SHARE_PERMISSION_CHANGED"
        case .folderUnshared: return "FOLDER_UNSHARED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActivityType(rawValue: rawValue) ?? ActivityType.sdkUnknown(rawValue)
    }
}

public struct AddResourcePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "AddResourcePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddResourcePermissionsInput>
    public typealias MOutput = OperationOutput<AddResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddResourcePermissionsOutputError>
}

extension AddResourcePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddResourcePermissionsInput(authenticationToken: \(String(describing: authenticationToken)), notificationOptions: \(String(describing: notificationOptions)), principals: \(String(describing: principals)), resourceId: \(String(describing: resourceId)))"}
}

extension AddResourcePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationOptions = notificationOptions {
            try encodeContainer.encode(notificationOptions, forKey: .notificationOptions)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for shareprincipallist0 in principals {
                try principalsContainer.encode(shareprincipallist0)
            }
        }
    }
}

public struct AddResourcePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "AddResourcePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddResourcePermissionsInput>
    public typealias MOutput = OperationOutput<AddResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddResourcePermissionsOutputError>
}

public struct AddResourcePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddResourcePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddResourcePermissionsInput>
    public typealias MOutput = OperationOutput<AddResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddResourcePermissionsOutputError>
}

public struct AddResourcePermissionsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The notification options.</p>
    public let notificationOptions: NotificationOptions?
    /// <p>The users, groups, or organization being granted permission.</p>
    public let principals: [SharePrincipal]?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        notificationOptions: NotificationOptions? = nil,
        principals: [SharePrincipal]? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.notificationOptions = notificationOptions
        self.principals = principals
        self.resourceId = resourceId
    }
}

struct AddResourcePermissionsInputBody: Equatable {
    public let principals: [SharePrincipal]?
    public let notificationOptions: NotificationOptions?
}

extension AddResourcePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([SharePrincipal?].self, forKey: .principals)
        var principalsDecoded0:[SharePrincipal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [SharePrincipal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let notificationOptionsDecoded = try containerValues.decodeIfPresent(NotificationOptions.self, forKey: .notificationOptions)
        notificationOptions = notificationOptionsDecoded
    }
}

extension AddResourcePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddResourcePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddResourcePermissionsOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddResourcePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddResourcePermissionsOutputResponse(shareResults: \(String(describing: shareResults)))"}
}

extension AddResourcePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddResourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.shareResults = output.shareResults
        } else {
            self.shareResults = nil
        }
    }
}

public struct AddResourcePermissionsOutputResponse: Equatable {
    /// <p>The share results.</p>
    public let shareResults: [ShareResult]?

    public init (
        shareResults: [ShareResult]? = nil
    )
    {
        self.shareResults = shareResults
    }
}

struct AddResourcePermissionsOutputResponseBody: Equatable {
    public let shareResults: [ShareResult]?
}

extension AddResourcePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case shareResults = "ShareResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareResultsContainer = try containerValues.decodeIfPresent([ShareResult?].self, forKey: .shareResults)
        var shareResultsDecoded0:[ShareResult]? = nil
        if let shareResultsContainer = shareResultsContainer {
            shareResultsDecoded0 = [ShareResult]()
            for structure0 in shareResultsContainer {
                if let structure0 = structure0 {
                    shareResultsDecoded0?.append(structure0)
                }
            }
        }
        shareResults = shareResultsDecoded0
    }
}

public enum BooleanEnumType {
    case `false`
    case `true`
    case sdkUnknown(String)
}

extension BooleanEnumType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BooleanEnumType] {
        return [
            .false,
            .true,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .false: return "FALSE"
        case .true: return "TRUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BooleanEnumType(rawValue: rawValue) ?? BooleanEnumType.sdkUnknown(rawValue)
    }
}

extension Comment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId = "CommentId"
        case contributor = "Contributor"
        case createdTimestamp = "CreatedTimestamp"
        case parentId = "ParentId"
        case recipientId = "RecipientId"
        case status = "Status"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let contributor = contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let recipientId = recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CommentStatusType.self, forKey: .status)
        status = statusDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
    }
}

extension Comment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Comment(commentId: \(String(describing: commentId)), contributor: \(String(describing: contributor)), createdTimestamp: \(String(describing: createdTimestamp)), parentId: \(String(describing: parentId)), recipientId: \(String(describing: recipientId)), status: \(String(describing: status)), text: \(String(describing: text)), threadId: \(String(describing: threadId)), visibility: \(String(describing: visibility)))"}
}

/// <p>Describes a comment.</p>
public struct Comment: Equatable {
    /// <p>The ID of the comment.</p>
    public let commentId: String?
    /// <p>The details of the user who made the comment.</p>
    public let contributor: User?
    /// <p>The time that the comment was created.</p>
    public let createdTimestamp: Date?
    /// <p>The ID of the parent comment.</p>
    public let parentId: String?
    /// <p>If the comment is a reply to another user's comment, this field contains the user
    ///             ID of the user being replied to.</p>
    public let recipientId: String?
    /// <p>The status of the comment.</p>
    public let status: CommentStatusType?
    /// <p>The text of the comment.</p>
    public let text: String?
    /// <p>The ID of the root comment in the thread.</p>
    public let threadId: String?
    /// <p>The visibility of the comment. Options are either PRIVATE, where the comment is
    ///             visible only to the comment author and document owner and co-owners, or PUBLIC, where
    ///             the comment is visible to document owners, co-owners, and contributors.</p>
    public let visibility: CommentVisibilityType?

    public init (
        commentId: String? = nil,
        contributor: User? = nil,
        createdTimestamp: Date? = nil,
        parentId: String? = nil,
        recipientId: String? = nil,
        status: CommentStatusType? = nil,
        text: String? = nil,
        threadId: String? = nil,
        visibility: CommentVisibilityType? = nil
    )
    {
        self.commentId = commentId
        self.contributor = contributor
        self.createdTimestamp = createdTimestamp
        self.parentId = parentId
        self.recipientId = recipientId
        self.status = status
        self.text = text
        self.threadId = threadId
        self.visibility = visibility
    }
}

extension CommentMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId = "CommentId"
        case commentStatus = "CommentStatus"
        case contributor = "Contributor"
        case createdTimestamp = "CreatedTimestamp"
        case recipientId = "RecipientId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let commentStatus = commentStatus {
            try encodeContainer.encode(commentStatus.rawValue, forKey: .commentStatus)
        }
        if let contributor = contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let recipientId = recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let commentStatusDecoded = try containerValues.decodeIfPresent(CommentStatusType.self, forKey: .commentStatus)
        commentStatus = commentStatusDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
    }
}

extension CommentMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentMetadata(commentId: \(String(describing: commentId)), commentStatus: \(String(describing: commentStatus)), contributor: \(String(describing: contributor)), createdTimestamp: \(String(describing: createdTimestamp)), recipientId: \(String(describing: recipientId)))"}
}

/// <p>Describes the metadata of a comment.</p>
public struct CommentMetadata: Equatable {
    /// <p>The ID of the comment.</p>
    public let commentId: String?
    /// <p>The status of the comment.</p>
    public let commentStatus: CommentStatusType?
    /// <p>The user who made the comment.</p>
    public let contributor: User?
    /// <p>The timestamp that the comment was created.</p>
    public let createdTimestamp: Date?
    /// <p>The ID of the user being replied to.</p>
    public let recipientId: String?

    public init (
        commentId: String? = nil,
        commentStatus: CommentStatusType? = nil,
        contributor: User? = nil,
        createdTimestamp: Date? = nil,
        recipientId: String? = nil
    )
    {
        self.commentId = commentId
        self.commentStatus = commentStatus
        self.contributor = contributor
        self.createdTimestamp = createdTimestamp
        self.recipientId = recipientId
    }
}

public enum CommentStatusType {
    case deleted
    case draft
    case published
    case sdkUnknown(String)
}

extension CommentStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommentStatusType] {
        return [
            .deleted,
            .draft,
            .published,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .draft: return "DRAFT"
        case .published: return "PUBLISHED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommentStatusType(rawValue: rawValue) ?? CommentStatusType.sdkUnknown(rawValue)
    }
}

public enum CommentVisibilityType {
    case `private`
    case `public`
    case sdkUnknown(String)
}

extension CommentVisibilityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommentVisibilityType] {
        return [
            .private,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .private: return "PRIVATE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommentVisibilityType(rawValue: rawValue) ?? CommentVisibilityType.sdkUnknown(rawValue)
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource hierarchy is changing.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictingOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictingOperationException(message: \(String(describing: message)))"}
}

extension ConflictingOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
public struct ConflictingOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictingOperationExceptionBody: Equatable {
    public let message: String?
}

extension ConflictingOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCommentInputBodyMiddleware: Middleware {
    public let id: String = "CreateCommentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommentInput>
    public typealias MOutput = OperationOutput<CreateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommentOutputError>
}

extension CreateCommentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCommentInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), notifyCollaborators: \(String(describing: notifyCollaborators)), parentId: \(String(describing: parentId)), text: \(String(describing: text)), threadId: \(String(describing: threadId)), versionId: \(String(describing: versionId)), visibility: \(String(describing: visibility)))"}
}

extension CreateCommentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if notifyCollaborators != false {
            try encodeContainer.encode(notifyCollaborators, forKey: .notifyCollaborators)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }
}

public struct CreateCommentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCommentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommentInput>
    public typealias MOutput = OperationOutput<CreateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommentOutputError>
}

public struct CreateCommentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCommentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommentInput>
    public typealias MOutput = OperationOutput<CreateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommentOutputError>
}

public struct CreateCommentInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>Set this parameter to TRUE to send an email out to the document collaborators after
    ///             the comment is created.</p>
    public let notifyCollaborators: Bool
    /// <p>The ID of the parent comment.</p>
    public let parentId: String?
    /// <p>The text of the comment.</p>
    public let text: String?
    /// <p>The ID of the root comment in the thread.</p>
    public let threadId: String?
    /// <p>The ID of the document version.</p>
    public let versionId: String?
    /// <p>The visibility of the comment. Options are either PRIVATE, where the comment is
    ///             visible only to the comment author and document owner and co-owners, or PUBLIC, where
    ///             the comment is visible to document owners, co-owners, and contributors.</p>
    public let visibility: CommentVisibilityType?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        notifyCollaborators: Bool = false,
        parentId: String? = nil,
        text: String? = nil,
        threadId: String? = nil,
        versionId: String? = nil,
        visibility: CommentVisibilityType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.notifyCollaborators = notifyCollaborators
        self.parentId = parentId
        self.text = text
        self.threadId = threadId
        self.versionId = versionId
        self.visibility = visibility
    }
}

struct CreateCommentInputBody: Equatable {
    public let parentId: String?
    public let threadId: String?
    public let text: String?
    public let visibility: CommentVisibilityType?
    public let notifyCollaborators: Bool
}

extension CreateCommentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let notifyCollaboratorsDecoded = try containerValues.decode(Bool.self, forKey: .notifyCollaborators)
        notifyCollaborators = notifyCollaboratorsDecoded
    }
}

extension CreateCommentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCommentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DocumentLockedForCommentsException" : self = .documentLockedForCommentsException(try DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentOperationException" : self = .invalidCommentOperationException(try InvalidCommentOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCommentOutputError: Equatable {
    case documentLockedForCommentsException(DocumentLockedForCommentsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidCommentOperationException(InvalidCommentOperationException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCommentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCommentOutputResponse(comment: \(String(describing: comment)))"}
}

extension CreateCommentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCommentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct CreateCommentOutputResponse: Equatable {
    /// <p>The comment that has been created.</p>
    public let comment: Comment?

    public init (
        comment: Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct CreateCommentOutputResponseBody: Equatable {
    public let comment: Comment?
}

extension CreateCommentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

public struct CreateCustomMetadataInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetadataInput>
    public typealias MOutput = OperationOutput<CreateCustomMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetadataOutputError>
}

extension CreateCustomMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomMetadataInput(authenticationToken: \(String(describing: authenticationToken)), customMetadata: \(String(describing: customMetadata)), resourceId: \(String(describing: resourceId)), versionId: \(String(describing: versionId)))"}
}

extension CreateCustomMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customMetadata = customMetadata {
            var customMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customMetadata)
            for (dictKey0, custommetadatamap0) in customMetadata {
                try customMetadataContainer.encode(custommetadatamap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateCustomMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetadataInput>
    public typealias MOutput = OperationOutput<CreateCustomMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetadataOutputError>
}

public struct CreateCustomMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionid".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomMetadataInput>
    public typealias MOutput = OperationOutput<CreateCustomMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomMetadataOutputError>
}

public struct CreateCustomMetadataInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>Custom metadata in the form of name-value pairs.</p>
    public let customMetadata: [String:String]?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?
    /// <p>The ID of the version, if the custom metadata is being added to a document
    ///             version.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        customMetadata: [String:String]? = nil,
        resourceId: String? = nil,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.customMetadata = customMetadata
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct CreateCustomMetadataInputBody: Equatable {
    public let customMetadata: [String:String]?
}

extension CreateCustomMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [String:String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [String:String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension CreateCustomMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomMetadataLimitExceededException" : self = .customMetadataLimitExceededException(try CustomMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomMetadataOutputError: Equatable {
    case customMetadataLimitExceededException(CustomMetadataLimitExceededException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomMetadataOutputResponse()"}
}

extension CreateCustomMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateCustomMetadataOutputResponse: Equatable {

    public init() {}
}

struct CreateCustomMetadataOutputResponseBody: Equatable {
}

extension CreateCustomMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateFolderInputBodyMiddleware: Middleware {
    public let id: String = "CreateFolderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFolderInput>
    public typealias MOutput = OperationOutput<CreateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFolderOutputError>
}

extension CreateFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFolderInput(authenticationToken: \(String(describing: authenticationToken)), name: \(String(describing: name)), parentFolderId: \(String(describing: parentFolderId)))"}
}

extension CreateFolderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

public struct CreateFolderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFolderInput>
    public typealias MOutput = OperationOutput<CreateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFolderOutputError>
}

public struct CreateFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFolderInput>
    public typealias MOutput = OperationOutput<CreateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFolderOutputError>
}

public struct CreateFolderInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The name of the new folder.</p>
    public let name: String?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?

    public init (
        authenticationToken: String? = nil,
        name: String? = nil,
        parentFolderId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct CreateFolderInputBody: Equatable {
    public let name: String?
    public let parentFolderId: String?
}

extension CreateFolderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension CreateFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFolderOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFolderOutputResponse(metadata: \(String(describing: metadata)))"}
}

extension CreateFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFolderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
        } else {
            self.metadata = nil
        }
    }
}

public struct CreateFolderOutputResponse: Equatable {
    /// <p>The metadata of the folder.</p>
    public let metadata: FolderMetadata?

    public init (
        metadata: FolderMetadata? = nil
    )
    {
        self.metadata = metadata
    }
}

struct CreateFolderOutputResponseBody: Equatable {
    public let metadata: FolderMetadata?
}

extension CreateFolderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct CreateLabelsInputBodyMiddleware: Middleware {
    public let id: String = "CreateLabelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLabelsInput>
    public typealias MOutput = OperationOutput<CreateLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLabelsOutputError>
}

extension CreateLabelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLabelsInput(authenticationToken: \(String(describing: authenticationToken)), labels: \(String(describing: labels)), resourceId: \(String(describing: resourceId)))"}
}

extension CreateLabelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
    }
}

public struct CreateLabelsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLabelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLabelsInput>
    public typealias MOutput = OperationOutput<CreateLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLabelsOutputError>
}

public struct CreateLabelsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLabelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLabelsInput>
    public typealias MOutput = OperationOutput<CreateLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLabelsOutputError>
}

public struct CreateLabelsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>List of labels to add to the resource.</p>
    public let labels: [String]?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        labels: [String]? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct CreateLabelsInputBody: Equatable {
    public let labels: [String]?
}

extension CreateLabelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension CreateLabelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLabelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLabelsException" : self = .tooManyLabelsException(try TooManyLabelsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLabelsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyLabelsException(TooManyLabelsException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLabelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLabelsOutputResponse()"}
}

extension CreateLabelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateLabelsOutputResponse: Equatable {

    public init() {}
}

struct CreateLabelsOutputResponseBody: Equatable {
}

extension CreateLabelsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateNotificationSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateNotificationSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateNotificationSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationSubscriptionOutputError>
}

extension CreateNotificationSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationSubscriptionInput(endpoint: \(String(describing: endpoint)), organizationId: \(String(describing: organizationId)), protocol: \(String(describing: `protocol`)), subscriptionType: \(String(describing: subscriptionType)))"}
}

extension CreateNotificationSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }
}

public struct CreateNotificationSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNotificationSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateNotificationSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationSubscriptionOutputError>
}

public struct CreateNotificationSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNotificationSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateNotificationSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationSubscriptionOutputError>
}

public struct CreateNotificationSubscriptionInput: Equatable {
    /// <p>The protocol to use. The supported value is https, which delivers JSON-encoded
    ///             messages using HTTPS POST.</p>
    public let `protocol`: SubscriptionProtocolType?
    /// <p>The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint
    ///             is a URL that begins with <code>https</code>.</p>
    public let endpoint: String?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>The notification type.</p>
    public let subscriptionType: SubscriptionType?

    public init (
        `protocol`: SubscriptionProtocolType? = nil,
        endpoint: String? = nil,
        organizationId: String? = nil,
        subscriptionType: SubscriptionType? = nil
    )
    {
        self.`protocol` = `protocol`
        self.endpoint = endpoint
        self.organizationId = organizationId
        self.subscriptionType = subscriptionType
    }
}

struct CreateNotificationSubscriptionInputBody: Equatable {
    public let endpoint: String?
    public let `protocol`: SubscriptionProtocolType?
    public let subscriptionType: SubscriptionType?
}

extension CreateNotificationSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
    }
}

extension CreateNotificationSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManySubscriptionsException" : self = .tooManySubscriptionsException(try TooManySubscriptionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationSubscriptionOutputError: Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManySubscriptionsException(TooManySubscriptionsException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationSubscriptionOutputResponse(subscription: \(String(describing: subscription)))"}
}

extension CreateNotificationSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNotificationSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct CreateNotificationSubscriptionOutputResponse: Equatable {
    /// <p>The subscription.</p>
    public let subscription: Subscription?

    public init (
        subscription: Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct CreateNotificationSubscriptionOutputResponseBody: Equatable {
    public let subscription: Subscription?
}

extension CreateNotificationSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscription = "Subscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(authenticationToken: \(String(describing: authenticationToken)), emailAddress: \(String(describing: emailAddress)), givenName: \(String(describing: givenName)), organizationId: \(String(describing: organizationId)), password: \(String(describing: password)), storageRule: \(String(describing: storageRule)), surname: \(String(describing: surname)), timeZoneId: \(String(describing: timeZoneId)), username: \(String(describing: username)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The email address of the user.</p>
    public let emailAddress: String?
    /// <p>The given name of the user.</p>
    public let givenName: String?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>The password of the user.</p>
    public let password: String?
    /// <p>The amount of storage for the user.</p>
    public let storageRule: StorageRuleType?
    /// <p>The surname of the user.</p>
    public let surname: String?
    /// <p>The time zone ID of the user.</p>
    public let timeZoneId: String?
    /// <p>The login name of the user.</p>
    public let username: String?

    public init (
        authenticationToken: String? = nil,
        emailAddress: String? = nil,
        givenName: String? = nil,
        organizationId: String? = nil,
        password: String? = nil,
        storageRule: StorageRuleType? = nil,
        surname: String? = nil,
        timeZoneId: String? = nil,
        username: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.organizationId = organizationId
        self.password = password
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.username = username
    }
}

struct CreateUserInputBody: Equatable {
    public let organizationId: String?
    public let username: String?
    public let emailAddress: String?
    public let givenName: String?
    public let surname: String?
    public let password: String?
    public let timeZoneId: String?
    public let storageRule: StorageRuleType?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .surname)
        surname = surnameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(user: \(String(describing: user)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutputResponse: Equatable {
    /// <p>The user information.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let user: User?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

extension CustomMetadataLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomMetadataLimitExceededException(message: \(String(describing: message)))"}
}

extension CustomMetadataLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit has been reached on the number of custom properties for the specified
///             resource.</p>
public struct CustomMetadataLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomMetadataLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CustomMetadataLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeactivateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateUserInput(authenticationToken: \(String(describing: authenticationToken)), userId: \(String(describing: userId)))"}
}

extension DeactivateUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeactivateUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeactivateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateUserInput>
    public typealias MOutput = OperationOutput<DeactivateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateUserOutputError>
}

public struct DeactivateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeactivateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateUserInput>
    public typealias MOutput = OperationOutput<DeactivateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateUserOutputError>
}

public struct DeactivateUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the user.</p>
    public let userId: String?

    public init (
        authenticationToken: String? = nil,
        userId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeactivateUserInputBody: Equatable {
}

extension DeactivateUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeactivateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateUserOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateUserOutputResponse()"}
}

extension DeactivateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateUserOutputResponse: Equatable {

    public init() {}
}

struct DeactivateUserOutputResponseBody: Equatable {
}

extension DeactivateUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeactivatingLastSystemUserException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivatingLastSystemUserException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension DeactivatingLastSystemUserException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeactivatingLastSystemUserExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The last user in the organization is being deactivated.</p>
public struct DeactivatingLastSystemUserException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DeactivatingLastSystemUserExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension DeactivatingLastSystemUserExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DeleteCommentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCommentInput(authenticationToken: \(String(describing: authenticationToken)), commentId: \(String(describing: commentId)), documentId: \(String(describing: documentId)), versionId: \(String(describing: versionId)))"}
}

extension DeleteCommentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCommentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCommentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCommentInput>
    public typealias MOutput = OperationOutput<DeleteCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCommentOutputError>
}

public struct DeleteCommentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCommentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCommentInput>
    public typealias MOutput = OperationOutput<DeleteCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCommentOutputError>
}

public struct DeleteCommentInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the comment.</p>
    public let commentId: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>The ID of the document version.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        commentId: String? = nil,
        documentId: String? = nil,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.commentId = commentId
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct DeleteCommentInputBody: Equatable {
}

extension DeleteCommentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCommentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCommentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DocumentLockedForCommentsException" : self = .documentLockedForCommentsException(try DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCommentOutputError: Equatable {
    case documentLockedForCommentsException(DocumentLockedForCommentsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCommentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCommentOutputResponse()"}
}

extension DeleteCommentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCommentOutputResponse: Equatable {

    public init() {}
}

struct DeleteCommentOutputResponseBody: Equatable {
}

extension DeleteCommentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomMetadataInput(authenticationToken: \(String(describing: authenticationToken)), deleteAll: \(String(describing: deleteAll)), keys: \(String(describing: keys)), resourceId: \(String(describing: resourceId)), versionId: \(String(describing: versionId)))"}
}

extension DeleteCustomMetadataInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCustomMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomMetadataInput>
    public typealias MOutput = OperationOutput<DeleteCustomMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomMetadataOutputError>
}

public struct DeleteCustomMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        let deleteAllQueryItem = URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: String(input.operationInput.deleteAll).urlPercentEncoding())
        input.builder.withQueryItem(deleteAllQueryItem)
        if let keys = input.operationInput.keys {
            keys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "keys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomMetadataInput>
    public typealias MOutput = OperationOutput<DeleteCustomMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomMetadataOutputError>
}

public struct DeleteCustomMetadataInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>Flag to indicate removal of all custom metadata properties from the specified
    ///             resource.</p>
    public let deleteAll: Bool
    /// <p>List of properties to remove.</p>
    public let keys: [String]?
    /// <p>The ID of the resource, either a document or folder.</p>
    public let resourceId: String?
    /// <p>The ID of the version, if the custom metadata is being deleted from a document
    ///             version.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        deleteAll: Bool = false,
        keys: [String]? = nil,
        resourceId: String? = nil,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.keys = keys
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct DeleteCustomMetadataInputBody: Equatable {
}

extension DeleteCustomMetadataInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomMetadataOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomMetadataOutputResponse()"}
}

extension DeleteCustomMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomMetadataOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomMetadataOutputResponseBody: Equatable {
}

extension DeleteCustomMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)))"}
}

extension DeleteDocumentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

struct DeleteDocumentInputBody: Equatable {
}

extension DeleteDocumentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentOutputResponse()"}
}

extension DeleteDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentOutputResponse: Equatable {

    public init() {}
}

struct DeleteDocumentOutputResponseBody: Equatable {
}

extension DeleteDocumentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFolderContentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFolderContentsInput(authenticationToken: \(String(describing: authenticationToken)), folderId: \(String(describing: folderId)))"}
}

extension DeleteFolderContentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFolderContentsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFolderContentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFolderContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFolderContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFolderContentsInput>
    public typealias MOutput = OperationOutput<DeleteFolderContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFolderContentsOutputError>
}

public struct DeleteFolderContentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFolderContentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFolderContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFolderContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFolderContentsInput>
    public typealias MOutput = OperationOutput<DeleteFolderContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFolderContentsOutputError>
}

public struct DeleteFolderContentsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?

    public init (
        authenticationToken: String? = nil,
        folderId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderContentsInputBody: Equatable {
}

extension DeleteFolderContentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFolderContentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderContentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderContentsOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderContentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFolderContentsOutputResponse()"}
}

extension DeleteFolderContentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFolderContentsOutputResponse: Equatable {

    public init() {}
}

struct DeleteFolderContentsOutputResponseBody: Equatable {
}

extension DeleteFolderContentsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFolderInput(authenticationToken: \(String(describing: authenticationToken)), folderId: \(String(describing: folderId)))"}
}

extension DeleteFolderInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFolderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFolderInput>
    public typealias MOutput = OperationOutput<DeleteFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFolderOutputError>
}

public struct DeleteFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFolderInput>
    public typealias MOutput = OperationOutput<DeleteFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFolderOutputError>
}

public struct DeleteFolderInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?

    public init (
        authenticationToken: String? = nil,
        folderId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderInputBody: Equatable {
}

extension DeleteFolderInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFolderOutputResponse()"}
}

extension DeleteFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFolderOutputResponse: Equatable {

    public init() {}
}

struct DeleteFolderOutputResponseBody: Equatable {
}

extension DeleteFolderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLabelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLabelsInput(authenticationToken: \(String(describing: authenticationToken)), deleteAll: \(String(describing: deleteAll)), labels: \(String(describing: labels)), resourceId: \(String(describing: resourceId)))"}
}

extension DeleteLabelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLabelsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLabelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLabelsInput>
    public typealias MOutput = OperationOutput<DeleteLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLabelsOutputError>
}

public struct DeleteLabelsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLabelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLabelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let deleteAllQueryItem = URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: String(input.operationInput.deleteAll).urlPercentEncoding())
        input.builder.withQueryItem(deleteAllQueryItem)
        if let labels = input.operationInput.labels {
            labels.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "labels".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLabelsInput>
    public typealias MOutput = OperationOutput<DeleteLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLabelsOutputError>
}

public struct DeleteLabelsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>Flag to request removal of all labels from the specified resource.</p>
    public let deleteAll: Bool
    /// <p>List of labels to delete from the resource.</p>
    public let labels: [String]?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        deleteAll: Bool = false,
        labels: [String]? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct DeleteLabelsInputBody: Equatable {
}

extension DeleteLabelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLabelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLabelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLabelsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLabelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLabelsOutputResponse()"}
}

extension DeleteLabelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLabelsOutputResponse: Equatable {

    public init() {}
}

struct DeleteLabelsOutputResponseBody: Equatable {
}

extension DeleteLabelsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNotificationSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationSubscriptionInput(organizationId: \(String(describing: organizationId)), subscriptionId: \(String(describing: subscriptionId)))"}
}

extension DeleteNotificationSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteNotificationSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNotificationSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteNotificationSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationSubscriptionOutputError>
}

public struct DeleteNotificationSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNotificationSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteNotificationSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationSubscriptionOutputError>
}

public struct DeleteNotificationSubscriptionInput: Equatable {
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>The ID of the subscription.</p>
    public let subscriptionId: String?

    public init (
        organizationId: String? = nil,
        subscriptionId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.subscriptionId = subscriptionId
    }
}

struct DeleteNotificationSubscriptionInputBody: Equatable {
}

extension DeleteNotificationSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNotificationSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationSubscriptionOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationSubscriptionOutputResponse()"}
}

extension DeleteNotificationSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotificationSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteNotificationSubscriptionOutputResponseBody: Equatable {
}

extension DeleteNotificationSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(authenticationToken: \(String(describing: authenticationToken)), userId: \(String(describing: userId)))"}
}

extension DeleteUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Do not set this field when using
    ///             administrative API actions, as in accessing the API using AWS credentials.</p>
    public let authenticationToken: String?
    /// <p>The ID of the user.</p>
    public let userId: String?

    public init (
        authenticationToken: String? = nil,
        userId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeleteUserInputBody: Equatable {
}

extension DeleteUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeActivitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivitiesInput(activityTypes: \(String(describing: activityTypes)), authenticationToken: \(String(describing: authenticationToken)), endTime: \(String(describing: endTime)), includeIndirectActivities: \(String(describing: includeIndirectActivities)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)), startTime: \(String(describing: startTime)), userId: \(String(describing: userId)))"}
}

extension DescribeActivitiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeActivitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeActivitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivitiesInput>
    public typealias MOutput = OperationOutput<DescribeActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivitiesOutputError>
}

public struct DescribeActivitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeActivitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let resourceId = input.operationInput.resourceId {
            let resourceIdQueryItem = URLQueryItem(name: "resourceId".urlPercentEncoding(), value: String(resourceId).urlPercentEncoding())
            input.builder.withQueryItem(resourceIdQueryItem)
        }
        if let userId = input.operationInput.userId {
            let userIdQueryItem = URLQueryItem(name: "userId".urlPercentEncoding(), value: String(userId).urlPercentEncoding())
            input.builder.withQueryItem(userIdQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        let includeIndirectActivitiesQueryItem = URLQueryItem(name: "includeIndirectActivities".urlPercentEncoding(), value: String(input.operationInput.includeIndirectActivities).urlPercentEncoding())
        input.builder.withQueryItem(includeIndirectActivitiesQueryItem)
        if let organizationId = input.operationInput.organizationId {
            let organizationIdQueryItem = URLQueryItem(name: "organizationId".urlPercentEncoding(), value: String(organizationId).urlPercentEncoding())
            input.builder.withQueryItem(organizationIdQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let activityTypes = input.operationInput.activityTypes {
            let activityTypesQueryItem = URLQueryItem(name: "activityTypes".urlPercentEncoding(), value: String(activityTypes).urlPercentEncoding())
            input.builder.withQueryItem(activityTypesQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivitiesInput>
    public typealias MOutput = OperationOutput<DescribeActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivitiesOutputError>
}

public struct DescribeActivitiesInput: Equatable {
    /// <p>Specifies which activity types to include in the response. If this field is left
    ///             empty, all activity types are returned.</p>
    public let activityTypes: String?
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The timestamp that determines the end time of the activities. The response includes
    ///             the activities performed before the specified timestamp.</p>
    public let endTime: Date?
    /// <p>Includes indirect activities. An indirect activity results from a direct activity
    ///             performed on a parent resource. For example, sharing a parent folder (the direct
    ///             activity) shares all of the subfolders and documents within the parent folder (the
    ///             indirect activity).</p>
    public let includeIndirectActivities: Bool
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The ID of the organization. This is a mandatory parameter when using administrative
    ///             API (SigV4) requests.</p>
    public let organizationId: String?
    /// <p>The document or folder ID for which to describe activity types.</p>
    public let resourceId: String?
    /// <p>The timestamp that determines the starting time of the activities. The response
    ///             includes the activities performed after the specified timestamp.</p>
    public let startTime: Date?
    /// <p>The ID of the user who performed the action. The response includes activities
    ///             pertaining to this user. This is an optional parameter and is only applicable for
    ///             administrative API (SigV4) requests.</p>
    public let userId: String?

    public init (
        activityTypes: String? = nil,
        authenticationToken: String? = nil,
        endTime: Date? = nil,
        includeIndirectActivities: Bool = false,
        limit: Int? = nil,
        marker: String? = nil,
        organizationId: String? = nil,
        resourceId: String? = nil,
        startTime: Date? = nil,
        userId: String? = nil
    )
    {
        self.activityTypes = activityTypes
        self.authenticationToken = authenticationToken
        self.endTime = endTime
        self.includeIndirectActivities = includeIndirectActivities
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.startTime = startTime
        self.userId = userId
    }
}

struct DescribeActivitiesInputBody: Equatable {
}

extension DescribeActivitiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeActivitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivitiesOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivitiesOutputResponse(marker: \(String(describing: marker)), userActivities: \(String(describing: userActivities)))"}
}

extension DescribeActivitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeActivitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.userActivities = output.userActivities
        } else {
            self.marker = nil
            self.userActivities = nil
        }
    }
}

public struct DescribeActivitiesOutputResponse: Equatable {
    /// <p>The marker for the next set of results.</p>
    public let marker: String?
    /// <p>The list of activities for the specified user and time period.</p>
    public let userActivities: [Activity]?

    public init (
        marker: String? = nil,
        userActivities: [Activity]? = nil
    )
    {
        self.marker = marker
        self.userActivities = userActivities
    }
}

struct DescribeActivitiesOutputResponseBody: Equatable {
    public let userActivities: [Activity]?
    public let marker: String?
}

extension DescribeActivitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case userActivities = "UserActivities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userActivitiesContainer = try containerValues.decodeIfPresent([Activity?].self, forKey: .userActivities)
        var userActivitiesDecoded0:[Activity]? = nil
        if let userActivitiesContainer = userActivitiesContainer {
            userActivitiesDecoded0 = [Activity]()
            for structure0 in userActivitiesContainer {
                if let structure0 = structure0 {
                    userActivitiesDecoded0?.append(structure0)
                }
            }
        }
        userActivities = userActivitiesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCommentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommentsInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), versionId: \(String(describing: versionId)))"}
}

extension DescribeCommentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCommentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCommentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommentsInput>
    public typealias MOutput = OperationOutput<DescribeCommentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommentsOutputError>
}

public struct DescribeCommentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCommentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommentsInput>
    public typealias MOutput = OperationOutput<DescribeCommentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommentsOutputError>
}

public struct DescribeCommentsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. This marker was received from a previous
    ///             call.</p>
    public let marker: String?
    /// <p>The ID of the document version.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.limit = limit
        self.marker = marker
        self.versionId = versionId
    }
}

struct DescribeCommentsInputBody: Equatable {
}

extension DescribeCommentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCommentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommentsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommentsOutputResponse(comments: \(String(describing: comments)), marker: \(String(describing: marker)))"}
}

extension DescribeCommentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCommentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comments = output.comments
            self.marker = output.marker
        } else {
            self.comments = nil
            self.marker = nil
        }
    }
}

public struct DescribeCommentsOutputResponse: Equatable {
    /// <p>The list of comments for the specified document version.</p>
    public let comments: [Comment]?
    /// <p>The marker for the next set of results. This marker was received from a previous
    ///             call.</p>
    public let marker: String?

    public init (
        comments: [Comment]? = nil,
        marker: String? = nil
    )
    {
        self.comments = comments
        self.marker = marker
    }
}

struct DescribeCommentsOutputResponseBody: Equatable {
    public let comments: [Comment]?
    public let marker: String?
}

extension DescribeCommentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comments = "Comments"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsContainer = try containerValues.decodeIfPresent([Comment?].self, forKey: .comments)
        var commentsDecoded0:[Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDocumentVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentVersionsInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), fields: \(String(describing: fields)), include: \(String(describing: include)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension DescribeDocumentVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDocumentVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDocumentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentVersionsOutputError>
}

public struct DescribeDocumentVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDocumentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fields = input.operationInput.fields {
            let fieldsQueryItem = URLQueryItem(name: "fields".urlPercentEncoding(), value: String(fields).urlPercentEncoding())
            input.builder.withQueryItem(fieldsQueryItem)
        }
        if let include = input.operationInput.include {
            let includeQueryItem = URLQueryItem(name: "include".urlPercentEncoding(), value: String(include).urlPercentEncoding())
            input.builder.withQueryItem(includeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentVersionsInput>
    public typealias MOutput = OperationOutput<DescribeDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentVersionsOutputError>
}

public struct DescribeDocumentVersionsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>Specify "SOURCE" to include initialized versions and a URL for the source
    ///             document.</p>
    public let fields: String?
    /// <p>A comma-separated list of values. Specify "INITIALIZED" to include incomplete
    ///             versions.</p>
    public let include: String?
    /// <p>The maximum number of versions to return with this call.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call.)</p>
    public let marker: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        fields: String? = nil,
        include: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeDocumentVersionsInputBody: Equatable {
}

extension DescribeDocumentVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDocumentVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentVersionsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentVersionsOutputResponse(documentVersions: \(String(describing: documentVersions)), marker: \(String(describing: marker)))"}
}

extension DescribeDocumentVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDocumentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentVersions = output.documentVersions
            self.marker = output.marker
        } else {
            self.documentVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeDocumentVersionsOutputResponse: Equatable {
    /// <p>The document versions.</p>
    public let documentVersions: [DocumentVersionMetadata]?
    /// <p>The marker to use when requesting the next set of results. If there are no
    ///             additional results, the string is empty.</p>
    public let marker: String?

    public init (
        documentVersions: [DocumentVersionMetadata]? = nil,
        marker: String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.marker = marker
    }
}

struct DescribeDocumentVersionsOutputResponseBody: Equatable {
    public let documentVersions: [DocumentVersionMetadata]?
    public let marker: String?
}

extension DescribeDocumentVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersions = "DocumentVersions"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([DocumentVersionMetadata?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[DocumentVersionMetadata]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [DocumentVersionMetadata]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeFolderContentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFolderContentsInput(authenticationToken: \(String(describing: authenticationToken)), folderId: \(String(describing: folderId)), include: \(String(describing: include)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), order: \(String(describing: order)), sort: \(String(describing: sort)), type: \(String(describing: type)))"}
}

extension DescribeFolderContentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeFolderContentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFolderContentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFolderContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFolderContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFolderContentsInput>
    public typealias MOutput = OperationOutput<DescribeFolderContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFolderContentsOutputError>
}

public struct DescribeFolderContentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFolderContentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFolderContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFolderContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let order = input.operationInput.order {
            let orderQueryItem = URLQueryItem(name: "order".urlPercentEncoding(), value: String(order.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(orderQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let sort = input.operationInput.sort {
            let sortQueryItem = URLQueryItem(name: "sort".urlPercentEncoding(), value: String(sort.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortQueryItem)
        }
        if let include = input.operationInput.include {
            let includeQueryItem = URLQueryItem(name: "include".urlPercentEncoding(), value: String(include).urlPercentEncoding())
            input.builder.withQueryItem(includeQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFolderContentsInput>
    public typealias MOutput = OperationOutput<DescribeFolderContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFolderContentsOutputError>
}

public struct DescribeFolderContentsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?
    /// <p>The contents to include. Specify "INITIALIZED" to include initialized
    ///             documents.</p>
    public let include: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. This marker was received from a previous
    ///             call.</p>
    public let marker: String?
    /// <p>The order for the contents of the folder.</p>
    public let order: OrderType?
    /// <p>The sorting criteria.</p>
    public let sort: ResourceSortType?
    /// <p>The type of items.</p>
    public let type: FolderContentType?

    public init (
        authenticationToken: String? = nil,
        folderId: String? = nil,
        include: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        order: OrderType? = nil,
        sort: ResourceSortType? = nil,
        type: FolderContentType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.sort = sort
        self.type = type
    }
}

struct DescribeFolderContentsInputBody: Equatable {
}

extension DescribeFolderContentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFolderContentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderContentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFolderContentsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderContentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFolderContentsOutputResponse(documents: \(String(describing: documents)), folders: \(String(describing: folders)), marker: \(String(describing: marker)))"}
}

extension DescribeFolderContentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFolderContentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeFolderContentsOutputResponse: Equatable {
    /// <p>The documents in the specified folder.</p>
    public let documents: [DocumentMetadata]?
    /// <p>The subfolders in the specified folder.</p>
    public let folders: [FolderMetadata]?
    /// <p>The marker to use when requesting the next set of results. If there are no
    ///             additional results, the string is empty.</p>
    public let marker: String?

    public init (
        documents: [DocumentMetadata]? = nil,
        folders: [FolderMetadata]? = nil,
        marker: String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeFolderContentsOutputResponseBody: Equatable {
    public let folders: [FolderMetadata]?
    public let documents: [DocumentMetadata]?
    public let marker: String?
}

extension DescribeFolderContentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupsInput(authenticationToken: \(String(describing: authenticationToken)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), organizationId: \(String(describing: organizationId)), searchQuery: \(String(describing: searchQuery)))"}
}

extension DescribeGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupsInput>
    public typealias MOutput = OperationOutput<DescribeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupsOutputError>
}

public struct DescribeGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let searchQuery = input.operationInput.searchQuery {
            let searchQueryQueryItem = URLQueryItem(name: "searchQuery".urlPercentEncoding(), value: String(searchQuery).urlPercentEncoding())
            input.builder.withQueryItem(searchQueryQueryItem)
        }
        if let organizationId = input.operationInput.organizationId {
            let organizationIdQueryItem = URLQueryItem(name: "organizationId".urlPercentEncoding(), value: String(organizationId).urlPercentEncoding())
            input.builder.withQueryItem(organizationIdQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupsInput>
    public typealias MOutput = OperationOutput<DescribeGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupsOutputError>
}

public struct DescribeGroupsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call.)</p>
    public let marker: String?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>A query to describe groups by group name.</p>
    public let searchQuery: String?

    public init (
        authenticationToken: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        organizationId: String? = nil,
        searchQuery: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.searchQuery = searchQuery
    }
}

struct DescribeGroupsInputBody: Equatable {
}

extension DescribeGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupsOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupsOutputResponse(groups: \(String(describing: groups)), marker: \(String(describing: marker)))"}
}

extension DescribeGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.marker = output.marker
        } else {
            self.groups = nil
            self.marker = nil
        }
    }
}

public struct DescribeGroupsOutputResponse: Equatable {
    /// <p>The list of groups.</p>
    public let groups: [GroupMetadata]?
    /// <p>The marker to use when requesting the next set of results. If there are no additional
    ///             results, the string is empty.</p>
    public let marker: String?

    public init (
        groups: [GroupMetadata]? = nil,
        marker: String? = nil
    )
    {
        self.groups = groups
        self.marker = marker
    }
}

struct DescribeGroupsOutputResponseBody: Equatable {
    public let groups: [GroupMetadata]?
    public let marker: String?
}

extension DescribeGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeNotificationSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationSubscriptionsInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), organizationId: \(String(describing: organizationId)))"}
}

extension DescribeNotificationSubscriptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeNotificationSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNotificationSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeNotificationSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationSubscriptionsOutputError>
}

public struct DescribeNotificationSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNotificationSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationSubscriptionsInput>
    public typealias MOutput = OperationOutput<DescribeNotificationSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationSubscriptionsOutputError>
}

public struct DescribeNotificationSubscriptionsInput: Equatable {
    /// <p>The maximum number of items to return with this call.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call.)</p>
    public let marker: String?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        organizationId: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
    }
}

struct DescribeNotificationSubscriptionsInputBody: Equatable {
}

extension DescribeNotificationSubscriptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeNotificationSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationSubscriptionsOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationSubscriptionsOutputResponse(marker: \(String(describing: marker)), subscriptions: \(String(describing: subscriptions)))"}
}

extension DescribeNotificationSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNotificationSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.subscriptions = output.subscriptions
        } else {
            self.marker = nil
            self.subscriptions = nil
        }
    }
}

public struct DescribeNotificationSubscriptionsOutputResponse: Equatable {
    /// <p>The marker to use when requesting the next set of results. If there are no
    ///             additional results, the string is empty.</p>
    public let marker: String?
    /// <p>The subscriptions.</p>
    public let subscriptions: [Subscription]?

    public init (
        marker: String? = nil,
        subscriptions: [Subscription]? = nil
    )
    {
        self.marker = marker
        self.subscriptions = subscriptions
    }
}

struct DescribeNotificationSubscriptionsOutputResponseBody: Equatable {
    public let subscriptions: [Subscription]?
    public let marker: String?
}

extension DescribeNotificationSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeResourcePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePermissionsInput(authenticationToken: \(String(describing: authenticationToken)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), principalId: \(String(describing: principalId)), resourceId: \(String(describing: resourceId)))"}
}

extension DescribeResourcePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeResourcePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourcePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePermissionsOutputError>
}

public struct DescribeResourcePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourcePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principalId = input.operationInput.principalId {
            let principalIdQueryItem = URLQueryItem(name: "principalId".urlPercentEncoding(), value: String(principalId).urlPercentEncoding())
            input.builder.withQueryItem(principalIdQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePermissionsInput>
    public typealias MOutput = OperationOutput<DescribeResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePermissionsOutputError>
}

public struct DescribeResourcePermissionsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call)</p>
    public let marker: String?
    /// <p>The ID of the principal to filter permissions by.</p>
    public let principalId: String?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        principalId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.principalId = principalId
        self.resourceId = resourceId
    }
}

struct DescribeResourcePermissionsInputBody: Equatable {
}

extension DescribeResourcePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeResourcePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourcePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourcePermissionsOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourcePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePermissionsOutputResponse(marker: \(String(describing: marker)), principals: \(String(describing: principals)))"}
}

extension DescribeResourcePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.principals = output.principals
        } else {
            self.marker = nil
            self.principals = nil
        }
    }
}

public struct DescribeResourcePermissionsOutputResponse: Equatable {
    /// <p>The marker to use when requesting the next set of results. If there are no
    ///             additional results, the string is empty.</p>
    public let marker: String?
    /// <p>The principals.</p>
    public let principals: [Principal]?

    public init (
        marker: String? = nil,
        principals: [Principal]? = nil
    )
    {
        self.marker = marker
        self.principals = principals
    }
}

struct DescribeResourcePermissionsOutputResponseBody: Equatable {
    public let principals: [Principal]?
    public let marker: String?
}

extension DescribeResourcePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case principals = "Principals"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Principal?].self, forKey: .principals)
        var principalsDecoded0:[Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeRootFoldersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRootFoldersInput(authenticationToken: \(String(describing: authenticationToken)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension DescribeRootFoldersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRootFoldersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRootFoldersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRootFoldersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRootFoldersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRootFoldersInput>
    public typealias MOutput = OperationOutput<DescribeRootFoldersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRootFoldersOutputError>
}

public struct DescribeRootFoldersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRootFoldersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRootFoldersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRootFoldersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRootFoldersInput>
    public typealias MOutput = OperationOutput<DescribeRootFoldersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRootFoldersOutputError>
}

public struct DescribeRootFoldersInput: Equatable {
    /// <p>Amazon WorkDocs authentication token.</p>
    public let authenticationToken: String?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call.)</p>
    public let marker: String?

    public init (
        authenticationToken: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeRootFoldersInputBody: Equatable {
}

extension DescribeRootFoldersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRootFoldersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRootFoldersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRootFoldersOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRootFoldersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRootFoldersOutputResponse(folders: \(String(describing: folders)), marker: \(String(describing: marker)))"}
}

extension DescribeRootFoldersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRootFoldersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeRootFoldersOutputResponse: Equatable {
    /// <p>The user's special folders.</p>
    public let folders: [FolderMetadata]?
    /// <p>The marker for the next set of results.</p>
    public let marker: String?

    public init (
        folders: [FolderMetadata]? = nil,
        marker: String? = nil
    )
    {
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeRootFoldersOutputResponseBody: Equatable {
    public let folders: [FolderMetadata]?
    public let marker: String?
}

extension DescribeRootFoldersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsersInput(authenticationToken: \(String(describing: authenticationToken)), fields: \(String(describing: fields)), include: \(String(describing: include)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), order: \(String(describing: order)), organizationId: \(String(describing: organizationId)), query: \(String(describing: query)), sort: \(String(describing: sort)), userIds: \(String(describing: userIds)))"}
}

extension DescribeUsersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUsersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let order = input.operationInput.order {
            let orderQueryItem = URLQueryItem(name: "order".urlPercentEncoding(), value: String(order.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(orderQueryItem)
        }
        if let fields = input.operationInput.fields {
            let fieldsQueryItem = URLQueryItem(name: "fields".urlPercentEncoding(), value: String(fields).urlPercentEncoding())
            input.builder.withQueryItem(fieldsQueryItem)
        }
        if let query = input.operationInput.query {
            let queryQueryItem = URLQueryItem(name: "query".urlPercentEncoding(), value: String(query).urlPercentEncoding())
            input.builder.withQueryItem(queryQueryItem)
        }
        if let include = input.operationInput.include {
            let includeQueryItem = URLQueryItem(name: "include".urlPercentEncoding(), value: String(include.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(includeQueryItem)
        }
        if let sort = input.operationInput.sort {
            let sortQueryItem = URLQueryItem(name: "sort".urlPercentEncoding(), value: String(sort.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortQueryItem)
        }
        if let organizationId = input.operationInput.organizationId {
            let organizationIdQueryItem = URLQueryItem(name: "organizationId".urlPercentEncoding(), value: String(organizationId).urlPercentEncoding())
            input.builder.withQueryItem(organizationIdQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let userIds = input.operationInput.userIds {
            let userIdsQueryItem = URLQueryItem(name: "userIds".urlPercentEncoding(), value: String(userIds).urlPercentEncoding())
            input.builder.withQueryItem(userIdsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>A comma-separated list of values. Specify "STORAGE_METADATA" to include the user
    ///             storage quota and utilization information.</p>
    public let fields: String?
    /// <p>The state of the users. Specify "ALL" to include inactive users.</p>
    public let include: UserFilterType?
    /// <p>The maximum number of items to return.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///             call.)</p>
    public let marker: String?
    /// <p>The order for the results.</p>
    public let order: OrderType?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>A query to filter users by user name.</p>
    public let query: String?
    /// <p>The sorting criteria.</p>
    public let sort: UserSortType?
    /// <p>The IDs of the users.</p>
    public let userIds: String?

    public init (
        authenticationToken: String? = nil,
        fields: String? = nil,
        include: UserFilterType? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        order: OrderType? = nil,
        organizationId: String? = nil,
        query: String? = nil,
        sort: UserSortType? = nil,
        userIds: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.organizationId = organizationId
        self.query = query
        self.sort = sort
        self.userIds = userIds
    }
}

struct DescribeUsersInputBody: Equatable {
}

extension DescribeUsersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestedEntityTooLargeException" : self = .requestedEntityTooLargeException(try RequestedEntityTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsersOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case requestedEntityTooLargeException(RequestedEntityTooLargeException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUsersOutputResponse(marker: \(String(describing: marker)), totalNumberOfUsers: \(String(describing: totalNumberOfUsers)), users: \(String(describing: users)))"}
}

extension DescribeUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.totalNumberOfUsers = output.totalNumberOfUsers
            self.users = output.users
        } else {
            self.marker = nil
            self.totalNumberOfUsers = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutputResponse: Equatable {
    /// <p>The marker to use when requesting the next set of results. If there are no
    ///             additional results, the string is empty.</p>
    public let marker: String?
    /// <p>The total number of users included in the results.</p>
    @available(*, deprecated)
    public let totalNumberOfUsers: Int?
    /// <p>The users.</p>
    public let users: [User]?

    public init (
        marker: String? = nil,
        totalNumberOfUsers: Int? = nil,
        users: [User]? = nil
    )
    {
        self.marker = marker
        self.totalNumberOfUsers = totalNumberOfUsers
        self.users = users
    }
}

struct DescribeUsersOutputResponseBody: Equatable {
    public let users: [User]?
    public let totalNumberOfUsers: Int?
    public let marker: String?
}

extension DescribeUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case totalNumberOfUsers = "TotalNumberOfUsers"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([User?].self, forKey: .users)
        var usersDecoded0:[User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let totalNumberOfUsersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalNumberOfUsers)
        totalNumberOfUsers = totalNumberOfUsersDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DocumentLockedForCommentsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentLockedForCommentsException(message: \(String(describing: message)))"}
}

extension DocumentLockedForCommentsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentLockedForCommentsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the document is locked for comments and user tries to
///             create or delete a comment on that document.</p>
public struct DocumentLockedForCommentsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentLockedForCommentsExceptionBody: Equatable {
    public let message: String?
}

extension DocumentLockedForCommentsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocumentMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionMetadata = "LatestVersionMetadata"
        case modifiedTimestamp = "ModifiedTimestamp"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
        if let latestVersionMetadata = latestVersionMetadata {
            try encodeContainer.encode(latestVersionMetadata, forKey: .latestVersionMetadata)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let latestVersionMetadataDecoded = try containerValues.decodeIfPresent(DocumentVersionMetadata.self, forKey: .latestVersionMetadata)
        latestVersionMetadata = latestVersionMetadataDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension DocumentMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentMetadata(createdTimestamp: \(String(describing: createdTimestamp)), creatorId: \(String(describing: creatorId)), id: \(String(describing: id)), labels: \(String(describing: labels)), latestVersionMetadata: \(String(describing: latestVersionMetadata)), modifiedTimestamp: \(String(describing: modifiedTimestamp)), parentFolderId: \(String(describing: parentFolderId)), resourceState: \(String(describing: resourceState)))"}
}

/// <p>Describes the document.</p>
public struct DocumentMetadata: Equatable {
    /// <p>The time when the document was created.</p>
    public let createdTimestamp: Date?
    /// <p>The ID of the creator.</p>
    public let creatorId: String?
    /// <p>The ID of the document.</p>
    public let id: String?
    /// <p>List of labels on the document.</p>
    public let labels: [String]?
    /// <p>The latest version of the document.</p>
    public let latestVersionMetadata: DocumentVersionMetadata?
    /// <p>The time when the document was updated.</p>
    public let modifiedTimestamp: Date?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?
    /// <p>The resource state.</p>
    public let resourceState: ResourceStateType?

    public init (
        createdTimestamp: Date? = nil,
        creatorId: String? = nil,
        id: String? = nil,
        labels: [String]? = nil,
        latestVersionMetadata: DocumentVersionMetadata? = nil,
        modifiedTimestamp: Date? = nil,
        parentFolderId: String? = nil,
        resourceState: ResourceStateType? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.creatorId = creatorId
        self.id = id
        self.labels = labels
        self.latestVersionMetadata = latestVersionMetadata
        self.modifiedTimestamp = modifiedTimestamp
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

public enum DocumentSourceType {
    case original
    case withComments
    case sdkUnknown(String)
}

extension DocumentSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentSourceType] {
        return [
            .original,
            .withComments,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .original: return "ORIGINAL"
        case .withComments: return "WITH_COMMENTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentSourceType(rawValue: rawValue) ?? DocumentSourceType.sdkUnknown(rawValue)
    }
}

public enum DocumentStatusType {
    case active
    case initialized
    case sdkUnknown(String)
}

extension DocumentStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentStatusType] {
        return [
            .active,
            .initialized,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .initialized: return "INITIALIZED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentStatusType(rawValue: rawValue) ?? DocumentStatusType.sdkUnknown(rawValue)
    }
}

public enum DocumentThumbnailType {
    case large
    case small
    case smallHq
    case sdkUnknown(String)
}

extension DocumentThumbnailType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentThumbnailType] {
        return [
            .large,
            .small,
            .smallHq,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .large: return "LARGE"
        case .small: return "SMALL"
        case .smallHq: return "SMALL_HQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentThumbnailType(rawValue: rawValue) ?? DocumentThumbnailType.sdkUnknown(rawValue)
    }
}

extension DocumentVersionMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case signature = "Signature"
        case size = "Size"
        case source = "Source"
        case status = "Status"
        case thumbnail = "Thumbnail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = contentCreatedTimestamp {
            try encodeContainer.encode(contentCreatedTimestamp.timeIntervalSince1970, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = contentModifiedTimestamp {
            try encodeContainer.encode(contentModifiedTimestamp.timeIntervalSince1970, forKey: .contentModifiedTimestamp)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let source = source {
            var sourceContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .source)
            for (dictKey0, documentsourceurlmap0) in source {
                try sourceContainer.encode(documentsourceurlmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let thumbnail = thumbnail {
            var thumbnailContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .thumbnail)
            for (dictKey0, documentthumbnailurlmap0) in thumbnail {
                try thumbnailContainer.encode(documentthumbnailurlmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocumentStatusType.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let thumbnailContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .thumbnail)
        var thumbnailDecoded0: [String:String]? = nil
        if let thumbnailContainer = thumbnailContainer {
            thumbnailDecoded0 = [String:String]()
            for (key0, urltype0) in thumbnailContainer {
                if let urltype0 = urltype0 {
                    thumbnailDecoded0?[key0] = urltype0
                }
            }
        }
        thumbnail = thumbnailDecoded0
        let sourceContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .source)
        var sourceDecoded0: [String:String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [String:String]()
            for (key0, urltype0) in sourceContainer {
                if let urltype0 = urltype0 {
                    sourceDecoded0?[key0] = urltype0
                }
            }
        }
        source = sourceDecoded0
    }
}

extension DocumentVersionMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentVersionMetadata(contentCreatedTimestamp: \(String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(String(describing: contentModifiedTimestamp)), contentType: \(String(describing: contentType)), createdTimestamp: \(String(describing: createdTimestamp)), creatorId: \(String(describing: creatorId)), id: \(String(describing: id)), modifiedTimestamp: \(String(describing: modifiedTimestamp)), name: \(String(describing: name)), signature: \(String(describing: signature)), size: \(String(describing: size)), source: \(String(describing: source)), status: \(String(describing: status)), thumbnail: \(String(describing: thumbnail)))"}
}

/// <p>Describes a version of a document.</p>
public struct DocumentVersionMetadata: Equatable {
    /// <p>The timestamp when the content of the document was originally created.</p>
    public let contentCreatedTimestamp: Date?
    /// <p>The timestamp when the content of the document was modified.</p>
    public let contentModifiedTimestamp: Date?
    /// <p>The content type of the document.</p>
    public let contentType: String?
    /// <p>The timestamp when the document was first uploaded.</p>
    public let createdTimestamp: Date?
    /// <p>The ID of the creator.</p>
    public let creatorId: String?
    /// <p>The ID of the version.</p>
    public let id: String?
    /// <p>The timestamp when the document was last uploaded.</p>
    public let modifiedTimestamp: Date?
    /// <p>The name of the version.</p>
    public let name: String?
    /// <p>The signature of the document.</p>
    public let signature: String?
    /// <p>The size of the document, in bytes.</p>
    public let size: Int?
    /// <p>The source of the document.</p>
    public let source: [String:String]?
    /// <p>The status of the document.</p>
    public let status: DocumentStatusType?
    /// <p>The thumbnail of the document.</p>
    public let thumbnail: [String:String]?

    public init (
        contentCreatedTimestamp: Date? = nil,
        contentModifiedTimestamp: Date? = nil,
        contentType: String? = nil,
        createdTimestamp: Date? = nil,
        creatorId: String? = nil,
        id: String? = nil,
        modifiedTimestamp: Date? = nil,
        name: String? = nil,
        signature: String? = nil,
        size: Int? = nil,
        source: [String:String]? = nil,
        status: DocumentStatusType? = nil,
        thumbnail: [String:String]? = nil
    )
    {
        self.contentCreatedTimestamp = contentCreatedTimestamp
        self.contentModifiedTimestamp = contentModifiedTimestamp
        self.contentType = contentType
        self.createdTimestamp = createdTimestamp
        self.creatorId = creatorId
        self.id = id
        self.modifiedTimestamp = modifiedTimestamp
        self.name = name
        self.signature = signature
        self.size = size
        self.source = source
        self.status = status
        self.thumbnail = thumbnail
    }
}

public enum DocumentVersionStatus {
    case active
    case sdkUnknown(String)
}

extension DocumentVersionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentVersionStatus] {
        return [
            .active,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentVersionStatus(rawValue: rawValue) ?? DocumentVersionStatus.sdkUnknown(rawValue)
    }
}

extension DraftUploadOutOfSyncException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DraftUploadOutOfSyncException(message: \(String(describing: message)))"}
}

extension DraftUploadOutOfSyncException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DraftUploadOutOfSyncExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a valid checkout ID is not presented on document
///             version upload calls for a document that has been checked out from Web client.</p>
public struct DraftUploadOutOfSyncException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DraftUploadOutOfSyncExceptionBody: Equatable {
    public let message: String?
}

extension DraftUploadOutOfSyncExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityAlreadyExistsException(message: \(String(describing: message)))"}
}

extension EntityAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct EntityAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension EntityAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityNotExistsException(entityIds: \(String(describing: entityIds)), message: \(String(describing: message)))"}
}

extension EntityNotExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityNotExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityIds = output.entityIds
            self.message = output.message
        } else {
            self.entityIds = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource does not exist.</p>
public struct EntityNotExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var entityIds: [String]?
    public var message: String?

    public init (
        entityIds: [String]? = nil,
        message: String? = nil
    )
    {
        self.entityIds = entityIds
        self.message = message
    }
}

struct EntityNotExistsExceptionBody: Equatable {
    public let message: String?
    public let entityIds: [String]?
}

extension EntityNotExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityIds = "EntityIds"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let entityIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityIds)
        var entityIdsDecoded0:[String]? = nil
        if let entityIdsContainer = entityIdsContainer {
            entityIdsDecoded0 = [String]()
            for string0 in entityIdsContainer {
                if let string0 = string0 {
                    entityIdsDecoded0?.append(string0)
                }
            }
        }
        entityIds = entityIdsDecoded0
    }
}

extension FailedDependencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedDependencyException(message: \(String(describing: message)))"}
}

extension FailedDependencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Directory Service cannot reach an on-premises instance. Or a dependency
///             under the control of the organization is failing, such as a connected Active
///             Directory.</p>
public struct FailedDependencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FailedDependencyExceptionBody: Equatable {
    public let message: String?
}

extension FailedDependencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum FolderContentType {
    case all
    case document
    case folder
    case sdkUnknown(String)
}

extension FolderContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FolderContentType] {
        return [
            .all,
            .document,
            .folder,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .document: return "DOCUMENT"
        case .folder: return "FOLDER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FolderContentType(rawValue: rawValue) ?? FolderContentType.sdkUnknown(rawValue)
    }
}

extension FolderMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionSize = "LatestVersionSize"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
        case signature = "Signature"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
        if let latestVersionSize = latestVersionSize {
            try encodeContainer.encode(latestVersionSize, forKey: .latestVersionSize)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let latestVersionSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .latestVersionSize)
        latestVersionSize = latestVersionSizeDecoded
    }
}

extension FolderMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FolderMetadata(createdTimestamp: \(String(describing: createdTimestamp)), creatorId: \(String(describing: creatorId)), id: \(String(describing: id)), labels: \(String(describing: labels)), latestVersionSize: \(String(describing: latestVersionSize)), modifiedTimestamp: \(String(describing: modifiedTimestamp)), name: \(String(describing: name)), parentFolderId: \(String(describing: parentFolderId)), resourceState: \(String(describing: resourceState)), signature: \(String(describing: signature)), size: \(String(describing: size)))"}
}

/// <p>Describes a folder.</p>
public struct FolderMetadata: Equatable {
    /// <p>The time when the folder was created.</p>
    public let createdTimestamp: Date?
    /// <p>The ID of the creator.</p>
    public let creatorId: String?
    /// <p>The ID of the folder.</p>
    public let id: String?
    /// <p>List of labels on the folder.</p>
    public let labels: [String]?
    /// <p>The size of the latest version of the folder metadata.</p>
    public let latestVersionSize: Int?
    /// <p>The time when the folder was updated.</p>
    public let modifiedTimestamp: Date?
    /// <p>The name of the folder.</p>
    public let name: String?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?
    /// <p>The resource state of the folder.</p>
    public let resourceState: ResourceStateType?
    /// <p>The unique identifier created from the subfolders and documents of the
    ///             folder.</p>
    public let signature: String?
    /// <p>The size of the folder metadata.</p>
    public let size: Int?

    public init (
        createdTimestamp: Date? = nil,
        creatorId: String? = nil,
        id: String? = nil,
        labels: [String]? = nil,
        latestVersionSize: Int? = nil,
        modifiedTimestamp: Date? = nil,
        name: String? = nil,
        parentFolderId: String? = nil,
        resourceState: ResourceStateType? = nil,
        signature: String? = nil,
        size: Int? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.creatorId = creatorId
        self.id = id
        self.labels = labels
        self.latestVersionSize = latestVersionSize
        self.modifiedTimestamp = modifiedTimestamp
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
        self.signature = signature
        self.size = size
    }
}

extension GetCurrentUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCurrentUserInput(authenticationToken: \(String(describing: authenticationToken)))"}
}

extension GetCurrentUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCurrentUserInputHeadersMiddleware: Middleware {
    public let id: String = "GetCurrentUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCurrentUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCurrentUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCurrentUserInput>
    public typealias MOutput = OperationOutput<GetCurrentUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCurrentUserOutputError>
}

public struct GetCurrentUserInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCurrentUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCurrentUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCurrentUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCurrentUserInput>
    public typealias MOutput = OperationOutput<GetCurrentUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCurrentUserOutputError>
}

public struct GetCurrentUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token.</p>
    public let authenticationToken: String?

    public init (
        authenticationToken: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
    }
}

struct GetCurrentUserInputBody: Equatable {
}

extension GetCurrentUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCurrentUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCurrentUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCurrentUserOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCurrentUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCurrentUserOutputResponse(user: \(String(describing: user)))"}
}

extension GetCurrentUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCurrentUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct GetCurrentUserOutputResponse: Equatable {
    /// <p>Metadata of the user.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct GetCurrentUserOutputResponseBody: Equatable {
    public let user: User?
}

extension GetCurrentUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

extension GetDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), includeCustomMetadata: \(String(describing: includeCustomMetadata)))"}
}

extension GetDocumentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentInput>
    public typealias MOutput = OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentOutputError>
}

public struct GetDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let includeCustomMetadataQueryItem = URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: String(input.operationInput.includeCustomMetadata).urlPercentEncoding())
        input.builder.withQueryItem(includeCustomMetadataQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentInput>
    public typealias MOutput = OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentOutputError>
}

public struct GetDocumentInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>Set this to <code>TRUE</code> to include custom metadata in the response.</p>
    public let includeCustomMetadata: Bool

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        includeCustomMetadata: Bool = false
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetDocumentInputBody: Equatable {
}

extension GetDocumentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPasswordException(InvalidPasswordException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentOutputResponse(customMetadata: \(String(describing: customMetadata)), metadata: \(String(describing: metadata)))"}
}

extension GetDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentOutputResponse: Equatable {
    /// <p>The custom metadata on the document.</p>
    public let customMetadata: [String:String]?
    /// <p>The metadata details of the document.</p>
    public let metadata: DocumentMetadata?

    public init (
        customMetadata: [String:String]? = nil,
        metadata: DocumentMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentOutputResponseBody: Equatable {
    public let metadata: DocumentMetadata?
    public let customMetadata: [String:String]?
}

extension GetDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [String:String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [String:String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetDocumentPathInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentPathInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), fields: \(String(describing: fields)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension GetDocumentPathInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentPathInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentPathInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentPathInput>
    public typealias MOutput = OperationOutput<GetDocumentPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentPathOutputError>
}

public struct GetDocumentPathInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentPathInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fields = input.operationInput.fields {
            let fieldsQueryItem = URLQueryItem(name: "fields".urlPercentEncoding(), value: String(fields).urlPercentEncoding())
            input.builder.withQueryItem(fieldsQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentPathInput>
    public typealias MOutput = OperationOutput<GetDocumentPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentPathOutputError>
}

public struct GetDocumentPathInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>A comma-separated list of values. Specify <code>NAME</code> to include the names of
    ///             the parent folders.</p>
    public let fields: String?
    /// <p>The maximum number of levels in the hierarchy to return.</p>
    public let limit: Int?
    /// <p>This value is not supported.</p>
    public let marker: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        fields: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.limit = limit
        self.marker = marker
    }
}

struct GetDocumentPathInputBody: Equatable {
}

extension GetDocumentPathInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentPathOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentPathOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentPathOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentPathOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentPathOutputResponse(path: \(String(describing: path)))"}
}

extension GetDocumentPathOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentPathOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetDocumentPathOutputResponse: Equatable {
    /// <p>The path information.</p>
    public let path: ResourcePath?

    public init (
        path: ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetDocumentPathOutputResponseBody: Equatable {
    public let path: ResourcePath?
}

extension GetDocumentPathOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case path = "Path"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

extension GetDocumentVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentVersionInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), fields: \(String(describing: fields)), includeCustomMetadata: \(String(describing: includeCustomMetadata)), versionId: \(String(describing: versionId)))"}
}

extension GetDocumentVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDocumentVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentVersionInput>
    public typealias MOutput = OperationOutput<GetDocumentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentVersionOutputError>
}

public struct GetDocumentVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fields = input.operationInput.fields {
            let fieldsQueryItem = URLQueryItem(name: "fields".urlPercentEncoding(), value: String(fields).urlPercentEncoding())
            input.builder.withQueryItem(fieldsQueryItem)
        }
        let includeCustomMetadataQueryItem = URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: String(input.operationInput.includeCustomMetadata).urlPercentEncoding())
        input.builder.withQueryItem(includeCustomMetadataQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentVersionInput>
    public typealias MOutput = OperationOutput<GetDocumentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentVersionOutputError>
}

public struct GetDocumentVersionInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>A comma-separated list of values. Specify "SOURCE" to include a URL for the source
    ///             document.</p>
    public let fields: String?
    /// <p>Set this to TRUE to include custom metadata in the response.</p>
    public let includeCustomMetadata: Bool
    /// <p>The version ID of the document.</p>
    public let versionId: String?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        fields: String? = nil,
        includeCustomMetadata: Bool = false,
        versionId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.includeCustomMetadata = includeCustomMetadata
        self.versionId = versionId
    }
}

struct GetDocumentVersionInputBody: Equatable {
}

extension GetDocumentVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDocumentVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentVersionOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidPasswordException(InvalidPasswordException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentVersionOutputResponse(customMetadata: \(String(describing: customMetadata)), metadata: \(String(describing: metadata)))"}
}

extension GetDocumentVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentVersionOutputResponse: Equatable {
    /// <p>The custom metadata on the document version.</p>
    public let customMetadata: [String:String]?
    /// <p>The version metadata.</p>
    public let metadata: DocumentVersionMetadata?

    public init (
        customMetadata: [String:String]? = nil,
        metadata: DocumentVersionMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentVersionOutputResponseBody: Equatable {
    public let metadata: DocumentVersionMetadata?
    public let customMetadata: [String:String]?
}

extension GetDocumentVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(DocumentVersionMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [String:String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [String:String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderInput(authenticationToken: \(String(describing: authenticationToken)), folderId: \(String(describing: folderId)), includeCustomMetadata: \(String(describing: includeCustomMetadata)))"}
}

extension GetFolderInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFolderInputHeadersMiddleware: Middleware {
    public let id: String = "GetFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderInput>
    public typealias MOutput = OperationOutput<GetFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderOutputError>
}

public struct GetFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let includeCustomMetadataQueryItem = URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: String(input.operationInput.includeCustomMetadata).urlPercentEncoding())
        input.builder.withQueryItem(includeCustomMetadataQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderInput>
    public typealias MOutput = OperationOutput<GetFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderOutputError>
}

public struct GetFolderInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?
    /// <p>Set to TRUE to include custom metadata in the response.</p>
    public let includeCustomMetadata: Bool

    public init (
        authenticationToken: String? = nil,
        folderId: String? = nil,
        includeCustomMetadata: Bool = false
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetFolderInputBody: Equatable {
}

extension GetFolderInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFolderOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderOutputResponse(customMetadata: \(String(describing: customMetadata)), metadata: \(String(describing: metadata)))"}
}

extension GetFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFolderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetFolderOutputResponse: Equatable {
    /// <p>The custom metadata on the folder.</p>
    public let customMetadata: [String:String]?
    /// <p>The metadata of the folder.</p>
    public let metadata: FolderMetadata?

    public init (
        customMetadata: [String:String]? = nil,
        metadata: FolderMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetFolderOutputResponseBody: Equatable {
    public let metadata: FolderMetadata?
    public let customMetadata: [String:String]?
}

extension GetFolderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [String:String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [String:String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetFolderPathInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderPathInput(authenticationToken: \(String(describing: authenticationToken)), fields: \(String(describing: fields)), folderId: \(String(describing: folderId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension GetFolderPathInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFolderPathInputHeadersMiddleware: Middleware {
    public let id: String = "GetFolderPathInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderPathInput>
    public typealias MOutput = OperationOutput<GetFolderPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderPathOutputError>
}

public struct GetFolderPathInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFolderPathInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fields = input.operationInput.fields {
            let fieldsQueryItem = URLQueryItem(name: "fields".urlPercentEncoding(), value: String(fields).urlPercentEncoding())
            input.builder.withQueryItem(fieldsQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderPathInput>
    public typealias MOutput = OperationOutput<GetFolderPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderPathOutputError>
}

public struct GetFolderPathInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>A comma-separated list of values. Specify "NAME" to include the names of the parent
    ///             folders.</p>
    public let fields: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?
    /// <p>The maximum number of levels in the hierarchy to return.</p>
    public let limit: Int?
    /// <p>This value is not supported.</p>
    public let marker: String?

    public init (
        authenticationToken: String? = nil,
        fields: String? = nil,
        folderId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.folderId = folderId
        self.limit = limit
        self.marker = marker
    }
}

struct GetFolderPathInputBody: Equatable {
}

extension GetFolderPathInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFolderPathOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderPathOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFolderPathOutputError: Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderPathOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderPathOutputResponse(path: \(String(describing: path)))"}
}

extension GetFolderPathOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFolderPathOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetFolderPathOutputResponse: Equatable {
    /// <p>The path information.</p>
    public let path: ResourcePath?

    public init (
        path: ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetFolderPathOutputResponseBody: Equatable {
    public let path: ResourcePath?
}

extension GetFolderPathOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case path = "Path"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

extension GetResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesInput(authenticationToken: \(String(describing: authenticationToken)), collectionType: \(String(describing: collectionType)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), userId: \(String(describing: userId)))"}
}

extension GetResourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

public struct GetResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let userId = input.operationInput.userId {
            let userIdQueryItem = URLQueryItem(name: "userId".urlPercentEncoding(), value: String(userId).urlPercentEncoding())
            input.builder.withQueryItem(userIdQueryItem)
        }
        if let collectionType = input.operationInput.collectionType {
            let collectionTypeQueryItem = URLQueryItem(name: "collectionType".urlPercentEncoding(), value: String(collectionType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(collectionTypeQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcesInput>
    public typealias MOutput = OperationOutput<GetResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcesOutputError>
}

public struct GetResourcesInput: Equatable {
    /// <p>The Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The collection type.</p>
    public let collectionType: ResourceCollectionType?
    /// <p>The maximum number of resources to return.</p>
    public let limit: Int?
    /// <p>The marker for the next set of results. This marker was received from a previous call.</p>
    public let marker: String?
    /// <p>The user ID for the resource collection. This is a required field for accessing the
    ///             API operation using IAM credentials.</p>
    public let userId: String?

    public init (
        authenticationToken: String? = nil,
        collectionType: ResourceCollectionType? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        userId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.collectionType = collectionType
        self.limit = limit
        self.marker = marker
        self.userId = userId
    }
}

struct GetResourcesInputBody: Equatable {
}

extension GetResourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcesOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcesOutputResponse(documents: \(String(describing: documents)), folders: \(String(describing: folders)), marker: \(String(describing: marker)))"}
}

extension GetResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct GetResourcesOutputResponse: Equatable {
    /// <p>The documents in the specified collection.</p>
    public let documents: [DocumentMetadata]?
    /// <p>The folders in the specified folder.</p>
    public let folders: [FolderMetadata]?
    /// <p>The marker to use when requesting the next set of results. If there are no additional results, the string is empty.</p>
    public let marker: String?

    public init (
        documents: [DocumentMetadata]? = nil,
        folders: [FolderMetadata]? = nil,
        marker: String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct GetResourcesOutputResponseBody: Equatable {
    public let folders: [FolderMetadata]?
    public let documents: [DocumentMetadata]?
    public let marker: String?
}

extension GetResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension GroupMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroupMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupMetadata(id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Describes the metadata of a user group.</p>
public struct GroupMetadata: Equatable {
    /// <p>The ID of the user group.</p>
    public let id: String?
    /// <p>The name of the group.</p>
    public let name: String?

    public init (
        id: String? = nil,
        name: String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

extension IllegalUserStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalUserStateException(message: \(String(describing: message)))"}
}

extension IllegalUserStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IllegalUserStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user is undergoing transfer of ownership.</p>
public struct IllegalUserStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUserStateExceptionBody: Equatable {
    public let message: String?
}

extension IllegalUserStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct InitiateDocumentVersionUploadInputBodyMiddleware: Middleware {
    public let id: String = "InitiateDocumentVersionUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateDocumentVersionUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateDocumentVersionUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateDocumentVersionUploadInput>
    public typealias MOutput = OperationOutput<InitiateDocumentVersionUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateDocumentVersionUploadOutputError>
}

extension InitiateDocumentVersionUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateDocumentVersionUploadInput(authenticationToken: \(String(describing: authenticationToken)), contentCreatedTimestamp: \(String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(String(describing: contentModifiedTimestamp)), contentType: \(String(describing: contentType)), documentSizeInBytes: \(String(describing: documentSizeInBytes)), id: \(String(describing: id)), name: \(String(describing: name)), parentFolderId: \(String(describing: parentFolderId)))"}
}

extension InitiateDocumentVersionUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = contentCreatedTimestamp {
            try encodeContainer.encode(contentCreatedTimestamp.timeIntervalSince1970, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = contentModifiedTimestamp {
            try encodeContainer.encode(contentModifiedTimestamp.timeIntervalSince1970, forKey: .contentModifiedTimestamp)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let documentSizeInBytes = documentSizeInBytes {
            try encodeContainer.encode(documentSizeInBytes, forKey: .documentSizeInBytes)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

public struct InitiateDocumentVersionUploadInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateDocumentVersionUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateDocumentVersionUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateDocumentVersionUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateDocumentVersionUploadInput>
    public typealias MOutput = OperationOutput<InitiateDocumentVersionUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateDocumentVersionUploadOutputError>
}

public struct InitiateDocumentVersionUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateDocumentVersionUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateDocumentVersionUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateDocumentVersionUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateDocumentVersionUploadInput>
    public typealias MOutput = OperationOutput<InitiateDocumentVersionUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateDocumentVersionUploadOutputError>
}

public struct InitiateDocumentVersionUploadInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The timestamp when the content of the document was originally created.</p>
    public let contentCreatedTimestamp: Date?
    /// <p>The timestamp when the content of the document was modified.</p>
    public let contentModifiedTimestamp: Date?
    /// <p>The content type of the document.</p>
    public let contentType: String?
    /// <p>The size of the document, in bytes.</p>
    public let documentSizeInBytes: Int?
    /// <p>The ID of the document.</p>
    public let id: String?
    /// <p>The name of the document.</p>
    public let name: String?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?

    public init (
        authenticationToken: String? = nil,
        contentCreatedTimestamp: Date? = nil,
        contentModifiedTimestamp: Date? = nil,
        contentType: String? = nil,
        documentSizeInBytes: Int? = nil,
        id: String? = nil,
        name: String? = nil,
        parentFolderId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.contentCreatedTimestamp = contentCreatedTimestamp
        self.contentModifiedTimestamp = contentModifiedTimestamp
        self.contentType = contentType
        self.documentSizeInBytes = documentSizeInBytes
        self.id = id
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct InitiateDocumentVersionUploadInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let contentCreatedTimestamp: Date?
    public let contentModifiedTimestamp: Date?
    public let contentType: String?
    public let documentSizeInBytes: Int?
    public let parentFolderId: String?
}

extension InitiateDocumentVersionUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let documentSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .documentSizeInBytes)
        documentSizeInBytes = documentSizeInBytesDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension InitiateDocumentVersionUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateDocumentVersionUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DraftUploadOutOfSyncException" : self = .draftUploadOutOfSyncException(try DraftUploadOutOfSyncException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyCheckedOutException" : self = .resourceAlreadyCheckedOutException(try ResourceAlreadyCheckedOutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageLimitExceededException" : self = .storageLimitExceededException(try StorageLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageLimitWillExceedException" : self = .storageLimitWillExceedException(try StorageLimitWillExceedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateDocumentVersionUploadOutputError: Equatable {
    case draftUploadOutOfSyncException(DraftUploadOutOfSyncException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case resourceAlreadyCheckedOutException(ResourceAlreadyCheckedOutException)
    case serviceUnavailableException(ServiceUnavailableException)
    case storageLimitExceededException(StorageLimitExceededException)
    case storageLimitWillExceedException(StorageLimitWillExceedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateDocumentVersionUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateDocumentVersionUploadOutputResponse(metadata: \(String(describing: metadata)), uploadMetadata: \(String(describing: uploadMetadata)))"}
}

extension InitiateDocumentVersionUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InitiateDocumentVersionUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.metadata = nil
            self.uploadMetadata = nil
        }
    }
}

public struct InitiateDocumentVersionUploadOutputResponse: Equatable {
    /// <p>The document metadata.</p>
    public let metadata: DocumentMetadata?
    /// <p>The upload metadata.</p>
    public let uploadMetadata: UploadMetadata?

    public init (
        metadata: DocumentMetadata? = nil,
        uploadMetadata: UploadMetadata? = nil
    )
    {
        self.metadata = metadata
        self.uploadMetadata = uploadMetadata
    }
}

struct InitiateDocumentVersionUploadOutputResponseBody: Equatable {
    public let metadata: DocumentMetadata?
    public let uploadMetadata: UploadMetadata?
}

extension InitiateDocumentVersionUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case uploadMetadata = "UploadMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination marker or limit fields are not valid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCommentOperationException(message: \(String(describing: message)))"}
}

extension InvalidCommentOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCommentOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not allowed on the specified comment object.</p>
public struct InvalidCommentOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommentOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCommentOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is invalid.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPasswordException(message: \(String(describing: message)))"}
}

extension InvalidPasswordException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The password is invalid.</p>
public struct InvalidPasswordException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPasswordExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum of 100,000 folders under the parent folder has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LocaleType {
    case de
    case `default`
    case en
    case es
    case fr
    case ja
    case ko
    case ptBr
    case ru
    case zhCn
    case zhTw
    case sdkUnknown(String)
}

extension LocaleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LocaleType] {
        return [
            .de,
            .default,
            .en,
            .es,
            .fr,
            .ja,
            .ko,
            .ptBr,
            .ru,
            .zhCn,
            .zhTw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .de: return "de"
        case .default: return "default"
        case .en: return "en"
        case .es: return "es"
        case .fr: return "fr"
        case .ja: return "ja"
        case .ko: return "ko"
        case .ptBr: return "pt_BR"
        case .ru: return "ru"
        case .zhCn: return "zh_CN"
        case .zhTw: return "zh_TW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LocaleType(rawValue: rawValue) ?? LocaleType.sdkUnknown(rawValue)
    }
}

extension NotificationOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailMessage = "EmailMessage"
        case sendEmail = "SendEmail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if sendEmail != false {
            try encodeContainer.encode(sendEmail, forKey: .sendEmail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendEmailDecoded = try containerValues.decode(Bool.self, forKey: .sendEmail)
        sendEmail = sendEmailDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
    }
}

extension NotificationOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationOptions(emailMessage: \(String(describing: emailMessage)), sendEmail: \(String(describing: sendEmail)))"}
}

/// <p>Set of options which defines notification preferences of given action.</p>
public struct NotificationOptions: Equatable {
    /// <p>Text value to be included in the email body.</p>
    public let emailMessage: String?
    /// <p>Boolean value to indicate an email notification should be sent to the
    ///             receipients.</p>
    public let sendEmail: Bool

    public init (
        emailMessage: String? = nil,
        sendEmail: Bool = false
    )
    {
        self.emailMessage = emailMessage
        self.sendEmail = sendEmail
    }
}

public enum OrderType {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension OrderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderType] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderType(rawValue: rawValue) ?? OrderType.sdkUnknown(rawValue)
    }
}

extension Participants: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case users = "Users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupmetadatalist0 in groups {
                try groupsContainer.encode(groupmetadatalist0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for usermetadatalist0 in users {
                try usersContainer.encode(usermetadatalist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([UserMetadata?].self, forKey: .users)
        var usersDecoded0:[UserMetadata]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserMetadata]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension Participants: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Participants(groups: \(String(describing: groups)), users: \(String(describing: users)))"}
}

/// <p>Describes the users or user groups.</p>
public struct Participants: Equatable {
    /// <p>The list of user groups.</p>
    public let groups: [GroupMetadata]?
    /// <p>The list of users.</p>
    public let users: [UserMetadata]?

    public init (
        groups: [GroupMetadata]? = nil,
        users: [UserMetadata]? = nil
    )
    {
        self.groups = groups
        self.users = users
    }
}

extension PermissionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .role)
        role = roleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RolePermissionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PermissionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionInfo(role: \(String(describing: role)), type: \(String(describing: type)))"}
}

/// <p>Describes the permissions.</p>
public struct PermissionInfo: Equatable {
    /// <p>The role of the user.</p>
    public let role: RoleType?
    /// <p>The type of permissions.</p>
    public let type: RolePermissionType?

    public init (
        role: RoleType? = nil,
        type: RolePermissionType? = nil
    )
    {
        self.role = role
        self.type = type
    }
}

extension Principal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case roles = "Roles"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for permissioninfolist0 in roles {
                try rolesContainer.encode(permissioninfolist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .type)
        type = typeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([PermissionInfo?].self, forKey: .roles)
        var rolesDecoded0:[PermissionInfo]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [PermissionInfo]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension Principal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Principal(id: \(String(describing: id)), roles: \(String(describing: roles)), type: \(String(describing: type)))"}
}

/// <p>Describes a resource.</p>
public struct Principal: Equatable {
    /// <p>The ID of the resource.</p>
    public let id: String?
    /// <p>The permission information for the resource.</p>
    public let roles: [PermissionInfo]?
    /// <p>The type of resource.</p>
    public let type: PrincipalType?

    public init (
        id: String? = nil,
        roles: [PermissionInfo]? = nil,
        type: PrincipalType? = nil
    )
    {
        self.id = id
        self.roles = roles
        self.type = type
    }
}

public enum PrincipalType {
    case anonymous
    case group
    case invite
    case organization
    case user
    case sdkUnknown(String)
}

extension PrincipalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrincipalType] {
        return [
            .anonymous,
            .group,
            .invite,
            .organization,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .anonymous: return "ANONYMOUS"
        case .group: return "GROUP"
        case .invite: return "INVITE"
        case .organization: return "ORGANIZATION"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
    }
}

extension ProhibitedStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProhibitedStateException(message: \(String(describing: message)))"}
}

extension ProhibitedStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProhibitedStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified document version is not in the INITIALIZED state.</p>
public struct ProhibitedStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProhibitedStateExceptionBody: Equatable {
    public let message: String?
}

extension ProhibitedStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RemoveAllResourcePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAllResourcePermissionsInput(authenticationToken: \(String(describing: authenticationToken)), resourceId: \(String(describing: resourceId)))"}
}

extension RemoveAllResourcePermissionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveAllResourcePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveAllResourcePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAllResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAllResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAllResourcePermissionsInput>
    public typealias MOutput = OperationOutput<RemoveAllResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAllResourcePermissionsOutputError>
}

public struct RemoveAllResourcePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveAllResourcePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAllResourcePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAllResourcePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAllResourcePermissionsInput>
    public typealias MOutput = OperationOutput<RemoveAllResourcePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAllResourcePermissionsOutputError>
}

public struct RemoveAllResourcePermissionsInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.resourceId = resourceId
    }
}

struct RemoveAllResourcePermissionsInputBody: Equatable {
}

extension RemoveAllResourcePermissionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveAllResourcePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAllResourcePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAllResourcePermissionsOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAllResourcePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAllResourcePermissionsOutputResponse()"}
}

extension RemoveAllResourcePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveAllResourcePermissionsOutputResponse: Equatable {

    public init() {}
}

struct RemoveAllResourcePermissionsOutputResponseBody: Equatable {
}

extension RemoveAllResourcePermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveResourcePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveResourcePermissionInput(authenticationToken: \(String(describing: authenticationToken)), principalId: \(String(describing: principalId)), principalType: \(String(describing: principalType)), resourceId: \(String(describing: resourceId)))"}
}

extension RemoveResourcePermissionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveResourcePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveResourcePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveResourcePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveResourcePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveResourcePermissionInput>
    public typealias MOutput = OperationOutput<RemoveResourcePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveResourcePermissionOutputError>
}

public struct RemoveResourcePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveResourcePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveResourcePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveResourcePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let principalType = input.operationInput.principalType {
            let principalTypeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(principalType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(principalTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveResourcePermissionInput>
    public typealias MOutput = OperationOutput<RemoveResourcePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveResourcePermissionOutputError>
}

public struct RemoveResourcePermissionInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The principal ID of the resource.</p>
    public let principalId: String?
    /// <p>The principal type of the resource.</p>
    public let principalType: PrincipalType?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?

    public init (
        authenticationToken: String? = nil,
        principalId: String? = nil,
        principalType: PrincipalType? = nil,
        resourceId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.principalId = principalId
        self.principalType = principalType
        self.resourceId = resourceId
    }
}

struct RemoveResourcePermissionInputBody: Equatable {
}

extension RemoveResourcePermissionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveResourcePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveResourcePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveResourcePermissionOutputError: Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveResourcePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveResourcePermissionOutputResponse()"}
}

extension RemoveResourcePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveResourcePermissionOutputResponse: Equatable {

    public init() {}
}

struct RemoveResourcePermissionOutputResponseBody: Equatable {
}

extension RemoveResourcePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestedEntityTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestedEntityTooLargeException(message: \(String(describing: message)))"}
}

extension RequestedEntityTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestedEntityTooLargeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
public struct RequestedEntityTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestedEntityTooLargeExceptionBody: Equatable {
    public let message: String?
}

extension RequestedEntityTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyCheckedOutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyCheckedOutException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyCheckedOutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyCheckedOutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is already checked out.</p>
public struct ResourceAlreadyCheckedOutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyCheckedOutExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyCheckedOutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceCollectionType {
    case sharedWithMe
    case sdkUnknown(String)
}

extension ResourceCollectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceCollectionType] {
        return [
            .sharedWithMe,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sharedWithMe: return "SHARED_WITH_ME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
    }
}

extension ResourceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case originalName = "OriginalName"
        case owner = "Owner"
        case parentId = "ParentId"
        case type = "Type"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let originalName = originalName {
            try encodeContainer.encode(originalName, forKey: .originalName)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let originalNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originalName)
        originalName = originalNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(UserMetadata.self, forKey: .owner)
        owner = ownerDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentId)
        parentId = parentIdDecoded
    }
}

extension ResourceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceMetadata(id: \(String(describing: id)), name: \(String(describing: name)), originalName: \(String(describing: originalName)), owner: \(String(describing: owner)), parentId: \(String(describing: parentId)), type: \(String(describing: type)), versionId: \(String(describing: versionId)))"}
}

/// <p>Describes the metadata of a resource.</p>
public struct ResourceMetadata: Equatable {
    /// <p>The ID of the resource.</p>
    public let id: String?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The original name of the resource before a rename operation.</p>
    public let originalName: String?
    /// <p>The owner of the resource.</p>
    public let owner: UserMetadata?
    /// <p>The parent ID of the resource before a rename operation.</p>
    public let parentId: String?
    /// <p>The type of resource.</p>
    public let type: ResourceType?
    /// <p>The version ID of the resource. This is an optional field and is filled for action
    ///             on document version.</p>
    public let versionId: String?

    public init (
        id: String? = nil,
        name: String? = nil,
        originalName: String? = nil,
        owner: UserMetadata? = nil,
        parentId: String? = nil,
        type: ResourceType? = nil,
        versionId: String? = nil
    )
    {
        self.id = id
        self.name = name
        self.originalName = originalName
        self.owner = owner
        self.parentId = parentId
        self.type = type
        self.versionId = versionId
    }
}

extension ResourcePath: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case components = "Components"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for resourcepathcomponentlist0 in components {
                try componentsContainer.encode(resourcepathcomponentlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([ResourcePathComponent?].self, forKey: .components)
        var componentsDecoded0:[ResourcePathComponent]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ResourcePathComponent]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
    }
}

extension ResourcePath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePath(components: \(String(describing: components)))"}
}

/// <p>Describes the path information of a resource.</p>
public struct ResourcePath: Equatable {
    /// <p>The components of the resource path.</p>
    public let components: [ResourcePathComponent]?

    public init (
        components: [ResourcePathComponent]? = nil
    )
    {
        self.components = components
    }
}

extension ResourcePathComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ResourcePathComponent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePathComponent(id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Describes the resource path.</p>
public struct ResourcePathComponent: Equatable {
    /// <p>The ID of the resource path.</p>
    public let id: String?
    /// <p>The name of the resource path.</p>
    public let name: String?

    public init (
        id: String? = nil,
        name: String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

public enum ResourceSortType {
    case date
    case name
    case sdkUnknown(String)
}

extension ResourceSortType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceSortType] {
        return [
            .date,
            .name,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .date: return "DATE"
        case .name: return "NAME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceSortType(rawValue: rawValue) ?? ResourceSortType.sdkUnknown(rawValue)
    }
}

public enum ResourceStateType {
    case active
    case recycled
    case recycling
    case restoring
    case sdkUnknown(String)
}

extension ResourceStateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStateType] {
        return [
            .active,
            .recycled,
            .recycling,
            .restoring,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .recycled: return "RECYCLED"
        case .recycling: return "RECYCLING"
        case .restoring: return "RESTORING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStateType(rawValue: rawValue) ?? ResourceStateType.sdkUnknown(rawValue)
    }
}

public enum ResourceType {
    case document
    case folder
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .document,
            .folder,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .document: return "DOCUMENT"
        case .folder: return "FOLDER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public enum RolePermissionType {
    case direct
    case inherited
    case sdkUnknown(String)
}

extension RolePermissionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RolePermissionType] {
        return [
            .direct,
            .inherited,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .direct: return "DIRECT"
        case .inherited: return "INHERITED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RolePermissionType(rawValue: rawValue) ?? RolePermissionType.sdkUnknown(rawValue)
    }
}

public enum RoleType {
    case contributor
    case coowner
    case owner
    case viewer
    case sdkUnknown(String)
}

extension RoleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RoleType] {
        return [
            .contributor,
            .coowner,
            .owner,
            .viewer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contributor: return "CONTRIBUTOR"
        case .coowner: return "COOWNER"
        case .owner: return "OWNER"
        case .viewer: return "VIEWER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the dependencies is unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SharePrincipal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .role)
        role = roleDecoded
    }
}

extension SharePrincipal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SharePrincipal(id: \(String(describing: id)), role: \(String(describing: role)), type: \(String(describing: type)))"}
}

/// <p>Describes the recipient type and ID, if available.</p>
public struct SharePrincipal: Equatable {
    /// <p>The ID of the recipient.</p>
    public let id: String?
    /// <p>The role of the recipient.</p>
    public let role: RoleType?
    /// <p>The type of the recipient.</p>
    public let type: PrincipalType?

    public init (
        id: String? = nil,
        role: RoleType? = nil,
        type: PrincipalType? = nil
    )
    {
        self.id = id
        self.role = role
        self.type = type
    }
}

extension ShareResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inviteePrincipalId = "InviteePrincipalId"
        case principalId = "PrincipalId"
        case role = "Role"
        case shareId = "ShareId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inviteePrincipalId = inviteePrincipalId {
            try encodeContainer.encode(inviteePrincipalId, forKey: .inviteePrincipalId)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let inviteePrincipalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inviteePrincipalId)
        inviteePrincipalId = inviteePrincipalIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .role)
        role = roleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ShareStatusType.self, forKey: .status)
        status = statusDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ShareResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareResult(inviteePrincipalId: \(String(describing: inviteePrincipalId)), principalId: \(String(describing: principalId)), role: \(String(describing: role)), shareId: \(String(describing: shareId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Describes the share results of a resource.</p>
public struct ShareResult: Equatable {
    /// <p>The ID of the invited user.</p>
    public let inviteePrincipalId: String?
    /// <p>The ID of the principal.</p>
    public let principalId: String?
    /// <p>The role.</p>
    public let role: RoleType?
    /// <p>The ID of the resource that was shared.</p>
    public let shareId: String?
    /// <p>The status.</p>
    public let status: ShareStatusType?
    /// <p>The status message.</p>
    public let statusMessage: String?

    public init (
        inviteePrincipalId: String? = nil,
        principalId: String? = nil,
        role: RoleType? = nil,
        shareId: String? = nil,
        status: ShareStatusType? = nil,
        statusMessage: String? = nil
    )
    {
        self.inviteePrincipalId = inviteePrincipalId
        self.principalId = principalId
        self.role = role
        self.shareId = shareId
        self.status = status
        self.statusMessage = statusMessage
    }
}

public enum ShareStatusType {
    case failure
    case success
    case sdkUnknown(String)
}

extension ShareStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareStatusType] {
        return [
            .failure,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "FAILURE"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareStatusType(rawValue: rawValue) ?? ShareStatusType.sdkUnknown(rawValue)
    }
}

extension StorageLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLimitExceededException(message: \(String(describing: message)))"}
}

extension StorageLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StorageLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The storage limit has been exceeded.</p>
public struct StorageLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension StorageLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageLimitWillExceedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageLimitWillExceedException(message: \(String(describing: message)))"}
}

extension StorageLimitWillExceedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StorageLimitWillExceedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The storage limit will be exceeded.</p>
public struct StorageLimitWillExceedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StorageLimitWillExceedExceptionBody: Equatable {
    public let message: String?
}

extension StorageLimitWillExceedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageRuleType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storageAllocatedInBytes = "StorageAllocatedInBytes"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageAllocatedInBytes = storageAllocatedInBytes {
            try encodeContainer.encode(storageAllocatedInBytes, forKey: .storageAllocatedInBytes)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageAllocatedInBytes)
        storageAllocatedInBytes = storageAllocatedInBytesDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
    }
}

extension StorageRuleType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StorageRuleType(storageAllocatedInBytes: \(String(describing: storageAllocatedInBytes)), storageType: \(String(describing: storageType)))"}
}

/// <p>Describes the storage for a user.</p>
public struct StorageRuleType: Equatable {
    /// <p>The amount of storage allocated, in bytes.</p>
    public let storageAllocatedInBytes: Int?
    /// <p>The type of storage.</p>
    public let storageType: StorageType?

    public init (
        storageAllocatedInBytes: Int? = nil,
        storageType: StorageType? = nil
    )
    {
        self.storageAllocatedInBytes = storageAllocatedInBytes
        self.storageType = storageType
    }
}

public enum StorageType {
    case quota
    case unlimited
    case sdkUnknown(String)
}

extension StorageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageType] {
        return [
            .quota,
            .unlimited,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .quota: return "QUOTA"
        case .unlimited: return "UNLIMITED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
    }
}

extension Subscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endPoint = "EndPoint"
        case `protocol` = "Protocol"
        case subscriptionId = "SubscriptionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endPoint = endPoint {
            try encodeContainer.encode(endPoint, forKey: .endPoint)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionId = subscriptionId {
            try encodeContainer.encode(subscriptionId, forKey: .subscriptionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
        let endPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endPoint)
        endPoint = endPointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension Subscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscription(endPoint: \(String(describing: endPoint)), protocol: \(String(describing: `protocol`)), subscriptionId: \(String(describing: subscriptionId)))"}
}

/// <p>Describes a subscription.</p>
public struct Subscription: Equatable {
    /// <p>The protocol of the subscription.</p>
    public let `protocol`: SubscriptionProtocolType?
    /// <p>The endpoint of the subscription.</p>
    public let endPoint: String?
    /// <p>The ID of the subscription.</p>
    public let subscriptionId: String?

    public init (
        `protocol`: SubscriptionProtocolType? = nil,
        endPoint: String? = nil,
        subscriptionId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.endPoint = endPoint
        self.subscriptionId = subscriptionId
    }
}

public enum SubscriptionProtocolType {
    case https
    case sdkUnknown(String)
}

extension SubscriptionProtocolType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionProtocolType] {
        return [
            .https,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .https: return "HTTPS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionProtocolType(rawValue: rawValue) ?? SubscriptionProtocolType.sdkUnknown(rawValue)
    }
}

public enum SubscriptionType {
    case all
    case sdkUnknown(String)
}

extension SubscriptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionType] {
        return [
            .all,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
    }
}

extension TooManyLabelsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyLabelsException(message: \(String(describing: message)))"}
}

extension TooManyLabelsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyLabelsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit has been reached on the number of labels for the specified
///             resource.</p>
public struct TooManyLabelsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLabelsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyLabelsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManySubscriptionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManySubscriptionsException(message: \(String(describing: message)))"}
}

extension TooManySubscriptionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManySubscriptionsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of subscriptions for the WorkDocs
///             instance.</p>
public struct TooManySubscriptionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManySubscriptionsExceptionBody: Equatable {
    public let message: String?
}

extension TooManySubscriptionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedOperationException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension UnauthorizedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is not permitted.</p>
public struct UnauthorizedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedOperationExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension UnauthorizedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnauthorizedResourceAccessException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedResourceAccessException(message: \(String(describing: message)))"}
}

extension UnauthorizedResourceAccessException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedResourceAccessExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller does not have access to perform the action on the resource.</p>
public struct UnauthorizedResourceAccessException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedResourceAccessExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedResourceAccessExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateDocumentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

extension UpdateDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), name: \(String(describing: name)), parentFolderId: \(String(describing: parentFolderId)), resourceState: \(String(describing: resourceState)))"}
}

extension UpdateDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

public struct UpdateDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>The name of the document.</p>
    public let name: String?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?
    /// <p>The resource state of the document. Only ACTIVE and RECYCLED are
    ///             supported.</p>
    public let resourceState: ResourceStateType?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        name: String? = nil,
        parentFolderId: String? = nil,
        resourceState: ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateDocumentInputBody: Equatable {
    public let name: String?
    public let parentFolderId: String?
    public let resourceState: ResourceStateType?
}

extension UpdateDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentOutputResponse()"}
}

extension UpdateDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentOutputResponse: Equatable {

    public init() {}
}

struct UpdateDocumentOutputResponseBody: Equatable {
}

extension UpdateDocumentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDocumentVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentVersionOutputError>
}

extension UpdateDocumentVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentVersionInput(authenticationToken: \(String(describing: authenticationToken)), documentId: \(String(describing: documentId)), versionId: \(String(describing: versionId)), versionStatus: \(String(describing: versionStatus)))"}
}

extension UpdateDocumentVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case versionStatus = "VersionStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionStatus = versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }
}

public struct UpdateDocumentVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentVersionOutputError>
}

public struct UpdateDocumentVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentVersionOutputError>
}

public struct UpdateDocumentVersionInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the document.</p>
    public let documentId: String?
    /// <p>The version ID of the document.</p>
    public let versionId: String?
    /// <p>The status of the version.</p>
    public let versionStatus: DocumentVersionStatus?

    public init (
        authenticationToken: String? = nil,
        documentId: String? = nil,
        versionId: String? = nil,
        versionStatus: DocumentVersionStatus? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
        self.versionStatus = versionStatus
    }
}

struct UpdateDocumentVersionInputBody: Equatable {
    public let versionStatus: DocumentVersionStatus?
}

extension UpdateDocumentVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case versionStatus = "VersionStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionStatusDecoded = try containerValues.decodeIfPresent(DocumentVersionStatus.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
    }
}

extension UpdateDocumentVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentVersionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidOperationException(InvalidOperationException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentVersionOutputResponse()"}
}

extension UpdateDocumentVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentVersionOutputResponse: Equatable {

    public init() {}
}

struct UpdateDocumentVersionOutputResponseBody: Equatable {
}

extension UpdateDocumentVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFolderInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFolderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFolderInput>
    public typealias MOutput = OperationOutput<UpdateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFolderOutputError>
}

extension UpdateFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFolderInput(authenticationToken: \(String(describing: authenticationToken)), folderId: \(String(describing: folderId)), name: \(String(describing: name)), parentFolderId: \(String(describing: parentFolderId)), resourceState: \(String(describing: resourceState)))"}
}

extension UpdateFolderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

public struct UpdateFolderInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFolderInput>
    public typealias MOutput = OperationOutput<UpdateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFolderOutputError>
}

public struct UpdateFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFolderInput>
    public typealias MOutput = OperationOutput<UpdateFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFolderOutputError>
}

public struct UpdateFolderInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The ID of the folder.</p>
    public let folderId: String?
    /// <p>The name of the folder.</p>
    public let name: String?
    /// <p>The ID of the parent folder.</p>
    public let parentFolderId: String?
    /// <p>The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from
    ///             the API.</p>
    public let resourceState: ResourceStateType?

    public init (
        authenticationToken: String? = nil,
        folderId: String? = nil,
        name: String? = nil,
        parentFolderId: String? = nil,
        resourceState: ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateFolderInputBody: Equatable {
    public let name: String?
    public let parentFolderId: String?
    public let resourceState: ResourceStateType?
}

extension UpdateFolderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFolderOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFolderOutputResponse()"}
}

extension UpdateFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFolderOutputResponse: Equatable {

    public init() {}
}

struct UpdateFolderOutputResponseBody: Equatable {
}

extension UpdateFolderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserInput(authenticationToken: \(String(describing: authenticationToken)), givenName: \(String(describing: givenName)), grantPoweruserPrivileges: \(String(describing: grantPoweruserPrivileges)), locale: \(String(describing: locale)), storageRule: \(String(describing: storageRule)), surname: \(String(describing: surname)), timeZoneId: \(String(describing: timeZoneId)), type: \(String(describing: type)), userId: \(String(describing: userId)))"}
}

extension UpdateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let grantPoweruserPrivileges = grantPoweruserPrivileges {
            try encodeContainer.encode(grantPoweruserPrivileges.rawValue, forKey: .grantPoweruserPrivileges)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let authenticationToken = input.operationInput.authenticationToken {
            input.builder.withHeader(name: "Authentication", value: String(authenticationToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Equatable {
    /// <p>Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.</p>
    public let authenticationToken: String?
    /// <p>The given name of the user.</p>
    public let givenName: String?
    /// <p>Boolean value to determine whether the user is granted Poweruser privileges.</p>
    public let grantPoweruserPrivileges: BooleanEnumType?
    /// <p>The locale of the user.</p>
    public let locale: LocaleType?
    /// <p>The amount of storage for the user.</p>
    public let storageRule: StorageRuleType?
    /// <p>The surname of the user.</p>
    public let surname: String?
    /// <p>The time zone ID of the user.</p>
    public let timeZoneId: String?
    /// <p>The type of the user.</p>
    public let type: UserType?
    /// <p>The ID of the user.</p>
    public let userId: String?

    public init (
        authenticationToken: String? = nil,
        givenName: String? = nil,
        grantPoweruserPrivileges: BooleanEnumType? = nil,
        locale: LocaleType? = nil,
        storageRule: StorageRuleType? = nil,
        surname: String? = nil,
        timeZoneId: String? = nil,
        type: UserType? = nil,
        userId: String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.givenName = givenName
        self.grantPoweruserPrivileges = grantPoweruserPrivileges
        self.locale = locale
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.type = type
        self.userId = userId
    }
}

struct UpdateUserInputBody: Equatable {
    public let givenName: String?
    public let surname: String?
    public let type: UserType?
    public let storageRule: StorageRuleType?
    public let timeZoneId: String?
    public let locale: LocaleType?
    public let grantPoweruserPrivileges: BooleanEnumType?
}

extension UpdateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let givenNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .surname)
        surname = surnameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UserType.self, forKey: .type)
        type = typeDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let grantPoweruserPrivilegesDecoded = try containerValues.decodeIfPresent(BooleanEnumType.self, forKey: .grantPoweruserPrivileges)
        grantPoweruserPrivileges = grantPoweruserPrivilegesDecoded
    }
}

extension UpdateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeactivatingLastSystemUserException" : self = .deactivatingLastSystemUserException(try DeactivatingLastSystemUserException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUserStateException" : self = .illegalUserStateException(try IllegalUserStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Equatable {
    case deactivatingLastSystemUserException(DeactivatingLastSystemUserException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case illegalUserStateException(IllegalUserStateException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserOutputResponse(user: \(String(describing: user)))"}
}

extension UpdateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutputResponse: Equatable {
    /// <p>The user information.</p>
    public let user: User?

    public init (
        user: User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Equatable {
    public let user: User?
}

extension UpdateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(User.self, forKey: .user)
        user = userDecoded
    }
}

extension UploadMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signedHeaders = "SignedHeaders"
        case uploadUrl = "UploadUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signedHeaders = signedHeaders {
            var signedHeadersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .signedHeaders)
            for (dictKey0, signedheadermap0) in signedHeaders {
                try signedHeadersContainer.encode(signedheadermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let uploadUrl = uploadUrl {
            try encodeContainer.encode(uploadUrl, forKey: .uploadUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
        let signedHeadersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .signedHeaders)
        var signedHeadersDecoded0: [String:String]? = nil
        if let signedHeadersContainer = signedHeadersContainer {
            signedHeadersDecoded0 = [String:String]()
            for (key0, headervaluetype0) in signedHeadersContainer {
                if let headervaluetype0 = headervaluetype0 {
                    signedHeadersDecoded0?[key0] = headervaluetype0
                }
            }
        }
        signedHeaders = signedHeadersDecoded0
    }
}

extension UploadMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadMetadata(signedHeaders: \(String(describing: signedHeaders)), uploadUrl: \(String(describing: uploadUrl)))"}
}

/// <p>Describes the upload.</p>
public struct UploadMetadata: Equatable {
    /// <p>The signed headers.</p>
    public let signedHeaders: [String:String]?
    /// <p>The URL of the upload.</p>
    public let uploadUrl: String?

    public init (
        signedHeaders: [String:String]? = nil,
        uploadUrl: String? = nil
    )
    {
        self.signedHeaders = signedHeaders
        self.uploadUrl = uploadUrl
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case locale = "Locale"
        case modifiedTimestamp = "ModifiedTimestamp"
        case organizationId = "OrganizationId"
        case recycleBinFolderId = "RecycleBinFolderId"
        case rootFolderId = "RootFolderId"
        case status = "Status"
        case storage = "Storage"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let recycleBinFolderId = recycleBinFolderId {
            try encodeContainer.encode(recycleBinFolderId, forKey: .recycleBinFolderId)
        }
        if let rootFolderId = rootFolderId {
            try encodeContainer.encode(rootFolderId, forKey: .rootFolderId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .surname)
        surname = surnameDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let rootFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootFolderId)
        rootFolderId = rootFolderIdDecoded
        let recycleBinFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recycleBinFolderId)
        recycleBinFolderId = recycleBinFolderIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(UserStatusType.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UserType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let storageDecoded = try containerValues.decodeIfPresent(UserStorageMetadata.self, forKey: .storage)
        storage = storageDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(createdTimestamp: \(String(describing: createdTimestamp)), emailAddress: \(String(describing: emailAddress)), givenName: \(String(describing: givenName)), id: \(String(describing: id)), locale: \(String(describing: locale)), modifiedTimestamp: \(String(describing: modifiedTimestamp)), organizationId: \(String(describing: organizationId)), recycleBinFolderId: \(String(describing: recycleBinFolderId)), rootFolderId: \(String(describing: rootFolderId)), status: \(String(describing: status)), storage: \(String(describing: storage)), surname: \(String(describing: surname)), timeZoneId: \(String(describing: timeZoneId)), type: \(String(describing: type)), username: \(String(describing: username)))"}
}

/// <p>Describes a user.</p>
public struct User: Equatable {
    /// <p>The time when the user was created.</p>
    public let createdTimestamp: Date?
    /// <p>The email address of the user.</p>
    public let emailAddress: String?
    /// <p>The given name of the user.</p>
    public let givenName: String?
    /// <p>The ID of the user.</p>
    public let id: String?
    /// <p>The locale of the user.</p>
    public let locale: LocaleType?
    /// <p>The time when the user was modified.</p>
    public let modifiedTimestamp: Date?
    /// <p>The ID of the organization.</p>
    public let organizationId: String?
    /// <p>The ID of the recycle bin folder.</p>
    public let recycleBinFolderId: String?
    /// <p>The ID of the root folder.</p>
    public let rootFolderId: String?
    /// <p>The status of the user.</p>
    public let status: UserStatusType?
    /// <p>The storage for the user.</p>
    public let storage: UserStorageMetadata?
    /// <p>The surname of the user.</p>
    public let surname: String?
    /// <p>The time zone ID of the user.</p>
    public let timeZoneId: String?
    /// <p>The type of user.</p>
    public let type: UserType?
    /// <p>The login name of the user.</p>
    public let username: String?

    public init (
        createdTimestamp: Date? = nil,
        emailAddress: String? = nil,
        givenName: String? = nil,
        id: String? = nil,
        locale: LocaleType? = nil,
        modifiedTimestamp: Date? = nil,
        organizationId: String? = nil,
        recycleBinFolderId: String? = nil,
        rootFolderId: String? = nil,
        status: UserStatusType? = nil,
        storage: UserStorageMetadata? = nil,
        surname: String? = nil,
        timeZoneId: String? = nil,
        type: UserType? = nil,
        username: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.id = id
        self.locale = locale
        self.modifiedTimestamp = modifiedTimestamp
        self.organizationId = organizationId
        self.recycleBinFolderId = recycleBinFolderId
        self.rootFolderId = rootFolderId
        self.status = status
        self.storage = storage
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.type = type
        self.username = username
    }
}

public enum UserFilterType {
    case activePending
    case all
    case sdkUnknown(String)
}

extension UserFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserFilterType] {
        return [
            .activePending,
            .all,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activePending: return "ACTIVE_PENDING"
        case .all: return "ALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserFilterType(rawValue: rawValue) ?? UserFilterType.sdkUnknown(rawValue)
    }
}

extension UserMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case surname = "Surname"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .surname)
        surname = surnameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension UserMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserMetadata(emailAddress: \(String(describing: emailAddress)), givenName: \(String(describing: givenName)), id: \(String(describing: id)), surname: \(String(describing: surname)), username: \(String(describing: username)))"}
}

/// <p>Describes the metadata of the user.</p>
public struct UserMetadata: Equatable {
    /// <p>The email address of the user.</p>
    public let emailAddress: String?
    /// <p>The given name of the user before a rename operation.</p>
    public let givenName: String?
    /// <p>The ID of the user.</p>
    public let id: String?
    /// <p>The surname of the user.</p>
    public let surname: String?
    /// <p>The name of the user.</p>
    public let username: String?

    public init (
        emailAddress: String? = nil,
        givenName: String? = nil,
        id: String? = nil,
        surname: String? = nil,
        username: String? = nil
    )
    {
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.id = id
        self.surname = surname
        self.username = username
    }
}

public enum UserSortType {
    case fullName
    case storageLimit
    case storageUsed
    case userName
    case userStatus
    case sdkUnknown(String)
}

extension UserSortType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserSortType] {
        return [
            .fullName,
            .storageLimit,
            .storageUsed,
            .userName,
            .userStatus,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullName: return "FULL_NAME"
        case .storageLimit: return "STORAGE_LIMIT"
        case .storageUsed: return "STORAGE_USED"
        case .userName: return "USER_NAME"
        case .userStatus: return "USER_STATUS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserSortType(rawValue: rawValue) ?? UserSortType.sdkUnknown(rawValue)
    }
}

public enum UserStatusType {
    case active
    case inactive
    case pending
    case sdkUnknown(String)
}

extension UserStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserStatusType] {
        return [
            .active,
            .inactive,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserStatusType(rawValue: rawValue) ?? UserStatusType.sdkUnknown(rawValue)
    }
}

extension UserStorageMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storageRule = "StorageRule"
        case storageUtilizedInBytes = "StorageUtilizedInBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let storageUtilizedInBytes = storageUtilizedInBytes {
            try encodeContainer.encode(storageUtilizedInBytes, forKey: .storageUtilizedInBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageUtilizedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .storageUtilizedInBytes)
        storageUtilizedInBytes = storageUtilizedInBytesDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension UserStorageMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserStorageMetadata(storageRule: \(String(describing: storageRule)), storageUtilizedInBytes: \(String(describing: storageUtilizedInBytes)))"}
}

/// <p>Describes the storage for a user.</p>
public struct UserStorageMetadata: Equatable {
    /// <p>The storage for a user.</p>
    public let storageRule: StorageRuleType?
    /// <p>The amount of storage used, in bytes.</p>
    public let storageUtilizedInBytes: Int?

    public init (
        storageRule: StorageRuleType? = nil,
        storageUtilizedInBytes: Int? = nil
    )
    {
        self.storageRule = storageRule
        self.storageUtilizedInBytes = storageUtilizedInBytes
    }
}

public enum UserType {
    case admin
    case minimaluser
    case poweruser
    case user
    case workspacesuser
    case sdkUnknown(String)
}

extension UserType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserType] {
        return [
            .admin,
            .minimaluser,
            .poweruser,
            .user,
            .workspacesuser,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .admin: return "ADMIN"
        case .minimaluser: return "MINIMALUSER"
        case .poweruser: return "POWERUSER"
        case .user: return "USER"
        case .workspacesuser: return "WORKSPACESUSER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
    }
}
