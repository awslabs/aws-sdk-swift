// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ApiGatewayEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiGatewayEndpointType] {
            return [
                .private,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiGatewayEndpointType(rawValue: rawValue) ?? ApiGatewayEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayId = "ApiGatewayId"
        case endpointType = "EndpointType"
        case nlbArn = "NlbArn"
        case nlbName = "NlbName"
        case proxyUrl = "ProxyUrl"
        case stageName = "StageName"
        case vpcLinkId = "VpcLinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayId = apiGatewayId {
            try encodeContainer.encode(apiGatewayId, forKey: .apiGatewayId)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let nlbArn = nlbArn {
            try encodeContainer.encode(nlbArn, forKey: .nlbArn)
        }
        if let nlbName = nlbName {
            try encodeContainer.encode(nlbName, forKey: .nlbName)
        }
        if let proxyUrl = proxyUrl {
            try encodeContainer.encode(proxyUrl, forKey: .proxyUrl)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let vpcLinkId = vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyUrl)
        proxyUrl = proxyUrlDecoded
        let apiGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayId)
        apiGatewayId = apiGatewayIdDecoded
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let nlbArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbArn)
        nlbArn = nlbArnDecoded
        let nlbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbName)
        nlbName = nlbNameDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway proxy configuration.
    public struct ApiGatewayProxyConfig: Swift.Equatable {
        /// The resource ID of the API Gateway for the proxy.
        public var apiGatewayId: Swift.String?
        /// The type of API Gateway endpoint created.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The Amazon Resource Name (ARN) of the Network Load Balancer configured by the API Gateway proxy.
        public var nlbArn: Swift.String?
        /// The name of the Network Load Balancer that is configured by the API Gateway proxy.
        public var nlbName: Swift.String?
        /// The endpoint URL of the API Gateway proxy.
        public var proxyUrl: Swift.String?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?
        /// The VpcLink ID of the API Gateway proxy.
        public var vpcLinkId: Swift.String?

        public init (
            apiGatewayId: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            nlbArn: Swift.String? = nil,
            nlbName: Swift.String? = nil,
            proxyUrl: Swift.String? = nil,
            stageName: Swift.String? = nil,
            vpcLinkId: Swift.String? = nil
        )
        {
            self.apiGatewayId = apiGatewayId
            self.endpointType = endpointType
            self.nlbArn = nlbArn
            self.nlbName = nlbName
            self.proxyUrl = proxyUrl
            self.stageName = stageName
            self.vpcLinkId = vpcLinkId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case stageName = "StageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway endpoint input.
    public struct ApiGatewayProxyInput: Swift.Equatable {
        /// The type of endpoint to use for the API Gateway proxy. If no value is specified in the request, the value is set to REGIONAL by default. If the value is set to PRIVATE in the request, this creates a private API endpoint that is isolated from the public internet. The private endpoint can only be accessed by using Amazon Virtual Private Cloud (Amazon VPC) endpoints for Amazon API Gateway that have been granted access.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?

        public init (
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.stageName = stageName
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayId = "ApiGatewayId"
        case endpointType = "EndpointType"
        case nlbArn = "NlbArn"
        case nlbName = "NlbName"
        case proxyUrl = "ProxyUrl"
        case stageName = "StageName"
        case vpcLinkId = "VpcLinkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayId = apiGatewayId {
            try encodeContainer.encode(apiGatewayId, forKey: .apiGatewayId)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let nlbArn = nlbArn {
            try encodeContainer.encode(nlbArn, forKey: .nlbArn)
        }
        if let nlbName = nlbName {
            try encodeContainer.encode(nlbName, forKey: .nlbName)
        }
        if let proxyUrl = proxyUrl {
            try encodeContainer.encode(proxyUrl, forKey: .proxyUrl)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let vpcLinkId = vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyUrl)
        proxyUrl = proxyUrlDecoded
        let apiGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayId)
        apiGatewayId = apiGatewayIdDecoded
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let nlbArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbArn)
        nlbArn = nlbArnDecoded
        let nlbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nlbName)
        nlbName = nlbNameDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A wrapper object holding the Amazon API Gateway proxy summary.
    public struct ApiGatewayProxySummary: Swift.Equatable {
        /// The resource ID of the API Gateway for the proxy.
        public var apiGatewayId: Swift.String?
        /// The type of API Gateway endpoint created.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType?
        /// The Amazon Resource Name (ARN) of the Network Load Balancer configured by the API Gateway proxy.
        public var nlbArn: Swift.String?
        /// The name of the Network Load Balancer that is configured by the API Gateway proxy.
        public var nlbName: Swift.String?
        /// The endpoint URL of the API Gateway proxy.
        public var proxyUrl: Swift.String?
        /// The name of the API Gateway stage. The name defaults to prod.
        public var stageName: Swift.String?
        /// The VpcLink ID of the API Gateway proxy.
        public var vpcLinkId: Swift.String?

        public init (
            apiGatewayId: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ApiGatewayEndpointType? = nil,
            nlbArn: Swift.String? = nil,
            nlbName: Swift.String? = nil,
            proxyUrl: Swift.String? = nil,
            stageName: Swift.String? = nil,
            vpcLinkId: Swift.String? = nil
        )
        {
            self.apiGatewayId = apiGatewayId
            self.endpointType = endpointType
            self.nlbArn = nlbArn
            self.nlbName = nlbName
            self.proxyUrl = proxyUrl
            self.stageName = stageName
            self.vpcLinkId = vpcLinkId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationState(rawValue: rawValue) ?? ApplicationState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayProxy = apiGatewayProxy {
            try encodeContainer.encode(apiGatewayProxy, forKey: .apiGatewayProxy)
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let proxyType = proxyType {
            try encodeContainer.encode(proxyType.rawValue, forKey: .proxyType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The list of ApplicationSummary objects.
    public struct ApplicationSummary: Swift.Equatable {
        /// The endpoint URL of the Amazon API Gateway proxy.
        public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary?
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// he Amazon Resource Name (ARN) of the application.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the application creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the application is created.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the application resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A timestamp that indicates when the application was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the application.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the application owner.
        public var ownerAccountId: Swift.String?
        /// The proxy type of the proxy created within the application.
        public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
        /// The current state of the application.
        public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
        /// The tags assigned to the application.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the virtual private cloud (VPC).
        public var vpcId: Swift.String?

        public init (
            apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxySummary? = nil,
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
            state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.apiGatewayProxy = apiGatewayProxy
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.error = error
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.proxyType = proxyType
            self.state = state
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case clientToken = "ClientToken"
        case name = "Name"
        case proxyType = "ProxyType"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayProxy = apiGatewayProxy {
            try encodeContainer.encode(apiGatewayProxy, forKey: .apiGatewayProxy)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let proxyType = proxyType {
            try encodeContainer.encode(proxyType.rawValue, forKey: .proxyType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A wrapper object holding the API Gateway endpoint type and stage name for the proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The name to use for the application.
    /// This member is required.
    public var name: Swift.String?
    /// The proxy type of the proxy created within the application.
    /// This member is required.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The tags to assign to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the virtual private cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput? = nil,
        clientToken: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.clientToken = clientToken
        self.environmentIdentifier = environmentIdentifier
        self.name = name
        self.proxyType = proxyType
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case clientToken = "ClientToken"
        case name = "Name"
        case proxyType = "ProxyType"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayProxy = output.apiGatewayProxy
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.proxyType = output.proxyType
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.apiGatewayProxy = nil
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.proxyType = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// A wrapper object holding the API Gateway endpoint type and stage name for the proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    /// The unique identifier of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application. The format for this ARN is arn:aws:refactor-spaces:region:account-id:resource-type/resource-id . For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of application creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the application is created.
    public var createdTime: ClientRuntime.Date?
    /// The ID of the environment in which the application is created.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the application was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the application owner.
    public var ownerAccountId: Swift.String?
    /// The proxy type of the proxy created within the application.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    /// The tags assigned to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the Amazon VPC.
    public var vpcId: Swift.String?

    public init (
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput? = nil,
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.proxyType = proxyType
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyInput.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkFabricType = networkFabricType {
            try encodeContainer.encode(networkFabricType.rawValue, forKey: .networkFabricType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The name of the environment.
    /// This member is required.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    /// This member is required.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The tags to assign to the environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.networkFabricType = networkFabricType
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.networkFabricType = output.networkFabricType
            self.ownerAccountId = output.ownerAccountId
            self.state = output.state
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.networkFabricType = nil
            self.ownerAccountId = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// A timestamp that indicates when the environment is created.
    public var createdTime: ClientRuntime.Date?
    /// A description of the environment.
    public var description: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The Amazon Web Services account ID of environment owner.
    public var ownerAccountId: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    /// The tags assigned to the created environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        ownerAccountId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.networkFabricType = networkFabricType
        self.ownerAccountId = ownerAccountId
        self.state = state
        self.tags = tags
    }
}

struct CreateEnvironmentOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let ownerAccountId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CreateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case routeType = "RouteType"
        case serviceIdentifier = "ServiceIdentifier"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let routeType = routeType {
            try encodeContainer.encode(routeType.rawValue, forKey: .routeType)
        }
        if let serviceIdentifier = serviceIdentifier {
            try encodeContainer.encode(serviceIdentifier, forKey: .serviceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uriPathRoute = uriPathRoute {
            try encodeContainer.encode(uriPathRoute, forKey: .uriPathRoute)
        }
    }
}

extension CreateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes"
    }
}

public struct CreateRouteInput: Swift.Equatable {
    /// The ID of the application within which the route is being created.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the environment in which the route is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The route type of the route. DEFAULT indicates that all traffic that does not match another route is forwarded to the default route. Applications must have a default route before any other routes can be created. URI_PATH indicates a route that is based on a URI path.
    /// This member is required.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The ID of the service in which the route is created. Traffic that matches this route is forwarded to this service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags to assign to the route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URI path route type.
    public var uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?

    public init (
        applicationIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.clientToken = clientToken
        self.environmentIdentifier = environmentIdentifier
        self.routeType = routeType
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
        self.uriPathRoute = uriPathRoute
    }
}

struct CreateRouteInputBody: Swift.Equatable {
    let serviceIdentifier: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case routeType = "RouteType"
        case serviceIdentifier = "ServiceIdentifier"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceIdentifier)
        serviceIdentifier = serviceIdentifierDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let uriPathRouteDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UriPathRouteInput.self, forKey: .uriPathRoute)
        uriPathRoute = uriPathRouteDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.lastUpdatedTime = output.lastUpdatedTime
            self.ownerAccountId = output.ownerAccountId
            self.routeId = output.routeId
            self.routeType = output.routeType
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.uriPathRoute = output.uriPathRoute
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.lastUpdatedTime = nil
            self.ownerAccountId = nil
            self.routeId = nil
            self.routeType = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.uriPathRoute = nil
        }
    }
}

public struct CreateRouteOutputResponse: Swift.Equatable {
    /// The ID of the application in which the route is created.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route. The format for this ARN is arn:aws:refactor-spaces:region:account-id:resource-type/resource-id . For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the route creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the route is created.
    public var createdTime: ClientRuntime.Date?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Web Services account ID of the route owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the route.
    public var routeId: Swift.String?
    /// The route type of the route.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The ID of service in which the rute iscreated. Traffic that matches this route is forwarded to this service.
    public var serviceId: Swift.String?
    /// he current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
    /// The tags assigned to the created route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// onfiguration for the URI path route type.
    public var uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        ownerAccountId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.lastUpdatedTime = lastUpdatedTime
        self.ownerAccountId = ownerAccountId
        self.routeId = routeId
        self.routeType = routeType
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.uriPathRoute = uriPathRoute
    }
}

struct CreateRouteOutputResponseBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let uriPathRoute: MigrationHubRefactorSpacesClientTypes.UriPathRouteInput?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case ownerAccountId = "OwnerAccountId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case uriPathRoute = "UriPathRoute"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let uriPathRouteDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UriPathRouteInput.self, forKey: .uriPathRoute)
        uriPathRoute = uriPathRouteDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endpointType = "EndpointType"
        case lambdaEndpoint = "LambdaEndpoint"
        case name = "Name"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let lambdaEndpoint = lambdaEndpoint {
            try encodeContainer.encode(lambdaEndpoint, forKey: .lambdaEndpoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let urlEndpoint = urlEndpoint {
            try encodeContainer.encode(urlEndpoint, forKey: .urlEndpoint)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The ID of the application which the service is created.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The description of the service.
    public var description: Swift.String?
    /// The type of endpoint to use for the service. The type can be a URL in a VPC or an Lambda function.
    /// This member is required.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The ID of the environment in which the service is created.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The configuration for the Lambda endpoint type.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    /// The name of the service.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to assign to the service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentIdentifier: Swift.String? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.clientToken = clientToken
        self.description = description
        self.endpointType = endpointType
        self.environmentIdentifier = environmentIdentifier
        self.lambdaEndpoint = lambdaEndpoint
        self.name = name
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endpointType = "EndpointType"
        case lambdaEndpoint = "LambdaEndpoint"
        case name = "Name"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointInput.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.description = output.description
            self.endpointType = output.endpointType
            self.environmentId = output.environmentId
            self.lambdaEndpoint = output.lambdaEndpoint
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.urlEndpoint = output.urlEndpoint
            self.vpcId = output.vpcId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.description = nil
            self.endpointType = nil
            self.environmentId = nil
            self.lambdaEndpoint = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.urlEndpoint = nil
            self.vpcId = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// The ID of the application that the created service belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the service creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the service is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the created service.
    public var description: Swift.String?
    /// The endpoint type of the service.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// The configuration for the Lambda endpoint type.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the service owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    /// The tags assigned to the created service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair..
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentId: Swift.String? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.description = description
        self.endpointType = endpointType
        self.environmentId = environmentId
        self.lambdaEndpoint = lambdaEndpoint
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointInput?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let tags: [Swift.String:Swift.String]?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointInput.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var arn: Swift.String?
    /// The unique identifier of the applications environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.state = state
    }
}

struct DeleteApplicationOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init (
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DeleteEnvironmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?

    public init (
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil
    )
    {
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.state = state
    }
}

struct DeleteEnvironmentOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let environmentId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/resourcepolicy/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resource associated with the policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

}

extension DeleteRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let routeIdentifier = routeIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes/\(routeIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteRouteInput: Swift.Equatable {
    /// The ID of the application to delete the route from.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment to delete the route from.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the route to delete.
    /// This member is required.
    public var routeIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.routeIdentifier = routeIdentifier
    }
}

struct DeleteRouteInputBody: Swift.Equatable {
}

extension DeleteRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.lastUpdatedTime = output.lastUpdatedTime
            self.routeId = output.routeId
            self.serviceId = output.serviceId
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.lastUpdatedTime = nil
            self.routeId = nil
            self.serviceId = nil
            self.state = nil
        }
    }
}

public struct DeleteRouteOutputResponse: Swift.Equatable {
    /// he ID of the application that the route belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route.
    public var arn: Swift.String?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The ID of the route to delete.
    public var routeId: Swift.String?
    /// The ID of the service that the route belongs to.
    public var serviceId: Swift.String?
    /// The current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        routeId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.lastUpdatedTime = lastUpdatedTime
        self.routeId = routeId
        self.serviceId = serviceId
        self.state = state
    }
}

struct DeleteRouteOutputResponseBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case lastUpdatedTime = "LastUpdatedTime"
        case routeId = "RouteId"
        case serviceId = "ServiceId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// Deletes a Refactor Spaces service. The RefactorSpacesSecurityGroup security group must be removed from all Amazon Web Services resources in the virtual private cloud (VPC) prior to deleting a service with a URL endpoint in a VPC.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment that the service is in.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the service to delete.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
}

extension DeleteServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.environmentId = output.environmentId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.serviceId = output.serviceId
            self.state = output.state
        } else {
            self.applicationId = nil
            self.arn = nil
            self.environmentId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.serviceId = nil
            self.state = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// The ID of the application that the service is in.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.environmentId = environmentId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.serviceId = serviceId
        self.state = state
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case serviceId = "ServiceId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum EnvironmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
        case transitGatewayId = "TransitGatewayId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkFabricType = networkFabricType {
            try encodeContainer.encode(networkFabricType.rawValue, forKey: .networkFabricType)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transitGatewayId = transitGatewayId {
            try encodeContainer.encode(transitGatewayId, forKey: .transitGatewayId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let transitGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayId)
        transitGatewayId = transitGatewayIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary information for environments as a response to ListEnvironments.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// A timestamp that indicates when the environment is created.
        public var createdTime: ClientRuntime.Date?
        /// A description of the environment.
        public var description: Swift.String?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the environment resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A timestamp that indicates when the environment was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the environment.
        public var name: Swift.String?
        /// The network fabric type of the environment.
        public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
        /// The Amazon Web Services account ID of the environment owner.
        public var ownerAccountId: Swift.String?
        /// The current state of the environment.
        public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
        /// The tags assigned to the environment.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the transit gateway set up by the environment.
        public var transitGatewayId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
            ownerAccountId: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            transitGatewayId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.environmentId = environmentId
            self.error = error
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkFabricType = networkFabricType
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
            self.transitGatewayId = transitGatewayId
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.EnvironmentVpc: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case cidrBlocks = "CidrBlocks"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case lastUpdatedTime = "LastUpdatedTime"
        case vpcId = "VpcId"
        case vpcName = "VpcName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let cidrBlocks = cidrBlocks {
            var cidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrBlocks)
            for cidrblocks0 in cidrBlocks {
                try cidrBlocksContainer.encode(cidrblocks0)
            }
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcName = vpcName {
            try encodeContainer.encode(vpcName, forKey: .vpcName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let cidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrBlocks)
        var cidrBlocksDecoded0:[Swift.String]? = nil
        if let cidrBlocksContainer = cidrBlocksContainer {
            cidrBlocksDecoded0 = [Swift.String]()
            for string0 in cidrBlocksContainer {
                if let string0 = string0 {
                    cidrBlocksDecoded0?.append(string0)
                }
            }
        }
        cidrBlocks = cidrBlocksDecoded0
        let vpcNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcName)
        vpcName = vpcNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// Provides summary information for the EnvironmentVpc resource as a response to ListEnvironmentVpc.
    public struct EnvironmentVpc: Swift.Equatable {
        /// The Amazon Web Services account ID of the virtual private cloud (VPC) owner.
        public var accountId: Swift.String?
        /// The list of Amazon Virtual Private Cloud (Amazon VPC) CIDR blocks.
        public var cidrBlocks: [Swift.String]?
        /// A timestamp that indicates when the VPC is first added to the environment.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// A timestamp that indicates when the VPC was last updated by the environment.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The ID of the VPC.
        public var vpcId: Swift.String?
        /// The name of the VPC at the time it is added to the environment.
        public var vpcName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            cidrBlocks: [Swift.String]? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            vpcId: Swift.String? = nil,
            vpcName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.cidrBlocks = cidrBlocks
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.lastUpdatedTime = lastUpdatedTime
            self.vpcId = vpcId
            self.vpcName = vpcName
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidResourceState
        case notAuthorized
        case requestLimitExceeded
        case resourceCreationFailure
        case resourceDeletionFailure
        case resourceInUse
        case resourceLimitExceeded
        case resourceNotFound
        case resourceRetrievalFailure
        case resourceUpdateFailure
        case serviceEndpointHealthCheckFailure
        case stateTransitionFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .invalidResourceState,
                .notAuthorized,
                .requestLimitExceeded,
                .resourceCreationFailure,
                .resourceDeletionFailure,
                .resourceInUse,
                .resourceLimitExceeded,
                .resourceNotFound,
                .resourceRetrievalFailure,
                .resourceUpdateFailure,
                .serviceEndpointHealthCheckFailure,
                .stateTransitionFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidResourceState: return "INVALID_RESOURCE_STATE"
            case .notAuthorized: return "NOT_AUTHORIZED"
            case .requestLimitExceeded: return "REQUEST_LIMIT_EXCEEDED"
            case .resourceCreationFailure: return "RESOURCE_CREATION_FAILURE"
            case .resourceDeletionFailure: return "RESOURCE_DELETION_FAILURE"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case .resourceLimitExceeded: return "RESOURCE_LIMIT_EXCEEDED"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .resourceRetrievalFailure: return "RESOURCE_RETRIEVAL_FAILURE"
            case .resourceUpdateFailure: return "RESOURCE_UPDATE_FAILURE"
            case .serviceEndpointHealthCheckFailure: return "SERVICE_ENDPOINT_HEALTH_CHECK_FAILURE"
            case .stateTransitionFailure: return "STATE_TRANSITION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ErrorResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case application
        case environment
        case iamRole
        case lambda
        case loadBalancerListener
        case nlb
        case resourceShare
        case route
        case routeTable
        case securityGroup
        case service
        case subnet
        case targetGroup
        case transitGateway
        case transitGatewayAttachment
        case vpc
        case vpcEndpointServiceConfiguration
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorResourceType] {
            return [
                .apiGateway,
                .application,
                .environment,
                .iamRole,
                .lambda,
                .loadBalancerListener,
                .nlb,
                .resourceShare,
                .route,
                .routeTable,
                .securityGroup,
                .service,
                .subnet,
                .targetGroup,
                .transitGateway,
                .transitGatewayAttachment,
                .vpc,
                .vpcEndpointServiceConfiguration,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .application: return "APPLICATION"
            case .environment: return "ENVIRONMENT"
            case .iamRole: return "IAM_ROLE"
            case .lambda: return "LAMBDA"
            case .loadBalancerListener: return "LOAD_BALANCER_LISTENER"
            case .nlb: return "NLB"
            case .resourceShare: return "RESOURCE_SHARE"
            case .route: return "ROUTE"
            case .routeTable: return "ROUTE_TABLE"
            case .securityGroup: return "SECURITY_GROUP"
            case .service: return "SERVICE"
            case .subnet: return "SUBNET"
            case .targetGroup: return "TARGET_GROUP"
            case .transitGateway: return "TRANSIT_GATEWAY"
            case .transitGatewayAttachment: return "TRANSIT_GATEWAY_ATTACHMENT"
            case .vpc: return "VPC"
            case .vpcEndpointServiceConfiguration: return "VPC_ENDPOINT_SERVICE_CONFIGURATION"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorResourceType(rawValue: rawValue) ?? ErrorResourceType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ErrorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case additionalDetails = "AdditionalDetails"
        case code = "Code"
        case message = "Message"
        case resourceIdentifier = "ResourceIdentifier"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let additionalDetails = additionalDetails {
            var additionalDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalDetails)
            for (dictKey0, additionaldetails0) in additionalDetails {
                try additionalDetailsContainer.encode(additionaldetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let additionalDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalDetails)
        var additionalDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalDetailsContainer = additionalDetailsContainer {
            additionalDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, additionaldetailsvalue0) in additionalDetailsContainer {
                if let additionaldetailsvalue0 = additionaldetailsvalue0 {
                    additionalDetailsDecoded0?[key0] = additionaldetailsvalue0
                }
            }
        }
        additionalDetails = additionalDetailsDecoded0
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// Error associated with a resource returned for a Get or List resource response.
    public struct ErrorResponse: Swift.Equatable {
        /// The Amazon Web Services account ID of the resource owner.
        public var accountId: Swift.String?
        /// Additional details about the error.
        public var additionalDetails: [Swift.String:Swift.String]?
        /// The error code associated with the error.
        public var code: MigrationHubRefactorSpacesClientTypes.ErrorCode?
        /// The message associated with the error.
        public var message: Swift.String?
        /// The ID of the resource.
        public var resourceIdentifier: Swift.String?
        /// The type of resource.
        public var resourceType: MigrationHubRefactorSpacesClientTypes.ErrorResourceType?

        public init (
            accountId: Swift.String? = nil,
            additionalDetails: [Swift.String:Swift.String]? = nil,
            code: MigrationHubRefactorSpacesClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: MigrationHubRefactorSpacesClientTypes.ErrorResourceType? = nil
        )
        {
            self.accountId = accountId
            self.additionalDetails = additionalDetails
            self.code = code
            self.message = message
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayProxy = output.apiGatewayProxy
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.error = output.error
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.proxyType = output.proxyType
            self.state = output.state
            self.tags = output.tags
            self.vpcId = output.vpcId
        } else {
            self.apiGatewayProxy = nil
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.error = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.proxyType = nil
            self.state = nil
            self.tags = nil
            self.vpcId = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// The endpoint URL of the API Gateway proxy.
    public var apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig?
    /// The unique identifier of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the application.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the application creator.
    public var createdByAccountId: Swift.String?
    /// A timestamp that indicates when the application is created.
    public var createdTime: ClientRuntime.Date?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the application resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// A timestamp that indicates when the application was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the application.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the application owner.
    public var ownerAccountId: Swift.String?
    /// The proxy type of the proxy created within the application.
    public var proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    /// The current state of the application.
    public var state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    /// The tags assigned to the application. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the virtual private cloud (VPC).
    public var vpcId: Swift.String?

    public init (
        apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig? = nil,
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ApplicationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.apiGatewayProxy = apiGatewayProxy
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.error = error
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.proxyType = proxyType
        self.state = state
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let vpcId: Swift.String?
    let proxyType: MigrationHubRefactorSpacesClientTypes.ProxyType?
    let apiGatewayProxy: MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig?
    let state: MigrationHubRefactorSpacesClientTypes.ApplicationState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayProxy = "ApiGatewayProxy"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case proxyType = "ProxyType"
        case state = "State"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let proxyTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ProxyType.self, forKey: .proxyType)
        proxyType = proxyTypeDecoded
        let apiGatewayProxyDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApiGatewayProxyConfig.self, forKey: .apiGatewayProxy)
        apiGatewayProxy = apiGatewayProxyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?

    public init (
        environmentIdentifier: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.environmentId = output.environmentId
            self.error = output.error
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.networkFabricType = output.networkFabricType
            self.ownerAccountId = output.ownerAccountId
            self.state = output.state
            self.tags = output.tags
            self.transitGatewayId = output.transitGatewayId
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.environmentId = nil
            self.error = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.networkFabricType = nil
            self.ownerAccountId = nil
            self.state = nil
            self.tags = nil
            self.transitGatewayId = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the environment.
    public var arn: Swift.String?
    /// A timestamp that indicates when the environment is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the environment.
    public var description: Swift.String?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the environment resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// A timestamp that indicates when the environment was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the environment.
    public var name: Swift.String?
    /// The network fabric type of the environment.
    public var networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    /// The Amazon Web Services account ID of the environment owner.
    public var ownerAccountId: Swift.String?
    /// The current state of the environment.
    public var state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    /// The tags to assign to the environment. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the transit gateway set up by the environment.
    public var transitGatewayId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType? = nil,
        ownerAccountId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.EnvironmentState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transitGatewayId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.environmentId = environmentId
        self.error = error
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.networkFabricType = networkFabricType
        self.ownerAccountId = ownerAccountId
        self.state = state
        self.tags = tags
        self.transitGatewayId = transitGatewayId
    }
}

struct GetEnvironmentOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let networkFabricType: MigrationHubRefactorSpacesClientTypes.NetworkFabricType?
    let ownerAccountId: Swift.String?
    let transitGatewayId: Swift.String?
    let state: MigrationHubRefactorSpacesClientTypes.EnvironmentState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case networkFabricType = "NetworkFabricType"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
        case tags = "Tags"
        case transitGatewayId = "TransitGatewayId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let networkFabricTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.NetworkFabricType.self, forKey: .networkFabricType)
        networkFabricType = networkFabricTypeDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let transitGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayId)
        transitGatewayId = transitGatewayIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/resourcepolicy/\(identifier.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource associated with the policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// A JSON-formatted string for an Amazon Web Services resource-based policy.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let routeIdentifier = routeIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes/\(routeIdentifier.urlPercentEncoding())"
    }
}

public struct GetRouteInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the route.
    /// This member is required.
    public var routeIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        routeIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.routeIdentifier = routeIdentifier
    }
}

struct GetRouteInputBody: Swift.Equatable {
}

extension GetRouteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRouteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.environmentId = output.environmentId
            self.error = output.error
            self.includeChildPaths = output.includeChildPaths
            self.lastUpdatedTime = output.lastUpdatedTime
            self.methods = output.methods
            self.ownerAccountId = output.ownerAccountId
            self.pathResourceToId = output.pathResourceToId
            self.routeId = output.routeId
            self.routeType = output.routeType
            self.serviceId = output.serviceId
            self.sourcePath = output.sourcePath
            self.state = output.state
            self.tags = output.tags
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.environmentId = nil
            self.error = nil
            self.includeChildPaths = nil
            self.lastUpdatedTime = nil
            self.methods = nil
            self.ownerAccountId = nil
            self.pathResourceToId = nil
            self.routeId = nil
            self.routeType = nil
            self.serviceId = nil
            self.sourcePath = nil
            self.state = nil
            self.tags = nil
        }
    }
}

public struct GetRouteOutputResponse: Swift.Equatable {
    /// The ID of the application that the route belongs to.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the route.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the route creator.
    public var createdByAccountId: Swift.String?
    /// The timestamp of when the route is created.
    public var createdTime: ClientRuntime.Date?
    /// Unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the route resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
    public var includeChildPaths: Swift.Bool?
    /// A timestamp that indicates when the route was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
    public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
    /// The Amazon Web Services account ID of the route owner.
    public var ownerAccountId: Swift.String?
    /// A mapping of Amazon API Gateway path resources to resource IDs.
    public var pathResourceToId: [Swift.String:Swift.String]?
    /// The unique identifier of the route. DEFAULT: All traffic that does not match another route is forwarded to the default route. Applications must have a default route before any other routes can be created. URI_PATH: A route that is based on a URI path.
    public var routeId: Swift.String?
    /// The type of route.
    public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The path to use to match traffic. Paths must start with / and are relative to the base of the application.
    public var sourcePath: Swift.String?
    /// The current state of the route.
    public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
    /// The tags assigned to the route. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        includeChildPaths: Swift.Bool? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
        ownerAccountId: Swift.String? = nil,
        pathResourceToId: [Swift.String:Swift.String]? = nil,
        routeId: Swift.String? = nil,
        routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
        serviceId: Swift.String? = nil,
        sourcePath: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.environmentId = environmentId
        self.error = error
        self.includeChildPaths = includeChildPaths
        self.lastUpdatedTime = lastUpdatedTime
        self.methods = methods
        self.ownerAccountId = ownerAccountId
        self.pathResourceToId = pathResourceToId
        self.routeId = routeId
        self.routeType = routeType
        self.serviceId = serviceId
        self.sourcePath = sourcePath
        self.state = state
        self.tags = tags
    }
}

struct GetRouteOutputResponseBody: Swift.Equatable {
    let routeId: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
    let serviceId: Swift.String?
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let sourcePath: Swift.String?
    let methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
    let includeChildPaths: Swift.Bool?
    let pathResourceToId: [Swift.String:Swift.String]?
    let state: MigrationHubRefactorSpacesClientTypes.RouteState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetRouteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case includeChildPaths = "IncludeChildPaths"
        case lastUpdatedTime = "LastUpdatedTime"
        case methods = "Methods"
        case ownerAccountId = "OwnerAccountId"
        case pathResourceToId = "PathResourceToId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case sourcePath = "SourcePath"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
        let pathResourceToIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pathResourceToId)
        var pathResourceToIdDecoded0: [Swift.String:Swift.String]? = nil
        if let pathResourceToIdContainer = pathResourceToIdContainer {
            pathResourceToIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, pathresourcetoidvalue0) in pathResourceToIdContainer {
                if let pathresourcetoidvalue0 = pathresourcetoidvalue0 {
                    pathResourceToIdDecoded0?[key0] = pathresourcetoidvalue0
                }
            }
        }
        pathResourceToId = pathResourceToIdDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The ID of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetServiceInputBody: Swift.Equatable {
}

extension GetServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.createdByAccountId = output.createdByAccountId
            self.createdTime = output.createdTime
            self.description = output.description
            self.endpointType = output.endpointType
            self.environmentId = output.environmentId
            self.error = output.error
            self.lambdaEndpoint = output.lambdaEndpoint
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.serviceId = output.serviceId
            self.state = output.state
            self.tags = output.tags
            self.urlEndpoint = output.urlEndpoint
            self.vpcId = output.vpcId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.createdByAccountId = nil
            self.createdTime = nil
            self.description = nil
            self.endpointType = nil
            self.environmentId = nil
            self.error = nil
            self.lambdaEndpoint = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ownerAccountId = nil
            self.serviceId = nil
            self.state = nil
            self.tags = nil
            self.urlEndpoint = nil
            self.vpcId = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// The ID of the application.
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The Amazon Web Services account ID of the service creator.
    public var createdByAccountId: Swift.String?
    /// The timestamp of when the service is created.
    public var createdTime: ClientRuntime.Date?
    /// The description of the service.
    public var description: Swift.String?
    /// The endpoint type of the service.
    public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    /// The unique identifier of the environment.
    public var environmentId: Swift.String?
    /// Any error associated with the service resource.
    public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    /// The configuration for the Lambda endpoint type. The Arn is the Amazon Resource Name (ARN) of the Lambda function associated with this service.
    public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig?
    /// A timestamp that indicates when the service was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The Amazon Web Services account ID of the service owner.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the service.
    public var serviceId: Swift.String?
    /// The current state of the service.
    public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    /// The tags assigned to the service. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key-value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The configuration for the URL endpoint type. The Url isthe URL of the endpoint type. The HealthUrl is the health check URL of the endpoint type.
    public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig?
    /// The ID of the virtual private cloud (VPC).
    public var vpcId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdByAccountId: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
        environmentId: Swift.String? = nil,
        error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
        lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.createdByAccountId = createdByAccountId
        self.createdTime = createdTime
        self.description = description
        self.endpointType = endpointType
        self.environmentId = environmentId
        self.error = error
        self.lambdaEndpoint = lambdaEndpoint
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.serviceId = serviceId
        self.state = state
        self.tags = tags
        self.urlEndpoint = urlEndpoint
        self.vpcId = vpcId
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    let serviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let ownerAccountId: Swift.String?
    let createdByAccountId: Swift.String?
    let description: Swift.String?
    let environmentId: Swift.String?
    let applicationId: Swift.String?
    let vpcId: Swift.String?
    let endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
    let urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig?
    let lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig?
    let state: MigrationHubRefactorSpacesClientTypes.ServiceState?
    let tags: [Swift.String:Swift.String]?
    let error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum HttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpMethod] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpMethod(rawValue: rawValue) ?? HttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourcePolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourcePolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource policy is not valid.
public struct InvalidResourcePolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourcePolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourcePolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the Lambda endpoint type.
    public struct LambdaEndpointConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda endpoint.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The input for the Lambda endpoint type.
    public struct LambdaEndpointInput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda endpoint.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary for the Lambda endpoint type.
    public struct LambdaEndpointSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Lambda endpoint.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummaryList = output.applicationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.applicationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// The list of ApplicationSummary objects.
    public var applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationSummaryList = applicationSummaryList
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applicationSummaryList: [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSummaryList = "ApplicationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.ApplicationSummary?].self, forKey: .applicationSummaryList)
        var applicationSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.ApplicationSummary]? = nil
        if let applicationSummaryListContainer = applicationSummaryListContainer {
            applicationSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.ApplicationSummary]()
            for structure0 in applicationSummaryListContainer {
                if let structure0 = structure0 {
                    applicationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaryList = applicationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentVpcsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentVpcsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/vpcs"
    }
}

public struct ListEnvironmentVpcsInput: Swift.Equatable {
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentVpcsInputBody: Swift.Equatable {
}

extension ListEnvironmentVpcsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentVpcsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentVpcsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentVpcsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentVpcsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentVpcsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentVpcList = output.environmentVpcList
            self.nextToken = output.nextToken
        } else {
            self.environmentVpcList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentVpcsOutputResponse: Swift.Equatable {
    /// The list of EnvironmentVpc objects.
    public var environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentVpcList = environmentVpcList
        self.nextToken = nextToken
    }
}

struct ListEnvironmentVpcsOutputResponseBody: Swift.Equatable {
    let environmentVpcList: [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]?
    let nextToken: Swift.String?
}

extension ListEnvironmentVpcsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVpcList = "EnvironmentVpcList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentVpcListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.EnvironmentVpc?].self, forKey: .environmentVpcList)
        var environmentVpcListDecoded0:[MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]? = nil
        if let environmentVpcListContainer = environmentVpcListContainer {
            environmentVpcListDecoded0 = [MigrationHubRefactorSpacesClientTypes.EnvironmentVpc]()
            for structure0 in environmentVpcListContainer {
                if let structure0 = structure0 {
                    environmentVpcListDecoded0?.append(structure0)
                }
            }
        }
        environmentVpcList = environmentVpcListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentSummaryList = output.environmentSummaryList
            self.nextToken = output.nextToken
        } else {
            self.environmentSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Swift.Equatable {
    /// The list of EnvironmentSummary objects.
    public var environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentSummaryList = environmentSummaryList
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Swift.Equatable {
    let environmentSummaryList: [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentSummaryList = "EnvironmentSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.EnvironmentSummary?].self, forKey: .environmentSummaryList)
        var environmentSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]? = nil
        if let environmentSummaryListContainer = environmentSummaryListContainer {
            environmentSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.EnvironmentSummary]()
            for structure0 in environmentSummaryListContainer {
                if let structure0 = structure0 {
                    environmentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        environmentSummaryList = environmentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/routes"
    }
}

public struct ListRoutesInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRoutesInputBody: Swift.Equatable {
}

extension ListRoutesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRoutesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoutesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.routeSummaryList = output.routeSummaryList
        } else {
            self.nextToken = nil
            self.routeSummaryList = nil
        }
    }
}

public struct ListRoutesOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of RouteSummary objects.
    public var routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]?

    public init (
        nextToken: Swift.String? = nil,
        routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.routeSummaryList = routeSummaryList
    }
}

struct ListRoutesOutputResponseBody: Swift.Equatable {
    let routeSummaryList: [MigrationHubRefactorSpacesClientTypes.RouteSummary]?
    let nextToken: Swift.String?
}

extension ListRoutesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case routeSummaryList = "RouteSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.RouteSummary?].self, forKey: .routeSummaryList)
        var routeSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.RouteSummary]? = nil
        if let routeSummaryListContainer = routeSummaryListContainer {
            routeSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.RouteSummary]()
            for structure0 in routeSummaryListContainer {
                if let structure0 = structure0 {
                    routeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        routeSummaryList = routeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let environmentIdentifier = environmentIdentifier else {
            return nil
        }
        guard let applicationIdentifier = applicationIdentifier else {
            return nil
        }
        return "/environments/\(environmentIdentifier.urlPercentEncoding())/applications/\(applicationIdentifier.urlPercentEncoding())/services"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The ID of the environment.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        applicationIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
}

extension ListServicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The list of ServiceSummary objects.
    public var serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    let serviceSummaryList: [MigrationHubRefactorSpacesClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[MigrationHubRefactorSpacesClientTypes.ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [MigrationHubRefactorSpacesClientTypes.ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum NetworkFabricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case transitGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFabricType] {
            return [
                .transitGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .transitGateway: return "TRANSIT_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkFabricType(rawValue: rawValue) ?? NetworkFabricType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ProxyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxyType] {
            return [
                .apiGateway,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxyType(rawValue: rawValue) ?? ProxyType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resourcepolicy"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// A JSON-formatted string for an Amazon Web Services resource-based policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource to which the policy is being attached.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourcePolicyException" : self = .invalidResourcePolicyException(try InvalidResourcePolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidResourcePolicyException(InvalidResourcePolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteActivationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteActivationState] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteActivationState(rawValue: rawValue) ?? RouteActivationState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case inactive
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .inactive,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteState(rawValue: rawValue) ?? RouteState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.RouteSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case includeChildPaths = "IncludeChildPaths"
        case lastUpdatedTime = "LastUpdatedTime"
        case methods = "Methods"
        case ownerAccountId = "OwnerAccountId"
        case pathResourceToId = "PathResourceToId"
        case routeId = "RouteId"
        case routeType = "RouteType"
        case serviceId = "ServiceId"
        case sourcePath = "SourcePath"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let includeChildPaths = includeChildPaths {
            try encodeContainer.encode(includeChildPaths, forKey: .includeChildPaths)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let methods = methods {
            var methodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methods)
            for httpmethods0 in methods {
                try methodsContainer.encode(httpmethods0.rawValue)
            }
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let pathResourceToId = pathResourceToId {
            var pathResourceToIdContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pathResourceToId)
            for (dictKey0, pathresourcetoid0) in pathResourceToId {
                try pathResourceToIdContainer.encode(pathresourcetoid0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeId = routeId {
            try encodeContainer.encode(routeId, forKey: .routeId)
        }
        if let routeType = routeType {
            try encodeContainer.encode(routeType.rawValue, forKey: .routeType)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let routeTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteType.self, forKey: .routeType)
        routeType = routeTypeDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
        let pathResourceToIdContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pathResourceToId)
        var pathResourceToIdDecoded0: [Swift.String:Swift.String]? = nil
        if let pathResourceToIdContainer = pathResourceToIdContainer {
            pathResourceToIdDecoded0 = [Swift.String:Swift.String]()
            for (key0, pathresourcetoidvalue0) in pathResourceToIdContainer {
                if let pathresourcetoidvalue0 = pathresourcetoidvalue0 {
                    pathResourceToIdDecoded0?[key0] = pathresourcetoidvalue0
                }
            }
        }
        pathResourceToId = pathResourceToIdDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary information for the routes as a response to ListRoutes.
    public struct RouteSummary: Swift.Equatable {
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the route.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the route creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the route is created.
        public var createdTime: ClientRuntime.Date?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the route resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
        public var includeChildPaths: Swift.Bool?
        /// A timestamp that indicates when the route was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
        public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
        /// The Amazon Web Services account ID of the route owner.
        public var ownerAccountId: Swift.String?
        /// A mapping of Amazon API Gateway path resources to resource IDs.
        public var pathResourceToId: [Swift.String:Swift.String]?
        /// The unique identifier of the route.
        public var routeId: Swift.String?
        /// The route type of the route.
        public var routeType: MigrationHubRefactorSpacesClientTypes.RouteType?
        /// The unique identifier of the service.
        public var serviceId: Swift.String?
        /// The path to use to match traffic. Paths must start with / and are relative to the base of the application.
        public var sourcePath: Swift.String?
        /// The current state of the route.
        public var state: MigrationHubRefactorSpacesClientTypes.RouteState?
        /// The tags assigned to the route.
        public var tags: [Swift.String:Swift.String]?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            includeChildPaths: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
            ownerAccountId: Swift.String? = nil,
            pathResourceToId: [Swift.String:Swift.String]? = nil,
            routeId: Swift.String? = nil,
            routeType: MigrationHubRefactorSpacesClientTypes.RouteType? = nil,
            serviceId: Swift.String? = nil,
            sourcePath: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.RouteState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.environmentId = environmentId
            self.error = error
            self.includeChildPaths = includeChildPaths
            self.lastUpdatedTime = lastUpdatedTime
            self.methods = methods
            self.ownerAccountId = ownerAccountId
            self.pathResourceToId = pathResourceToId
            self.routeId = routeId
            self.routeType = routeType
            self.serviceId = serviceId
            self.sourcePath = sourcePath
            self.state = state
            self.tags = tags
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes {
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case uriPath
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .default,
                .uriPath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .uriPath: return "URI_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ServiceEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambda
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceEndpointType] {
            return [
                .lambda,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceEndpointType(rawValue: rawValue) ?? ServiceEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service quota requirement to identify originating quota. Reached throttling quota exception.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource.
    /// This member is required.
    public var resourceType: Swift.String?
    /// Service quota requirement to identify originating service. Reached throttling quota exception service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    public enum ServiceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceState(rawValue: rawValue) ?? ServiceState.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubRefactorSpacesClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case createdByAccountId = "CreatedByAccountId"
        case createdTime = "CreatedTime"
        case description = "Description"
        case endpointType = "EndpointType"
        case environmentId = "EnvironmentId"
        case error = "Error"
        case lambdaEndpoint = "LambdaEndpoint"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case serviceId = "ServiceId"
        case state = "State"
        case tags = "Tags"
        case urlEndpoint = "UrlEndpoint"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdByAccountId = createdByAccountId {
            try encodeContainer.encode(createdByAccountId, forKey: .createdByAccountId)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let lambdaEndpoint = lambdaEndpoint {
            try encodeContainer.encode(lambdaEndpoint, forKey: .lambdaEndpoint)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let urlEndpoint = urlEndpoint {
            try encodeContainer.encode(urlEndpoint, forKey: .urlEndpoint)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdByAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdByAccountId)
        createdByAccountId = createdByAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let urlEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary.self, forKey: .urlEndpoint)
        urlEndpoint = urlEndpointDecoded
        let lambdaEndpointDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary.self, forKey: .lambdaEndpoint)
        lambdaEndpoint = lambdaEndpointDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ServiceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.ErrorResponse.self, forKey: .error)
        error = errorDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// A summary for the service as a response to ListServices.
    public struct ServiceSummary: Swift.Equatable {
        /// The unique identifier of the application.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The Amazon Web Services account ID of the service creator.
        public var createdByAccountId: Swift.String?
        /// A timestamp that indicates when the service is created.
        public var createdTime: ClientRuntime.Date?
        /// A description of the service.
        public var description: Swift.String?
        /// The endpoint type of the service.
        public var endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType?
        /// The unique identifier of the environment.
        public var environmentId: Swift.String?
        /// Any error associated with the service resource.
        public var error: MigrationHubRefactorSpacesClientTypes.ErrorResponse?
        /// A summary of the configuration for the Lambda endpoint type.
        public var lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary?
        /// A timestamp that indicates when the service was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the service owner.
        public var ownerAccountId: Swift.String?
        /// The unique identifier of the service.
        public var serviceId: Swift.String?
        /// The current state of the service.
        public var state: MigrationHubRefactorSpacesClientTypes.ServiceState?
        /// The tags assigned to the service.
        public var tags: [Swift.String:Swift.String]?
        /// The summary of the configuration for the URL endpoint type.
        public var urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary?
        /// The ID of the virtual private cloud (VPC).
        public var vpcId: Swift.String?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdByAccountId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            endpointType: MigrationHubRefactorSpacesClientTypes.ServiceEndpointType? = nil,
            environmentId: Swift.String? = nil,
            error: MigrationHubRefactorSpacesClientTypes.ErrorResponse? = nil,
            lambdaEndpoint: MigrationHubRefactorSpacesClientTypes.LambdaEndpointSummary? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            state: MigrationHubRefactorSpacesClientTypes.ServiceState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            urlEndpoint: MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.createdByAccountId = createdByAccountId
            self.createdTime = createdTime
            self.description = description
            self.endpointType = endpointType
            self.environmentId = environmentId
            self.error = error
            self.lambdaEndpoint = lambdaEndpoint
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.serviceId = serviceId
            self.state = state
            self.tags = tags
            self.urlEndpoint = urlEndpoint
            self.vpcId = vpcId
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied because the request was throttled.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Service quota requirement to identify originating quota. Reached throttling quota exception.
    public var quotaCode: Swift.String?
    /// The number of seconds to wait before retrying.
    public var retryAfterSeconds: Swift.Int
    /// Service quota requirement to identify originating service. Reached throttling quota exception service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension MigrationHubRefactorSpacesClientTypes.UriPathRouteInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationState = "ActivationState"
        case includeChildPaths = "IncludeChildPaths"
        case methods = "Methods"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationState = activationState {
            try encodeContainer.encode(activationState.rawValue, forKey: .activationState)
        }
        if let includeChildPaths = includeChildPaths {
            try encodeContainer.encode(includeChildPaths, forKey: .includeChildPaths)
        }
        if let methods = methods {
            var methodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methods)
            for httpmethods0 in methods {
                try methodsContainer.encode(httpmethods0.rawValue)
            }
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let activationStateDecoded = try containerValues.decodeIfPresent(MigrationHubRefactorSpacesClientTypes.RouteActivationState.self, forKey: .activationState)
        activationState = activationStateDecoded
        let methodsContainer = try containerValues.decodeIfPresent([MigrationHubRefactorSpacesClientTypes.HttpMethod?].self, forKey: .methods)
        var methodsDecoded0:[MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil
        if let methodsContainer = methodsContainer {
            methodsDecoded0 = [MigrationHubRefactorSpacesClientTypes.HttpMethod]()
            for string0 in methodsContainer {
                if let string0 = string0 {
                    methodsDecoded0?.append(string0)
                }
            }
        }
        methods = methodsDecoded0
        let includeChildPathsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeChildPaths)
        includeChildPaths = includeChildPathsDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URI path route type.
    public struct UriPathRouteInput: Swift.Equatable {
        /// Indicates whether traffic is forwarded to this routes service after the route is created.
        /// This member is required.
        public var activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState?
        /// Indicates whether to match all subpaths of the given source path. If this value is false, requests must match the source path exactly before they are forwarded to this route's service.
        public var includeChildPaths: Swift.Bool?
        /// A list of HTTP methods to match. An empty list matches all values. If a method is present, only HTTP requests using that method are forwarded to this routes service.
        public var methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]?
        /// The path to use to match traffic. Paths must start with / and are relative to the base of the application.
        /// This member is required.
        public var sourcePath: Swift.String?

        public init (
            activationState: MigrationHubRefactorSpacesClientTypes.RouteActivationState? = nil,
            includeChildPaths: Swift.Bool? = nil,
            methods: [MigrationHubRefactorSpacesClientTypes.HttpMethod]? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.activationState = activationState
            self.includeChildPaths = includeChildPaths
            self.methods = methods
            self.sourcePath = sourcePath
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URL endpoint type.
    public struct UrlEndpointConfig: Swift.Equatable {
        /// The health check URL of the URL endpoint type.
        public var healthUrl: Swift.String?
        /// The HTTP URL endpoint.
        public var url: Swift.String?

        public init (
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The configuration for the URL endpoint type.
    public struct UrlEndpointInput: Swift.Equatable {
        /// The health check URL of the URL endpoint type. If the URL is a public endpoint, the HealthUrl must also be a public endpoint. If the URL is a private endpoint inside a virtual private cloud (VPC), the health URL must also be a private endpoint, and the host must be the same as the URL.
        public var healthUrl: Swift.String?
        /// The URL to route traffic to. The URL must be an [rfc3986-formatted URL](https://datatracker.ietf.org/doc/html/rfc3986). If the host is a domain name, the name must be resolvable over the public internet. If the scheme is https, the top level domain of the host must be listed in the [IANA root zone database](https://www.iana.org/domains/root/db).
        /// This member is required.
        public var url: Swift.String?

        public init (
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension MigrationHubRefactorSpacesClientTypes.UrlEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthUrl = "HealthUrl"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthUrl = healthUrl {
            try encodeContainer.encode(healthUrl, forKey: .healthUrl)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let healthUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthUrl)
        healthUrl = healthUrlDecoded
    }
}

extension MigrationHubRefactorSpacesClientTypes {
    /// The summary of the configuration for the URL endpoint type.
    public struct UrlEndpointSummary: Swift.Equatable {
        /// The health check URL of the URL endpoint type. If the URL is a public endpoint, the HealthUrl must also be a public endpoint. If the URL is a private endpoint inside a virtual private cloud (VPC), the health URL must also be a private endpoint, and the host must be the same as the URL.
        public var healthUrl: Swift.String?
        /// The URL to route traffic to. The URL must be an [rfc3986-formatted URL](https://datatracker.ietf.org/doc/html/rfc3986). If the host is a domain name, the name must be resolvable over the public internet. If the scheme is https, the top level domain of the host must be listed in the [IANA root zone database](https://www.iana.org/domains/root/db).
        public var url: Swift.String?

        public init (
            healthUrl: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.healthUrl = healthUrl
            self.url = url
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
