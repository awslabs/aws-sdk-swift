// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessLogSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationArn = "destinationArn"
        case format = "format"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
    }
}

extension AccessLogSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessLogSettings(destinationArn: \(String(describing: destinationArn)), format: \(String(describing: format)))"}
}

/// <p>Settings for logging access in a stage.</p>
public struct AccessLogSettings: Equatable {
    /// <p>The ARN of the CloudWatch Logs log group to receive access logs.</p>
    public let destinationArn: String?
    /// <p>A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.</p>
    public let format: String?

    public init (
        destinationArn: String? = nil,
        format: String? = nil
    )
    {
        self.destinationArn = destinationArn
        self.format = format
    }
}

extension Api: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiEndpoint = apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if disableSchemaValidation != false {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let importInfo = importInfo {
            var importInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importInfo)
            for __listof__string0 in importInfo {
                try importInfoContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for __listof__string0 in warnings {
                try warningsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension Api: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Api(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

/// <p>Represents an API.</p>
public struct Api: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

extension ApiMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingId = apiMappingId {
            try encodeContainer.encode(apiMappingId, forKey: .apiMappingId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ApiMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiMapping(apiId: \(String(describing: apiId)), apiMappingId: \(String(describing: apiMappingId)), apiMappingKey: \(String(describing: apiMappingKey)), stage: \(String(describing: stage)))"}
}

/// <p>Represents an API mapping.</p>
public struct ApiMapping: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The API mapping key.</p>
    public let apiMappingKey: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingId: String? = nil,
        apiMappingKey: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

/// <p>The authorization type. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
public enum AuthorizationType {
    case awsIam
    case custom
    case jwt
    case `none`
    case sdkUnknown(String)
}

extension AuthorizationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizationType] {
        return [
            .awsIam,
            .custom,
            .jwt,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsIam: return "AWS_IAM"
        case .custom: return "CUSTOM"
        case .jwt: return "JWT"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
    }
}

extension Authorizer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if enableSimpleResponses != false {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Authorizer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Authorizer(authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerId: \(String(describing: authorizerId)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

/// <p>Represents an authorizer.</p>
public struct Authorizer: Equatable {
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.</p>
    public let authorizerCredentialsArn: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>The validation expression does not apply to the REQUEST authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        authorizerCredentialsArn: String? = nil,
        authorizerId: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

/// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
public enum AuthorizerType {
    case jwt
    case request
    case sdkUnknown(String)
}

extension AuthorizerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizerType] {
        return [
            .jwt,
            .request,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jwt: return "JWT"
        case .request: return "REQUEST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Describes the error encountered.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Describes the error encountered.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>Represents a connection type.</p>
public enum ConnectionType {
    case internet
    case vpcLink
    case sdkUnknown(String)
}

extension ConnectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionType] {
        return [
            .internet,
            .vpcLink,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internet: return "INTERNET"
        case .vpcLink: return "VPC_LINK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
    }
}

/// <p>Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.</p>
public enum ContentHandlingStrategy {
    case convertToBinary
    case convertToText
    case sdkUnknown(String)
}

extension ContentHandlingStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContentHandlingStrategy] {
        return [
            .convertToBinary,
            .convertToText,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .convertToBinary: return "CONVERT_TO_BINARY"
        case .convertToText: return "CONVERT_TO_TEXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
    }
}

extension Cors: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowCredentials = "allowCredentials"
        case allowHeaders = "allowHeaders"
        case allowMethods = "allowMethods"
        case allowOrigins = "allowOrigins"
        case exposeHeaders = "exposeHeaders"
        case maxAge = "maxAge"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowCredentials != false {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for corsheaderlist0 in allowHeaders {
                try allowHeadersContainer.encode(corsheaderlist0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for corsmethodlist0 in allowMethods {
                try allowMethodsContainer.encode(corsmethodlist0)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for corsoriginlist0 in allowOrigins {
                try allowOriginsContainer.encode(corsoriginlist0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for corsheaderlist0 in exposeHeaders {
                try exposeHeadersContainer.encode(corsheaderlist0)
            }
        }
        if maxAge != 0 {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCredentialsDecoded = try containerValues.decode(Bool.self, forKey: .allowCredentials)
        allowCredentials = allowCredentialsDecoded
        let allowHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
        let allowMethodsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowOriginsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let exposeHeadersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decode(Int.self, forKey: .maxAge)
        maxAge = maxAgeDecoded
    }
}

extension Cors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cors(allowCredentials: \(String(describing: allowCredentials)), allowHeaders: \(String(describing: allowHeaders)), allowMethods: \(String(describing: allowMethods)), allowOrigins: \(String(describing: allowOrigins)), exposeHeaders: \(String(describing: exposeHeaders)), maxAge: \(String(describing: maxAge)))"}
}

/// <p>Represents a CORS configuration. Supported only for HTTP APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html">Configuring CORS</a> for more information.</p>
public struct Cors: Equatable {
    /// <p>Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.</p>
    public let allowCredentials: Bool
    /// <p>Represents a collection of allowed headers. Supported only for HTTP APIs.</p>
    public let allowHeaders: [String]?
    /// <p>Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.</p>
    public let allowMethods: [String]?
    /// <p>Represents a collection of allowed origins. Supported only for HTTP APIs.</p>
    public let allowOrigins: [String]?
    /// <p>Represents a collection of exposed headers. Supported only for HTTP APIs.</p>
    public let exposeHeaders: [String]?
    /// <p>The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.</p>
    public let maxAge: Int

    public init (
        allowCredentials: Bool = false,
        allowHeaders: [String]? = nil,
        allowMethods: [String]? = nil,
        allowOrigins: [String]? = nil,
        exposeHeaders: [String]? = nil,
        maxAge: Int = 0
    )
    {
        self.allowCredentials = allowCredentials
        self.allowHeaders = allowHeaders
        self.allowMethods = allowMethods
        self.allowOrigins = allowOrigins
        self.exposeHeaders = exposeHeaders
        self.maxAge = maxAge
    }
}

public struct CreateApiInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiInput>
    public typealias MOutput = OperationOutput<CreateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiOutputError>
}

extension CreateApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiInput(apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeKey: \(String(describing: routeKey)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), target: \(String(describing: target)), version: \(String(describing: version)))"}
}

extension CreateApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if disableSchemaValidation != false {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct CreateApiInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiInput>
    public typealias MOutput = OperationOutput<CreateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiOutputError>
}

public struct CreateApiInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiInput>
    public typealias MOutput = OperationOutput<CreateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiOutputError>
}

/// <p>Creates a new Api resource to represent an API.</p>
public struct CreateApiInput: Equatable {
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html">Configuring CORS</a> for more information.</p>
    public let corsConfiguration: Cors?
    /// <p>This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.</p>
    public let credentialsArn: String?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.</p>
    public let routeKey: String?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?
    /// <p>This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.</p>
    public let target: String?
    /// <p>A version identifier for the API.</p>
    public let version: String?

    public init (
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeKey: String? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        target: String? = nil,
        version: String? = nil
    )
    {
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.protocolType = protocolType
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.target = target
        self.version = version
    }
}

struct CreateApiInputBody: Equatable {
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let credentialsArn: String?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeKey: String?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let target: String?
    public let version: String?
}

extension CreateApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateApiMappingInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiMappingInput>
    public typealias MOutput = OperationOutput<CreateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiMappingOutputError>
}

extension CreateApiMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiMappingInput(apiId: \(String(describing: apiId)), apiMappingKey: \(String(describing: apiMappingKey)), domainName: \(String(describing: domainName)), stage: \(String(describing: stage)))"}
}

extension CreateApiMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

public struct CreateApiMappingInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiMappingInput>
    public typealias MOutput = OperationOutput<CreateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiMappingOutputError>
}

public struct CreateApiMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiMappingInput>
    public typealias MOutput = OperationOutput<CreateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiMappingOutputError>
}

/// <p>Creates a new ApiMapping resource to represent an API mapping.</p>
public struct CreateApiMappingInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// The API mapping key.
    public let apiMappingKey: String?
    /// <p>The domain name.</p>
    public let domainName: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingKey: String? = nil,
        domainName: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct CreateApiMappingInputBody: Equatable {
    public let apiId: String?
    public let apiMappingKey: String?
    public let stage: String?
}

extension CreateApiMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateApiMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiMappingOutputResponse(apiId: \(String(describing: apiId)), apiMappingId: \(String(describing: apiMappingId)), apiMappingKey: \(String(describing: apiMappingKey)), stage: \(String(describing: stage)))"}
}

extension CreateApiMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct CreateApiMappingOutputResponse: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The API mapping key.</p>
    public let apiMappingKey: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingId: String? = nil,
        apiMappingKey: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct CreateApiMappingOutputResponseBody: Equatable {
    public let apiId: String?
    public let apiMappingId: String?
    public let apiMappingKey: String?
    public let stage: String?
}

extension CreateApiMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiOutputResponse(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension CreateApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = false
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.disableSchemaValidation = false
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct CreateApiOutputResponse: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateApiOutputResponseBody: Equatable {
    public let apiEndpoint: String?
    public let apiGatewayManaged: Bool
    public let apiId: String?
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let createdDate: Date?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let importInfo: [String]?
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let version: String?
    public let warnings: [String]?
}

extension CreateApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct CreateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

extension CreateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerInput(apiId: \(String(describing: apiId)), authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

extension CreateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if enableSimpleResponses != false {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

public struct CreateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAuthorizerInput>
    public typealias MOutput = OperationOutput<CreateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAuthorizerOutputError>
}

/// <p>Creates a new Authorizer resource to represent an authorizer.</p>
public struct CreateAuthorizerInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.</p>
    public let authorizerCredentialsArn: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>This parameter is not used.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        apiId: String? = nil,
        authorizerCredentialsArn: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerInputBody: Equatable {
    public let authorizerCredentialsArn: String?
    public let authorizerPayloadFormatVersion: String?
    public let authorizerResultTtlInSeconds: Int
    public let authorizerType: AuthorizerType?
    public let authorizerUri: String?
    public let enableSimpleResponses: Bool
    public let identitySource: [String]?
    public let identityValidationExpression: String?
    public let jwtConfiguration: JWTConfiguration?
    public let name: String?
}

extension CreateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAuthorizerOutputResponse(authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerId: \(String(describing: authorizerId)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

extension CreateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = 0
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = false
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct CreateAuthorizerOutputResponse: Equatable {
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.</p>
    public let authorizerCredentialsArn: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>The validation expression does not apply to the REQUEST authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        authorizerCredentialsArn: String? = nil,
        authorizerId: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerOutputResponseBody: Equatable {
    public let authorizerCredentialsArn: String?
    public let authorizerId: String?
    public let authorizerPayloadFormatVersion: String?
    public let authorizerResultTtlInSeconds: Int
    public let authorizerType: AuthorizerType?
    public let authorizerUri: String?
    public let enableSimpleResponses: Bool
    public let identitySource: [String]?
    public let identityValidationExpression: String?
    public let jwtConfiguration: JWTConfiguration?
    public let name: String?
}

extension CreateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(apiId: \(String(describing: apiId)), description: \(String(describing: description)), stageName: \(String(describing: stageName)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

/// <p>Creates a new Deployment resource to represent a deployment.</p>
public struct CreateDeploymentInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The description for the deployment resource.</p>
    public let description: String?
    /// <p>The name of the Stage resource for the Deployment resource to create.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        description: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.stageName = stageName
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let description: String?
    public let stageName: String?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(autoDeployed: \(String(describing: autoDeployed)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), deploymentStatus: \(String(describing: deploymentStatus)), deploymentStatusMessage: \(String(describing: deploymentStatusMessage)), description: \(String(describing: description)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = false
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Equatable {
    /// <p>Specifies whether a deployment was automatically released.</p>
    public let autoDeployed: Bool
    /// <p>The date and time when the Deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for the deployment.</p>
    public let deploymentId: String?
    /// <p>The status of the deployment: PENDING, FAILED, or SUCCEEDED.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>May contain additional feedback on the status of an API deployment.</p>
    public let deploymentStatusMessage: String?
    /// <p>The description for the deployment.</p>
    public let description: String?

    public init (
        autoDeployed: Bool = false,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        deploymentStatusMessage: String? = nil,
        description: String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let autoDeployed: Bool
    public let createdDate: Date?
    public let deploymentId: String?
    public let deploymentStatus: DeploymentStatus?
    public let deploymentStatusMessage: String?
    public let description: String?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decode(Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct CreateDomainNameInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

extension CreateDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainNameInput(domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), tags: \(String(describing: tags)))"}
}

extension CreateDomainNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

public struct CreateDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainNameInput>
    public typealias MOutput = OperationOutput<CreateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainNameOutputError>
}

/// <p>Creates a new DomainName resource to represent a domain name.</p>
public struct CreateDomainNameInput: Equatable {
    /// <p>The domain name.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
    /// <p>The collection of tags associated with a domain name.</p>
    public let tags: [String:String]?

    public init (
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthenticationInput? = nil,
        tags: [String:String]? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Equatable {
    public let domainName: String?
    public let domainNameConfigurations: [DomainNameConfiguration]?
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
    public let tags: [String:String]?
}

extension CreateDomainNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainNameOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainNameOutputResponse(apiMappingSelectionExpression: \(String(describing: apiMappingSelectionExpression)), domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), tags: \(String(describing: tags)))"}
}

extension CreateDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainNameOutputResponse: Equatable {
    /// <p>The API mapping selection expression.</p>
    public let apiMappingSelectionExpression: String?
    /// <p>The name of the DomainName resource.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The collection of tags associated with a domain name.</p>
    public let tags: [String:String]?

    public init (
        apiMappingSelectionExpression: String? = nil,
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        tags: [String:String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameOutputResponseBody: Equatable {
    public let apiMappingSelectionExpression: String?
    public let domainName: String?
    public let domainNameConfigurations: [DomainNameConfiguration]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    public let tags: [String:String]?
}

extension CreateDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "CreateIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationOutputError>
}

extension CreateIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationInput(apiId: \(String(describing: apiId)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationMethod: \(String(describing: integrationMethod)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

extension CreateIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

public struct CreateIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationOutputError>
}

public struct CreateIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationInput>
    public typealias MOutput = OperationOutput<CreateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationOutputError>
}

/// <p>Creates a new Integration resource to represent an integration.</p>
public struct CreateIntegrationInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>The description of the integration.</p>
    public let description: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///                , where
    ///                   <replaceable>{location}</replaceable>
    ///                 is querystring, path, or header; and
    ///                   <replaceable>{name}</replaceable>
    ///                 must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt; where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfigInput?

    public init (
        apiId: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationMethod: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationInputBody: Equatable {
    public let connectionId: String?
    public let connectionType: ConnectionType?
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let credentialsArn: String?
    public let description: String?
    public let integrationMethod: String?
    public let integrationSubtype: String?
    public let integrationType: IntegrationType?
    public let integrationUri: String?
    public let passthroughBehavior: PassthroughBehavior?
    public let payloadFormatVersion: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let responseParameters: [String:[String:String]]?
    public let templateSelectionExpression: String?
    public let timeoutInMillis: Int
    public let tlsConfig: TlsConfigInput?
}

extension CreateIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension CreateIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationId: \(String(describing: integrationId)), integrationMethod: \(String(describing: integrationMethod)), integrationResponseSelectionExpression: \(String(describing: integrationResponseSelectionExpression)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

extension CreateIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = false
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
        }
    }
}

public struct CreateIntegrationOutputResponse: Equatable {
    /// <p>Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>Represents the description of an integration.</p>
    public let description: String?
    /// <p>Represents the identifier of an integration.</p>
    public let integrationId: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>The integration response selection expression for the integration. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions">Integration Response Selection Expressions</a>.</p>
    public let integrationResponseSelectionExpression: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///           , where
    ///             <replaceable>{location}</replaceable>
    ///            is querystring, path, or header; and
    ///             <replaceable>{name}</replaceable>
    ///            must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfig?

    public init (
        apiGatewayManaged: Bool = false,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationId: String? = nil,
        integrationMethod: String? = nil,
        integrationResponseSelectionExpression: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let connectionId: String?
    public let connectionType: ConnectionType?
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let credentialsArn: String?
    public let description: String?
    public let integrationId: String?
    public let integrationMethod: String?
    public let integrationResponseSelectionExpression: String?
    public let integrationSubtype: String?
    public let integrationType: IntegrationType?
    public let integrationUri: String?
    public let passthroughBehavior: PassthroughBehavior?
    public let payloadFormatVersion: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let responseParameters: [String:[String:String]]?
    public let templateSelectionExpression: String?
    public let timeoutInMillis: Int
    public let tlsConfig: TlsConfig?
}

extension CreateIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

public struct CreateIntegrationResponseInputBodyMiddleware: Middleware {
    public let id: String = "CreateIntegrationResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<CreateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationResponseOutputError>
}

extension CreateIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationResponseInput(apiId: \(String(describing: apiId)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationId: \(String(describing: integrationId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

extension CreateIntegrationResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

public struct CreateIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<CreateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationResponseOutputError>
}

public struct CreateIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<CreateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIntegrationResponseOutputError>
}

/// <p>Creates a new IntegrationResponse resource to represent an integration response.</p>
public struct CreateIntegrationResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expression for the integration response. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?

    public init (
        apiId: String? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseInputBody: Equatable {
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let integrationResponseKey: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let templateSelectionExpression: String?
}

extension CreateIntegrationResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension CreateIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIntegrationResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIntegrationResponseOutputResponse(contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationResponseId: \(String(describing: integrationResponseId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

extension CreateIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct CreateIntegrationResponseOutputResponse: Equatable {
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expressions for the integration response.</p>
    public let templateSelectionExpression: String?

    public init (
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationResponseId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseOutputResponseBody: Equatable {
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let integrationResponseId: String?
    public let integrationResponseKey: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let templateSelectionExpression: String?
}

extension CreateIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

public struct CreateModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

extension CreateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelInput(apiId: \(String(describing: apiId)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension CreateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

public struct CreateModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

/// <p>Creates a new Model.</p>
public struct CreateModelInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        apiId: String? = nil,
        contentType: String? = nil,
        description: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.name = name
        self.schema = schema
    }
}

struct CreateModelInputBody: Equatable {
    public let contentType: String?
    public let description: String?
    public let name: String?
    public let schema: String?
}

extension CreateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension CreateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct CreateModelOutputResponse: Equatable {
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The model identifier.</p>
    public let modelId: String?
    /// <p>The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputResponseBody: Equatable {
    public let contentType: String?
    public let description: String?
    public let modelId: String?
    public let name: String?
    public let schema: String?
}

extension CreateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

public struct CreateRouteInputBodyMiddleware: Middleware {
    public let id: String = "CreateRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

extension CreateRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteInput(apiId: \(String(describing: apiId)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

extension CreateRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct CreateRouteInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

public struct CreateRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

/// <p>Creates a new Route resource to represent a route.</p>
public struct CreateRouteInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies whether an API key is required for the route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>The authorization scopes supported by this route.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiId: String? = nil,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteInputBody: Equatable {
    public let apiKeyRequired: Bool
    public let authorizationScopes: [String]?
    public let authorizationType: AuthorizationType?
    public let authorizerId: String?
    public let modelSelectionExpression: String?
    public let operationName: String?
    public let requestModels: [String:String]?
    public let requestParameters: [String:ParameterConstraints]?
    public let routeKey: String?
    public let routeResponseSelectionExpression: String?
    public let target: String?
}

extension CreateRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension CreateRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeId: \(String(describing: routeId)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

extension CreateRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRouteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = false
            self.apiKeyRequired = false
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct CreateRouteOutputResponse: Equatable {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiGatewayManaged: Bool = false,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let apiKeyRequired: Bool
    public let authorizationScopes: [String]?
    public let authorizationType: AuthorizationType?
    public let authorizerId: String?
    public let modelSelectionExpression: String?
    public let operationName: String?
    public let requestModels: [String:String]?
    public let requestParameters: [String:ParameterConstraints]?
    public let routeId: String?
    public let routeKey: String?
    public let routeResponseSelectionExpression: String?
    public let target: String?
}

extension CreateRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

public struct CreateRouteResponseInputBodyMiddleware: Middleware {
    public let id: String = "CreateRouteResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteResponseInput>
    public typealias MOutput = OperationOutput<CreateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteResponseOutputError>
}

extension CreateRouteResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteResponseInput(apiId: \(String(describing: apiId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeId: \(String(describing: routeId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

extension CreateRouteResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

public struct CreateRouteResponseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRouteResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteResponseInput>
    public typealias MOutput = OperationOutput<CreateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteResponseOutputError>
}

public struct CreateRouteResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRouteResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteResponseInput>
    public typealias MOutput = OperationOutput<CreateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteResponseOutputError>
}

/// <p>Creates a new RouteResponse resource to represent a route response.</p>
public struct CreateRouteResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The model selection expression for the route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The response models for the route response.</p>
    public let responseModels: [String:String]?
    /// <p>The route response parameters.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route response key.</p>
    public let routeResponseKey: String?

    public init (
        apiId: String? = nil,
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseInputBody: Equatable {
    public let modelSelectionExpression: String?
    public let responseModels: [String:String]?
    public let responseParameters: [String:ParameterConstraints]?
    public let routeResponseKey: String?
}

extension CreateRouteResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension CreateRouteResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteResponseOutputResponse(modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeResponseId: \(String(describing: routeResponseId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

extension CreateRouteResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct CreateRouteResponseOutputResponse: Equatable {
    /// <p>Represents the model selection expression of a route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>Represents the response models of a route response.</p>
    public let responseModels: [String:String]?
    /// <p>Represents the response parameters of a route response.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>Represents the identifier of a route response.</p>
    public let routeResponseId: String?
    /// <p>Represents the route response key of a route response.</p>
    public let routeResponseKey: String?

    public init (
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeResponseId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseOutputResponseBody: Equatable {
    public let modelSelectionExpression: String?
    public let responseModels: [String:String]?
    public let responseParameters: [String:ParameterConstraints]?
    public let routeResponseId: String?
    public let routeResponseKey: String?
}

extension CreateRouteResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

public struct CreateStageInputBodyMiddleware: Middleware {
    public let id: String = "CreateStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

extension CreateStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStageInput(accessLogSettings: \(String(describing: accessLogSettings)), apiId: \(String(describing: apiId)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)), tags: \(String(describing: tags)))"}
}

extension CreateStageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if autoDeploy != false {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

public struct CreateStageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStageInput>
    public typealias MOutput = OperationOutput<CreateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStageOutputError>
}

/// <p>Creates a new Stage resource to represent a stage.</p>
public struct CreateStageInput: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.</p>
    public let clientCertificateId: String?
    /// <p>The default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The deployment identifier of the API stage.</p>
    public let deploymentId: String?
    /// <p>The description for the API stage.</p>
    public let description: String?
    /// <p>Route settings for the stage, by routeKey.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiId: String? = nil,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageInputBody: Equatable {
    public let accessLogSettings: AccessLogSettings?
    public let autoDeploy: Bool
    public let clientCertificateId: String?
    public let defaultRouteSettings: RouteSettings?
    public let deploymentId: String?
    public let description: String?
    public let routeSettings: [String:RouteSettings]?
    public let stageName: String?
    public let stageVariables: [String:String]?
    public let tags: [String:String]?
}

extension CreateStageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), lastDeploymentStatusMessage: \(String(describing: lastDeploymentStatusMessage)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)), tags: \(String(describing: tags)))"}
}

extension CreateStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = false
            self.autoDeploy = false
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct CreateStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>Default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.</p>
    public let deploymentId: String?
    /// <p>The description of the stage.</p>
    public let description: String?
    /// <p>Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.</p>
    public let lastDeploymentStatusMessage: String?
    /// <p>The timestamp when the stage was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>Route settings for the stage, by routeKey.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiGatewayManaged: Bool = false,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        lastDeploymentStatusMessage: String? = nil,
        lastUpdatedDate: Date? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageOutputResponseBody: Equatable {
    public let accessLogSettings: AccessLogSettings?
    public let apiGatewayManaged: Bool
    public let autoDeploy: Bool
    public let clientCertificateId: String?
    public let createdDate: Date?
    public let defaultRouteSettings: RouteSettings?
    public let deploymentId: String?
    public let description: String?
    public let lastDeploymentStatusMessage: String?
    public let lastUpdatedDate: Date?
    public let routeSettings: [String:RouteSettings]?
    public let stageName: String?
    public let stageVariables: [String:String]?
    public let tags: [String:String]?
}

extension CreateStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateVpcLinkInputBodyMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

extension CreateVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVpcLinkInput(name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateVpcLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

public struct CreateVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVpcLinkInput>
    public typealias MOutput = OperationOutput<CreateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVpcLinkOutputError>
}

/// <p>Creates a VPC link</p>
public struct CreateVpcLinkInput: Equatable {
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>A list of security group IDs for the VPC link.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs to include in the VPC link.</p>
    public let subnetIds: [String]?
    /// <p>A list of tags.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateVpcLinkInputBody: Equatable {
    public let name: String?
    public let securityGroupIds: [String]?
    public let subnetIds: [String]?
    public let tags: [String:String]?
}

extension CreateVpcLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVpcLinkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVpcLinkOutputResponse(createdDate: \(String(describing: createdDate)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), vpcLinkId: \(String(describing: vpcLinkId)), vpcLinkStatus: \(String(describing: vpcLinkStatus)), vpcLinkStatusMessage: \(String(describing: vpcLinkStatusMessage)), vpcLinkVersion: \(String(describing: vpcLinkVersion)))"}
}

extension CreateVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct CreateVpcLinkOutputResponse: Equatable {
    /// <p>The timestamp when the VPC link was created.</p>
    public let createdDate: Date?
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>A list of security group IDs for the VPC link.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs to include in the VPC link.</p>
    public let subnetIds: [String]?
    /// <p>Tags for the VPC link.</p>
    public let tags: [String:String]?
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?
    /// <p>The status of the VPC link.</p>
    public let vpcLinkStatus: VpcLinkStatus?
    /// <p>A message summarizing the cause of the status of the VPC link.</p>
    public let vpcLinkStatusMessage: String?
    /// <p>The version of the VPC link.</p>
    public let vpcLinkVersion: VpcLinkVersion?

    public init (
        createdDate: Date? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        vpcLinkId: String? = nil,
        vpcLinkStatus: VpcLinkStatus? = nil,
        vpcLinkStatusMessage: String? = nil,
        vpcLinkVersion: VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct CreateVpcLinkOutputResponseBody: Equatable {
    public let createdDate: Date?
    public let name: String?
    public let securityGroupIds: [String]?
    public let subnetIds: [String]?
    public let tags: [String:String]?
    public let vpcLinkId: String?
    public let vpcLinkStatus: VpcLinkStatus?
    public let vpcLinkStatusMessage: String?
    public let vpcLinkVersion: VpcLinkVersion?
}

extension CreateVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension DeleteAccessLogSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessLogSettingsInput(apiId: \(String(describing: apiId)), stageName: \(String(describing: stageName)))"}
}

extension DeleteAccessLogSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessLogSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessLogSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessLogSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessLogSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessLogSettingsInput>
    public typealias MOutput = OperationOutput<DeleteAccessLogSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessLogSettingsOutputError>
}

public struct DeleteAccessLogSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessLogSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessLogSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessLogSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessLogSettingsInput>
    public typealias MOutput = OperationOutput<DeleteAccessLogSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessLogSettingsOutputError>
}

public struct DeleteAccessLogSettingsInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteAccessLogSettingsInputBody: Equatable {
}

extension DeleteAccessLogSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessLogSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessLogSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessLogSettingsOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessLogSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessLogSettingsOutputResponse()"}
}

extension DeleteAccessLogSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessLogSettingsOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessLogSettingsOutputResponseBody: Equatable {
}

extension DeleteAccessLogSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiInput(apiId: \(String(describing: apiId)))"}
}

extension DeleteApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApiInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiInput>
    public typealias MOutput = OperationOutput<DeleteApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiOutputError>
}

public struct DeleteApiInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiInput>
    public typealias MOutput = OperationOutput<DeleteApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiOutputError>
}

public struct DeleteApiInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiInputBody: Equatable {
}

extension DeleteApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiMappingInput(apiMappingId: \(String(describing: apiMappingId)), domainName: \(String(describing: domainName)))"}
}

extension DeleteApiMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApiMappingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiMappingInput>
    public typealias MOutput = OperationOutput<DeleteApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiMappingOutputError>
}

public struct DeleteApiMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiMappingInput>
    public typealias MOutput = OperationOutput<DeleteApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiMappingOutputError>
}

public struct DeleteApiMappingInput: Equatable {
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The domain name.</p>
    public let domainName: String?

    public init (
        apiMappingId: String? = nil,
        domainName: String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct DeleteApiMappingInputBody: Equatable {
}

extension DeleteApiMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiMappingOutputResponse()"}
}

extension DeleteApiMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiMappingOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiMappingOutputResponseBody: Equatable {
}

extension DeleteApiMappingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiOutputResponse()"}
}

extension DeleteApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiOutputResponseBody: Equatable {
}

extension DeleteApiOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerInput(apiId: \(String(describing: apiId)), authorizerId: \(String(describing: authorizerId)))"}
}

extension DeleteAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

public struct DeleteAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAuthorizerInput>
    public typealias MOutput = OperationOutput<DeleteAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAuthorizerOutputError>
}

public struct DeleteAuthorizerInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?

    public init (
        apiId: String? = nil,
        authorizerId: String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct DeleteAuthorizerInputBody: Equatable {
}

extension DeleteAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuthorizerOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAuthorizerOutputResponse()"}
}

extension DeleteAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthorizerOutputResponse: Equatable {

    public init() {}
}

struct DeleteAuthorizerOutputResponseBody: Equatable {
}

extension DeleteAuthorizerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCorsConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCorsConfigurationInput(apiId: \(String(describing: apiId)))"}
}

extension DeleteCorsConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCorsConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCorsConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCorsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCorsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCorsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteCorsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCorsConfigurationOutputError>
}

public struct DeleteCorsConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCorsConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCorsConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCorsConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCorsConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteCorsConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCorsConfigurationOutputError>
}

public struct DeleteCorsConfigurationInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteCorsConfigurationInputBody: Equatable {
}

extension DeleteCorsConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCorsConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCorsConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCorsConfigurationOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCorsConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCorsConfigurationOutputResponse()"}
}

extension DeleteCorsConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCorsConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteCorsConfigurationOutputResponseBody: Equatable {
}

extension DeleteCorsConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentInput(apiId: \(String(describing: apiId)), deploymentId: \(String(describing: deploymentId)))"}
}

extension DeleteDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentOutputError>
}

public struct DeleteDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentOutputError>
}

public struct DeleteDeploymentInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The deployment ID.</p>
    public let deploymentId: String?

    public init (
        apiId: String? = nil,
        deploymentId: String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct DeleteDeploymentInputBody: Equatable {
}

extension DeleteDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentOutputResponse()"}
}

extension DeleteDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeploymentOutputResponseBody: Equatable {
}

extension DeleteDeploymentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainNameInput(domainName: \(String(describing: domainName)))"}
}

extension DeleteDomainNameInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainNameInput>
    public typealias MOutput = OperationOutput<DeleteDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainNameOutputError>
}

public struct DeleteDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainNameInput>
    public typealias MOutput = OperationOutput<DeleteDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainNameOutputError>
}

public struct DeleteDomainNameInput: Equatable {
    /// <p>The domain name.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Equatable {
}

extension DeleteDomainNameInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainNameOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainNameOutputResponse()"}
}

extension DeleteDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainNameOutputResponse: Equatable {

    public init() {}
}

struct DeleteDomainNameOutputResponseBody: Equatable {
}

extension DeleteDomainNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationInput(apiId: \(String(describing: apiId)), integrationId: \(String(describing: integrationId)))"}
}

extension DeleteIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

public struct DeleteIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationOutputError>
}

public struct DeleteIntegrationInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?

    public init (
        apiId: String? = nil,
        integrationId: String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct DeleteIntegrationInputBody: Equatable {
}

extension DeleteIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationOutputResponse()"}
}

extension DeleteIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntegrationOutputResponseBody: Equatable {
}

extension DeleteIntegrationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationResponseInput(apiId: \(String(describing: apiId)), integrationId: \(String(describing: integrationId)), integrationResponseId: \(String(describing: integrationResponseId)))"}
}

extension DeleteIntegrationResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationResponseInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationResponseOutputError>
}

public struct DeleteIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIntegrationResponseInput>
    public typealias MOutput = OperationOutput<DeleteIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIntegrationResponseOutputError>
}

public struct DeleteIntegrationResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?

    public init (
        apiId: String? = nil,
        integrationId: String? = nil,
        integrationResponseId: String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct DeleteIntegrationResponseInputBody: Equatable {
}

extension DeleteIntegrationResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIntegrationResponseOutputResponse()"}
}

extension DeleteIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationResponseOutputResponse: Equatable {

    public init() {}
}

struct DeleteIntegrationResponseOutputResponseBody: Equatable {
}

extension DeleteIntegrationResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelInput(apiId: \(String(describing: apiId)), modelId: \(String(describing: modelId)))"}
}

extension DeleteModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The model ID.</p>
    public let modelId: String?

    public init (
        apiId: String? = nil,
        modelId: String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct DeleteModelInputBody: Equatable {
}

extension DeleteModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelOutputResponse()"}
}

extension DeleteModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteModelOutputResponseBody: Equatable {
}

extension DeleteModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteInput(apiId: \(String(describing: apiId)), routeId: \(String(describing: routeId)))"}
}

extension DeleteRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRouteInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteInput>
    public typealias MOutput = OperationOutput<DeleteRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteOutputError>
}

public struct DeleteRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteInput>
    public typealias MOutput = OperationOutput<DeleteRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteOutputError>
}

public struct DeleteRouteInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route ID.</p>
    public let routeId: String?

    public init (
        apiId: String? = nil,
        routeId: String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct DeleteRouteInputBody: Equatable {
}

extension DeleteRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteOutputResponse()"}
}

extension DeleteRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteOutputResponse: Equatable {

    public init() {}
}

struct DeleteRouteOutputResponseBody: Equatable {
}

extension DeleteRouteOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteRequestParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteRequestParameterInput(apiId: \(String(describing: apiId)), requestParameterKey: \(String(describing: requestParameterKey)), routeId: \(String(describing: routeId)))"}
}

extension DeleteRouteRequestParameterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRouteRequestParameterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRouteRequestParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteRequestParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteRequestParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteRequestParameterInput>
    public typealias MOutput = OperationOutput<DeleteRouteRequestParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteRequestParameterOutputError>
}

public struct DeleteRouteRequestParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRouteRequestParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteRequestParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteRequestParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteRequestParameterInput>
    public typealias MOutput = OperationOutput<DeleteRouteRequestParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteRequestParameterOutputError>
}

public struct DeleteRouteRequestParameterInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route request parameter key.</p>
    public let requestParameterKey: String?
    /// <p>The route ID.</p>
    public let routeId: String?

    public init (
        apiId: String? = nil,
        requestParameterKey: String? = nil,
        routeId: String? = nil
    )
    {
        self.apiId = apiId
        self.requestParameterKey = requestParameterKey
        self.routeId = routeId
    }
}

struct DeleteRouteRequestParameterInputBody: Equatable {
}

extension DeleteRouteRequestParameterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteRequestParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteRequestParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteRequestParameterOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteRequestParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteRequestParameterOutputResponse()"}
}

extension DeleteRouteRequestParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteRequestParameterOutputResponse: Equatable {

    public init() {}
}

struct DeleteRouteRequestParameterOutputResponseBody: Equatable {
}

extension DeleteRouteRequestParameterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteResponseInput(apiId: \(String(describing: apiId)), routeId: \(String(describing: routeId)), routeResponseId: \(String(describing: routeResponseId)))"}
}

extension DeleteRouteResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRouteResponseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRouteResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteResponseInput>
    public typealias MOutput = OperationOutput<DeleteRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteResponseOutputError>
}

public struct DeleteRouteResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRouteResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteResponseInput>
    public typealias MOutput = OperationOutput<DeleteRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteResponseOutputError>
}

public struct DeleteRouteResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route response ID.</p>
    public let routeResponseId: String?

    public init (
        apiId: String? = nil,
        routeId: String? = nil,
        routeResponseId: String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct DeleteRouteResponseInputBody: Equatable {
}

extension DeleteRouteResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteResponseOutputResponse()"}
}

extension DeleteRouteResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteResponseOutputResponse: Equatable {

    public init() {}
}

struct DeleteRouteResponseOutputResponseBody: Equatable {
}

extension DeleteRouteResponseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteSettingsInput(apiId: \(String(describing: apiId)), routeKey: \(String(describing: routeKey)), stageName: \(String(describing: stageName)))"}
}

extension DeleteRouteSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRouteSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRouteSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteSettingsInput>
    public typealias MOutput = OperationOutput<DeleteRouteSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteSettingsOutputError>
}

public struct DeleteRouteSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRouteSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteSettingsInput>
    public typealias MOutput = OperationOutput<DeleteRouteSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteSettingsOutputError>
}

public struct DeleteRouteSettingsInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route key.</p>
    public let routeKey: String?
    /// <p>The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        routeKey: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.routeKey = routeKey
        self.stageName = stageName
    }
}

struct DeleteRouteSettingsInputBody: Equatable {
}

extension DeleteRouteSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteSettingsOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteSettingsOutputResponse()"}
}

extension DeleteRouteSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRouteSettingsOutputResponse: Equatable {

    public init() {}
}

struct DeleteRouteSettingsOutputResponseBody: Equatable {
}

extension DeleteRouteSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStageInput(apiId: \(String(describing: apiId)), stageName: \(String(describing: stageName)))"}
}

extension DeleteStageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStageInput>
    public typealias MOutput = OperationOutput<DeleteStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStageOutputError>
}

public struct DeleteStageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStageInput>
    public typealias MOutput = OperationOutput<DeleteStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStageOutputError>
}

public struct DeleteStageInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Equatable {
}

extension DeleteStageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStageOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStageOutputResponse()"}
}

extension DeleteStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStageOutputResponse: Equatable {

    public init() {}
}

struct DeleteStageOutputResponseBody: Equatable {
}

extension DeleteStageOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVpcLinkInput(vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension DeleteVpcLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVpcLinkInput>
    public typealias MOutput = OperationOutput<DeleteVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVpcLinkOutputError>
}

public struct DeleteVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVpcLinkInput>
    public typealias MOutput = OperationOutput<DeleteVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVpcLinkOutputError>
}

public struct DeleteVpcLinkInput: Equatable {
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?

    public init (
        vpcLinkId: String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Equatable {
}

extension DeleteVpcLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVpcLinkOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVpcLinkOutputResponse()"}
}

extension DeleteVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVpcLinkOutputResponse: Equatable {

    public init() {}
}

struct DeleteVpcLinkOutputResponseBody: Equatable {
}

extension DeleteVpcLinkOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoDeployed != false {
            try encodeContainer.encode(autoDeployed, forKey: .autoDeployed)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decode(Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(autoDeployed: \(String(describing: autoDeployed)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), deploymentStatus: \(String(describing: deploymentStatus)), deploymentStatusMessage: \(String(describing: deploymentStatusMessage)), description: \(String(describing: description)))"}
}

/// <p>An immutable representation of an API that can be called by users. A Deployment must be associated with a Stage for it to be callable over the internet.</p>
public struct Deployment: Equatable {
    /// <p>Specifies whether a deployment was automatically released.</p>
    public let autoDeployed: Bool
    /// <p>The date and time when the Deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for the deployment.</p>
    public let deploymentId: String?
    /// <p>The status of the deployment: PENDING, FAILED, or SUCCEEDED.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>May contain additional feedback on the status of an API deployment.</p>
    public let deploymentStatusMessage: String?
    /// <p>The description for the deployment.</p>
    public let description: String?

    public init (
        autoDeployed: Bool = false,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        deploymentStatusMessage: String? = nil,
        description: String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

/// <p>Represents a deployment status.</p>
public enum DeploymentStatus {
    case deployed
    case failed
    case pending
    case sdkUnknown(String)
}

extension DeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentStatus] {
        return [
            .deployed,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deployed: return "DEPLOYED"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
    }
}

extension DomainName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiMappingSelectionExpression = apiMappingSelectionExpression {
            try encodeContainer.encode(apiMappingSelectionExpression, forKey: .apiMappingSelectionExpression)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DomainName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainName(apiMappingSelectionExpression: \(String(describing: apiMappingSelectionExpression)), domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a domain name.</p>
public struct DomainName: Equatable {
    /// <p>The API mapping selection expression.</p>
    public let apiMappingSelectionExpression: String?
    /// <p>The name of the DomainName resource.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The collection of tags associated with a domain name.</p>
    public let tags: [String:String]?

    public init (
        apiMappingSelectionExpression: String? = nil,
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        tags: [String:String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

extension DomainNameConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiGatewayDomainName = "apiGatewayDomainName"
        case certificateArn = "certificateArn"
        case certificateName = "certificateName"
        case certificateUploadDate = "certificateUploadDate"
        case domainNameStatus = "domainNameStatus"
        case domainNameStatusMessage = "domainNameStatusMessage"
        case endpointType = "endpointType"
        case hostedZoneId = "hostedZoneId"
        case securityPolicy = "securityPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayDomainName = apiGatewayDomainName {
            try encodeContainer.encode(apiGatewayDomainName, forKey: .apiGatewayDomainName)
        }
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = certificateUploadDate {
            try encodeContainer.encode(certificateUploadDate.timeIntervalSince1970, forKey: .certificateUploadDate)
        }
        if let domainNameStatus = domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayDomainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiGatewayDomainName)
        apiGatewayDomainName = apiGatewayDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

extension DomainNameConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainNameConfiguration(apiGatewayDomainName: \(String(describing: apiGatewayDomainName)), certificateArn: \(String(describing: certificateArn)), certificateName: \(String(describing: certificateName)), certificateUploadDate: \(String(describing: certificateUploadDate)), domainNameStatus: \(String(describing: domainNameStatus)), domainNameStatusMessage: \(String(describing: domainNameStatusMessage)), endpointType: \(String(describing: endpointType)), hostedZoneId: \(String(describing: hostedZoneId)), securityPolicy: \(String(describing: securityPolicy)))"}
}

/// <p>The domain name configuration.</p>
public struct DomainNameConfiguration: Equatable {
    /// <p>A domain name for the API.</p>
    public let apiGatewayDomainName: String?
    /// <p>An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.</p>
    public let certificateArn: String?
    /// <p>The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.</p>
    public let certificateName: String?
    /// <p>The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.</p>
    public let certificateUploadDate: Date?
    /// <p>The status of the domain name migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.</p>
    public let domainNameStatus: DomainNameStatus?
    /// <p>An optional text message containing detailed information about status of the domain name migration.</p>
    public let domainNameStatusMessage: String?
    /// <p>The endpoint type.</p>
    public let endpointType: EndpointType?
    /// <p>The Amazon Route 53 Hosted Zone ID of the endpoint.</p>
    public let hostedZoneId: String?
    /// <p>The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.</p>
    public let securityPolicy: SecurityPolicy?

    public init (
        apiGatewayDomainName: String? = nil,
        certificateArn: String? = nil,
        certificateName: String? = nil,
        certificateUploadDate: Date? = nil,
        domainNameStatus: DomainNameStatus? = nil,
        domainNameStatusMessage: String? = nil,
        endpointType: EndpointType? = nil,
        hostedZoneId: String? = nil,
        securityPolicy: SecurityPolicy? = nil
    )
    {
        self.apiGatewayDomainName = apiGatewayDomainName
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointType = endpointType
        self.hostedZoneId = hostedZoneId
        self.securityPolicy = securityPolicy
    }
}

/// <p>The status of the domain name migration. The valid values are AVAILABLE and UPDATING. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.</p>
public enum DomainNameStatus {
    case available
    case updating
    case sdkUnknown(String)
}

extension DomainNameStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainNameStatus] {
        return [
            .available,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
    }
}

/// <p>Represents an endpoint type.</p>
public enum EndpointType {
    case edge
    case regional
    case sdkUnknown(String)
}

extension EndpointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointType] {
        return [
            .edge,
            .regional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .edge: return "EDGE"
        case .regional: return "REGIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
    }
}

extension ExportApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportApiInput(apiId: \(String(describing: apiId)), exportVersion: \(String(describing: exportVersion)), includeExtensions: \(String(describing: includeExtensions)), outputType: \(String(describing: outputType)), specification: \(String(describing: specification)), stageName: \(String(describing: stageName)))"}
}

extension ExportApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportApiInputHeadersMiddleware: Middleware {
    public let id: String = "ExportApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportApiInput>
    public typealias MOutput = OperationOutput<ExportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportApiOutputError>
}

public struct ExportApiInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stageName = input.operationInput.stageName {
            let stageNameQueryItem = URLQueryItem(name: "stageName".urlPercentEncoding(), value: String(stageName).urlPercentEncoding())
            input.builder.withQueryItem(stageNameQueryItem)
        }
        let includeExtensionsQueryItem = URLQueryItem(name: "includeExtensions".urlPercentEncoding(), value: String(input.operationInput.includeExtensions).urlPercentEncoding())
        input.builder.withQueryItem(includeExtensionsQueryItem)
        if let exportVersion = input.operationInput.exportVersion {
            let exportVersionQueryItem = URLQueryItem(name: "exportVersion".urlPercentEncoding(), value: String(exportVersion).urlPercentEncoding())
            input.builder.withQueryItem(exportVersionQueryItem)
        }
        if let outputType = input.operationInput.outputType {
            let outputTypeQueryItem = URLQueryItem(name: "outputType".urlPercentEncoding(), value: String(outputType).urlPercentEncoding())
            input.builder.withQueryItem(outputTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportApiInput>
    public typealias MOutput = OperationOutput<ExportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportApiOutputError>
}

public struct ExportApiInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.</p>
    public let exportVersion: String?
    /// <p>Specifies whether to include <a href="https://docs.aws.amazon.com//apigateway/latest/developerguide/api-gateway-swagger-extensions.html">API Gateway extensions</a> in the exported API definition. API Gateway extensions are included by default.</p>
    public let includeExtensions: Bool
    /// <p>The output type of the exported definition file. Valid values are JSON and YAML.</p>
    public let outputType: String?
    /// <p>The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.</p>
    public let specification: String?
    /// <p>The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        exportVersion: String? = nil,
        includeExtensions: Bool = false,
        outputType: String? = nil,
        specification: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.exportVersion = exportVersion
        self.includeExtensions = includeExtensions
        self.outputType = outputType
        self.specification = specification
        self.stageName = stageName
    }
}

struct ExportApiInputBody: Equatable {
}

extension ExportApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportApiOutputResponse(body: \(String(describing: body)))"}
}

extension ExportApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
    }
}

public struct ExportApiOutputResponse: Equatable {
    /// <p>Represents an exported definition of an API in a particular output format, for example, YAML. The API is serialized to the requested specification, for example, OpenAPI 3.0.</p>
    public let body: Data?

    public init (
        body: Data? = nil
    )
    {
        self.body = body
    }
}

struct ExportApiOutputResponseBody: Equatable {
    public let body: Data?
}

extension ExportApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiInput(apiId: \(String(describing: apiId)))"}
}

extension GetApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiInput>
    public typealias MOutput = OperationOutput<GetApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiOutputError>
}

public struct GetApiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiInput>
    public typealias MOutput = OperationOutput<GetApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiOutputError>
}

public struct GetApiInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiInputBody: Equatable {
}

extension GetApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiMappingInput(apiMappingId: \(String(describing: apiMappingId)), domainName: \(String(describing: domainName)))"}
}

extension GetApiMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiMappingInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiMappingInput>
    public typealias MOutput = OperationOutput<GetApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiMappingOutputError>
}

public struct GetApiMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiMappingInput>
    public typealias MOutput = OperationOutput<GetApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiMappingOutputError>
}

public struct GetApiMappingInput: Equatable {
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The domain name.</p>
    public let domainName: String?

    public init (
        apiMappingId: String? = nil,
        domainName: String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct GetApiMappingInputBody: Equatable {
}

extension GetApiMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiMappingOutputResponse(apiId: \(String(describing: apiId)), apiMappingId: \(String(describing: apiMappingId)), apiMappingKey: \(String(describing: apiMappingKey)), stage: \(String(describing: stage)))"}
}

extension GetApiMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct GetApiMappingOutputResponse: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The API mapping key.</p>
    public let apiMappingKey: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingId: String? = nil,
        apiMappingKey: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct GetApiMappingOutputResponseBody: Equatable {
    public let apiId: String?
    public let apiMappingId: String?
    public let apiMappingKey: String?
    public let stage: String?
}

extension GetApiMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension GetApiMappingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiMappingsInput(domainName: \(String(describing: domainName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetApiMappingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiMappingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiMappingsInput>
    public typealias MOutput = OperationOutput<GetApiMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiMappingsOutputError>
}

public struct GetApiMappingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiMappingsInput>
    public typealias MOutput = OperationOutput<GetApiMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiMappingsOutputError>
}

public struct GetApiMappingsInput: Equatable {
    /// <p>The domain name.</p>
    public let domainName: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        domainName: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApiMappingsInputBody: Equatable {
}

extension GetApiMappingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiMappingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiMappingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiMappingsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiMappingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiMappingsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetApiMappingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiMappingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApiMappingsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [ApiMapping]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [ApiMapping]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApiMappingsOutputResponseBody: Equatable {
    public let items: [ApiMapping]?
    public let nextToken: String?
}

extension GetApiMappingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiMapping?].self, forKey: .items)
        var itemsDecoded0:[ApiMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiOutputResponse(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension GetApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = false
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.disableSchemaValidation = false
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct GetApiOutputResponse: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetApiOutputResponseBody: Equatable {
    public let apiEndpoint: String?
    public let apiGatewayManaged: Bool
    public let apiId: String?
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let createdDate: Date?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let importInfo: [String]?
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let version: String?
    public let warnings: [String]?
}

extension GetApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension GetApisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApisInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetApisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApisInputHeadersMiddleware: Middleware {
    public let id: String = "GetApisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApisInput>
    public typealias MOutput = OperationOutput<GetApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApisOutputError>
}

public struct GetApisInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApisInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApisInput>
    public typealias MOutput = OperationOutput<GetApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApisOutputError>
}

public struct GetApisInput: Equatable {
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApisInputBody: Equatable {
}

extension GetApisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApisOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApisOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetApisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApisOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Api]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Api]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApisOutputResponseBody: Equatable {
    public let items: [Api]?
    public let nextToken: String?
}

extension GetApisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Api?].self, forKey: .items)
        var itemsDecoded0:[Api]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Api]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizerInput(apiId: \(String(describing: apiId)), authorizerId: \(String(describing: authorizerId)))"}
}

extension GetAuthorizerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizerInput>
    public typealias MOutput = OperationOutput<GetAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizerOutputError>
}

public struct GetAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizerInput>
    public typealias MOutput = OperationOutput<GetAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizerOutputError>
}

public struct GetAuthorizerInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?

    public init (
        apiId: String? = nil,
        authorizerId: String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct GetAuthorizerInputBody: Equatable {
}

extension GetAuthorizerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizerOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizerOutputResponse(authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerId: \(String(describing: authorizerId)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

extension GetAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = 0
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = false
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct GetAuthorizerOutputResponse: Equatable {
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.</p>
    public let authorizerCredentialsArn: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>The validation expression does not apply to the REQUEST authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        authorizerCredentialsArn: String? = nil,
        authorizerId: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct GetAuthorizerOutputResponseBody: Equatable {
    public let authorizerCredentialsArn: String?
    public let authorizerId: String?
    public let authorizerPayloadFormatVersion: String?
    public let authorizerResultTtlInSeconds: Int
    public let authorizerType: AuthorizerType?
    public let authorizerUri: String?
    public let enableSimpleResponses: Bool
    public let identitySource: [String]?
    public let identityValidationExpression: String?
    public let jwtConfiguration: JWTConfiguration?
    public let name: String?
}

extension GetAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetAuthorizersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizersInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAuthorizersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizersInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizersInput>
    public typealias MOutput = OperationOutput<GetAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizersOutputError>
}

public struct GetAuthorizersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizersInput>
    public typealias MOutput = OperationOutput<GetAuthorizersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizersOutputError>
}

public struct GetAuthorizersInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetAuthorizersInputBody: Equatable {
}

extension GetAuthorizersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizersOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAuthorizersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetAuthorizersOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Authorizer]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Authorizer]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetAuthorizersOutputResponseBody: Equatable {
    public let items: [Authorizer]?
    public let nextToken: String?
}

extension GetAuthorizersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Authorizer?].self, forKey: .items)
        var itemsDecoded0:[Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentInput(apiId: \(String(describing: apiId)), deploymentId: \(String(describing: deploymentId)))"}
}

extension GetDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The deployment ID.</p>
    public let deploymentId: String?

    public init (
        apiId: String? = nil,
        deploymentId: String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Equatable {
}

extension GetDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentOutputResponse(autoDeployed: \(String(describing: autoDeployed)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), deploymentStatus: \(String(describing: deploymentStatus)), deploymentStatusMessage: \(String(describing: deploymentStatusMessage)), description: \(String(describing: description)))"}
}

extension GetDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = false
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Equatable {
    /// <p>Specifies whether a deployment was automatically released.</p>
    public let autoDeployed: Bool
    /// <p>The date and time when the Deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for the deployment.</p>
    public let deploymentId: String?
    /// <p>The status of the deployment: PENDING, FAILED, or SUCCEEDED.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>May contain additional feedback on the status of an API deployment.</p>
    public let deploymentStatusMessage: String?
    /// <p>The description for the deployment.</p>
    public let description: String?

    public init (
        autoDeployed: Bool = false,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        deploymentStatusMessage: String? = nil,
        description: String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct GetDeploymentOutputResponseBody: Equatable {
    public let autoDeployed: Bool
    public let createdDate: Date?
    public let deploymentId: String?
    public let deploymentStatus: DeploymentStatus?
    public let deploymentStatusMessage: String?
    public let description: String?
}

extension GetDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decode(Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentsInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentsInput>
    public typealias MOutput = OperationOutput<GetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentsOutputError>
}

public struct GetDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentsInput>
    public typealias MOutput = OperationOutput<GetDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentsOutputError>
}

public struct GetDeploymentsInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDeploymentsInputBody: Equatable {
}

extension GetDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDeploymentsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Deployment]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Deployment]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDeploymentsOutputResponseBody: Equatable {
    public let items: [Deployment]?
    public let nextToken: String?
}

extension GetDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Deployment?].self, forKey: .items)
        var itemsDecoded0:[Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNameInput(domainName: \(String(describing: domainName)))"}
}

extension GetDomainNameInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNameInput>
    public typealias MOutput = OperationOutput<GetDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNameOutputError>
}

public struct GetDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNameInput>
    public typealias MOutput = OperationOutput<GetDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNameOutputError>
}

public struct GetDomainNameInput: Equatable {
    /// <p>The domain name.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Equatable {
}

extension GetDomainNameInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNameOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNameOutputResponse(apiMappingSelectionExpression: \(String(describing: apiMappingSelectionExpression)), domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), tags: \(String(describing: tags)))"}
}

extension GetDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct GetDomainNameOutputResponse: Equatable {
    /// <p>The API mapping selection expression.</p>
    public let apiMappingSelectionExpression: String?
    /// <p>The name of the DomainName resource.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The collection of tags associated with a domain name.</p>
    public let tags: [String:String]?

    public init (
        apiMappingSelectionExpression: String? = nil,
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        tags: [String:String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct GetDomainNameOutputResponseBody: Equatable {
    public let apiMappingSelectionExpression: String?
    public let domainName: String?
    public let domainNameConfigurations: [DomainNameConfiguration]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    public let tags: [String:String]?
}

extension GetDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainNamesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNamesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDomainNamesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainNamesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainNamesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNamesInput>
    public typealias MOutput = OperationOutput<GetDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNamesOutputError>
}

public struct GetDomainNamesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainNamesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainNamesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainNamesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainNamesInput>
    public typealias MOutput = OperationOutput<GetDomainNamesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainNamesOutputError>
}

public struct GetDomainNamesInput: Equatable {
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDomainNamesInputBody: Equatable {
}

extension GetDomainNamesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainNamesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNamesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNamesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNamesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainNamesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDomainNamesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDomainNamesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [DomainName]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [DomainName]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDomainNamesOutputResponseBody: Equatable {
    public let items: [DomainName]?
    public let nextToken: String?
}

extension GetDomainNamesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DomainName?].self, forKey: .items)
        var itemsDecoded0:[DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationInput(apiId: \(String(describing: apiId)), integrationId: \(String(describing: integrationId)))"}
}

extension GetIntegrationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

public struct GetIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationInput>
    public typealias MOutput = OperationOutput<GetIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationOutputError>
}

public struct GetIntegrationInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?

    public init (
        apiId: String? = nil,
        integrationId: String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct GetIntegrationInputBody: Equatable {
}

extension GetIntegrationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationId: \(String(describing: integrationId)), integrationMethod: \(String(describing: integrationMethod)), integrationResponseSelectionExpression: \(String(describing: integrationResponseSelectionExpression)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

extension GetIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = false
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
        }
    }
}

public struct GetIntegrationOutputResponse: Equatable {
    /// <p>Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>Represents the description of an integration.</p>
    public let description: String?
    /// <p>Represents the identifier of an integration.</p>
    public let integrationId: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>The integration response selection expression for the integration. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions">Integration Response Selection Expressions</a>.</p>
    public let integrationResponseSelectionExpression: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///           , where
    ///             <replaceable>{location}</replaceable>
    ///            is querystring, path, or header; and
    ///             <replaceable>{name}</replaceable>
    ///            must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfig?

    public init (
        apiGatewayManaged: Bool = false,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationId: String? = nil,
        integrationMethod: String? = nil,
        integrationResponseSelectionExpression: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct GetIntegrationOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let connectionId: String?
    public let connectionType: ConnectionType?
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let credentialsArn: String?
    public let description: String?
    public let integrationId: String?
    public let integrationMethod: String?
    public let integrationResponseSelectionExpression: String?
    public let integrationSubtype: String?
    public let integrationType: IntegrationType?
    public let integrationUri: String?
    public let passthroughBehavior: PassthroughBehavior?
    public let payloadFormatVersion: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let responseParameters: [String:[String:String]]?
    public let templateSelectionExpression: String?
    public let timeoutInMillis: Int
    public let tlsConfig: TlsConfig?
}

extension GetIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension GetIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponseInput(apiId: \(String(describing: apiId)), integrationId: \(String(describing: integrationId)), integrationResponseId: \(String(describing: integrationResponseId)))"}
}

extension GetIntegrationResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponseInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponseOutputError>
}

public struct GetIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponseInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponseOutputError>
}

public struct GetIntegrationResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?

    public init (
        apiId: String? = nil,
        integrationId: String? = nil,
        integrationResponseId: String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct GetIntegrationResponseInputBody: Equatable {
}

extension GetIntegrationResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponseOutputResponse(contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationResponseId: \(String(describing: integrationResponseId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

extension GetIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct GetIntegrationResponseOutputResponse: Equatable {
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expressions for the integration response.</p>
    public let templateSelectionExpression: String?

    public init (
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationResponseId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct GetIntegrationResponseOutputResponseBody: Equatable {
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let integrationResponseId: String?
    public let integrationResponseKey: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let templateSelectionExpression: String?
}

extension GetIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension GetIntegrationResponsesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponsesInput(apiId: \(String(describing: apiId)), integrationId: \(String(describing: integrationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetIntegrationResponsesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationResponsesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationResponsesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponsesInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponsesOutputError>
}

public struct GetIntegrationResponsesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationResponsesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationResponsesInput>
    public typealias MOutput = OperationOutput<GetIntegrationResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationResponsesOutputError>
}

public struct GetIntegrationResponsesInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        integrationId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesInputBody: Equatable {
}

extension GetIntegrationResponsesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationResponsesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponsesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponsesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponsesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationResponsesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetIntegrationResponsesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationResponsesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationResponsesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [IntegrationResponse]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [IntegrationResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesOutputResponseBody: Equatable {
    public let items: [IntegrationResponse]?
    public let nextToken: String?
}

extension GetIntegrationResponsesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([IntegrationResponse?].self, forKey: .items)
        var itemsDecoded0:[IntegrationResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [IntegrationResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetIntegrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationsInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetIntegrationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntegrationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntegrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationsInput>
    public typealias MOutput = OperationOutput<GetIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationsOutputError>
}

public struct GetIntegrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntegrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntegrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntegrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntegrationsInput>
    public typealias MOutput = OperationOutput<GetIntegrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntegrationsOutputError>
}

public struct GetIntegrationsInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationsInputBody: Equatable {
}

extension GetIntegrationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntegrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntegrationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetIntegrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIntegrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Integration]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Integration]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationsOutputResponseBody: Equatable {
    public let items: [Integration]?
    public let nextToken: String?
}

extension GetIntegrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Integration?].self, forKey: .items)
        var itemsDecoded0:[Integration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Integration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelInput(apiId: \(String(describing: apiId)), modelId: \(String(describing: modelId)))"}
}

extension GetModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelInput>
    public typealias MOutput = OperationOutput<GetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelOutputError>
}

public struct GetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelInput>
    public typealias MOutput = OperationOutput<GetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelOutputError>
}

public struct GetModelInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The model ID.</p>
    public let modelId: String?

    public init (
        apiId: String? = nil,
        modelId: String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelInputBody: Equatable {
}

extension GetModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension GetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct GetModelOutputResponse: Equatable {
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The model identifier.</p>
    public let modelId: String?
    /// <p>The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputResponseBody: Equatable {
    public let contentType: String?
    public let description: String?
    public let modelId: String?
    public let name: String?
    public let schema: String?
}

extension GetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension GetModelTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelTemplateInput(apiId: \(String(describing: apiId)), modelId: \(String(describing: modelId)))"}
}

extension GetModelTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelTemplateInput>
    public typealias MOutput = OperationOutput<GetModelTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelTemplateOutputError>
}

public struct GetModelTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelTemplateInput>
    public typealias MOutput = OperationOutput<GetModelTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelTemplateOutputError>
}

public struct GetModelTemplateInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The model ID.</p>
    public let modelId: String?

    public init (
        apiId: String? = nil,
        modelId: String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelTemplateInputBody: Equatable {
}

extension GetModelTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelTemplateOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelTemplateOutputResponse(value: \(String(describing: value)))"}
}

extension GetModelTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

public struct GetModelTemplateOutputResponse: Equatable {
    /// <p>The template value.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputResponseBody: Equatable {
    public let value: String?
}

extension GetModelTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case value = "value"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GetModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetModelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

public struct GetModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetModelsInput>
    public typealias MOutput = OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetModelsOutputError>
}

public struct GetModelsInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Equatable {
}

extension GetModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetModelsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Model]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Model]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetModelsOutputResponseBody: Equatable {
    public let items: [Model]?
    public let nextToken: String?
}

extension GetModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Model?].self, forKey: .items)
        var itemsDecoded0:[Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteInput(apiId: \(String(describing: apiId)), routeId: \(String(describing: routeId)))"}
}

extension GetRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRouteInputHeadersMiddleware: Middleware {
    public let id: String = "GetRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteInput>
    public typealias MOutput = OperationOutput<GetRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteOutputError>
}

public struct GetRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteInput>
    public typealias MOutput = OperationOutput<GetRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteOutputError>
}

public struct GetRouteInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route ID.</p>
    public let routeId: String?

    public init (
        apiId: String? = nil,
        routeId: String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct GetRouteInputBody: Equatable {
}

extension GetRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeId: \(String(describing: routeId)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

extension GetRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRouteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = false
            self.apiKeyRequired = false
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct GetRouteOutputResponse: Equatable {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiGatewayManaged: Bool = false,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct GetRouteOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let apiKeyRequired: Bool
    public let authorizationScopes: [String]?
    public let authorizationType: AuthorizationType?
    public let authorizerId: String?
    public let modelSelectionExpression: String?
    public let operationName: String?
    public let requestModels: [String:String]?
    public let requestParameters: [String:ParameterConstraints]?
    public let routeId: String?
    public let routeKey: String?
    public let routeResponseSelectionExpression: String?
    public let target: String?
}

extension GetRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GetRouteResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteResponseInput(apiId: \(String(describing: apiId)), routeId: \(String(describing: routeId)), routeResponseId: \(String(describing: routeResponseId)))"}
}

extension GetRouteResponseInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRouteResponseInputHeadersMiddleware: Middleware {
    public let id: String = "GetRouteResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteResponseInput>
    public typealias MOutput = OperationOutput<GetRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteResponseOutputError>
}

public struct GetRouteResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRouteResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteResponseInput>
    public typealias MOutput = OperationOutput<GetRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteResponseOutputError>
}

public struct GetRouteResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route response ID.</p>
    public let routeResponseId: String?

    public init (
        apiId: String? = nil,
        routeId: String? = nil,
        routeResponseId: String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct GetRouteResponseInputBody: Equatable {
}

extension GetRouteResponseInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRouteResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteResponseOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteResponseOutputResponse(modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeResponseId: \(String(describing: routeResponseId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

extension GetRouteResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct GetRouteResponseOutputResponse: Equatable {
    /// <p>Represents the model selection expression of a route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>Represents the response models of a route response.</p>
    public let responseModels: [String:String]?
    /// <p>Represents the response parameters of a route response.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>Represents the identifier of a route response.</p>
    public let routeResponseId: String?
    /// <p>Represents the route response key of a route response.</p>
    public let routeResponseKey: String?

    public init (
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeResponseId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct GetRouteResponseOutputResponseBody: Equatable {
    public let modelSelectionExpression: String?
    public let responseModels: [String:String]?
    public let responseParameters: [String:ParameterConstraints]?
    public let routeResponseId: String?
    public let routeResponseKey: String?
}

extension GetRouteResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension GetRouteResponsesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteResponsesInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), routeId: \(String(describing: routeId)))"}
}

extension GetRouteResponsesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRouteResponsesInputHeadersMiddleware: Middleware {
    public let id: String = "GetRouteResponsesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteResponsesInput>
    public typealias MOutput = OperationOutput<GetRouteResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteResponsesOutputError>
}

public struct GetRouteResponsesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRouteResponsesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRouteResponsesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRouteResponsesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRouteResponsesInput>
    public typealias MOutput = OperationOutput<GetRouteResponsesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRouteResponsesOutputError>
}

public struct GetRouteResponsesInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?
    /// <p>The route ID.</p>
    public let routeId: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil,
        routeId: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeId = routeId
    }
}

struct GetRouteResponsesInputBody: Equatable {
}

extension GetRouteResponsesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRouteResponsesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRouteResponsesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRouteResponsesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRouteResponsesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRouteResponsesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetRouteResponsesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRouteResponsesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRouteResponsesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [RouteResponse]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [RouteResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRouteResponsesOutputResponseBody: Equatable {
    public let items: [RouteResponse]?
    public let nextToken: String?
}

extension GetRouteResponsesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([RouteResponse?].self, forKey: .items)
        var itemsDecoded0:[RouteResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [RouteResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoutesInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetRoutesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "GetRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoutesInput>
    public typealias MOutput = OperationOutput<GetRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoutesOutputError>
}

public struct GetRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRoutesInput>
    public typealias MOutput = OperationOutput<GetRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRoutesOutputError>
}

public struct GetRoutesInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetRoutesInputBody: Equatable {
}

extension GetRoutesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoutesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRoutesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRoutesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRoutesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Route]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Route]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRoutesOutputResponseBody: Equatable {
    public let items: [Route]?
    public let nextToken: String?
}

extension GetRoutesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Route?].self, forKey: .items)
        var itemsDecoded0:[Route]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Route]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStageInput(apiId: \(String(describing: apiId)), stageName: \(String(describing: stageName)))"}
}

extension GetStageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStageInputHeadersMiddleware: Middleware {
    public let id: String = "GetStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStageInput>
    public typealias MOutput = OperationOutput<GetStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStageOutputError>
}

public struct GetStageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStageInput>
    public typealias MOutput = OperationOutput<GetStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStageOutputError>
}

public struct GetStageInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Equatable {
}

extension GetStageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStageOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), lastDeploymentStatusMessage: \(String(describing: lastDeploymentStatusMessage)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)), tags: \(String(describing: tags)))"}
}

extension GetStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = false
            self.autoDeploy = false
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct GetStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>Default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.</p>
    public let deploymentId: String?
    /// <p>The description of the stage.</p>
    public let description: String?
    /// <p>Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.</p>
    public let lastDeploymentStatusMessage: String?
    /// <p>The timestamp when the stage was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>Route settings for the stage, by routeKey.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiGatewayManaged: Bool = false,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        lastDeploymentStatusMessage: String? = nil,
        lastUpdatedDate: Date? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct GetStageOutputResponseBody: Equatable {
    public let accessLogSettings: AccessLogSettings?
    public let apiGatewayManaged: Bool
    public let autoDeploy: Bool
    public let clientCertificateId: String?
    public let createdDate: Date?
    public let defaultRouteSettings: RouteSettings?
    public let deploymentId: String?
    public let description: String?
    public let lastDeploymentStatusMessage: String?
    public let lastUpdatedDate: Date?
    public let routeSettings: [String:RouteSettings]?
    public let stageName: String?
    public let stageVariables: [String:String]?
    public let tags: [String:String]?
}

extension GetStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetStagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStagesInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetStagesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStagesInputHeadersMiddleware: Middleware {
    public let id: String = "GetStagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStagesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStagesInput>
    public typealias MOutput = OperationOutput<GetStagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStagesOutputError>
}

public struct GetStagesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStagesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStagesInput>
    public typealias MOutput = OperationOutput<GetStagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStagesOutputError>
}

public struct GetStagesInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetStagesInputBody: Equatable {
}

extension GetStagesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStagesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStagesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetStagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetStagesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Stage]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [Stage]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetStagesOutputResponseBody: Equatable {
    public let items: [Stage]?
    public let nextToken: String?
}

extension GetStagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Stage?].self, forKey: .items)
        var itemsDecoded0:[Stage]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Stage]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInput: Equatable {
    /// <p>The resource ARN for the tag.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Equatable {
}

extension GetTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsOutputResponse(tags: \(String(describing: tags)))"}
}

extension GetTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetTagsOutputResponse: Equatable {
    /// <p>Represents a collection of tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension GetTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinkInput(vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension GetVpcLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "GetVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinkInput>
    public typealias MOutput = OperationOutput<GetVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinkOutputError>
}

public struct GetVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinkInput>
    public typealias MOutput = OperationOutput<GetVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinkOutputError>
}

public struct GetVpcLinkInput: Equatable {
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?

    public init (
        vpcLinkId: String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Equatable {
}

extension GetVpcLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinkOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinkOutputResponse(createdDate: \(String(describing: createdDate)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), vpcLinkId: \(String(describing: vpcLinkId)), vpcLinkStatus: \(String(describing: vpcLinkStatus)), vpcLinkStatusMessage: \(String(describing: vpcLinkStatusMessage)), vpcLinkVersion: \(String(describing: vpcLinkVersion)))"}
}

extension GetVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct GetVpcLinkOutputResponse: Equatable {
    /// <p>The timestamp when the VPC link was created.</p>
    public let createdDate: Date?
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>A list of security group IDs for the VPC link.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs to include in the VPC link.</p>
    public let subnetIds: [String]?
    /// <p>Tags for the VPC link.</p>
    public let tags: [String:String]?
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?
    /// <p>The status of the VPC link.</p>
    public let vpcLinkStatus: VpcLinkStatus?
    /// <p>A message summarizing the cause of the status of the VPC link.</p>
    public let vpcLinkStatusMessage: String?
    /// <p>The version of the VPC link.</p>
    public let vpcLinkVersion: VpcLinkVersion?

    public init (
        createdDate: Date? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        vpcLinkId: String? = nil,
        vpcLinkStatus: VpcLinkStatus? = nil,
        vpcLinkStatusMessage: String? = nil,
        vpcLinkVersion: VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct GetVpcLinkOutputResponseBody: Equatable {
    public let createdDate: Date?
    public let name: String?
    public let securityGroupIds: [String]?
    public let subnetIds: [String]?
    public let tags: [String:String]?
    public let vpcLinkId: String?
    public let vpcLinkStatus: VpcLinkStatus?
    public let vpcLinkStatusMessage: String?
    public let vpcLinkVersion: VpcLinkVersion?
}

extension GetVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension GetVpcLinksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetVpcLinksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVpcLinksInputHeadersMiddleware: Middleware {
    public let id: String = "GetVpcLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinksInput>
    public typealias MOutput = OperationOutput<GetVpcLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinksOutputError>
}

public struct GetVpcLinksInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVpcLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVpcLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVpcLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVpcLinksInput>
    public typealias MOutput = OperationOutput<GetVpcLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVpcLinksOutputError>
}

public struct GetVpcLinksInput: Equatable {
    /// <p>The maximum number of elements to be returned for this resource.</p>
    public let maxResults: String?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        maxResults: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetVpcLinksInputBody: Equatable {
}

extension GetVpcLinksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVpcLinksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinksOutputError: Equatable {
    case badRequestException(BadRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVpcLinksOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension GetVpcLinksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVpcLinksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetVpcLinksOutputResponse: Equatable {
    /// <p>A collection of VPC links.</p>
    public let items: [VpcLink]?
    /// <p>The next page of elements from this collection. Not valid for the last element of the collection.</p>
    public let nextToken: String?

    public init (
        items: [VpcLink]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetVpcLinksOutputResponseBody: Equatable {
    public let items: [VpcLink]?
    public let nextToken: String?
}

extension GetVpcLinksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VpcLink?].self, forKey: .items)
        var itemsDecoded0:[VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ImportApiInputBodyMiddleware: Middleware {
    public let id: String = "ImportApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiInput>
    public typealias MOutput = OperationOutput<ImportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiOutputError>
}

extension ImportApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApiInput(basepath: \(String(describing: basepath)), body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)))"}
}

extension ImportApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

public struct ImportApiInputHeadersMiddleware: Middleware {
    public let id: String = "ImportApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiInput>
    public typealias MOutput = OperationOutput<ImportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiOutputError>
}

public struct ImportApiInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let failOnWarningsQueryItem = URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        if let basepath = input.operationInput.basepath {
            let basepathQueryItem = URLQueryItem(name: "basepath".urlPercentEncoding(), value: String(basepath).urlPercentEncoding())
            input.builder.withQueryItem(basepathQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportApiInput>
    public typealias MOutput = OperationOutput<ImportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportApiOutputError>
}

/// <p></p>
public struct ImportApiInput: Equatable {
    /// <p>Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html">Set the OpenAPI basePath Property</a>. Supported only for HTTP APIs.</p>
    public let basepath: String?
    /// <p>The OpenAPI definition. Supported only for HTTP APIs.</p>
    public let body: String?
    /// <p>Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.</p>
    public let failOnWarnings: Bool

    public init (
        basepath: String? = nil,
        body: String? = nil,
        failOnWarnings: Bool = false
    )
    {
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ImportApiInputBody: Equatable {
    public let body: String?
}

extension ImportApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportApiOutputResponse(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension ImportApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = false
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.disableSchemaValidation = false
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ImportApiOutputResponse: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportApiOutputResponseBody: Equatable {
    public let apiEndpoint: String?
    public let apiGatewayManaged: Bool
    public let apiId: String?
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let createdDate: Date?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let importInfo: [String]?
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let version: String?
    public let warnings: [String]?
}

extension ImportApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension Integration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationId = integrationId {
            try encodeContainer.encode(integrationId, forKey: .integrationId)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationResponseSelectionExpression = integrationResponseSelectionExpression {
            try encodeContainer.encode(integrationResponseSelectionExpression, forKey: .integrationResponseSelectionExpression)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension Integration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Integration(apiGatewayManaged: \(String(describing: apiGatewayManaged)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationId: \(String(describing: integrationId)), integrationMethod: \(String(describing: integrationMethod)), integrationResponseSelectionExpression: \(String(describing: integrationResponseSelectionExpression)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

/// <p>Represents an integration.</p>
public struct Integration: Equatable {
    /// <p>Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>Represents the description of an integration.</p>
    public let description: String?
    /// <p>Represents the identifier of an integration.</p>
    public let integrationId: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>The integration response selection expression for the integration. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions">Integration Response Selection Expressions</a>.</p>
    public let integrationResponseSelectionExpression: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///           , where
    ///             <replaceable>{location}</replaceable>
    ///            is querystring, path, or header; and
    ///             <replaceable>{name}</replaceable>
    ///            must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfig?

    public init (
        apiGatewayManaged: Bool = false,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationId: String? = nil,
        integrationMethod: String? = nil,
        integrationResponseSelectionExpression: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

extension IntegrationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseId = integrationResponseId {
            try encodeContainer.encode(integrationResponseId, forKey: .integrationResponseId)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension IntegrationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegrationResponse(contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationResponseId: \(String(describing: integrationResponseId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

/// <p>Represents an integration response.</p>
public struct IntegrationResponse: Equatable {
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expressions for the integration response.</p>
    public let templateSelectionExpression: String?

    public init (
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationResponseId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

/// <p>Represents an API method integration type.</p>
public enum IntegrationType {
    case aws
    case awsProxy
    case http
    case httpProxy
    case mock
    case sdkUnknown(String)
}

extension IntegrationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IntegrationType] {
        return [
            .aws,
            .awsProxy,
            .http,
            .httpProxy,
            .mock,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .awsProxy: return "AWS_PROXY"
        case .http: return "HTTP"
        case .httpProxy: return "HTTP_PROXY"
        case .mock: return "MOCK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
    }
}

extension JWTConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audience = "audience"
        case issuer = "issuer"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audience = audience {
            var audienceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audience)
            for __listof__string0 in audience {
                try audienceContainer.encode(__listof__string0)
            }
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .audience)
        var audienceDecoded0:[String]? = nil
        if let audienceContainer = audienceContainer {
            audienceDecoded0 = [String]()
            for string0 in audienceContainer {
                if let string0 = string0 {
                    audienceDecoded0?.append(string0)
                }
            }
        }
        audience = audienceDecoded0
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
    }
}

extension JWTConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JWTConfiguration(audience: \(String(describing: audience)), issuer: \(String(describing: issuer)))"}
}

/// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
public struct JWTConfiguration: Equatable {
    /// <p>A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See <a href="https://tools.ietf.org/html/rfc7519#section-4.1.3">RFC 7519</a>. Supported only for HTTP APIs.</p>
    public let audience: [String]?
    /// <p>The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.<replaceable>{region}</replaceable>.amazonaws.com/<replaceable>{userPoolId}</replaceable>
    ///                . Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let issuer: String?

    public init (
        audience: [String]? = nil,
        issuer: String? = nil
    )
    {
        self.audience = audience
        self.issuer = issuer
    }
}

/// <p>The logging level.</p>
public enum LoggingLevel {
    case error
    case info
    case off
    case sdkUnknown(String)
}

extension LoggingLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggingLevel] {
        return [
            .error,
            .info,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .info: return "INFO"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
    }
}

extension Model: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension Model: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Model(contentType: \(String(describing: contentType)), description: \(String(describing: description)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

/// <p>Represents a data model for an API. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html">Create Models and Mapping Templates for Request and Response Mappings</a>.</p>
public struct Model: Equatable {
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The model identifier.</p>
    public let modelId: String?
    /// <p>The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

extension MutualTlsAuthentication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
        case truststoreWarnings = "truststoreWarnings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for __listof__string0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension MutualTlsAuthentication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MutualTlsAuthentication(truststoreUri: \(String(describing: truststoreUri)), truststoreVersion: \(String(describing: truststoreVersion)), truststoreWarnings: \(String(describing: truststoreWarnings)))"}
}

public struct MutualTlsAuthentication: Equatable {
    /// <p>An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://<replaceable>bucket-name</replaceable>/<replaceable>key-name</replaceable>. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.</p>
    public let truststoreUri: String?
    /// <p>The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.</p>
    public let truststoreVersion: String?
    /// <p>A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.</p>
    public let truststoreWarnings: [String]?

    public init (
        truststoreUri: String? = nil,
        truststoreVersion: String? = nil,
        truststoreWarnings: [String]? = nil
    )
    {
        self.truststoreUri = truststoreUri
        self.truststoreVersion = truststoreVersion
        self.truststoreWarnings = truststoreWarnings
    }
}

extension MutualTlsAuthenticationInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension MutualTlsAuthenticationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MutualTlsAuthenticationInput(truststoreUri: \(String(describing: truststoreUri)), truststoreVersion: \(String(describing: truststoreVersion)))"}
}

public struct MutualTlsAuthenticationInput: Equatable {
    /// <p>An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://<replaceable>bucket-name</replaceable>/<replaceable>key-name</replaceable>. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.</p>
    public let truststoreUri: String?
    /// <p>The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.</p>
    public let truststoreVersion: String?

    public init (
        truststoreUri: String? = nil,
        truststoreVersion: String? = nil
    )
    {
        self.truststoreUri = truststoreUri
        self.truststoreVersion = truststoreVersion
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request was not found. See the message field for more information.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Describes the error encountered.</p>
    public var message: String?
    /// <p>The resource type.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ParameterConstraints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case `required` = "required"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredDecoded = try containerValues.decode(Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension ParameterConstraints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterConstraints(required: \(String(describing: `required`)))"}
}

/// <p>Validation constraints imposed on parameters of a request (path, query string, headers).</p>
public struct ParameterConstraints: Equatable {
    /// <p>Whether or not the parameter is required.</p>
    public let `required`: Bool

    public init (
        `required`: Bool = false
    )
    {
        self.`required` = `required`
    }
}

/// <p>Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.</p>
public enum PassthroughBehavior {
    case never
    case whenNoMatch
    case whenNoTemplates
    case sdkUnknown(String)
}

extension PassthroughBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PassthroughBehavior] {
        return [
            .never,
            .whenNoMatch,
            .whenNoTemplates,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .never: return "NEVER"
        case .whenNoMatch: return "WHEN_NO_MATCH"
        case .whenNoTemplates: return "WHEN_NO_TEMPLATES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PassthroughBehavior(rawValue: rawValue) ?? PassthroughBehavior.sdkUnknown(rawValue)
    }
}

/// Represents a protocol type.
public enum ProtocolType {
    case http
    case websocket
    case sdkUnknown(String)
}

extension ProtocolType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProtocolType] {
        return [
            .http,
            .websocket,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .websocket: return "WEBSOCKET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProtocolType(rawValue: rawValue) ?? ProtocolType.sdkUnknown(rawValue)
    }
}

public struct ReimportApiInputBodyMiddleware: Middleware {
    public let id: String = "ReimportApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReimportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ReimportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReimportApiInput>
    public typealias MOutput = OperationOutput<ReimportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReimportApiOutputError>
}

extension ReimportApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReimportApiInput(apiId: \(String(describing: apiId)), basepath: \(String(describing: basepath)), body: \(String(describing: body)), failOnWarnings: \(String(describing: failOnWarnings)))"}
}

extension ReimportApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

public struct ReimportApiInputHeadersMiddleware: Middleware {
    public let id: String = "ReimportApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReimportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ReimportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReimportApiInput>
    public typealias MOutput = OperationOutput<ReimportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReimportApiOutputError>
}

public struct ReimportApiInputQueryItemMiddleware: Middleware {
    public let id: String = "ReimportApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReimportApiInput>,
                  next: H) -> Swift.Result<OperationOutput<ReimportApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let failOnWarningsQueryItem = URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: String(input.operationInput.failOnWarnings).urlPercentEncoding())
        input.builder.withQueryItem(failOnWarningsQueryItem)
        if let basepath = input.operationInput.basepath {
            let basepathQueryItem = URLQueryItem(name: "basepath".urlPercentEncoding(), value: String(basepath).urlPercentEncoding())
            input.builder.withQueryItem(basepathQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReimportApiInput>
    public typealias MOutput = OperationOutput<ReimportApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReimportApiOutputError>
}

/// <p></p>
public struct ReimportApiInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html">Set the OpenAPI basePath Property</a>. Supported only for HTTP APIs.</p>
    public let basepath: String?
    /// <p>The OpenAPI definition. Supported only for HTTP APIs.</p>
    public let body: String?
    /// <p>Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.</p>
    public let failOnWarnings: Bool

    public init (
        apiId: String? = nil,
        basepath: String? = nil,
        body: String? = nil,
        failOnWarnings: Bool = false
    )
    {
        self.apiId = apiId
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ReimportApiInputBody: Equatable {
    public let body: String?
}

extension ReimportApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ReimportApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReimportApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReimportApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReimportApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReimportApiOutputResponse(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension ReimportApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReimportApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = false
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.disableSchemaValidation = false
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ReimportApiOutputResponse: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ReimportApiOutputResponseBody: Equatable {
    public let apiEndpoint: String?
    public let apiGatewayManaged: Bool
    public let apiId: String?
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let createdDate: Date?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let importInfo: [String]?
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let version: String?
    public let warnings: [String]?
}

extension ReimportApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ResetAuthorizersCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetAuthorizersCacheInput(apiId: \(String(describing: apiId)), stageName: \(String(describing: stageName)))"}
}

extension ResetAuthorizersCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ResetAuthorizersCacheInputHeadersMiddleware: Middleware {
    public let id: String = "ResetAuthorizersCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetAuthorizersCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetAuthorizersCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetAuthorizersCacheInput>
    public typealias MOutput = OperationOutput<ResetAuthorizersCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetAuthorizersCacheOutputError>
}

public struct ResetAuthorizersCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetAuthorizersCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetAuthorizersCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetAuthorizersCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetAuthorizersCacheInput>
    public typealias MOutput = OperationOutput<ResetAuthorizersCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetAuthorizersCacheOutputError>
}

public struct ResetAuthorizersCacheInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.</p>
    public let stageName: String?

    public init (
        apiId: String? = nil,
        stageName: String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct ResetAuthorizersCacheInputBody: Equatable {
}

extension ResetAuthorizersCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResetAuthorizersCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAuthorizersCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetAuthorizersCacheOutputError: Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAuthorizersCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetAuthorizersCacheOutputResponse()"}
}

extension ResetAuthorizersCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResetAuthorizersCacheOutputResponse: Equatable {

    public init() {}
}

struct ResetAuthorizersCacheOutputResponseBody: Equatable {
}

extension ResetAuthorizersCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Route: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeId = routeId {
            try encodeContainer.encode(routeId, forKey: .routeId)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension Route: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Route(apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeId: \(String(describing: routeId)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

/// <p>Represents a route.</p>
public struct Route: Equatable {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiGatewayManaged: Bool = false,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

extension RouteResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeResponseId = routeResponseId {
            try encodeContainer.encode(routeResponseId, forKey: .routeResponseId)
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension RouteResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteResponse(modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeResponseId: \(String(describing: routeResponseId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

/// <p>Represents a route response.</p>
public struct RouteResponse: Equatable {
    /// <p>Represents the model selection expression of a route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>Represents the response models of a route response.</p>
    public let responseModels: [String:String]?
    /// <p>Represents the response parameters of a route response.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>Represents the identifier of a route response.</p>
    public let routeResponseId: String?
    /// <p>Represents the route response key of a route response.</p>
    public let routeResponseKey: String?

    public init (
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeResponseId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

extension RouteSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataTraceEnabled = "dataTraceEnabled"
        case detailedMetricsEnabled = "detailedMetricsEnabled"
        case loggingLevel = "loggingLevel"
        case throttlingBurstLimit = "throttlingBurstLimit"
        case throttlingRateLimit = "throttlingRateLimit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if detailedMetricsEnabled != false {
            try encodeContainer.encode(detailedMetricsEnabled, forKey: .detailedMetricsEnabled)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel.rawValue, forKey: .loggingLevel)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTraceEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let detailedMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .detailedMetricsEnabled)
        detailedMetricsEnabled = detailedMetricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
    }
}

extension RouteSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteSettings(dataTraceEnabled: \(String(describing: dataTraceEnabled)), detailedMetricsEnabled: \(String(describing: detailedMetricsEnabled)), loggingLevel: \(String(describing: loggingLevel)), throttlingBurstLimit: \(String(describing: throttlingBurstLimit)), throttlingRateLimit: \(String(describing: throttlingRateLimit)))"}
}

/// <p>Represents a collection of route settings.</p>
public struct RouteSettings: Equatable {
    /// <p>Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.</p>
    public let dataTraceEnabled: Bool
    /// <p>Specifies whether detailed metrics are enabled.</p>
    public let detailedMetricsEnabled: Bool
    /// <p>Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.</p>
    public let loggingLevel: LoggingLevel?
    /// <p>Specifies the throttling burst limit.</p>
    public let throttlingBurstLimit: Int
    /// <p>Specifies the throttling rate limit.</p>
    public let throttlingRateLimit: Double

    public init (
        dataTraceEnabled: Bool = false,
        detailedMetricsEnabled: Bool = false,
        loggingLevel: LoggingLevel? = nil,
        throttlingBurstLimit: Int = 0,
        throttlingRateLimit: Double = 0.0
    )
    {
        self.dataTraceEnabled = dataTraceEnabled
        self.detailedMetricsEnabled = detailedMetricsEnabled
        self.loggingLevel = loggingLevel
        self.throttlingBurstLimit = throttlingBurstLimit
        self.throttlingRateLimit = throttlingRateLimit
    }
}

/// <p>The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.</p>
public enum SecurityPolicy {
    case tls10
    case tls12
    case sdkUnknown(String)
}

extension SecurityPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SecurityPolicy] {
        return [
            .tls10,
            .tls12,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .tls10: return "TLS_1_0"
        case .tls12: return "TLS_1_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
    }
}

extension Stage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if autoDeploy != false {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastDeploymentStatusMessage = lastDeploymentStatusMessage {
            try encodeContainer.encode(lastDeploymentStatusMessage, forKey: .lastDeploymentStatusMessage)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Stage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stage(accessLogSettings: \(String(describing: accessLogSettings)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), lastDeploymentStatusMessage: \(String(describing: lastDeploymentStatusMessage)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)), tags: \(String(describing: tags)))"}
}

/// <p>Represents an API stage.</p>
public struct Stage: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>Default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.</p>
    public let deploymentId: String?
    /// <p>The description of the stage.</p>
    public let description: String?
    /// <p>Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.</p>
    public let lastDeploymentStatusMessage: String?
    /// <p>The timestamp when the stage was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>Route settings for the stage, by routeKey.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiGatewayManaged: Bool = false,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        lastDeploymentStatusMessage: String? = nil,
        lastUpdatedDate: Date? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>Creates a new Tag resource to represent a tag.</p>
public struct TagResourceInput: Equatable {
    /// <p>The resource ARN for the tag.</p>
    public let resourceArn: String?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TlsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension TlsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsConfig(serverNameToVerify: \(String(describing: serverNameToVerify)))"}
}

/// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
public struct TlsConfig: Equatable {
    /// <p>If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.</p>
    public let serverNameToVerify: String?

    public init (
        serverNameToVerify: String? = nil
    )
    {
        self.serverNameToVerify = serverNameToVerify
    }
}

extension TlsConfigInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension TlsConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsConfigInput(serverNameToVerify: \(String(describing: serverNameToVerify)))"}
}

/// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
public struct TlsConfigInput: Equatable {
    /// <p>If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.</p>
    public let serverNameToVerify: String?

    public init (
        serverNameToVerify: String? = nil
    )
    {
        self.serverNameToVerify = serverNameToVerify
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(limitType: \(String(describing: limitType)), message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limitType = output.limitType
            self.message = output.message
        } else {
            self.limitType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit has been exceeded. See the accompanying error message for details.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The limit type.</p>
    public var limitType: String?
    /// <p>Describes the error encountered.</p>
    public var message: String?

    public init (
        limitType: String? = nil,
        message: String? = nil
    )
    {
        self.limitType = limitType
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let limitType: String?
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The resource ARN for the tag.</p>
    public let resourceArn: String?
    /// <p>The Tag keys to delete</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApiInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiInput>
    public typealias MOutput = OperationOutput<UpdateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiOutputError>
}

extension UpdateApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiInput(apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), name: \(String(describing: name)), routeKey: \(String(describing: routeKey)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), target: \(String(describing: target)), version: \(String(describing: version)))"}
}

extension UpdateApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if disableSchemaValidation != false {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct UpdateApiInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiInput>
    public typealias MOutput = OperationOutput<UpdateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiOutputError>
}

public struct UpdateApiInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiInput>
    public typealias MOutput = OperationOutput<UpdateApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiOutputError>
}

/// <p>Updates an Api.</p>
public struct UpdateApiInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.</p>
    public let credentialsArn: String?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.</p>
    public let routeKey: String?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.</p>
    public let target: String?
    /// <p>A version identifier for the API.</p>
    public let version: String?

    public init (
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        name: String? = nil,
        routeKey: String? = nil,
        routeSelectionExpression: String? = nil,
        target: String? = nil,
        version: String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.target = target
        self.version = version
    }
}

struct UpdateApiInputBody: Equatable {
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let credentialsArn: String?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let name: String?
    public let routeKey: String?
    public let routeSelectionExpression: String?
    public let target: String?
    public let version: String?
}

extension UpdateApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct UpdateApiMappingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiMappingInput>
    public typealias MOutput = OperationOutput<UpdateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiMappingOutputError>
}

extension UpdateApiMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiMappingInput(apiId: \(String(describing: apiId)), apiMappingId: \(String(describing: apiMappingId)), apiMappingKey: \(String(describing: apiMappingKey)), domainName: \(String(describing: domainName)), stage: \(String(describing: stage)))"}
}

extension UpdateApiMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

public struct UpdateApiMappingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiMappingInput>
    public typealias MOutput = OperationOutput<UpdateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiMappingOutputError>
}

public struct UpdateApiMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiMappingInput>
    public typealias MOutput = OperationOutput<UpdateApiMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiMappingOutputError>
}

/// <p>Updates an ApiMapping.</p>
public struct UpdateApiMappingInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The API mapping key.</p>
    public let apiMappingKey: String?
    /// <p>The domain name.</p>
    public let domainName: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingId: String? = nil,
        apiMappingKey: String? = nil,
        domainName: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct UpdateApiMappingInputBody: Equatable {
    public let apiId: String?
    public let apiMappingKey: String?
    public let stage: String?
}

extension UpdateApiMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateApiMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiMappingOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiMappingOutputResponse(apiId: \(String(describing: apiId)), apiMappingId: \(String(describing: apiMappingId)), apiMappingKey: \(String(describing: apiMappingKey)), stage: \(String(describing: stage)))"}
}

extension UpdateApiMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct UpdateApiMappingOutputResponse: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The API mapping identifier.</p>
    public let apiMappingId: String?
    /// <p>The API mapping key.</p>
    public let apiMappingKey: String?
    /// <p>The API stage.</p>
    public let stage: String?

    public init (
        apiId: String? = nil,
        apiMappingId: String? = nil,
        apiMappingKey: String? = nil,
        stage: String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct UpdateApiMappingOutputResponseBody: Equatable {
    public let apiId: String?
    public let apiMappingId: String?
    public let apiMappingKey: String?
    public let stage: String?
}

extension UpdateApiMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiOutputResponse(apiEndpoint: \(String(describing: apiEndpoint)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiId: \(String(describing: apiId)), apiKeySelectionExpression: \(String(describing: apiKeySelectionExpression)), corsConfiguration: \(String(describing: corsConfiguration)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), disableExecuteApiEndpoint: \(String(describing: disableExecuteApiEndpoint)), disableSchemaValidation: \(String(describing: disableSchemaValidation)), importInfo: \(String(describing: importInfo)), name: \(String(describing: name)), protocolType: \(String(describing: protocolType)), routeSelectionExpression: \(String(describing: routeSelectionExpression)), tags: \(String(describing: tags)), version: \(String(describing: version)), warnings: \(String(describing: warnings)))"}
}

extension UpdateApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = false
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.disableSchemaValidation = false
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct UpdateApiOutputResponse: Equatable {
    /// <p>The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.</p>
    public let apiEndpoint: String?
    /// <p>Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>An API key selection expression. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions">API Key Selection Expressions</a>.</p>
    public let apiKeySelectionExpression: String?
    /// <p>A CORS configuration. Supported only for HTTP APIs.</p>
    public let corsConfiguration: Cors?
    /// <p>The timestamp when the API was created.</p>
    public let createdDate: Date?
    /// <p>The description of the API.</p>
    public let description: String?
    /// <p>Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.</p>
    public let disableExecuteApiEndpoint: Bool
    /// <p>Avoid validating models when creating a deployment. Supported only for WebSocket APIs.</p>
    public let disableSchemaValidation: Bool
    /// <p>The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.</p>
    public let importInfo: [String]?
    /// <p>The name of the API.</p>
    public let name: String?
    /// <p>The API protocol.</p>
    public let protocolType: ProtocolType?
    /// <p>The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.</p>
    public let routeSelectionExpression: String?
    /// <p>A collection of tags associated with the API.</p>
    public let tags: [String:String]?
    /// <p>A version identifier for the API.</p>
    public let version: String?
    /// <p>The warning messages reported when failonwarnings is turned on during API import.</p>
    public let warnings: [String]?

    public init (
        apiEndpoint: String? = nil,
        apiGatewayManaged: Bool = false,
        apiId: String? = nil,
        apiKeySelectionExpression: String? = nil,
        corsConfiguration: Cors? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        disableExecuteApiEndpoint: Bool = false,
        disableSchemaValidation: Bool = false,
        importInfo: [String]? = nil,
        name: String? = nil,
        protocolType: ProtocolType? = nil,
        routeSelectionExpression: String? = nil,
        tags: [String:String]? = nil,
        version: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateApiOutputResponseBody: Equatable {
    public let apiEndpoint: String?
    public let apiGatewayManaged: Bool
    public let apiId: String?
    public let apiKeySelectionExpression: String?
    public let corsConfiguration: Cors?
    public let createdDate: Date?
    public let description: String?
    public let disableSchemaValidation: Bool
    public let disableExecuteApiEndpoint: Bool
    public let importInfo: [String]?
    public let name: String?
    public let protocolType: ProtocolType?
    public let routeSelectionExpression: String?
    public let tags: [String:String]?
    public let version: String?
    public let warnings: [String]?
}

extension UpdateApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importInfo)
        var importInfoDecoded0:[String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct UpdateAuthorizerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

extension UpdateAuthorizerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerInput(apiId: \(String(describing: apiId)), authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerId: \(String(describing: authorizerId)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

extension UpdateAuthorizerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if authorizerResultTtlInSeconds != 0 {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if enableSimpleResponses != false {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for identitysourcelist0 in identitySource {
                try identitySourceContainer.encode(identitysourcelist0)
            }
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAuthorizerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

public struct UpdateAuthorizerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuthorizerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthorizerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthorizerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthorizerInput>
    public typealias MOutput = OperationOutput<UpdateAuthorizerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthorizerOutputError>
}

/// <p>Updates an Authorizer.</p>
public struct UpdateAuthorizerInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.</p>
    public let authorizerCredentialsArn: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>This parameter is not used.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        apiId: String? = nil,
        authorizerCredentialsArn: String? = nil,
        authorizerId: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerInputBody: Equatable {
    public let authorizerCredentialsArn: String?
    public let authorizerPayloadFormatVersion: String?
    public let authorizerResultTtlInSeconds: Int
    public let authorizerType: AuthorizerType?
    public let authorizerUri: String?
    public let enableSimpleResponses: Bool
    public let identitySource: [String]?
    public let identityValidationExpression: String?
    public let jwtConfiguration: JWTConfiguration?
    public let name: String?
}

extension UpdateAuthorizerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAuthorizerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthorizerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthorizerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthorizerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthorizerOutputResponse(authorizerCredentialsArn: \(String(describing: authorizerCredentialsArn)), authorizerId: \(String(describing: authorizerId)), authorizerPayloadFormatVersion: \(String(describing: authorizerPayloadFormatVersion)), authorizerResultTtlInSeconds: \(String(describing: authorizerResultTtlInSeconds)), authorizerType: \(String(describing: authorizerType)), authorizerUri: \(String(describing: authorizerUri)), enableSimpleResponses: \(String(describing: enableSimpleResponses)), identitySource: \(String(describing: identitySource)), identityValidationExpression: \(String(describing: identityValidationExpression)), jwtConfiguration: \(String(describing: jwtConfiguration)), name: \(String(describing: name)))"}
}

extension UpdateAuthorizerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = 0
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = false
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct UpdateAuthorizerOutputResponse: Equatable {
    /// <p>Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.</p>
    public let authorizerCredentialsArn: String?
    /// <p>The authorizer identifier.</p>
    public let authorizerId: String?
    /// <p>Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p>
    public let authorizerPayloadFormatVersion: String?
    /// <p>The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.</p>
    public let authorizerResultTtlInSeconds: Int
    /// <p>The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).</p>
    public let authorizerType: AuthorizerType?
    /// <p>The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:<replaceable>{account_id}</replaceable>:function:<replaceable>{lambda_function_name}</replaceable>/invocations. In general, the URI has this form: arn:aws:apigateway:<replaceable>{region}</replaceable>:lambda:path/<replaceable>{service_api}</replaceable>
    ///                , where <replaceable></replaceable>{region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.</p>
    public let authorizerUri: String?
    /// <p>Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a></p>
    public let enableSimpleResponses: Bool
    /// <p>The identity source for which authorization is requested.</p> <p>For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html">Working with AWS Lambda authorizers for HTTP APIs</a>.</p> <p>For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.</p>
    public let identitySource: [String]?
    /// <p>The validation expression does not apply to the REQUEST authorizer.</p>
    public let identityValidationExpression: String?
    /// <p>Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.</p>
    public let jwtConfiguration: JWTConfiguration?
    /// <p>The name of the authorizer.</p>
    public let name: String?

    public init (
        authorizerCredentialsArn: String? = nil,
        authorizerId: String? = nil,
        authorizerPayloadFormatVersion: String? = nil,
        authorizerResultTtlInSeconds: Int = 0,
        authorizerType: AuthorizerType? = nil,
        authorizerUri: String? = nil,
        enableSimpleResponses: Bool = false,
        identitySource: [String]? = nil,
        identityValidationExpression: String? = nil,
        jwtConfiguration: JWTConfiguration? = nil,
        name: String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerOutputResponseBody: Equatable {
    public let authorizerCredentialsArn: String?
    public let authorizerId: String?
    public let authorizerPayloadFormatVersion: String?
    public let authorizerResultTtlInSeconds: Int
    public let authorizerType: AuthorizerType?
    public let authorizerUri: String?
    public let enableSimpleResponses: Bool
    public let identitySource: [String]?
    public let identityValidationExpression: String?
    public let jwtConfiguration: JWTConfiguration?
    public let name: String?
}

extension UpdateAuthorizerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decode(Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decode(Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

extension UpdateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentInput(apiId: \(String(describing: apiId)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)))"}
}

extension UpdateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

public struct UpdateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentOutputError>
}

/// <p>Updates a Deployment.</p>
public struct UpdateDeploymentInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The deployment ID.</p>
    public let deploymentId: String?
    /// <p>The description for the deployment resource.</p>
    public let description: String?

    public init (
        apiId: String? = nil,
        deploymentId: String? = nil,
        description: String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
        self.description = description
    }
}

struct UpdateDeploymentInputBody: Equatable {
    public let description: String?
}

extension UpdateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentOutputResponse(autoDeployed: \(String(describing: autoDeployed)), createdDate: \(String(describing: createdDate)), deploymentId: \(String(describing: deploymentId)), deploymentStatus: \(String(describing: deploymentStatus)), deploymentStatusMessage: \(String(describing: deploymentStatusMessage)), description: \(String(describing: description)))"}
}

extension UpdateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = false
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct UpdateDeploymentOutputResponse: Equatable {
    /// <p>Specifies whether a deployment was automatically released.</p>
    public let autoDeployed: Bool
    /// <p>The date and time when the Deployment resource was created.</p>
    public let createdDate: Date?
    /// <p>The identifier for the deployment.</p>
    public let deploymentId: String?
    /// <p>The status of the deployment: PENDING, FAILED, or SUCCEEDED.</p>
    public let deploymentStatus: DeploymentStatus?
    /// <p>May contain additional feedback on the status of an API deployment.</p>
    public let deploymentStatusMessage: String?
    /// <p>The description for the deployment.</p>
    public let description: String?

    public init (
        autoDeployed: Bool = false,
        createdDate: Date? = nil,
        deploymentId: String? = nil,
        deploymentStatus: DeploymentStatus? = nil,
        deploymentStatusMessage: String? = nil,
        description: String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct UpdateDeploymentOutputResponseBody: Equatable {
    public let autoDeployed: Bool
    public let createdDate: Date?
    public let deploymentId: String?
    public let deploymentStatus: DeploymentStatus?
    public let deploymentStatusMessage: String?
    public let description: String?
}

extension UpdateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decode(Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateDomainNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

extension UpdateDomainNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameInput(domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)))"}
}

extension UpdateDomainNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfigurations0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfigurations0)
            }
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
    }
}

public struct UpdateDomainNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

public struct UpdateDomainNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainNameInput>
    public typealias MOutput = OperationOutput<UpdateDomainNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainNameOutputError>
}

/// <p>Updates a DomainName.</p>
public struct UpdateDomainNameInput: Equatable {
    /// <p>The domain name.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?

    public init (
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthenticationInput? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
    }
}

struct UpdateDomainNameInputBody: Equatable {
    public let domainNameConfigurations: [DomainNameConfiguration]?
    public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
}

extension UpdateDomainNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension UpdateDomainNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainNameOutputResponse(apiMappingSelectionExpression: \(String(describing: apiMappingSelectionExpression)), domainName: \(String(describing: domainName)), domainNameConfigurations: \(String(describing: domainNameConfigurations)), mutualTlsAuthentication: \(String(describing: mutualTlsAuthentication)), tags: \(String(describing: tags)))"}
}

extension UpdateDomainNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct UpdateDomainNameOutputResponse: Equatable {
    /// <p>The API mapping selection expression.</p>
    public let apiMappingSelectionExpression: String?
    /// <p>The name of the DomainName resource.</p>
    public let domainName: String?
    /// <p>The domain name configurations.</p>
    public let domainNameConfigurations: [DomainNameConfiguration]?
    /// <p>The mutual TLS authentication configuration for a custom domain name.</p>
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    /// <p>The collection of tags associated with a domain name.</p>
    public let tags: [String:String]?

    public init (
        apiMappingSelectionExpression: String? = nil,
        domainName: String? = nil,
        domainNameConfigurations: [DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: MutualTlsAuthentication? = nil,
        tags: [String:String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct UpdateDomainNameOutputResponseBody: Equatable {
    public let apiMappingSelectionExpression: String?
    public let domainName: String?
    public let domainNameConfigurations: [DomainNameConfiguration]?
    public let mutualTlsAuthentication: MutualTlsAuthentication?
    public let tags: [String:String]?
}

extension UpdateDomainNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateIntegrationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

extension UpdateIntegrationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationInput(apiId: \(String(describing: apiId)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationId: \(String(describing: integrationId)), integrationMethod: \(String(describing: integrationMethod)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

extension UpdateIntegrationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, integrationparameters0) in requestParameters {
                try requestParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestTemplates)
            for (dictKey0, templatemap0) in requestTemplates {
                try requestTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, responseparameters0) in responseParameters {
                try responseParametersContainer.encode(responseparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

public struct UpdateIntegrationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

public struct UpdateIntegrationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIntegrationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationOutputError>
}

/// <p>Updates an Integration.</p>
public struct UpdateIntegrationInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>The description of the integration</p>
    public let description: String?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///           , where
    ///             <replaceable>{location}</replaceable>
    ///            is querystring, path, or header; and
    ///             <replaceable>{name}</replaceable>
    ///            must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt; where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfigInput?

    public init (
        apiId: String? = nil,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationId: String? = nil,
        integrationMethod: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationInputBody: Equatable {
    public let connectionId: String?
    public let connectionType: ConnectionType?
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let credentialsArn: String?
    public let description: String?
    public let integrationMethod: String?
    public let integrationSubtype: String?
    public let integrationType: IntegrationType?
    public let integrationUri: String?
    public let passthroughBehavior: PassthroughBehavior?
    public let payloadFormatVersion: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let responseParameters: [String:[String:String]]?
    public let templateSelectionExpression: String?
    public let timeoutInMillis: Int
    public let tlsConfig: TlsConfigInput?
}

extension UpdateIntegrationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateIntegrationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), connectionId: \(String(describing: connectionId)), connectionType: \(String(describing: connectionType)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), credentialsArn: \(String(describing: credentialsArn)), description: \(String(describing: description)), integrationId: \(String(describing: integrationId)), integrationMethod: \(String(describing: integrationMethod)), integrationResponseSelectionExpression: \(String(describing: integrationResponseSelectionExpression)), integrationSubtype: \(String(describing: integrationSubtype)), integrationType: \(String(describing: integrationType)), integrationUri: \(String(describing: integrationUri)), passthroughBehavior: \(String(describing: passthroughBehavior)), payloadFormatVersion: \(String(describing: payloadFormatVersion)), requestParameters: \(String(describing: requestParameters)), requestTemplates: \(String(describing: requestTemplates)), responseParameters: \(String(describing: responseParameters)), templateSelectionExpression: \(String(describing: templateSelectionExpression)), timeoutInMillis: \(String(describing: timeoutInMillis)), tlsConfig: \(String(describing: tlsConfig)))"}
}

extension UpdateIntegrationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = false
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
        }
    }
}

public struct UpdateIntegrationOutputResponse: Equatable {
    /// <p>Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.</p>
    public let apiGatewayManaged: Bool
    /// <p>The ID of the VPC link for a private integration. Supported only for HTTP APIs.</p>
    public let connectionId: String?
    /// <p>The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.</p>
    public let connectionType: ConnectionType?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.</p>
    public let credentialsArn: String?
    /// <p>Represents the description of an integration.</p>
    public let description: String?
    /// <p>Represents the identifier of an integration.</p>
    public let integrationId: String?
    /// <p>Specifies the integration's HTTP method type.</p>
    public let integrationMethod: String?
    /// <p>The integration response selection expression for the integration. Supported only for WebSocket APIs. See <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions">Integration Response Selection Expressions</a>.</p>
    public let integrationResponseSelectionExpression: String?
    /// <p>Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html">Integration subtype reference</a>.</p>
    public let integrationSubtype: String?
    /// <p>The integration type of an integration. One of the following:</p> <p>AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs.</p> <p>AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration.</p> <p>HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs.</p> <p>HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration.</p> <p>MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.</p>
    public let integrationType: IntegrationType?
    /// <p>For a Lambda integration, specify the URI of a Lambda function.</p> <p>For an HTTP integration, specify a fully-qualified URL.</p> <p>For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a>. For private integrations, all resources must be owned by the same AWS account.</p>
    public let integrationUri: String?
    /// <p>Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs.</p> <p>WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation.</p> <p>NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response.</p> <p>WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.</p>
    public let passthroughBehavior: PassthroughBehavior?
    /// <p>Specifies the format of the payload sent to an integration. Required for HTTP APIs.</p>
    public let payloadFormatVersion: String?
    /// <p>For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.<replaceable>{location}</replaceable>.<replaceable>{name}</replaceable>
    ///           , where
    ///             <replaceable>{location}</replaceable>
    ///            is querystring, path, or header; and
    ///             <replaceable>{name}</replaceable>
    ///            must be a valid and unique method request parameter name.</p> <p>For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html">Working with AWS service integrations for HTTP APIs</a>.</p> <p>For HTTP API itegrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let requestParameters: [String:String]?
    /// <p>Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.</p>
    public let requestTemplates: [String:String]?
    /// <p>Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html">Transforming API requests and responses</a>.</p>
    public let responseParameters: [String:[String:String]]?
    /// <p>The template selection expression for the integration. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?
    /// <p>Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.</p>
    public let timeoutInMillis: Int
    /// <p>The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.</p>
    public let tlsConfig: TlsConfig?

    public init (
        apiGatewayManaged: Bool = false,
        connectionId: String? = nil,
        connectionType: ConnectionType? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        credentialsArn: String? = nil,
        description: String? = nil,
        integrationId: String? = nil,
        integrationMethod: String? = nil,
        integrationResponseSelectionExpression: String? = nil,
        integrationSubtype: String? = nil,
        integrationType: IntegrationType? = nil,
        integrationUri: String? = nil,
        passthroughBehavior: PassthroughBehavior? = nil,
        payloadFormatVersion: String? = nil,
        requestParameters: [String:String]? = nil,
        requestTemplates: [String:String]? = nil,
        responseParameters: [String:[String:String]]? = nil,
        templateSelectionExpression: String? = nil,
        timeoutInMillis: Int = 0,
        tlsConfig: TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let connectionId: String?
    public let connectionType: ConnectionType?
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let credentialsArn: String?
    public let description: String?
    public let integrationId: String?
    public let integrationMethod: String?
    public let integrationResponseSelectionExpression: String?
    public let integrationSubtype: String?
    public let integrationType: IntegrationType?
    public let integrationUri: String?
    public let passthroughBehavior: PassthroughBehavior?
    public let payloadFormatVersion: String?
    public let requestParameters: [String:String]?
    public let requestTemplates: [String:String]?
    public let responseParameters: [String:[String:String]]?
    public let templateSelectionExpression: String?
    public let timeoutInMillis: Int
    public let tlsConfig: TlsConfig?
}

extension UpdateIntegrationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [String:String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:[String:String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:[String:String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [String: String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [String: String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

public struct UpdateIntegrationResponseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

extension UpdateIntegrationResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationResponseInput(apiId: \(String(describing: apiId)), contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationId: \(String(describing: integrationId)), integrationResponseId: \(String(describing: integrationResponseId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

extension UpdateIntegrationResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, integrationparameters0) in responseParameters {
                try responseParametersContainer.encode(integrationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseTemplates)
            for (dictKey0, templatemap0) in responseTemplates {
                try responseTemplatesContainer.encode(templatemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

public struct UpdateIntegrationResponseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

public struct UpdateIntegrationResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIntegrationResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIntegrationResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIntegrationResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIntegrationResponseInput>
    public typealias MOutput = OperationOutput<UpdateIntegrationResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIntegrationResponseOutputError>
}

/// <p>Updates an IntegrationResponses.</p>
public struct UpdateIntegrationResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration ID.</p>
    public let integrationId: String?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.<replaceable>{name}</replaceable>
    ///                , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.<replaceable>{name}</replaceable>
    ///                 or integration.response.body.<replaceable>{JSON-expression}</replaceable>
    ///                , where
    ///                   <replaceable>{name}</replaceable>
    ///                 is a valid and unique response header name and
    ///                   <replaceable>{JSON-expression}</replaceable>
    ///                 is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expression for the integration response. Supported only for WebSocket APIs.</p>
    public let templateSelectionExpression: String?

    public init (
        apiId: String? = nil,
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationId: String? = nil,
        integrationResponseId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseInputBody: Equatable {
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let integrationResponseKey: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let templateSelectionExpression: String?
}

extension UpdateIntegrationResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension UpdateIntegrationResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIntegrationResponseOutputResponse(contentHandlingStrategy: \(String(describing: contentHandlingStrategy)), integrationResponseId: \(String(describing: integrationResponseId)), integrationResponseKey: \(String(describing: integrationResponseKey)), responseParameters: \(String(describing: responseParameters)), responseTemplates: \(String(describing: responseTemplates)), templateSelectionExpression: \(String(describing: templateSelectionExpression)))"}
}

extension UpdateIntegrationResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct UpdateIntegrationResponseOutputResponse: Equatable {
    /// <p>Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:</p> <p>CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.</p> <p>CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.</p> <p>If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.</p>
    public let contentHandlingStrategy: ContentHandlingStrategy?
    /// <p>The integration response ID.</p>
    public let integrationResponseId: String?
    /// <p>The integration response key.</p>
    public let integrationResponseKey: String?
    /// <p>A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.</p>
    public let responseParameters: [String:String]?
    /// <p>The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.</p>
    public let responseTemplates: [String:String]?
    /// <p>The template selection expressions for the integration response.</p>
    public let templateSelectionExpression: String?

    public init (
        contentHandlingStrategy: ContentHandlingStrategy? = nil,
        integrationResponseId: String? = nil,
        integrationResponseKey: String? = nil,
        responseParameters: [String:String]? = nil,
        responseTemplates: [String:String]? = nil,
        templateSelectionExpression: String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseOutputResponseBody: Equatable {
    public let contentHandlingStrategy: ContentHandlingStrategy?
    public let integrationResponseId: String?
    public let integrationResponseKey: String?
    public let responseParameters: [String:String]?
    public let responseTemplates: [String:String]?
    public let templateSelectionExpression: String?
}

extension UpdateIntegrationResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [String:String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

public struct UpdateModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

extension UpdateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelInput(apiId: \(String(describing: apiId)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension UpdateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

public struct UpdateModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

public struct UpdateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateModelInput>
    public typealias MOutput = OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateModelOutputError>
}

/// <p>Updates a Model.</p>
public struct UpdateModelInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The model ID.</p>
    public let modelId: String?
    /// <p>The name of the model.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        apiId: String? = nil,
        contentType: String? = nil,
        description: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelInputBody: Equatable {
    public let contentType: String?
    public let description: String?
    public let name: String?
    public let schema: String?
}

extension UpdateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension UpdateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateModelOutputResponse(contentType: \(String(describing: contentType)), description: \(String(describing: description)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), schema: \(String(describing: schema)))"}
}

extension UpdateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct UpdateModelOutputResponse: Equatable {
    /// <p>The content-type for the model, for example, "application/json".</p>
    public let contentType: String?
    /// <p>The description of the model.</p>
    public let description: String?
    /// <p>The model identifier.</p>
    public let modelId: String?
    /// <p>The name of the model. Must be alphanumeric.</p>
    public let name: String?
    /// <p>The schema for the model. For application/json models, this should be JSON schema draft 4 model.</p>
    public let schema: String?

    public init (
        contentType: String? = nil,
        description: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        schema: String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputResponseBody: Equatable {
    public let contentType: String?
    public let description: String?
    public let modelId: String?
    public let name: String?
    public let schema: String?
}

extension UpdateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

public struct UpdateRouteInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

extension UpdateRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteInput(apiId: \(String(describing: apiId)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeId: \(String(describing: routeId)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

extension UpdateRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for authorizationscopes0 in authorizationScopes {
                try authorizationScopesContainer.encode(authorizationscopes0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestModels)
            for (dictKey0, routemodels0) in requestModels {
                try requestModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .requestParameters)
            for (dictKey0, routeparameters0) in requestParameters {
                try requestParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeKey = routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct UpdateRouteInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

public struct UpdateRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

/// <p>Updates a Route.</p>
public struct UpdateRouteInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies whether an API key is required for the route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>The authorization scopes supported by this route.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiId: String? = nil,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteInputBody: Equatable {
    public let apiKeyRequired: Bool
    public let authorizationScopes: [String]?
    public let authorizationType: AuthorizationType?
    public let authorizerId: String?
    public let modelSelectionExpression: String?
    public let operationName: String?
    public let requestModels: [String:String]?
    public let requestParameters: [String:ParameterConstraints]?
    public let routeKey: String?
    public let routeResponseSelectionExpression: String?
    public let target: String?
}

extension UpdateRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension UpdateRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteOutputResponse(apiGatewayManaged: \(String(describing: apiGatewayManaged)), apiKeyRequired: \(String(describing: apiKeyRequired)), authorizationScopes: \(String(describing: authorizationScopes)), authorizationType: \(String(describing: authorizationType)), authorizerId: \(String(describing: authorizerId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), operationName: \(String(describing: operationName)), requestModels: \(String(describing: requestModels)), requestParameters: \(String(describing: requestParameters)), routeId: \(String(describing: routeId)), routeKey: \(String(describing: routeKey)), routeResponseSelectionExpression: \(String(describing: routeResponseSelectionExpression)), target: \(String(describing: target)))"}
}

extension UpdateRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRouteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = false
            self.apiKeyRequired = false
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct UpdateRouteOutputResponse: Equatable {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    public let apiKeyRequired: Bool
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    public let authorizationScopes: [String]?
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    public let authorizationType: AuthorizationType?
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    public let authorizerId: String?
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The operation name for the route.</p>
    public let operationName: String?
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    public let requestModels: [String:String]?
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    public let requestParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route key for the route.</p>
    public let routeKey: String?
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    public let routeResponseSelectionExpression: String?
    /// <p>The target for the route.</p>
    public let target: String?

    public init (
        apiGatewayManaged: Bool = false,
        apiKeyRequired: Bool = false,
        authorizationScopes: [String]? = nil,
        authorizationType: AuthorizationType? = nil,
        authorizerId: String? = nil,
        modelSelectionExpression: String? = nil,
        operationName: String? = nil,
        requestModels: [String:String]? = nil,
        requestParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeKey: String? = nil,
        routeResponseSelectionExpression: String? = nil,
        target: String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteOutputResponseBody: Equatable {
    public let apiGatewayManaged: Bool
    public let apiKeyRequired: Bool
    public let authorizationScopes: [String]?
    public let authorizationType: AuthorizationType?
    public let authorizerId: String?
    public let modelSelectionExpression: String?
    public let operationName: String?
    public let requestModels: [String:String]?
    public let requestParameters: [String:ParameterConstraints]?
    public let routeId: String?
    public let routeKey: String?
    public let routeResponseSelectionExpression: String?
    public let target: String?
}

extension UpdateRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [String:String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [String:ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

public struct UpdateRouteResponseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRouteResponseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteResponseInput>
    public typealias MOutput = OperationOutput<UpdateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteResponseOutputError>
}

extension UpdateRouteResponseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteResponseInput(apiId: \(String(describing: apiId)), modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeId: \(String(describing: routeId)), routeResponseId: \(String(describing: routeResponseId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

extension UpdateRouteResponseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseModels)
            for (dictKey0, routemodels0) in responseModels {
                try responseModelsContainer.encode(routemodels0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .responseParameters)
            for (dictKey0, routeparameters0) in responseParameters {
                try responseParametersContainer.encode(routeparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

public struct UpdateRouteResponseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRouteResponseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteResponseInput>
    public typealias MOutput = OperationOutput<UpdateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteResponseOutputError>
}

public struct UpdateRouteResponseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRouteResponseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteResponseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteResponseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteResponseInput>
    public typealias MOutput = OperationOutput<UpdateRouteResponseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteResponseOutputError>
}

/// <p>Updates a RouteResponse.</p>
public struct UpdateRouteResponseInput: Equatable {
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>The model selection expression for the route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>The response models for the route response.</p>
    public let responseModels: [String:String]?
    /// <p>The route response parameters.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>The route ID.</p>
    public let routeId: String?
    /// <p>The route response ID.</p>
    public let routeResponseId: String?
    /// <p>The route response key.</p>
    public let routeResponseKey: String?

    public init (
        apiId: String? = nil,
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeId: String? = nil,
        routeResponseId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseInputBody: Equatable {
    public let modelSelectionExpression: String?
    public let responseModels: [String:String]?
    public let responseParameters: [String:ParameterConstraints]?
    public let routeResponseKey: String?
}

extension UpdateRouteResponseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension UpdateRouteResponseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteResponseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteResponseOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteResponseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteResponseOutputResponse(modelSelectionExpression: \(String(describing: modelSelectionExpression)), responseModels: \(String(describing: responseModels)), responseParameters: \(String(describing: responseParameters)), routeResponseId: \(String(describing: routeResponseId)), routeResponseKey: \(String(describing: routeResponseKey)))"}
}

extension UpdateRouteResponseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRouteResponseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct UpdateRouteResponseOutputResponse: Equatable {
    /// <p>Represents the model selection expression of a route response. Supported only for WebSocket APIs.</p>
    public let modelSelectionExpression: String?
    /// <p>Represents the response models of a route response.</p>
    public let responseModels: [String:String]?
    /// <p>Represents the response parameters of a route response.</p>
    public let responseParameters: [String:ParameterConstraints]?
    /// <p>Represents the identifier of a route response.</p>
    public let routeResponseId: String?
    /// <p>Represents the route response key of a route response.</p>
    public let routeResponseKey: String?

    public init (
        modelSelectionExpression: String? = nil,
        responseModels: [String:String]? = nil,
        responseParameters: [String:ParameterConstraints]? = nil,
        routeResponseId: String? = nil,
        routeResponseKey: String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseOutputResponseBody: Equatable {
    public let modelSelectionExpression: String?
    public let responseModels: [String:String]?
    public let responseParameters: [String:ParameterConstraints]?
    public let routeResponseId: String?
    public let routeResponseKey: String?
}

extension UpdateRouteResponseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [String:String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([String: ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [String:ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [String:ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

public struct UpdateStageInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

extension UpdateStageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStageInput(accessLogSettings: \(String(describing: accessLogSettings)), apiId: \(String(describing: apiId)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)))"}
}

extension UpdateStageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if autoDeploy != false {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .routeSettings)
            for (dictKey0, routesettingsmap0) in routeSettings {
                try routeSettingsContainer.encode(routesettingsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stageVariables)
            for (dictKey0, stagevariablesmap0) in stageVariables {
                try stageVariablesContainer.encode(stagevariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateStageInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

public struct UpdateStageInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStageInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStageInput>
    public typealias MOutput = OperationOutput<UpdateStageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStageOutputError>
}

/// <p>Updates a Stage.</p>
public struct UpdateStageInput: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>The API identifier.</p>
    public let apiId: String?
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage.</p>
    public let clientCertificateId: String?
    /// <p>The default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.</p>
    public let deploymentId: String?
    /// <p>The description for the API stage.</p>
    public let description: String?
    /// <p>Route settings for the stage.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiId: String? = nil,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

struct UpdateStageInputBody: Equatable {
    public let accessLogSettings: AccessLogSettings?
    public let autoDeploy: Bool
    public let clientCertificateId: String?
    public let defaultRouteSettings: RouteSettings?
    public let deploymentId: String?
    public let description: String?
    public let routeSettings: [String:RouteSettings]?
    public let stageVariables: [String:String]?
}

extension UpdateStageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension UpdateStageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStageOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStageOutputResponse(accessLogSettings: \(String(describing: accessLogSettings)), apiGatewayManaged: \(String(describing: apiGatewayManaged)), autoDeploy: \(String(describing: autoDeploy)), clientCertificateId: \(String(describing: clientCertificateId)), createdDate: \(String(describing: createdDate)), defaultRouteSettings: \(String(describing: defaultRouteSettings)), deploymentId: \(String(describing: deploymentId)), description: \(String(describing: description)), lastDeploymentStatusMessage: \(String(describing: lastDeploymentStatusMessage)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), routeSettings: \(String(describing: routeSettings)), stageName: \(String(describing: stageName)), stageVariables: \(String(describing: stageVariables)), tags: \(String(describing: tags)))"}
}

extension UpdateStageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateStageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = false
            self.autoDeploy = false
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct UpdateStageOutputResponse: Equatable {
    /// <p>Settings for logging access in this stage.</p>
    public let accessLogSettings: AccessLogSettings?
    /// <p>Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.</p>
    public let apiGatewayManaged: Bool
    /// <p>Specifies whether updates to an API automatically trigger a new deployment. The default value is false.</p>
    public let autoDeploy: Bool
    /// <p>The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.</p>
    public let clientCertificateId: String?
    /// <p>The timestamp when the stage was created.</p>
    public let createdDate: Date?
    /// <p>Default route settings for the stage.</p>
    public let defaultRouteSettings: RouteSettings?
    /// <p>The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.</p>
    public let deploymentId: String?
    /// <p>The description of the stage.</p>
    public let description: String?
    /// <p>Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.</p>
    public let lastDeploymentStatusMessage: String?
    /// <p>The timestamp when the stage was last updated.</p>
    public let lastUpdatedDate: Date?
    /// <p>Route settings for the stage, by routeKey.</p>
    public let routeSettings: [String:RouteSettings]?
    /// <p>The name of the stage.</p>
    public let stageName: String?
    /// <p>A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.</p>
    public let stageVariables: [String:String]?
    /// <p>The collection of tags. Each tag element is associated with a given resource.</p>
    public let tags: [String:String]?

    public init (
        accessLogSettings: AccessLogSettings? = nil,
        apiGatewayManaged: Bool = false,
        autoDeploy: Bool = false,
        clientCertificateId: String? = nil,
        createdDate: Date? = nil,
        defaultRouteSettings: RouteSettings? = nil,
        deploymentId: String? = nil,
        description: String? = nil,
        lastDeploymentStatusMessage: String? = nil,
        lastUpdatedDate: Date? = nil,
        routeSettings: [String:RouteSettings]? = nil,
        stageName: String? = nil,
        stageVariables: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct UpdateStageOutputResponseBody: Equatable {
    public let accessLogSettings: AccessLogSettings?
    public let apiGatewayManaged: Bool
    public let autoDeploy: Bool
    public let clientCertificateId: String?
    public let createdDate: Date?
    public let defaultRouteSettings: RouteSettings?
    public let deploymentId: String?
    public let description: String?
    public let lastDeploymentStatusMessage: String?
    public let lastUpdatedDate: Date?
    public let routeSettings: [String:RouteSettings]?
    public let stageName: String?
    public let stageVariables: [String:String]?
    public let tags: [String:String]?
}

extension UpdateStageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decode(Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decode(Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([String: RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [String:RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [String:RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [String:String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateVpcLinkInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

extension UpdateVpcLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVpcLinkInput(name: \(String(describing: name)), vpcLinkId: \(String(describing: vpcLinkId)))"}
}

extension UpdateVpcLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateVpcLinkInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

public struct UpdateVpcLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVpcLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVpcLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVpcLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVpcLinkInput>
    public typealias MOutput = OperationOutput<UpdateVpcLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVpcLinkOutputError>
}

/// <p>Updates a VPC link.</p>
public struct UpdateVpcLinkInput: Equatable {
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?

    public init (
        name: String? = nil,
        vpcLinkId: String? = nil
    )
    {
        self.name = name
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Equatable {
    public let name: String?
}

extension UpdateVpcLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateVpcLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVpcLinkOutputError: Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVpcLinkOutputResponse(createdDate: \(String(describing: createdDate)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), vpcLinkId: \(String(describing: vpcLinkId)), vpcLinkStatus: \(String(describing: vpcLinkStatus)), vpcLinkStatusMessage: \(String(describing: vpcLinkStatusMessage)), vpcLinkVersion: \(String(describing: vpcLinkVersion)))"}
}

extension UpdateVpcLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct UpdateVpcLinkOutputResponse: Equatable {
    /// <p>The timestamp when the VPC link was created.</p>
    public let createdDate: Date?
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>A list of security group IDs for the VPC link.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs to include in the VPC link.</p>
    public let subnetIds: [String]?
    /// <p>Tags for the VPC link.</p>
    public let tags: [String:String]?
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?
    /// <p>The status of the VPC link.</p>
    public let vpcLinkStatus: VpcLinkStatus?
    /// <p>A message summarizing the cause of the status of the VPC link.</p>
    public let vpcLinkStatusMessage: String?
    /// <p>The version of the VPC link.</p>
    public let vpcLinkVersion: VpcLinkVersion?

    public init (
        createdDate: Date? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        vpcLinkId: String? = nil,
        vpcLinkStatus: VpcLinkStatus? = nil,
        vpcLinkStatusMessage: String? = nil,
        vpcLinkVersion: VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct UpdateVpcLinkOutputResponseBody: Equatable {
    public let createdDate: Date?
    public let name: String?
    public let securityGroupIds: [String]?
    public let subnetIds: [String]?
    public let tags: [String:String]?
    public let vpcLinkId: String?
    public let vpcLinkStatus: VpcLinkStatus?
    public let vpcLinkStatusMessage: String?
    public let vpcLinkVersion: VpcLinkVersion?
}

extension UpdateVpcLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension VpcLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcLinkId = vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
        if let vpcLinkStatus = vpcLinkStatus {
            try encodeContainer.encode(vpcLinkStatus.rawValue, forKey: .vpcLinkStatus)
        }
        if let vpcLinkStatusMessage = vpcLinkStatusMessage {
            try encodeContainer.encode(vpcLinkStatusMessage, forKey: .vpcLinkStatusMessage)
        }
        if let vpcLinkVersion = vpcLinkVersion {
            try encodeContainer.encode(vpcLinkVersion.rawValue, forKey: .vpcLinkVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension VpcLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcLink(createdDate: \(String(describing: createdDate)), name: \(String(describing: name)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), vpcLinkId: \(String(describing: vpcLinkId)), vpcLinkStatus: \(String(describing: vpcLinkStatus)), vpcLinkStatusMessage: \(String(describing: vpcLinkStatusMessage)), vpcLinkVersion: \(String(describing: vpcLinkVersion)))"}
}

/// <p>Represents a VPC link.</p>
public struct VpcLink: Equatable {
    /// <p>The timestamp when the VPC link was created.</p>
    public let createdDate: Date?
    /// <p>The name of the VPC link.</p>
    public let name: String?
    /// <p>A list of security group IDs for the VPC link.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs to include in the VPC link.</p>
    public let subnetIds: [String]?
    /// <p>Tags for the VPC link.</p>
    public let tags: [String:String]?
    /// <p>The ID of the VPC link.</p>
    public let vpcLinkId: String?
    /// <p>The status of the VPC link.</p>
    public let vpcLinkStatus: VpcLinkStatus?
    /// <p>A message summarizing the cause of the status of the VPC link.</p>
    public let vpcLinkStatusMessage: String?
    /// <p>The version of the VPC link.</p>
    public let vpcLinkVersion: VpcLinkVersion?

    public init (
        createdDate: Date? = nil,
        name: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        vpcLinkId: String? = nil,
        vpcLinkStatus: VpcLinkStatus? = nil,
        vpcLinkStatusMessage: String? = nil,
        vpcLinkVersion: VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

/// <p>The status of the VPC link.</p>
public enum VpcLinkStatus {
    case available
    case deleting
    case failed
    case inactive
    case pending
    case sdkUnknown(String)
}

extension VpcLinkStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VpcLinkStatus] {
        return [
            .available,
            .deleting,
            .failed,
            .inactive,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .inactive: return "INACTIVE"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
    }
}

/// <p>The version of the VPC link.</p>
public enum VpcLinkVersion {
    case v2
    case sdkUnknown(String)
}

extension VpcLinkVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VpcLinkVersion] {
        return [
            .v2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v2: return "V2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VpcLinkVersion(rawValue: rawValue) ?? VpcLinkVersion.sdkUnknown(rawValue)
    }
}
