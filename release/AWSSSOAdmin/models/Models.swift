// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SsoAdminClientTypes.AccessControlAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.AccessControlAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsoAdminClientTypes {
    /// These are Amazon Web Services SSO identity store attributes that you can configure for use in attributes-based access control (ABAC). You can create permissions policies that determine who can access your Amazon Web Services resources based upon the configured attribute values. When you enable ABAC and specify AccessControlAttributes, Amazon Web Services SSO passes the attribute values of the authenticated user into IAM for use in policy evaluation.
    public struct AccessControlAttribute: Swift.Equatable {
        /// The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in Amazon Web Services SSO.
        /// This member is required.
        public var key: Swift.String?
        /// The value used for mapping a specified attribute to an identity source.
        /// This member is required.
        public var value: SsoAdminClientTypes.AccessControlAttributeValue?

        public init (
            key: Swift.String? = nil,
            value: SsoAdminClientTypes.AccessControlAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SsoAdminClientTypes.AccessControlAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            var sourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .source)
            for accesscontrolattributevaluesourcelist0 in source {
                try sourceContainer.encode(accesscontrolattributevaluesourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .source)
        var sourceDecoded0:[Swift.String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [Swift.String]()
            for string0 in sourceContainer {
                if let string0 = string0 {
                    sourceDecoded0?.append(string0)
                }
            }
        }
        source = sourceDecoded0
    }
}

extension SsoAdminClientTypes {
    /// The value used for mapping a specified attribute to an identity source.
    public struct AccessControlAttributeValue: Swift.Equatable {
        /// The identity source to use when mapping a specified attribute to Amazon Web Services SSO.
        /// This member is required.
        public var source: [Swift.String]?

        public init (
            source: [Swift.String]? = nil
        )
        {
            self.source = source
        }
    }

}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsoAdminClientTypes.AccountAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension SsoAdminClientTypes {
    /// The assignment that indicates a principal's limited access to a specified Amazon Web Services account with a specified permission set. The term principal here refers to a user or group that is defined in Amazon Web Services SSO.
    public struct AccountAssignment: Swift.Equatable {
        /// The identifier of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in Amazon Web Services SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in Amazon Web Services SSO, see the [Amazon Web Services SSO Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SsoAdminClientTypes.PrincipalType?

        public init (
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SsoAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SsoAdminClientTypes.AccountAssignmentOperationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case requestId = "RequestId"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SsoAdminClientTypes {
    /// The status of the creation or deletion operation of an assignment that a principal needs to access an account.
    public struct AccountAssignmentOperationStatus: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in Amazon Web Services SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in Amazon Web Services SSO, see the [Amazon Web Services SSO Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SsoAdminClientTypes.PrincipalType?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SsoAdminClientTypes.StatusValues?
        /// TargetID is an Amazon Web Services account identifier, typically a 10-12 digit string (For example, 123456789012).
        public var targetId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var targetType: SsoAdminClientTypes.TargetType?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SsoAdminClientTypes.PrincipalType? = nil,
            requestId: Swift.String? = nil,
            status: SsoAdminClientTypes.StatusValues? = nil,
            targetId: Swift.String? = nil,
            targetType: SsoAdminClientTypes.TargetType? = nil
        )
        {
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
            self.requestId = requestId
            self.status = status
            self.targetId = targetId
            self.targetType = targetType
        }
    }

}

extension SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SsoAdminClientTypes {
    /// Provides information about the [AccountAssignment] creation request.
    public struct AccountAssignmentOperationStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SsoAdminClientTypes.StatusValues?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SsoAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension AttachManagedPolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension AttachManagedPolicyToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachManagedPolicyToPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The IAM managed policy ARN to be attached to a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] that the managed policy should be attached to.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachManagedPolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension AttachManagedPolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension AttachManagedPolicyToPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachManagedPolicyToPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachManagedPolicyToPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachManagedPolicyToPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AttachManagedPolicyToPermissionSetOutputResponse: Swift.Equatable {

}

extension SsoAdminClientTypes.AttachedManagedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SsoAdminClientTypes {
    /// A structure that stores the details of the IAM managed policy.
    public struct AttachedManagedPolicy: Swift.Equatable {
        /// The ARN of the IAM managed policy. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The name of the IAM managed policy.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension CreateAccountAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that the admin wants to grant the principal access to.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in Amazon Web Services SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in Amazon Web Services SSO, see the [Amazon Web Services SSO Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SsoAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, typically a 10-12 digit string (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SsoAdminClientTypes.TargetType?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SsoAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SsoAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct CreateAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SsoAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SsoAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension CreateAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension CreateAccountAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccountAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct CreateAccountAssignmentOutputResponse: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?

    public init (
        accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct CreateAccountAssignmentOutputResponseBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?
}

extension CreateAccountAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Specifies the Amazon Web Services SSO identity store attributes to add to your ABAC configuration. When using an external identity provider as an identity source, you can pass attributes through the SAML assertion. Doing so provides an alternative to configuring attributes from the Amazon Web Services SSO identity store. If a SAML assertion passes any of these attributes, Amazon Web Services SSO will replace the attribute value with the value from the Amazon Web Services SSO identity store.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the SSO instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceAccessControlAttributeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceAccessControlAttributeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationOutputResponse: Swift.Equatable {

}

extension CreatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreatePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the [PermissionSet].
    /// This member is required.
    public var name: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid in the ISO-8601 standard.
    public var sessionDuration: Swift.String?
    /// The tags to attach to the new [PermissionSet].
    public var tags: [SsoAdminClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil,
        tags: [SsoAdminClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.relayState = relayState
        self.sessionDuration = sessionDuration
        self.tags = tags
    }
}

struct CreatePermissionSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceArn: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
    let tags: [SsoAdminClientTypes.Tag]?
}

extension CreatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsoAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsoAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct CreatePermissionSetOutputResponse: Swift.Equatable {
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSet: SsoAdminClientTypes.PermissionSet?

    public init (
        permissionSet: SsoAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct CreatePermissionSetOutputResponseBody: Swift.Equatable {
    let permissionSet: SsoAdminClientTypes.PermissionSet?
}

extension CreatePermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

extension DeleteAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension DeleteAccountAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in Amazon Web Services SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in Amazon Web Services SSO, see the [Amazon Web Services SSO Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SsoAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, typically a 10-12 digit string (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var targetType: SsoAdminClientTypes.TargetType?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SsoAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SsoAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct DeleteAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SsoAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SsoAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension DeleteAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension DeleteAccountAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAccountAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DeleteAccountAssignmentOutputResponse: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?

    public init (
        accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DeleteAccountAssignmentOutputResponseBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DeleteAccountAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

extension DeleteInlinePolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeleteInlinePolicyFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInlinePolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeleteInlinePolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeleteInlinePolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeleteInlinePolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInlinePolicyFromPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInlinePolicyFromPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInlinePolicyFromPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInlinePolicyFromPermissionSetOutputResponse: Swift.Equatable {

}

extension DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceAccessControlAttributeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceAccessControlAttributeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationOutputResponse: Swift.Equatable {

}

extension DeletePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeletePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that should be deleted.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeletePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionSetOutputResponse: Swift.Equatable {

}

extension DescribeAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentCreationRequestId = accountAssignmentCreationRequestId {
            try encodeContainer.encode(accountAssignmentCreationRequestId, forKey: .accountAssignmentCreationRequestId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentCreationRequestId: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        accountAssignmentCreationRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentCreationRequestId = accountAssignmentCreationRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentCreationRequestId: Swift.String?
}

extension DescribeAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentCreationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentCreationRequestId)
        accountAssignmentCreationRequestId = accountAssignmentCreationRequestIdDecoded
    }
}

extension DescribeAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAssignmentCreationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAssignmentCreationStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAssignmentCreationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAssignmentCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentCreationStatusOutputResponse: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?

    public init (
        accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct DescribeAccountAssignmentCreationStatusOutputResponseBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentCreationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

extension DescribeAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId {
            try encodeContainer.encode(accountAssignmentDeletionRequestId, forKey: .accountAssignmentDeletionRequestId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentDeletionRequestId: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        accountAssignmentDeletionRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentDeletionRequestId: Swift.String?
}

extension DescribeAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentDeletionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentDeletionRequestId)
        accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestIdDecoded
    }
}

extension DescribeAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAssignmentDeletionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAssignmentDeletionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAssignmentDeletionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAssignmentDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentDeletionStatusOutputResponse: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?

    public init (
        accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DescribeAccountAssignmentDeletionStatusOutputResponseBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SsoAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentDeletionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAccessControlAttributeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceAccessControlAttributeConfiguration = output.instanceAccessControlAttributeConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.instanceAccessControlAttributeConfiguration = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationOutputResponse: Swift.Equatable {
    /// Gets the list of Amazon Web Services SSO identity store attributes that have been added to your ABAC configuration.
    public var instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The status of the attribute configuration process.
    public var status: SsoAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    /// Provides more details about the current status of the specified attribute.
    public var statusReason: Swift.String?

    public init (
        instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        status: SsoAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody: Swift.Equatable {
    let status: SsoAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    let statusReason: Swift.String?
    let instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension DescribePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DescribePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DescribePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DescribePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DescribePermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct DescribePermissionSetOutputResponse: Swift.Equatable {
    /// Describes the level of access on an Amazon Web Services account.
    public var permissionSet: SsoAdminClientTypes.PermissionSet?

    public init (
        permissionSet: SsoAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct DescribePermissionSetOutputResponseBody: Swift.Equatable {
    let permissionSet: SsoAdminClientTypes.PermissionSet?
}

extension DescribePermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

extension DescribePermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let provisionPermissionSetRequestId = provisionPermissionSetRequestId {
            try encodeContainer.encode(provisionPermissionSetRequestId, forKey: .provisionPermissionSetRequestId)
        }
    }
}

extension DescribePermissionSetProvisioningStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetProvisioningStatusInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The identifier that is provided by the [ProvisionPermissionSet] call to retrieve the current status of the provisioning workflow.
    /// This member is required.
    public var provisionPermissionSetRequestId: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        provisionPermissionSetRequestId: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.provisionPermissionSetRequestId = provisionPermissionSetRequestId
    }
}

struct DescribePermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let provisionPermissionSetRequestId: Swift.String?
}

extension DescribePermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let provisionPermissionSetRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionPermissionSetRequestId)
        provisionPermissionSetRequestId = provisionPermissionSetRequestIdDecoded
    }
}

extension DescribePermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionSetProvisioningStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionSetProvisioningStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionSetProvisioningStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePermissionSetProvisioningStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct DescribePermissionSetProvisioningStatusOutputResponse: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus?

    public init (
        permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct DescribePermissionSetProvisioningStatusOutputResponseBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus?
}

extension DescribePermissionSetProvisioningStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

extension DetachManagedPolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DetachManagedPolicyFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachManagedPolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The IAM managed policy ARN to be attached to a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] from which the policy should be detached.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachManagedPolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension DetachManagedPolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension DetachManagedPolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachManagedPolicyFromPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachManagedPolicyFromPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachManagedPolicyFromPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DetachManagedPolicyFromPermissionSetOutputResponse: Swift.Equatable {

}

extension GetInlinePolicyForPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension GetInlinePolicyForPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInlinePolicyForPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetInlinePolicyForPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension GetInlinePolicyForPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetInlinePolicyForPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInlinePolicyForPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInlinePolicyForPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInlinePolicyForPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInlinePolicyForPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inlinePolicy = output.inlinePolicy
        } else {
            self.inlinePolicy = nil
        }
    }
}

public struct GetInlinePolicyForPermissionSetOutputResponse: Swift.Equatable {
    /// The IAM inline policy that is attached to the permission set.
    public var inlinePolicy: Swift.String?

    public init (
        inlinePolicy: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
    }
}

struct GetInlinePolicyForPermissionSetOutputResponseBody: Swift.Equatable {
    let inlinePolicy: Swift.String?
}

extension GetInlinePolicyForPermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlAttributes = "AccessControlAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlAttributes = accessControlAttributes {
            var accessControlAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlAttributes)
            for accesscontrolattributelist0 in accessControlAttributes {
                try accessControlAttributesContainer.encode(accesscontrolattributelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAttributesContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.AccessControlAttribute?].self, forKey: .accessControlAttributes)
        var accessControlAttributesDecoded0:[SsoAdminClientTypes.AccessControlAttribute]? = nil
        if let accessControlAttributesContainer = accessControlAttributesContainer {
            accessControlAttributesDecoded0 = [SsoAdminClientTypes.AccessControlAttribute]()
            for structure0 in accessControlAttributesContainer {
                if let structure0 = structure0 {
                    accessControlAttributesDecoded0?.append(structure0)
                }
            }
        }
        accessControlAttributes = accessControlAttributesDecoded0
    }
}

extension SsoAdminClientTypes {
    /// Specifies the attributes to add to your attribute-based access control (ABAC) configuration.
    public struct InstanceAccessControlAttributeConfiguration: Swift.Equatable {
        /// Lists the attributes that are configured for ABAC in the specified Amazon Web Services SSO instance.
        /// This member is required.
        public var accessControlAttributes: [SsoAdminClientTypes.AccessControlAttribute]?

        public init (
            accessControlAttributes: [SsoAdminClientTypes.AccessControlAttribute]? = nil
        )
        {
            self.accessControlAttributes = accessControlAttributes
        }
    }

}

extension SsoAdminClientTypes {
    public enum InstanceAccessControlAttributeConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAccessControlAttributeConfigurationStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceAccessControlAttributeConfigurationStatus(rawValue: rawValue) ?? InstanceAccessControlAttributeConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SsoAdminClientTypes.InstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension SsoAdminClientTypes {
    /// Provides information about the SSO instance.
    public struct InstanceMetadata: Swift.Equatable {
        /// The identifier of the identity store that is connected to the SSO instance.
        public var identityStoreId: Swift.String?
        /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var instanceArn: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            instanceArn: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.instanceArn = instanceArn
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SsoAdminClientTypes.OperationStatusFilter?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        filter: SsoAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SsoAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentCreationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentCreationStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentCreationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountAssignmentCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsCreationStatus = output.accountAssignmentsCreationStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsCreationStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentCreationStatusOutputResponse: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentsCreationStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        accountAssignmentsCreationStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsCreationStatus = accountAssignmentsCreationStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusOutputResponseBody: Swift.Equatable {
    let accountAssignmentsCreationStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentCreationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsCreationStatus = "AccountAssignmentsCreationStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsCreationStatusContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsCreationStatus)
        var accountAssignmentsCreationStatusDecoded0:[SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsCreationStatusContainer = accountAssignmentsCreationStatusContainer {
            accountAssignmentsCreationStatusDecoded0 = [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsCreationStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsCreationStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsCreationStatus = accountAssignmentsCreationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SsoAdminClientTypes.OperationStatusFilter?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        filter: SsoAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SsoAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentDeletionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentDeletionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentDeletionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountAssignmentDeletionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsDeletionStatus = output.accountAssignmentsDeletionStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsDeletionStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentDeletionStatusOutputResponse: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentsDeletionStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        accountAssignmentsDeletionStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusOutputResponseBody: Swift.Equatable {
    let accountAssignmentsDeletionStatus: [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentDeletionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsDeletionStatus = "AccountAssignmentsDeletionStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsDeletionStatusContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsDeletionStatus)
        var accountAssignmentsDeletionStatusDecoded0:[SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsDeletionStatusContainer = accountAssignmentsDeletionStatusContainer {
            accountAssignmentsDeletionStatusDecoded0 = [SsoAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsDeletionStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDeletionStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListAccountAssignmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentsInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the permission set from which to list assignments.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListAccountAssignmentsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssignmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountAssignmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssignmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountAssignmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignments = output.accountAssignments
            self.nextToken = output.nextToken
        } else {
            self.accountAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentsOutputResponse: Swift.Equatable {
    /// The list of assignments that match the input Amazon Web Services account and permission set.
    public var accountAssignments: [SsoAdminClientTypes.AccountAssignment]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        accountAssignments: [SsoAdminClientTypes.AccountAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentsOutputResponseBody: Swift.Equatable {
    let accountAssignments: [SsoAdminClientTypes.AccountAssignment]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignments = "AccountAssignments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.AccountAssignment?].self, forKey: .accountAssignments)
        var accountAssignmentsDecoded0:[SsoAdminClientTypes.AccountAssignment]? = nil
        if let accountAssignmentsContainer = accountAssignmentsContainer {
            accountAssignmentsDecoded0 = [SsoAdminClientTypes.AccountAssignment]()
            for structure0 in accountAssignmentsContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        accountAssignments = accountAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountsForProvisionedPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let provisioningStatus = provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListAccountsForProvisionedPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountsForProvisionedPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] from which the associated Amazon Web Services accounts will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permission set provisioning status for an Amazon Web Services account.
    public var provisioningStatus: SsoAdminClientTypes.ProvisioningStatus?

    public init (
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        provisioningStatus: SsoAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
        self.provisioningStatus = provisioningStatus
    }
}

struct ListAccountsForProvisionedPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let provisioningStatus: SsoAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountsForProvisionedPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountsForProvisionedPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountsForProvisionedPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountsForProvisionedPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountsForProvisionedPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services AccountIds.
    public var accountIds: [Swift.String]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextToken = nextToken
    }
}

struct ListAccountsForProvisionedPermissionSetOutputResponseBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of results to display for the instance.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Swift.Equatable {
    /// Lists the SSO instances that the caller has access to.
    public var instances: [SsoAdminClientTypes.InstanceMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        instances: [SsoAdminClientTypes.InstanceMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Swift.Equatable {
    let instances: [SsoAdminClientTypes.InstanceMetadata]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.InstanceMetadata?].self, forKey: .instances)
        var instancesDecoded0:[SsoAdminClientTypes.InstanceMetadata]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [SsoAdminClientTypes.InstanceMetadata]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedPoliciesInPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListManagedPoliciesInPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListManagedPoliciesInPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] whose managed policies will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListManagedPoliciesInPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedPoliciesInPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedPoliciesInPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListManagedPoliciesInPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedPoliciesInPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListManagedPoliciesInPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachedManagedPolicies = output.attachedManagedPolicies
            self.nextToken = output.nextToken
        } else {
            self.attachedManagedPolicies = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedPoliciesInPermissionSetOutputResponse: Swift.Equatable {
    /// The array of the [AttachedManagedPolicy] data type object.
    public var attachedManagedPolicies: [SsoAdminClientTypes.AttachedManagedPolicy]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        attachedManagedPolicies: [SsoAdminClientTypes.AttachedManagedPolicy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.nextToken = nextToken
    }
}

struct ListManagedPoliciesInPermissionSetOutputResponseBody: Swift.Equatable {
    let attachedManagedPolicies: [SsoAdminClientTypes.AttachedManagedPolicy]?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.AttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SsoAdminClientTypes.AttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SsoAdminClientTypes.AttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetProvisioningStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetProvisioningStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SsoAdminClientTypes.OperationStatusFilter?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        filter: SsoAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SsoAdminClientTypes.OperationStatusFilter?
}

extension ListPermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListPermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetProvisioningStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetProvisioningStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetProvisioningStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionSetProvisioningStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSetsProvisioningStatus = output.permissionSetsProvisioningStatus
        } else {
            self.nextToken = nil
            self.permissionSetsProvisioningStatus = nil
        }
    }
}

public struct ListPermissionSetProvisioningStatusOutputResponse: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var permissionSetsProvisioningStatus: [SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        permissionSetsProvisioningStatus: [SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSetsProvisioningStatus = permissionSetsProvisioningStatus
    }
}

struct ListPermissionSetProvisioningStatusOutputResponseBody: Swift.Equatable {
    let permissionSetsProvisioningStatus: [SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListPermissionSetProvisioningStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSetsProvisioningStatus = "PermissionSetsProvisioningStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsProvisioningStatusContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata?].self, forKey: .permissionSetsProvisioningStatus)
        var permissionSetsProvisioningStatusDecoded0:[SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
        if let permissionSetsProvisioningStatusContainer = permissionSetsProvisioningStatusContainer {
            permissionSetsProvisioningStatusDecoded0 = [SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata]()
            for structure0 in permissionSetsProvisioningStatusContainer {
                if let structure0 = structure0 {
                    permissionSetsProvisioningStatusDecoded0?.append(structure0)
                }
            }
        }
        permissionSetsProvisioningStatus = permissionSetsProvisioningStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsOutputResponse: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSets: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsOutputResponseBody: Swift.Equatable {
    let permissionSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPermissionSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsProvisionedToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let provisioningStatus = provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListPermissionSetsProvisionedToAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsProvisionedToAccountInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var provisioningStatus: SsoAdminClientTypes.ProvisioningStatus?

    public init (
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisioningStatus: SsoAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningStatus = provisioningStatus
    }
}

struct ListPermissionSetsProvisionedToAccountInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let provisioningStatus: SsoAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPermissionSetsProvisionedToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsProvisionedToAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionSetsProvisionedToAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionSetsProvisionedToAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionSetsProvisionedToAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionSetsProvisionedToAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsProvisionedToAccountOutputResponse: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access that an Amazon Web Services account has.
    public var permissionSets: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsProvisionedToAccountOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let permissionSets: [Swift.String]?
}

extension ListPermissionSetsProvisionedToAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        instanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    public var tags: [SsoAdminClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [SsoAdminClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [SsoAdminClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsoAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsoAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SsoAdminClientTypes.OperationStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
    }
}

extension SsoAdminClientTypes {
    /// Filters he operation status list based on the passed attribute value.
    public struct OperationStatusFilter: Swift.Equatable {
        /// Filters the list operations result based on the status attribute.
        public var status: SsoAdminClientTypes.StatusValues?

        public init (
            status: SsoAdminClientTypes.StatusValues? = nil
        )
        {
            self.status = status
        }
    }

}

extension SsoAdminClientTypes.PermissionSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension SsoAdminClientTypes {
    /// An entity that contains IAM policies.
    public struct PermissionSet: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the [PermissionSet].
        public var description: Swift.String?
        /// The name of the permission set.
        public var name: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// Used to redirect users within the application during the federation authentication process.
        public var relayState: Swift.String?
        /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
        public var sessionDuration: Swift.String?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            relayState: Swift.String? = nil,
            sessionDuration: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.permissionSetArn = permissionSetArn
            self.relayState = relayState
            self.sessionDuration = sessionDuration
        }
    }

}

extension SsoAdminClientTypes.PermissionSetProvisioningStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SsoAdminClientTypes {
    /// A structure that is used to provide the status of the provisioning operation for a specified permission set.
    public struct PermissionSetProvisioningStatus: Swift.Equatable {
        /// The identifier of the Amazon Web Services account from which to list the assignments.
        public var accountId: Swift.String?
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set that is being provisioned. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SsoAdminClientTypes.StatusValues?

        public init (
            accountId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            requestId: Swift.String? = nil,
            status: SsoAdminClientTypes.StatusValues? = nil
        )
        {
            self.accountId = accountId
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SsoAdminClientTypes.PermissionSetProvisioningStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SsoAdminClientTypes {
    /// Provides information about the permission set provisioning status.
    public struct PermissionSetProvisioningStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SsoAdminClientTypes.StatusValues?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SsoAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SsoAdminClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension ProvisionPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvisionPermissionSetInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// TargetID is an Amazon Web Services account identifier, typically a 10-12 digit string (For example, 123456789012).
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SsoAdminClientTypes.ProvisionTargetType?

    public init (
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SsoAdminClientTypes.ProvisionTargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct ProvisionPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SsoAdminClientTypes.ProvisionTargetType?
}

extension ProvisionPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.ProvisionTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension ProvisionPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionPermissionSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct ProvisionPermissionSetOutputResponse: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus?

    public init (
        permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct ProvisionPermissionSetOutputResponseBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SsoAdminClientTypes.PermissionSetProvisioningStatus?
}

extension ProvisionPermissionSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

extension SsoAdminClientTypes {
    public enum ProvisionTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allProvisionedAccounts
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionTargetType] {
            return [
                .allProvisionedAccounts,
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allProvisionedAccounts: return "ALL_PROVISIONED_ACCOUNTS"
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionTargetType(rawValue: rawValue) ?? ProvisionTargetType.sdkUnknown(rawValue)
        }
    }
}

extension SsoAdminClientTypes {
    public enum ProvisioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latestPermissionSetNotProvisioned
        case latestPermissionSetProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .latestPermissionSetNotProvisioned,
                .latestPermissionSetProvisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latestPermissionSetNotProvisioned: return "LATEST_PERMISSION_SET_NOT_PROVISIONED"
            case .latestPermissionSetProvisioned: return "LATEST_PERMISSION_SET_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningStatus(rawValue: rawValue) ?? ProvisioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlinePolicy = inlinePolicy {
            try encodeContainer.encode(inlinePolicy, forKey: .inlinePolicy)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInlinePolicyToPermissionSetInput: Swift.Equatable {
    /// The IAM inline policy to attach to a [PermissionSet].
    /// This member is required.
    public var inlinePolicy: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init (
        inlinePolicy: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct PutInlinePolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let inlinePolicy: Swift.String?
}

extension PutInlinePolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension PutInlinePolicyToPermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInlinePolicyToPermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInlinePolicyToPermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInlinePolicyToPermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutInlinePolicyToPermissionSetOutputResponse: Swift.Equatable {

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the principal has crossed the permitted number of resources that can be created.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SsoAdminClientTypes {
    public enum StatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusValues] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusValues(rawValue: rawValue) ?? StatusValues.sdkUnknown(rawValue)
        }
    }
}

extension SsoAdminClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SsoAdminClientTypes {
    /// A set of key-value pairs that are used to manage the resource. Tags can only be applied to permission sets and cannot be applied to corresponding roles that Amazon Web Services SSO creates in Amazon Web Services accounts.
    public struct Tag: Swift.Equatable {
        /// The key for the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    /// This member is required.
    public var tags: [SsoAdminClientTypes.Tag]?

    public init (
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [SsoAdminClientTypes.Tag]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tags: [SsoAdminClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SsoAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SsoAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SsoAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension SsoAdminClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that are attached to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Updates the attributes for your ABAC configuration.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the SSO instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init (
        instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SsoAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceAccessControlAttributeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceAccessControlAttributeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationOutputResponse: Swift.Equatable {

}

extension UpdatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }
}

extension UpdatePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the SSO instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
    public var sessionDuration: Swift.String?

    public init (
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

struct UpdatePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let description: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
}

extension UpdatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension UpdatePermissionSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePermissionSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePermissionSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePermissionSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePermissionSetOutputResponse: Swift.Equatable {

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
