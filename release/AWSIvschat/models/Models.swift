// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    public enum ChatTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteMessage
        case disconnectUser
        case sendMessage
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatTokenCapability] {
            return [
                .deleteMessage,
                .disconnectUser,
                .sendMessage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteMessage: return "DELETE_MESSAGE"
            case .disconnectUser: return "DISCONNECT_USER"
            case .sendMessage: return "SEND_MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatTokenCapability(rawValue: rawValue) ?? ChatTokenCapability.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateChatTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, chattokenattributes0) in attributes {
                try attributesContainer.encode(chattokenattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for chattokencapabilities0 in capabilities {
                try capabilitiesContainer.encode(chattokencapabilities0.rawValue)
            }
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if sessionDurationInMinutes != 0 {
            try encodeContainer.encode(sessionDurationInMinutes, forKey: .sessionDurationInMinutes)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateChatTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateChatToken"
    }
}

public struct CreateChatTokenInput: Swift.Equatable {
    /// Application-provided attributes to encode into the token and attach to a chat session. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the room. Default: None (the capability to view messages is implicitly included in all requests).
    public var capabilities: [IvschatClientTypes.ChatTokenCapability]?
    /// Identifier of the room that the client is trying to access. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// Session duration (in minutes), after which the session expires. Default: 60 (1 hour).
    public var sessionDurationInMinutes: Swift.Int
    /// Application-provided ID that uniquely identifies the user associated with this token. This can be any UTF-8 encoded text.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IvschatClientTypes.ChatTokenCapability]? = nil,
        roomIdentifier: Swift.String? = nil,
        sessionDurationInMinutes: Swift.Int = 0,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.roomIdentifier = roomIdentifier
        self.sessionDurationInMinutes = sessionDurationInMinutes
        self.userId = userId
    }
}

struct CreateChatTokenInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let capabilities: [IvschatClientTypes.ChatTokenCapability]?
    let sessionDurationInMinutes: Swift.Int
    let attributes: [Swift.String:Swift.String]?
}

extension CreateChatTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ChatTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IvschatClientTypes.ChatTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IvschatClientTypes.ChatTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let sessionDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionDurationInMinutes) ?? 0
        sessionDurationInMinutes = sessionDurationInMinutesDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreateChatTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChatTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChatTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChatTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChatTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionExpirationTime = output.sessionExpirationTime
            self.token = output.token
            self.tokenExpirationTime = output.tokenExpirationTime
        } else {
            self.sessionExpirationTime = nil
            self.token = nil
            self.tokenExpirationTime = nil
        }
    }
}

public struct CreateChatTokenOutputResponse: Swift.Equatable {
    /// Time after which an end user's session is no longer valid. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var sessionExpirationTime: ClientRuntime.Date?
    /// The issued client token, encrypted.
    public var token: Swift.String?
    /// Time after which the token is no longer valid and cannot be used to connect to a room. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var tokenExpirationTime: ClientRuntime.Date?

    public init (
        sessionExpirationTime: ClientRuntime.Date? = nil,
        token: Swift.String? = nil,
        tokenExpirationTime: ClientRuntime.Date? = nil
    )
    {
        self.sessionExpirationTime = sessionExpirationTime
        self.token = token
        self.tokenExpirationTime = tokenExpirationTime
    }
}

struct CreateChatTokenOutputResponseBody: Swift.Equatable {
    let token: Swift.String?
    let tokenExpirationTime: ClientRuntime.Date?
    let sessionExpirationTime: ClientRuntime.Date?
}

extension CreateChatTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionExpirationTime
        case token
        case tokenExpirationTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .tokenExpirationTime)
        tokenExpirationTime = tokenExpirationTimeDecoded
        let sessionExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sessionExpirationTime)
        sessionExpirationTime = sessionExpirationTimeDecoded
    }
}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateRoom"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init (
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct CreateRoomOutputResponse: Swift.Equatable {
    /// Room ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Maximum number of characters in a single message, from the request.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource, from the request.
    public var tags: [Swift.String:Swift.String]?
    /// Time of the roomâ€™s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct CreateRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension DeleteMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteMessage"
    }
}

public struct DeleteMessageInput: Swift.Equatable {
    /// ID of the message to be deleted. This is the Id field in the received message (see [ Message (Subscribe)](https://docs.aws.amazon.com/ivs/latest/chatmsgapireference/actions-message-subscribe.html) in the Chat Messaging API).
    /// This member is required.
    public var id: Swift.String?
    /// Reason for deleting the message.
    public var reason: Swift.String?
    /// Identifier of the room where the message should be deleted. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init (
        id: Swift.String? = nil,
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.id = id
        self.reason = reason
        self.roomIdentifier = roomIdentifier
    }
}

struct DeleteMessageInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let id: Swift.String?
    let reason: Swift.String?
}

extension DeleteMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DeleteMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMessageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteMessageOutputResponse: Swift.Equatable {
    /// Operation identifier, generated by Amazon IVS Chat.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMessageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRoom"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// Identifier of the room to be deleted. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisconnectUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DisconnectUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectUser"
    }
}

public struct DisconnectUserInput: Swift.Equatable {
    /// Reason for disconnecting the user.
    public var reason: Swift.String?
    /// Identifier of the room from which the user's clients should be disconnected. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// ID of the user (connection) to disconnect from the room.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.roomIdentifier = roomIdentifier
        self.userId = userId
    }
}

struct DisconnectUserInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let reason: Swift.String?
}

extension DisconnectUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisconnectUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvschatClientTypes {
    public enum FallbackResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackResult] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FallbackResult(rawValue: rawValue) ?? FallbackResult.sdkUnknown(rawValue)
        }
    }
}

extension GetRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetRoom"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// Identifier of the room for which the configuration is to be retrieved. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetRoomOutputResponse: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the roomâ€™s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
}

extension GetRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRoomsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let messageReviewHandlerUri = self.messageReviewHandlerUri {
            try encodeContainer.encode(messageReviewHandlerUri, forKey: .messageReviewHandlerUri)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListRooms"
    }
}

public struct ListRoomsInput: Swift.Equatable {
    /// Maximum number of rooms to return. Default: 50.
    public var maxResults: Swift.Int
    /// Filters the list to match the specified message review handler URI.
    public var messageReviewHandlerUri: Swift.String?
    /// Filters the list to match the specified room name.
    public var name: Swift.String?
    /// The first room to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        messageReviewHandlerUri: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.messageReviewHandlerUri = messageReviewHandlerUri
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListRoomsInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let messageReviewHandlerUri: Swift.String?
}

extension ListRoomsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let messageReviewHandlerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageReviewHandlerUri)
        messageReviewHandlerUri = messageReviewHandlerUriDecoded
    }
}

extension ListRoomsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoomsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoomsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoomsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRoomsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
        } else {
            self.nextToken = nil
            self.rooms = nil
        }
    }
}

public struct ListRoomsOutputResponse: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching rooms (summary information only).
    /// This member is required.
    public var rooms: [IvschatClientTypes.RoomSummary]?

    public init (
        nextToken: Swift.String? = nil,
        rooms: [IvschatClientTypes.RoomSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

struct ListRoomsOutputResponseBody: Swift.Equatable {
    let rooms: [IvschatClientTypes.RoomSummary]?
    let nextToken: Swift.String?
}

extension ListRoomsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rooms
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([IvschatClientTypes.RoomSummary?].self, forKey: .rooms)
        var roomsDecoded0:[IvschatClientTypes.RoomSummary]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [IvschatClientTypes.RoomSummary]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags attached to the resource, from the request.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes.MessageReviewHandler: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fallbackResult
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fallbackResult = self.fallbackResult {
            try encodeContainer.encode(fallbackResult.rawValue, forKey: .fallbackResult)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let fallbackResultDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.FallbackResult.self, forKey: .fallbackResult)
        fallbackResult = fallbackResultDecoded
    }
}

extension IvschatClientTypes {
    /// Configuration information for optional message review.
    public struct MessageReviewHandler: Swift.Equatable {
        /// Specifies the fallback behavior (whether the message is allowed or denied) if the handler does not return a valid response, encounters an error, or times out. (For the timeout period, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/userguide/service-quotas.html).) If allowed, the message is delivered with returned content to all users connected to the room. If denied, the message is not delivered to any user. Default: ALLOW.
        public var fallbackResult: IvschatClientTypes.FallbackResult?
        /// Identifier of the message review handler. Currently this must be an ARN of a lambda function.
        public var uri: Swift.String?

        public init (
            fallbackResult: IvschatClientTypes.FallbackResult? = nil,
            uri: Swift.String? = nil
        )
        {
            self.fallbackResult = fallbackResult
            self.uri = uri
        }
    }

}

extension PendingVerification {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct PendingVerification: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let message: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IvschatClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.RoomSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    /// Summary information about a room.
    public struct RoomSummary: Swift.Equatable {
        /// Room ARN.
        public var arn: Swift.String?
        /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: ClientRuntime.Date?
        /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// Configuration information for optional review of messages.
        public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
        /// Room name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Time of the roomâ€™s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.messageReviewHandler = messageReviewHandler
            self.name = name
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, eventattributes0) in attributes {
                try attributesContainer.encode(eventattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SendEvent"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// Application-defined metadata to attach to the event sent to clients. The maximum length of the metadata is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Application-defined name of the event to send to clients.
    /// This member is required.
    public var eventName: Swift.String?
    /// Identifier of the room to which the event will be sent. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        eventName: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.eventName = eventName
        self.roomIdentifier = roomIdentifier
    }
}

struct SendEventInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let eventName: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SendEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct SendEventOutputResponse: Swift.Equatable {
    /// An identifier generated by Amazon IVS Chat. This identifier must be used in subsequent operations for this message, such as DeleteMessage.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct SendEventOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension SendEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.limit = 0
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    /// This member is required.
    public var limit: Swift.Int
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.limit = 0
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    /// This member is required.
    public var limit: Swift.Int
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateRoom"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// Identifier of the room to be updated. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages. Specify an empty uri string to disassociate a message review handler from the specified room.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?

    public init (
        identifier: Swift.String? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
    }
}

extension UpdateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRoomOutputResponse: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Maximum number of characters in a single message, from the request.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request.
    public var name: Swift.String?
    /// Tags attached to the resource.
    public var tags: [Swift.String:Swift.String]?
    /// Time of the roomâ€™s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct UpdateRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var fieldList: [IvschatClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var reason: IvschatClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IvschatClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: IvschatClientTypes.ValidationExceptionReason?
    let fieldList: [IvschatClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[IvschatClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [IvschatClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension IvschatClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    /// This object is used in the ValidationException error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Explanation of the reason for the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field which failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IvschatClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
