// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    public enum ChatTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteMessage
        case disconnectUser
        case sendMessage
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatTokenCapability] {
            return [
                .deleteMessage,
                .disconnectUser,
                .sendMessage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteMessage: return "DELETE_MESSAGE"
            case .disconnectUser: return "DISCONNECT_USER"
            case .sendMessage: return "SEND_MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatTokenCapability(rawValue: rawValue) ?? ChatTokenCapability.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.CloudWatchLogsDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies a CloudWatch Logs location where chat logs will be stored.
    public struct CloudWatchLogsDestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon Cloudwatch Logs destination where chat activity will be logged.
        /// This member is required.
        public var logGroupName: Swift.String?

        public init (
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateChatTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, chatTokenAttributes0) in attributes {
                try attributesContainer.encode(chatTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for chattokencapability0 in capabilities {
                try capabilitiesContainer.encode(chattokencapability0.rawValue)
            }
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if sessionDurationInMinutes != 0 {
            try encodeContainer.encode(sessionDurationInMinutes, forKey: .sessionDurationInMinutes)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateChatTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateChatToken"
    }
}

public struct CreateChatTokenInput: Swift.Equatable {
    /// Application-provided attributes to encode into the token and attach to a chat session. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the room. Default: None (the capability to view messages is implicitly included in all requests).
    public var capabilities: [IvschatClientTypes.ChatTokenCapability]?
    /// Identifier of the room that the client is trying to access. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// Session duration (in minutes), after which the session expires. Default: 60 (1 hour).
    public var sessionDurationInMinutes: Swift.Int
    /// Application-provided ID that uniquely identifies the user associated with this token. This can be any UTF-8 encoded text.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IvschatClientTypes.ChatTokenCapability]? = nil,
        roomIdentifier: Swift.String? = nil,
        sessionDurationInMinutes: Swift.Int = 0,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.roomIdentifier = roomIdentifier
        self.sessionDurationInMinutes = sessionDurationInMinutes
        self.userId = userId
    }
}

struct CreateChatTokenInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let capabilities: [IvschatClientTypes.ChatTokenCapability]?
    let sessionDurationInMinutes: Swift.Int
    let attributes: [Swift.String:Swift.String]?
}

extension CreateChatTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ChatTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IvschatClientTypes.ChatTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IvschatClientTypes.ChatTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let sessionDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionDurationInMinutes) ?? 0
        sessionDurationInMinutes = sessionDurationInMinutesDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreateChatTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChatTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChatTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChatTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChatTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sessionExpirationTime = output.sessionExpirationTime
            self.token = output.token
            self.tokenExpirationTime = output.tokenExpirationTime
        } else {
            self.sessionExpirationTime = nil
            self.token = nil
            self.tokenExpirationTime = nil
        }
    }
}

public struct CreateChatTokenOutputResponse: Swift.Equatable {
    /// Time after which an end user's session is no longer valid. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var sessionExpirationTime: ClientRuntime.Date?
    /// The issued client token, encrypted.
    public var token: Swift.String?
    /// Time after which the token is no longer valid and cannot be used to connect to a room. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var tokenExpirationTime: ClientRuntime.Date?

    public init (
        sessionExpirationTime: ClientRuntime.Date? = nil,
        token: Swift.String? = nil,
        tokenExpirationTime: ClientRuntime.Date? = nil
    )
    {
        self.sessionExpirationTime = sessionExpirationTime
        self.token = token
        self.tokenExpirationTime = tokenExpirationTime
    }
}

struct CreateChatTokenOutputResponseBody: Swift.Equatable {
    let token: Swift.String?
    let tokenExpirationTime: ClientRuntime.Date?
    let sessionExpirationTime: ClientRuntime.Date?
}

extension CreateChatTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionExpirationTime
        case token
        case tokenExpirationTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .tokenExpirationTime)
        tokenExpirationTime = tokenExpirationTimeDecoded
        let sessionExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sessionExpirationTime)
        sessionExpirationTime = sessionExpirationTimeDecoded
    }
}

extension CreateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLoggingConfiguration"
    }
}

public struct CreateLoggingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init (
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.tags = tags
    }
}

struct CreateLoggingConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct CreateLoggingConfigurationOutputResponse: Swift.Equatable {
    /// Logging-configuration ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.CreateLoggingConfigurationState?
    /// Tags attached to the resource, from the request (if specified). Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.CreateLoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct CreateLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.CreateLoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.CreateLoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    public enum CreateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [CreateLoggingConfigurationState] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreateLoggingConfigurationState(rawValue: rawValue) ?? CreateLoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateRoom"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init (
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension CreateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct CreateRoomOutputResponse: Swift.Equatable {
    /// Room ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource, from the request (if specified).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct CreateRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension CreateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension DeleteLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLoggingConfiguration"
    }
}

public struct DeleteLoggingConfigurationInput: Swift.Equatable {
    /// Identifier of the logging configuration to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoggingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension DeleteMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteMessage"
    }
}

public struct DeleteMessageInput: Swift.Equatable {
    /// ID of the message to be deleted. This is the Id field in the received message (see [ Message (Subscribe)](https://docs.aws.amazon.com/ivs/latest/chatmsgapireference/actions-message-subscribe.html) in the Chat Messaging API).
    /// This member is required.
    public var id: Swift.String?
    /// Reason for deleting the message.
    public var reason: Swift.String?
    /// Identifier of the room where the message should be deleted. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init (
        id: Swift.String? = nil,
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.id = id
        self.reason = reason
        self.roomIdentifier = roomIdentifier
    }
}

struct DeleteMessageInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let id: Swift.String?
    let reason: Swift.String?
}

extension DeleteMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DeleteMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMessageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteMessageOutputResponse: Swift.Equatable {
    /// Operation identifier, generated by Amazon IVS Chat.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMessageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRoom"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// Identifier of the room to be deleted. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvschatClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudwatchlogs = "cloudWatchLogs"
        case firehose
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cloudwatchlogs(cloudwatchlogs):
                try container.encode(cloudwatchlogs, forKey: .cloudwatchlogs)
            case let .firehose(firehose):
                try container.encode(firehose, forKey: .firehose)
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(IvschatClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        let cloudwatchlogsDecoded = try values.decodeIfPresent(IvschatClientTypes.CloudWatchLogsDestinationConfiguration.self, forKey: .cloudwatchlogs)
        if let cloudwatchlogs = cloudwatchlogsDecoded {
            self = .cloudwatchlogs(cloudwatchlogs)
            return
        }
        let firehoseDecoded = try values.decodeIfPresent(IvschatClientTypes.FirehoseDestinationConfiguration.self, forKey: .firehose)
        if let firehose = firehoseDecoded {
            self = .firehose(firehose)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IvschatClientTypes {
    /// A complex type that describes a location where chat logs will be stored. Each member represents the configuration of one log destination. For logging, you define only one type of destination (for CloudWatch Logs, Kinesis Firehose, or S3).
    public enum DestinationConfiguration: Swift.Equatable {
        /// An Amazon S3 destination configuration where chat activity will be logged.
        case s3(IvschatClientTypes.S3DestinationConfiguration)
        /// An Amazon CloudWatch Logs destination configuration where chat activity will be logged.
        case cloudwatchlogs(IvschatClientTypes.CloudWatchLogsDestinationConfiguration)
        /// An Amazon Kinesis Data Firehose destination configuration where chat activity will be logged.
        case firehose(IvschatClientTypes.FirehoseDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension DisconnectUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DisconnectUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectUser"
    }
}

public struct DisconnectUserInput: Swift.Equatable {
    /// Reason for disconnecting the user.
    public var reason: Swift.String?
    /// Identifier of the room from which the user's clients should be disconnected. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// ID of the user (connection) to disconnect from the room.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.roomIdentifier = roomIdentifier
        self.userId = userId
    }
}

struct DisconnectUserInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let reason: Swift.String?
}

extension DisconnectUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisconnectUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisconnectUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectUserOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvschatClientTypes {
    public enum FallbackResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackResult] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FallbackResult(rawValue: rawValue) ?? FallbackResult.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.FirehoseDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamName = self.deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies a Kinesis Firehose location where chat logs will be stored.
    public struct FirehoseDestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
        /// This member is required.
        public var deliveryStreamName: Swift.String?

        public init (
            deliveryStreamName: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
        }
    }

}

extension GetLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLoggingConfiguration"
    }
}

public struct GetLoggingConfigurationInput: Swift.Equatable {
    /// Identifier of the logging configuration to be retrieved.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetLoggingConfigurationOutputResponse: Swift.Equatable {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name. This value does not need to be unique.
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.LoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.LoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.LoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension GetLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.LoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetRoom"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// Identifier of the room for which the configuration is to be retrieved. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init (
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetRoomOutputResponse: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension GetRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListLoggingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLoggingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLoggingConfigurations"
    }
}

public struct ListLoggingConfigurationsInput: Swift.Equatable {
    /// Maximum number of logging configurations to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first logging configurations to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggingConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListLoggingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListLoggingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLoggingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLoggingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfigurations = output.loggingConfigurations
            self.nextToken = output.nextToken
        } else {
            self.loggingConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListLoggingConfigurationsOutputResponse: Swift.Equatable {
    /// List of the matching logging configurations (summary information only). There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]?
    /// If there are more logging configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init (
        loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurations = loggingConfigurations
        self.nextToken = nextToken
    }
}

struct ListLoggingConfigurationsOutputResponseBody: Swift.Equatable {
    let loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListLoggingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationsContainer = try containerValues.decodeIfPresent([IvschatClientTypes.LoggingConfigurationSummary?].self, forKey: .loggingConfigurations)
        var loggingConfigurationsDecoded0:[IvschatClientTypes.LoggingConfigurationSummary]? = nil
        if let loggingConfigurationsContainer = loggingConfigurationsContainer {
            loggingConfigurationsDecoded0 = [IvschatClientTypes.LoggingConfigurationSummary]()
            for structure0 in loggingConfigurationsContainer {
                if let structure0 = structure0 {
                    loggingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loggingConfigurations = loggingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoomsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifier
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfigurationIdentifier = self.loggingConfigurationIdentifier {
            try encodeContainer.encode(loggingConfigurationIdentifier, forKey: .loggingConfigurationIdentifier)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let messageReviewHandlerUri = self.messageReviewHandlerUri {
            try encodeContainer.encode(messageReviewHandlerUri, forKey: .messageReviewHandlerUri)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListRooms"
    }
}

public struct ListRoomsInput: Swift.Equatable {
    /// Logging-configuration identifier.
    public var loggingConfigurationIdentifier: Swift.String?
    /// Maximum number of rooms to return. Default: 50.
    public var maxResults: Swift.Int
    /// Filters the list to match the specified message review handler URI.
    public var messageReviewHandlerUri: Swift.String?
    /// Filters the list to match the specified room name.
    public var name: Swift.String?
    /// The first room to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        loggingConfigurationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        messageReviewHandlerUri: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurationIdentifier = loggingConfigurationIdentifier
        self.maxResults = maxResults
        self.messageReviewHandlerUri = messageReviewHandlerUri
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListRoomsInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let messageReviewHandlerUri: Swift.String?
    let loggingConfigurationIdentifier: Swift.String?
}

extension ListRoomsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifier
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let messageReviewHandlerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageReviewHandlerUri)
        messageReviewHandlerUri = messageReviewHandlerUriDecoded
        let loggingConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingConfigurationIdentifier)
        loggingConfigurationIdentifier = loggingConfigurationIdentifierDecoded
    }
}

extension ListRoomsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoomsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRoomsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoomsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRoomsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
        } else {
            self.nextToken = nil
            self.rooms = nil
        }
    }
}

public struct ListRoomsOutputResponse: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching rooms (summary information only).
    /// This member is required.
    public var rooms: [IvschatClientTypes.RoomSummary]?

    public init (
        nextToken: Swift.String? = nil,
        rooms: [IvschatClientTypes.RoomSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

struct ListRoomsOutputResponseBody: Swift.Equatable {
    let rooms: [IvschatClientTypes.RoomSummary]?
    let nextToken: Swift.String?
}

extension ListRoomsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rooms
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([IvschatClientTypes.RoomSummary?].self, forKey: .rooms)
        var roomsDecoded0:[IvschatClientTypes.RoomSummary]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [IvschatClientTypes.RoomSummary]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    public enum LoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingConfigurationState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingConfigurationState(rawValue: rawValue) ?? LoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.LoggingConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.LoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    /// Summary information about a logging configuration.
    public struct LoggingConfigurationSummary: Swift.Equatable {
        /// Logging-configuration ARN.
        public var arn: Swift.String?
        /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: ClientRuntime.Date?
        /// A complex type that contains a destination configuration for where chat content will be logged.
        public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
        /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// Logging-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// The state of the logging configuration. When this is ACTIVE, the configuration is ready for logging chat content.
        public var state: IvschatClientTypes.LoggingConfigurationState?
        /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: IvschatClientTypes.LoggingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.destinationConfiguration = destinationConfiguration
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension IvschatClientTypes.MessageReviewHandler: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fallbackResult
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fallbackResult = self.fallbackResult {
            try encodeContainer.encode(fallbackResult.rawValue, forKey: .fallbackResult)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let fallbackResultDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.FallbackResult.self, forKey: .fallbackResult)
        fallbackResult = fallbackResultDecoded
    }
}

extension IvschatClientTypes {
    /// Configuration information for optional message review.
    public struct MessageReviewHandler: Swift.Equatable {
        /// Specifies the fallback behavior (whether the message is allowed or denied) if the handler does not return a valid response, encounters an error, or times out. (For the timeout period, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/userguide/service-quotas.html).) If allowed, the message is delivered with returned content to all users connected to the room. If denied, the message is not delivered to any user. Default: ALLOW.
        public var fallbackResult: IvschatClientTypes.FallbackResult?
        /// Identifier of the message review handler. Currently this must be an ARN of a lambda function.
        public var uri: Swift.String?

        public init (
            fallbackResult: IvschatClientTypes.FallbackResult? = nil,
            uri: Swift.String? = nil
        )
        {
            self.fallbackResult = fallbackResult
            self.uri = uri
        }
    }

}

extension PendingVerification {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct PendingVerification: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let message: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IvschatClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.RoomSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension IvschatClientTypes {
    /// Summary information about a room.
    public struct RoomSummary: Swift.Equatable {
        /// Room ARN.
        public var arn: Swift.String?
        /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: ClientRuntime.Date?
        /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// List of logging-configuration identifiers attached to the room.
        public var loggingConfigurationIdentifiers: [Swift.String]?
        /// Configuration information for optional review of messages.
        public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
        /// Room name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            loggingConfigurationIdentifiers: [Swift.String]? = nil,
            messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
            self.messageReviewHandler = messageReviewHandler
            self.name = name
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension IvschatClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies an S3 location where chat logs will be stored.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon S3 bucket where chat activity will be logged.
        /// This member is required.
        public var bucketName: Swift.String?

        public init (
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, eventAttributes0) in attributes {
                try attributesContainer.encode(eventAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SendEvent"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// Application-defined metadata to attach to the event sent to clients. The maximum length of the metadata is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Application-defined name of the event to send to clients.
    /// This member is required.
    public var eventName: Swift.String?
    /// Identifier of the room to which the event will be sent. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init (
        attributes: [Swift.String:Swift.String]? = nil,
        eventName: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.eventName = eventName
        self.roomIdentifier = roomIdentifier
    }
}

struct SendEventInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let eventName: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SendEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct SendEventOutputResponse: Swift.Equatable {
    /// An identifier generated by Amazon IVS Chat. This identifier must be used in subsequent operations for this message, such as DeleteMessage.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct SendEventOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension SendEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.limit = 0
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    /// This member is required.
    public var limit: Swift.Int
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.limit = 0
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    /// This member is required.
    public var limit: Swift.Int
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var resourceId: Swift.String?
    ///
    /// This member is required.
    public var resourceType: IvschatClientTypes.ResourceType?

    public init (
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case identifier
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLoggingConfiguration"
    }
}

public struct UpdateLoggingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Identifier of the logging configuration to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?

    public init (
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.identifier = identifier
        self.name = name
    }
}

struct UpdateLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
}

extension UpdateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case identifier
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
    }
}

extension UpdateLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateLoggingConfigurationOutputResponse: Swift.Equatable {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.UpdateLoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.UpdateLoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct UpdateLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.UpdateLoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.UpdateLoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    public enum UpdateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateLoggingConfigurationState] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateLoggingConfigurationState(rawValue: rawValue) ?? UpdateLoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateRoom"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// Identifier of the room to be updated. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// The maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages. Specify an empty uri string to disassociate a message review handler from the specified room.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?

    public init (
        identifier: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension UpdateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRoomOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRoomOutputResponse: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct UpdateRoomOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension UpdateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var fieldList: [IvschatClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    ///
    /// This member is required.
    public var reason: IvschatClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IvschatClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: IvschatClientTypes.ValidationExceptionReason?
    let fieldList: [IvschatClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[IvschatClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [IvschatClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension IvschatClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    /// This object is used in the ValidationException error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Explanation of the reason for the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field which failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IvschatClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
